<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember</title>
  
  <subtitle>一切有为法,如梦幻泡影。如露亦如电,应作如是观。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yov.oschina.io/"/>
  <updated>2017-10-24T07:25:08.911Z</updated>
  <id>http://yov.oschina.io/</id>
  
  <author>
    <name>子语</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础知识(十二)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%BA%8C)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十二)/</id>
    <published>2017-10-23T12:21:57.951Z</published>
    <updated>2017-10-24T07:25:08.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辅助概念"><a class="markdownIt-Anchor" href="#辅助概念"></a> 辅助概念</h2><h3 id="关键字final"><a class="markdownIt-Anchor" href="#关键字final"></a> 关键字final</h3><p>Java中，<code>final</code>被称为终结器，可以用于定义类、方法、属性，具有如下特点：<br>1、final定义的类不能有子类</p><pre class="highlight"><code class="">final class A{}class B extends A{} //报错，无法继承A类</code></pre><p>开发系统类或者进行一些架构代码开发时使用到<code>final</code>定义类。<br>2、final定义的方法不能被方法覆写<br>父类中某些方法具备某种隐藏的特性，或子类必须使用该方法时，使用final定义，意思是子类不要破坏父类中该方法的结构。</p><pre class="highlight"><code class="">class A{    public final void fun(){}}class B extends A{    public void fun(){} // 报错，无法覆写方法}</code></pre><p>3、final定义的变量就成了常量。常量必须在定义时设置好值，且不能修改。</p><pre class="highlight"><code class="">class A {    final double GOOD = 100.0;    public void fun() {        GOOD = 200; // 无法修改常量GOOD的值    }}</code></pre><p>用final定义变量，就可以使用变量名来描述一些数据。开发中常量名均为大写，变量名首个单词小写，之后的单词首字母大写。<br>4、全局常量：public static final 声明的变量就是全局常量:</p><pre class="highlight"><code class="">public static final String MSG = &quot;MLDN&quot;;</code></pre><p>static数据存在公共数据区，因此MSG是一个公共常量。</p><blockquote><p>总结：<br>（1）final定义的类和方法不能继承，不能覆写；<br>（2）public static final 定义的是全局常量，常量名全部大写。</p></blockquote><h3 id="对象多态性"><a class="markdownIt-Anchor" href="#对象多态性"></a> 对象多态性</h3><p>多态性依赖于方法覆写。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print(); // 覆写的方法    }}</code></pre><p>1、多态性分为两种：</p><pre class="highlight"><code class="">（1）方法的多态性|- 方法重载：同一个方法名，根据传入的参数类型或个数的不同，执行不同方法体；|- 方法覆写：同一个方法，根据对象所属的子类不同，执行不同方法体。（2）对象的多态性：指发生在具有继承关系的类中，父类与子类的转换。|- 向上转型（自动完成）：父类 父类对象 = 子类实例化;|- 向下转型（强制完成）：子类 子类对象 = （父类）父类实例化;</code></pre><p><strong>范例</strong>：向上转型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        A a = new B();        a.print(); // 覆写的方法    }}</code></pre><p><strong>范例</strong>：向下转型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        B b = (B) new A(); // 向下转型        b.print(); // 覆写的方法    }}</code></pre><p>2、向上转型：由于子类对象都可以自动向上转型，所以可应用于参数的统一。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B覆写的方法&quot;);    }}class C extends A {    public void print() {        System.out.println(&quot;C覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a1 = new B(); // 向上转型        A a2 = new C(); // 向上转型        a1.print(); // B覆写的方法        a2.print(); // C覆写的方法    }}</code></pre><p>a1,a2参数统一后，还可以调用子类覆写的方法，即同一个方法针对不同子类可以有不同实现。<br>3、向下转型：父类发生向上转型后，不能调用子类中自定义的方法。因此当父类要调用子类自定义方法时，需要进行向下转型，将父类对象变为子类对象。</p><pre class="highlight"><code class="">class A {}class B extends A {    public void fun() {        System.out.println(&quot;自定义方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        a.fun(); // 报错，无法调用B自定义方法    }}</code></pre><p>向下转型后，可以调用子类自定义的方法：</p><pre class="highlight"><code class="">class A {}class B extends A {    public void fun() {        System.out.println(&quot;自定义方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        B b = (B) a; // 向下转型        b.fun();    }}</code></pre><blockquote><p>问题：上述代码中不适用向下转型,直接实例化子类对象就可以直接调用fun(),为什么还要转型？<br>答：数据的操作分为两步：设置数据（最需要进行参数统一）和取出数据。</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        fun(new B()); // 向上转型    }    public static void fun(A a){ // 统一参数        B b = (B) a; // 向下转型        b.fun(); // 调用子类自定义方法    }}</code></pre><p>5、个性化操作在开发中尽量少出现，因为对象的强制转型容易带来安全隐患。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A.print()&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B.print()&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new A();        B b = (B) a;        b.print();    }}</code></pre><p>上述代码会报错,<code>Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at ExDemo.main(ExDemo.java:15)</code>，表示类转换异常，指的是两个没有关系的类对象强制进行向下转型时发生的异常，因此向下转型存在风险。<br>为保证转型的安全性，Java提供关键字<code>instanceof</code>,其返回结果为boolean:<code>对象 instanceof 类</code><br>如果某个对象是某个类的实例，则会返回true，反之返回false。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A.print()&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B.print()&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B();        System.out.println(a instanceof A); // true        System.out.println(a instanceof B); // true        if (a instanceof B) {            B b = (B) a;            b.print(); // B.print()        }    }}</code></pre><p>向下转型前应先进行对象的向上转型，建立关系后才能进行向下转型。</p><blockquote><p>总结：<br>（1）大多数情况只使用向上转型，使得参数统一，便于程序设计；子类尽量覆写方法，而不是自定义方法；<br>（2）极少情况使用向下转型调用子类的自定义方法，或者不转型。</p></blockquote><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>1、抽象类是含有抽象方法的类。抽象方法没有方法体，必须用<code>abstract</code>定义。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public void fun(){方法体;} // 普通方法    public abstract void print(); // 抽象方法}public class Demo {    public static void main(String[] args) {        A a = new A(); // 报错，A是抽象类，无法实例化    }}</code></pre><p>结果显示，<strong>无法直接实例化抽象类对象</strong>.普通类的对象实例化后,该对象可以调用类中的属性和方法.而抽象类中存在抽象方法,抽象方法没有方法体无法调用，因此无法产生实例化对象.<br>2、抽象类使用原则：</p><blockquote><p>（1）抽象类必须有子类；<br>（2）抽象类的子类（非抽象类时）必须覆写抽象类中所有的抽象方法（强制子类进行方法覆写）<br>（3）抽象类对象的实例化依靠子类完成，采用向上转型方式。</p></blockquote><p><strong>范例</strong>：使用抽象类</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public void fun() { // 普通方法        System.out.println(&quot;普通方法&quot;);    }    public abstract void print(); // 抽象方法}class B extends A {    // 强制要求对抽象方法进行覆写，否则会报错    public void print() {        System.out.println(&quot;覆写后的抽象方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        a.fun();        a.print();    }}</code></pre><p>由上述代码，可知：</p><blockquote><p>（1）抽象类的子类明确要求方法覆写，而普通类没有；<br>（2）抽象类只比普通类多了抽象方法，其他部分相同；<br>（3）抽象类对象必须经过向上转型才能实例化；<br>（4）虽然子类可以继承任何类，但开发中，普通类最好继承抽象类。</p></blockquote><h3 id="使用限制"><a class="markdownIt-Anchor" href="#使用限制"></a> 使用限制</h3><p>1、抽象类由于存在属性，因此会有构造方法来初始化属性。子类对象实例化时依然先执行父类构造方法，再调用子类构造方法。<br>2、抽象类不能使用final定义，因为抽象类必须有子类。<br>3、抽象外部类不允许使用<code>static</code>定义，而抽象内部类可以使用<code>static</code>声明。使用<code>static</code>定义的抽象内部类相当于抽象外部类，继承时使用<code>外部类.内部类</code>的形式表示类名。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    static abstract class B {        public abstract void print();    }}class X extends A.B {    public void print() {        System.out.println(&quot;*****&quot;);    }}public class Demo {    public static void main(String[] args) {        A.B ab = new X(); // 向上转型        ab.print();    }}</code></pre><p>4、<code>static</code>定义的方法可以没有实例化对象的情况下直接调用，即使是抽象类中的static方法。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public static void print() {        System.out.println(&quot;static方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A.print(); // static方法        A a = new A() ; // 报错    }}</code></pre><p>5、有时抽象类只需要一个特定的子类操作，因此可以将该子类定义为该抽象类的内部类。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public abstract void print();    private static class B extends A { // 内部抽象类子类        public void print() {            System.out.println(&quot;Hello&quot;);        }    }    public static A getInstance() { // 获取B的实例化对象        return new B();    }}public class Demo {    public static void main(String[] args) {        // 客户端得到抽象类对象时，B对其不可见        A a = A.getInstance();        a.print();    }}</code></pre><p>上述设计在系统类库中较为常见，目的是：为用户隐藏不需要知道的子类。<br>6、观察下述代码：</p><pre class="highlight"><code class="">abstract class A { // 抽象类    // 1. 先调用父类构造    public A() {        this.print();    }    public abstract void print();}class B extends A {    private int num = 100;    // 3.调用子类构造，并初始化num = 30.运行结束，未输出初始化后的num    public B(int num) {        this.num = num;    }    // 2. 父类构造调用子类的print，此时num = 0,打印输出。    public void print() {        System.out.println(&quot;num = &quot; + num);    }}public class Demo {    public static void main(String[] args) {        new B(30); // 4. 结果为0    }}</code></pre><p>在构造方法执行完之前，属性的内容均为其对应的数据类型的默认值。子类在执行构造方法前必先执行父类的构造方法，因为此时子类构造方法还没执行，就调用<code>print()</code>输出了num的值，所以num为<code>0</code>.</p><h3 id="模板设计模式"><a class="markdownIt-Anchor" href="#模板设计模式"></a> 模板设计模式</h3><blockquote><p>要求：设计三个类，通过类描述如下行为：<br>（1）机器人：充电、工作；<br>（2）人：吃饭、工作、睡觉；<br>（3）猪：吃饭、睡觉<br><strong>思路</strong>：定义一个抽象类，具有吃饭、睡觉、工作的抽象方法。根据子类的不同，具体实现抽象方法。<br><img src="/article/Java/Java Base/Java基础知识(十二)/18-2.png" alt="无法加载" title="思路图"></p></blockquote><pre class="highlight"><code class="">abstract class Action {    public static final int EAT = 1;    public static final int SLEEP = 5;    public static final int WORK = 7;    public void command(int flag) {        switch (flag) {            case EAT:                this.eat();                break;            case SLEEP:                this.sleep();                break;            case WORK:                this.work();                break;            case EAT + WORK:                this.eat();                this.work();                break;        }    }    // 不确定方法中的具体行为，定义为抽象类    public abstract void eat();    public abstract void sleep();    public abstract void work();}</code></pre><p><strong>定义子类</strong>：</p><pre class="highlight"><code class="">class Robot extends Action {    public void eat() {        System.out.println(&quot;机器人正在补充能量&quot;);    }    public void sleep() {    }    public void work() {        System.out.println(&quot;机器人正在工作&quot;);    }}class Human extends Action {    public void eat() {        System.out.println(&quot;人正在吃饭&quot;);    }    public void sleep() {        System.out.println(&quot;人正在睡觉&quot;);    }    public void work() {        System.out.println(&quot;人正在工作&quot;);    }}class Pig extends Action {    public void eat() {        System.out.println(&quot;猪正在吃饭&quot;);    }    public void sleep() {        System.out.println(&quot;猪正在睡觉&quot;);    }    public void work() {    }}</code></pre><p><strong>范例</strong>：测试程序</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        fun(new Robot());        fun(new Human());        fun(new Pig());    }    public static void fun(Action act) {        act.command(Action.EAT);        act.command(Action.SLEEP);        act.command(Action.WORK);    }}</code></pre><p>结果显示：子类要实现操作，必须按照Action类的标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辅助概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#辅助概念&quot;&gt;&lt;/a&gt; 辅助概念&lt;/h2&gt;
&lt;h3 id=&quot;关键字final&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键字final&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用IDEA将SpringBoot打包成war</title>
    <link href="http://yov.oschina.io/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/%E4%BD%BF%E7%94%A8IDEA%E5%B0%86SpringBoot%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/"/>
    <id>http://yov.oschina.io/article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/</id>
    <published>2017-10-22T12:33:06.711Z</published>
    <updated>2017-10-22T12:48:32.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改pomxml"><a class="markdownIt-Anchor" href="#修改pomxml"></a> 修改pom.xml</h2><h3 id="将package格式改为war"><a class="markdownIt-Anchor" href="#将package格式改为war"></a> 将package格式改为war</h3><pre class="highlight"><code class="">&lt;groupId&gt;com&lt;/groupId&gt;&lt;artifactId&gt;demo&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;</code></pre><h3 id="排除内置tomcat"><a class="markdownIt-Anchor" href="#排除内置tomcat"></a> 排除内置tomcat</h3><pre class="highlight"><code class="">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="打包过程跳过测试"><a class="markdownIt-Anchor" href="#打包过程跳过测试"></a> 打包过程跳过测试</h3><pre class="highlight"><code class="">&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;skip&gt;true&lt;/skip&gt;&lt;/configuration&gt;&lt;/plugin&gt;</code></pre><h2 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h2><p>打开IDE右侧边栏的<code>Maven Projects</code></p><pre class="highlight"><code class="">demo |- Lifecycle |- clean |- validate |- compile |- test |- package |- verify |- install |- site |- deploy |- Plugins |- Dependencies</code></pre><p>双击<code>package</code>即可开始打包，打包后,会在项目文件<code>target</code>中。</p><h2 id="发布war包"><a class="markdownIt-Anchor" href="#发布war包"></a> 发布war包</h2><p>删除tomcat下webapps中的文件,将文件war包文件复制放入。点击tomcat中bin文件夹下的startup.bat，此时便可进行访问localhost查看SpringBoot。</p><pre class="highlight"><code class="">  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v1.5.8.RELEASE)20:45:57 CST 2017]; root of context hierarchy2017-10-22 20:46:01.008  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello],methods=[GET]}&quot; onto public java.lang.String com.demo.DemoApplication.hello()2017-10-22 20:46:01.016  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-10-22 20:46:01.030  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView 2017-10-22 20:46:01.635  INFO 5972 --- [ost-startStop-1] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2017-10-22 20:46:01.687  INFO 5972 --- [ost-startStop-1] com.demo.DemoApplication                 : Started DemoApplication in 5.963 seconds (JVM running for 11.781)2017-10-22 20:46:02.385  WARN 5972 --- [ost-startStop-1] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [682] milliseconds.application archive E:\apache-tomcat-8.0.45\webapps\ROOT.war has finished in 10,051 ms22-Oct-2017 20:46:02.430 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8888&quot;]22-Oct-2017 20:46:02.454 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]22-Oct-2017 20:46:02.468 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 10192 ms</code></pre><p>在上述信息中，告诉了我们可以访问的端口为8888.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改pomxml&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#修改pomxml&quot;&gt;&lt;/a&gt; 修改pom.xml&lt;/h2&gt;
&lt;h3 id=&quot;将package格式改为war&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="框架" scheme="http://yov.oschina.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
      <category term="框架" scheme="http://yov.oschina.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十一)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%80)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十一)/</id>
    <published>2017-10-22T07:53:56.490Z</published>
    <updated>2017-10-22T08:29:57.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承性"><a class="markdownIt-Anchor" href="#继承性"></a> 继承性</h2><blockquote><p>继承性的作用是解决代码重用问题。</p></blockquote><h3 id="继承问题的引出"><a class="markdownIt-Anchor" href="#继承问题的引出"></a> 继承问题的引出</h3><p>范例:定义两个类Person和Student</p><pre class="highlight"><code class="">class Person{private String name;private int age;public void setName(String name){this.name = name;}public void setAge(int age){this.age = age;}public String getName(){return this.name; }public int getAge(){return this.age;}}class Student{    private String name;private int age;private String school;public void setName(String name){this.name = name;}public void setAge(int age){this.age = age;}public void setSchool(String school){this.school = school;}public String getName(){return this.name; }public int getAge(){return this.age;}public String getSchool(){return this.school; }}</code></pre><p>由代码可见Studen和Person存在代码重复。在自然关系上，Student是Person的一种，只是Student描述的更细致，范围更小。</p><h3 id="实现继承"><a class="markdownIt-Anchor" href="#实现继承"></a> 实现继承</h3><p>继承使用关键字<code>extends</code>实现，语法如下：<code>class 子类 extends 父类{}</code><br>子类也被称为<code>派生类</code>，父类也被称为<code>基类、超类或super类</code>。<br><strong>范例</strong>：实现继承</p><pre class="highlight"><code class="">class Person { // 父类    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}class Student extends Person { // 继承Person类}public class Demo {    public static void main(String[] args) {        Student stu = new Student();        stu.setName(&quot;张三&quot;);        stu.setAge(18);        System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;,年龄：&quot; + stu.getAge());    }}</code></pre><p>Student继承了Person，可以使用Person类中的方法。<br><strong>范例</strong>：在Student中添加属性和方法</p><pre class="highlight"><code class="">class Student extends Person { // 继承Person类    private String school;    public String getSchool() {        return school;    }    public void setSchool(String school) {        this.school = school;    }}</code></pre><p>由上述代码，可知继承性的优点：</p><blockquote><p>（1）子类可以直接使用父类的属性和方法，进行代码重用；<br>（2）子类可以扩充属于自己的操作。</p></blockquote><h3 id="继承的限制"><a class="markdownIt-Anchor" href="#继承的限制"></a> 继承的限制</h3><p><strong>Java中继承存在如下限制：</strong><br>1、Java不允许多重继承，但允许多层继承。<br>C++允许多继承，即一个子类可以同时继承多个父类。但该操作在Java中是不允许的。多继承是为了使子类可以同时拥有多个父类的操作。Java中使用多层继承替代，语法如下：</p><pre class="highlight"><code class="">class A{}class B extends A{}class C extends B{}</code></pre><p>相当于C是B的子类，是A的孙子类。多层继承没有层数限制，但最好不超过三层。<br>2、子类继承父类时，会继承父类全部操作。对于私有操作属于隐式继承，对于非私有操作属于显式继承。</p><pre class="highlight"><code class="">class A {    private String msg;    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }}class B extends A {}public class Demo {    public static void main(String[] args) {        B b = new B();        b.setMsg(&quot;Hello&quot;);        System.out.println(b.getMsg()); // Hello    }}</code></pre><p>上述代码显示B类中也存在属性msg,因为如果msg不存在，setMsg()设置的内容就不能保存，即getMsg()无法输出内容。</p><pre class="highlight"><code class="">class B extends A {    public void fun() {        System.out.println(msg); // 报错，无法访问    }}</code></pre><p>但是在B类中无法直接访问msg，因为msg是A类的私有属性，只能间接访问。<br>3、在实例化子类对象之前，会先调用父类构造方法（默认是无参构造方法），以保证父类对象先实例化，而后在实例化子类对象。</p><pre class="highlight"><code class="">class A {    public A() {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B() {        System.out.println(&quot;B 构造方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        // A 构造方法        // B 构造方法    }}</code></pre><p>由结果可知，在实例化子类对象前，会先实例化父类对象。对于子类构造方法来说相当于隐藏一个”super()”.</p><pre class="highlight"><code class="">class B extends A {    public B() {        super(); // 父类有无参构造方法时，加不加都一样        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><blockquote><p>何时要在子类构造方法中添加super()：如果父类中没有无参构造方法，就必须使用super调用父类的有参构造方法。</p></blockquote><pre class="highlight"><code class="">class A {    public A(String title) {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B() {        // 子类默认调用无参构造，但A中没有无参构造        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p>上述代码执行后，不会调用A中的有参构造，因此需要在B类中的构造方法添加super():</p><pre class="highlight"><code class="">class A {    public A(String title) {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B(String title) {        super(title);        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p><code>super()</code>必须放在子类构造方法的第一行。而<code>this()</code>也应该放在构造方法的首行。</p><blockquote><p><strong>问题：子类构造方法未添加super()，系统默认使用super()调用父类的无参构造方法。如果在子类构造方法中添加this()，那么子类是不是无法调用父类构造方法？</strong></p></blockquote><pre class="highlight"><code class="">class B extends A {    public B() { // 报错，构造递归调用        this();         System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p>由结果可知，super()和this()不能同时存在。不论子类怎么修改，子类构造方法执行前都必须先执行父类的构造方法。</p><h3 id="方法覆写"><a class="markdownIt-Anchor" href="#方法覆写"></a> 方法覆写</h3><p>继承性的特点是子类可以对父类已有的功能进行扩展。子类在定义属性或方法时有可能与父类重名，该操作就称为覆写。<br>1、<strong>方法覆写</strong>：子类定义一个与父类方法的方法名、参数类型及个数、返回值都相同的方法。</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // A中的方法    }}</code></pre><p>此时B中没有fun()，所以调用的是从A继承的fun().<br><strong>范例</strong>：方法覆写</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void fun(){ // 方法覆写        System.out.println(&quot;覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // 覆写的方法    }}</code></pre><p>当方法覆写后，此时会调用子类中覆写的方法。<br>2、覆写结果的分析要素：</p><blockquote><p>（1）实例化的是那个类；<br>（2）该对象调用的方法是否被覆写，如果未覆写将调用父类中的方法。</p></blockquote><pre class="highlight"><code class="">class B extends A {    public String fun(){         System.out.println(&quot;覆写的方法&quot;);        // 报错，B中fun()无法覆盖A中fun()，返回类型不兼容        return &quot;Hello&quot;;    }}</code></pre><p><strong>进行方法覆写时，不能改变方法中的返回值和参数个数。</strong><br>3、方法覆写的使用原则：父类方法不能满足子类需求，但又必须使用该方法名时，要进行方法覆写。<br>方法覆写时还要考虑到权限问题，被子类覆写的方法不能拥有比父类更高的访问控制权限。</p><blockquote><p>访问控制权限：public&gt;default&gt;private，private的访问权限最严格。即如果父类方法使用public方法，子类覆写此方法时，只能使用public。父类使用的是default，子类覆写时，只能用default或public.</p></blockquote><p><strong>范例</strong>：正确覆写</p><pre class="highlight"><code class="">class A {    void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void fun(){        System.out.println(&quot;覆写的方法&quot;);    }}</code></pre><p><strong>错误覆写</strong>：</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    void fun(){        System.out.println(&quot;覆写的方法&quot;);        // 报错，正在尝试分配更低权限。    }}</code></pre><p>上述代码中子类使用default，比public权限更严格，不符合方法覆写原则。</p><blockquote><p>问题：父类方法使用private声明，子类使用public声明该方法，是覆写吗？<br>答：从概念上，private声明权限高于public，因此从权限上而言符合覆写的要求。观察下述代码：</p></blockquote><pre class="highlight"><code class="">class A {    public void fun() {        print();    }    private void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // Hello    }}</code></pre><p>从上述代码来看，子类并没有覆写print()，因为使用private定义的方法对于子类而言是不可见，因此子类定义的print()虽然符合覆写的要求，但是实际只是相当于定义了一个全新的方法，而不是方法覆写。而正确的覆写结果应该如下：</p><pre class="highlight"><code class="">class A {    public void fun() {        print();    }    public void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // World    }}</code></pre><p>5、默认情况下，子类对象调用是一定是覆写后的方法。</p><pre class="highlight"><code class="">class A {    public void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        print();  // 等同于this.print()        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print(); // 报错，方法递归调用，死循环    }}</code></pre><p>上述代码中，B类会优先调用B中print()，因此发生了递归调用。如果B中没有print()，则会调用父类中的。<br><strong>范例</strong>：调用父类中方法<code>super.方法名()</code></p><pre class="highlight"><code class="">class B extends A {    public void print(){        super.print();        System.out.println(&quot;World&quot;);    }}</code></pre><blockquote><p><strong>super.方法名()与this.方法名()的区别：</strong><br>（1）this.方法名()会优先查找本类中是否有目标方法，如果有则直接调用，没有就继续在父类中查找。<br>（2）super.方法名()会直接在父类中查找目标方法，不会在子类中查找。</p></blockquote><blockquote><p><strong>问题：请说明重载（overloading）和覆写（override）的区别</strong></p></blockquote><table><thead><tr><th>No.</th><th>区别</th><th>重载</th><th>覆写</th></tr></thead><tbody><tr><td>1</td><td>英文单词</td><td>Overloading</td><td>Overrid</td></tr><tr><td>2</td><td>发生范围</td><td>发生在一个类中</td><td>发生在继承关系中</td></tr><tr><td>3</td><td>定义</td><td>方法名相同，参数类型及个数不相同</td><td>方法名称、参数类型及个数，方法返回值都相同</td></tr><tr><td>4</td><td>权限</td><td>没有权限限制</td><td>被覆写的方法不能拥有比父类更严格的权限</td></tr></tbody></table><p>在方法重载时，返回值可以不同，但为了程序设计的统一性，应尽量保证返回值类型一致。</p><h3 id="属性覆写"><a class="markdownIt-Anchor" href="#属性覆写"></a> 属性覆写</h3><p>1、子类定义了与父类完全相同的属性名时，称为属性覆写。</p><pre class="highlight"><code class="">class A {    String info = &quot;Hello&quot;;}class B extends A {    String info = &quot;World&quot;;    public void print(){        System.out.println(super.info); // 调用父类属性        System.out.println(this.info);  // 调用本类属性    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print();    }}</code></pre><p>由于在开发中，类的属性必须封装，而封装后，属性覆写就没有意义。因为父类定义的私有属性，子类不可见，因此不会互相影响。</p><blockquote><p><strong>问题：super和this的区别</strong></p></blockquote><table><thead><tr><th>No.</th><th>区别</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>功能</td><td>调用本类中的操作</td><td>子类调用父类中的操作</td></tr><tr><td>2</td><td>形式</td><td>先从本类查找目标操作,再从父类中查找</td><td>只查找父类</td></tr><tr><td>3</td><td>特殊</td><td>表示本类的当前对象</td><td>super不能单独使用</td></tr></tbody></table><p>在开发中，对于本类或父类的操作，最好加上this.或super.，这样便于代码调试。</p><h3 id="继承综合实战数组操作"><a class="markdownIt-Anchor" href="#继承综合实战数组操作"></a> 继承综合实战：数组操作</h3><blockquote><p>要求：定义Array类，在类中可以进行整型数组的操作：由外部传入数组的数据，可以进行数据的保存和输出，并且在这个类上派生出两个子类：<br>（1）排序类：通过此类取得的数据可以进行排序；<br>（2）反转类：通过此类取得的数据采用倒序的方式输出。<br>开发时，先不考虑子类，先开发父类。</p></blockquote><h4 id="根据要求定义父类array实现其操作"><a class="markdownIt-Anchor" href="#根据要求定义父类array实现其操作"></a> 根据要求定义父类Array，实现其操作。</h4><blockquote><p>思路：开辟好数组后，根据索引，一一存放数据。</p></blockquote><pre class="highlight"><code class="">class Array {    private int data[]; // 数组    private int foot; // 脚标    // 开辟数组空间    public Array(int len) {        if (len &gt; 0) {             this.data = new int[len];        } else { // 数组默认长度为1            this.data = new int[1];        }    }    // 为数组添加数据    public boolean add(int num) {        if (this.foot &lt; this.a[this.foot++] = num; // 保存数据            return true;        }        return false;    }    // 取得数组内容    public int[] getData() {        return this.data;    }}public class Demo {    public static void main(String[] args) {        Array array = new Array(3);        System.out.println(array.add(10)); // true        System.out.println(array.add(20)); // true        System.out.println(array.add(30)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><p>####定义子类。</p><blockquote><p>思路：将Array类getData()返回的结果进行排序输出即可，因此要覆写父类的方法。</p></blockquote><pre class="highlight"><code class="">// 定义一个排序数组的子类class SortArray extends Array {    // Array中没有无参构造方法，    // 需要明确调用父类的有参构造方法    public SortArray(int len) {        super(len);    }    // Array的getData()无法排序，进行方法覆写    public int[] getData() {        // 调用类库中的方法排序        java.util.Arrays.sort(super.getData());        return super.getData();    }}public class Demo {    public static void main(String[] args) {        SortArray array = new SortArray(3);        System.out.println(array.add(20)); // true        System.out.println(array.add(30)); // true        System.out.println(array.add(10)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><p>####定义反转子类，也要保持客户端操作不变，因此要覆写父类的方法。</p><pre class="highlight"><code class="">// 定义一个反转子类class ReverseArray extends Array {    public ReverseArray(int len) {        super(len);    }    public int[] getData() {        int center = super.getData().length / 2;        int head = 0;        int tail = super.getData().length - 1;        for (int x = 0; x &lt; center; x++) {            int temp = super.getData()[head];            super.getData()[head] = super.getData()[tail];            super.getData()[tail] = temp;            head++;            tail--;        }        return super.getData();    }}public class Demo {    public static void main(String[] args) {        ReverseArray array = new ReverseArray(3);        System.out.println(array.add(20)); // true        System.out.println(array.add(10)); // true        System.out.println(array.add(30)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><blockquote><p><strong>总结</strong>：<br>子类扩充方法时，尽量根据需求覆写父类方法，而不是直接定义新方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承性&quot;&gt;&lt;/a&gt; 继承性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;继承性的作用是解决代码重用问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承问题的引出&quot;&gt;&lt;a c
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot小例子进阶</title>
    <link href="http://yov.oschina.io/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/SpringBoot%E5%B0%8F%E4%BE%8B%E5%AD%90%E8%BF%9B%E9%98%B6/"/>
    <id>http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子进阶/</id>
    <published>2017-10-21T05:42:31.770Z</published>
    <updated>2017-10-21T13:10:31.827Z</updated>
    
    <content type="html"><![CDATA[<p>本部分代码是基于<code>SpringBoot基础应用</code>博文的。</p><blockquote><p>代码结构如下：</p></blockquote><pre class="highlight"><code class="">demo   // 项目名|- .idea|- .mvn|- src  // 代码存放区   |- main       |- java         |- com.example.demo          // java包         |- aspect                 // 拦截器            |- HttpAspect.java              |- controller             // 控制器            |- PersonController            |- domain                 // 实体类            |- Person               |- Result              // 定义异常的响应信息的格式         |- enums            |- ResultEnum          // 定义异常的code和信息         |- exception              // 自定义异常            |- PersonException              |- handle                 // 捕获异常            |- ExceptionHandle          |- repository             // jpa操作            |- PersonRepository         |- service                // 处理业务逻辑            |- PersonService              |- DemoApplication.java   // 项目启动类      |- resources         |- static     // 用于存放css,js等样式文件         |- templates  // 用于存放html文件         application.properties  // 项目配置文件   |- test //测试代码存放区|- target.gitignoremvnwmvnw.cmddemo.imlpom.xml // 项目对象模型,添加项目依赖等配置</code></pre><h2 id="实现表单验证"><a class="markdownIt-Anchor" href="#实现表单验证"></a> 实现表单验证</h2><blockquote><p>要求： age小于18的数据无法入库</p></blockquote><h3 id="修改person类"><a class="markdownIt-Anchor" href="#修改person类"></a> 修改Person类</h3><pre class="highlight"><code class="">package com.example.demo.domain;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.validation.constraints.Min;@Entitypublic class Person {    @Id    @GeneratedValue    private Integer id;    private String name;    // @Min 使得该属性必须大于18,当数值小于18时,有提示信息    @Min(value = 18, message = &quot;年龄小于18无法添加&quot;)    private Integer age;    public Person() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><h3 id="修改personcontroller类addperson"><a class="markdownIt-Anchor" href="#修改personcontroller类addperson"></a> 修改PersonController类addPerson()</h3><pre class="highlight"><code class="">     /**     * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据     * @param person 要添加的person对象     * @param bindingResult 获取绑定结果信息     * @return 返回Person类信息     */    @PostMapping(value = &quot;/person&quot;)    public Person addPerson(@Valid Person person, BindingResult bindingResult) {    // 当输入数据不符合要求时,后台输出错误信息        if (bindingResult.hasErrors()) {            System.out.println(bindingResult.getFieldError().getDefaultMessage());            return null;        }        return  personRepository.save(person);    }</code></pre><p><code>@Valid</code>用于对传入的数据进行校验。</p><h2 id="使用aop处理请求"><a class="markdownIt-Anchor" href="#使用aop处理请求"></a> 使用AOP处理请求</h2><blockquote><p>什么是AOP<br>(1)AOP(面向切面, Aspect Oriented Programming)是一种编程范式,是一种程序设计思想。思想是将通用逻辑从业务逻辑中分离出来<br><img src="/article/框架/Spring Boot/SpringBoot小例子进阶/AOP%E6%80%9D%E6%83%B3.png" alt="无法加载" title="AOP"><br>将纵向的分析变为横向分析,从而将通用逻辑从业务逻辑中分离出来。<br>(2)除了AOP还有OOP(面向对象,Object Oriented Programming),POP(面向过程,Proceduer Oriented Programming)</p></blockquote><h3 id="aop统一处理请求日志"><a class="markdownIt-Anchor" href="#aop统一处理请求日志"></a> AOP统一处理请求日志</h3><blockquote><p>要求：记录每一个http请求</p></blockquote><h4 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h4><pre class="highlight"><code class="">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="创建httpaspect类"><a class="markdownIt-Anchor" href="#创建httpaspect类"></a> 创建HttpAspect类</h4><p><code>@Aspect</code>实现切面注入;<code>@Component</code>将该类注册到SpringBoot容器中</p><pre class="highlight"><code class="">package com.example.demo.aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;// 切面注入@Aspect@Componentpublic class HttpAspect {// 日志对象    private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect            .class);// 指明哪些方法需要执行AOP    @Pointcut(&quot;execution(public * com.example.demo.controller.PersonController&quot; +            &quot;.*(..))&quot;)    public void log() {}    /**     * 该方法功能是将请求中的信息输出至日志中     * @Before 在使用PersonController中方法前先执行该注解下的方法     * @param joinpoint 目标类连接点对象     */    @Before(&quot;log()&quot;)    public void doBefore(JoinPoint joinpoint) {        ServletRequestAttributes attributes = (ServletRequestAttributes)                RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 获取url        LOGGER.info(&quot;url = {}&quot;, request.getRequestURL());        // 获取请求方式        LOGGER.info(&quot;method = {}&quot;, request.getMethod());        // 获取请求方的ip        LOGGER.info(&quot;ip = {}&quot;, request.getRemoteAddr());        // 获取被调用的方法名        LOGGER.info(&quot;class_method = {}&quot;,                joinpoint.getSignature().getDeclaringTypeName() +                        &quot;.&quot; + joinpoint.getSignature().getName() + &quot;()&quot;);        // 获取请求参数        LOGGER.info(&quot;args = {}&quot;, joinpoint.getArgs());    }    /** 该方法功能是将响应中的信息输出至日志中     * @AfterReturning 使得该类可以接收HttpResponse中对象信息     * @param object 返回的对象信息     */    @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;)    public void doAfterReturning(Object object) {        LOGGER.info(&quot;response = {}&quot;, object.toString());    }}</code></pre><h2 id="统一异常处理"><a class="markdownIt-Anchor" href="#统一异常处理"></a> 统一异常处理</h2><blockquote><p>要求:获取Person对象的age并判断<br>age &lt; 12 : 返回&quot;正在上小学&quot;<br>age &gt; 12 &amp;&amp; age &lt; 15: 返回&quot;正在上初中&quot;</p></blockquote><h3 id="定义异常响应信息格式"><a class="markdownIt-Anchor" href="#定义异常响应信息格式"></a> 定义异常响应信息格式</h3><pre class="highlight"><code class="">package com.example.demo.domain;public class Result&lt;T&gt; {    private Integer code; // 错误码    private String msg;   // 提示信息    private T data;       // 具体内容    public Integer getCode() {        return code;    }    public void setCode(Integer code) {        this.code = code;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    public T getData() {        return data;    }    public void setData(T data) {        this.data = data;    }}</code></pre><h3 id="自定义异常类"><a class="markdownIt-Anchor" href="#自定义异常类"></a> 自定义异常类</h3><pre class="highlight"><code class="">package com.example.demo.exception;import com.example.demo.enums.ResultEnum;public class PersonException extends RuntimeException {    private Integer code;    public PersonException(ResultEnum resultEnum) {        super(resultEnum.getMsg());        this.code = resultEnum.getCode();    }    public Integer getCode() {        return code;    }    public void setCode(Integer code) {        this.code = code;    }}</code></pre><h3 id="规范响应code和msg"><a class="markdownIt-Anchor" href="#规范响应code和msg"></a> 规范响应code和msg</h3><pre class="highlight"><code class="">package com.example.demo.enums;public enum ResultEnum {    UNKNOW_ERROR(-1, &quot;未知错误&quot;),    SUCCESS(200, &quot;添加成功&quot;),    PRIMARY_SCHOOL(403, &quot;在上小学&quot;),    MIDDLE_SCHOOL(404, &quot;在上初中&quot;),    ;    private Integer code;    private String msg;    ResultEnum(Integer code, String msg) {        this.code = code;        this.msg = msg;    }    public Integer getCode() {        return code;    }    public String getMsg() {        return msg;    }}</code></pre><h3 id="进行异常捕获"><a class="markdownIt-Anchor" href="#进行异常捕获"></a> 进行异常捕获</h3><pre class="highlight"><code class="">package com.example.demo.handle;import com.example.demo.domain.Result;import com.example.demo.exception.PersonException;import com.example.demo.util.ResultUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger            (ExceptionHandle.class);    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e){        if (e instanceof PersonException) {            PersonException personException = (PersonException) e;            return ResultUtil.error(personException.getCode(),                    personException.getMessage());        } else {            LOGGER.error(&quot;[系统异常] {}&quot;, e);            return ResultUtil.error(-1, &quot;未知错误&quot;);        }    }}</code></pre><h3 id="进行逻辑判断从而判断异常"><a class="markdownIt-Anchor" href="#进行逻辑判断从而判断异常"></a> 进行逻辑判断,从而判断异常</h3><pre class="highlight"><code class="">package com.example.demo.service;import com.example.demo.domain.Person;import com.example.demo.enums.ResultEnum;import com.example.demo.exception.PersonException;import com.example.demo.repository.PersonRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PersonService {    @Autowired    private PersonRepository personRepository;    public void getAge(Integer id) throws Exception{        Person person = personRepository.findOne(id);        Integer age = person.getAge();        if (age &lt; 10) {            throw new PersonException(ResultEnum.PRIMARY_SCHOOL);        } else if (age &gt; 10 &amp;&amp; age &lt; 16) {            throw new PersonException(ResultEnum.MIDDLE_SCHOOL);        }    }}</code></pre><h2 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h2><p>对Service进行测试</p><pre class="highlight"><code class="">package com.example.demo;import com.example.demo.domain.Person;import com.example.demo.service.PersonService;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class PersonServiceTest {    @Autowired    private PersonService personService;    @Test    public void findOneTest() {        Person person = personService.findOne(9);        // 断言        Assert.assertEquals(new Integer(19), person.getAge());    }}</code></pre><p>对API进行测试</p><pre class="highlight"><code class="">package com.example.demo.controller;import com.example.demo.domain.Person;import com.example.demo.repository.PersonRepository;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet        .AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class PersonControllerTest {    @Autowired    private MockMvc mockMvc;    @Test    public void personList() throws Exception {        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person&quot;)).                // 对状态码进行断言                andExpect(MockMvcResultMatchers.status().isOk()).                // 对响应文本进行断言                andExpect(MockMvcResultMatchers.content().string(&quot;&quot;));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本部分代码是基于&lt;code&gt;SpringBoot基础应用&lt;/code&gt;博文的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码结构如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;&quot;&gt;demo   // 项目名
      
    
    </summary>
    
      <category term="框架" scheme="http://yov.oschina.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
      <category term="框架" scheme="http://yov.oschina.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十)/</id>
    <published>2017-10-18T02:24:29.526Z</published>
    <updated>2017-10-21T05:59:07.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><blockquote><p>链表是引用的加强应用.<br>知识点前提：依赖于引用传递；this表示当前对象。</p></blockquote><h3 id="链表基本概念"><a class="markdownIt-Anchor" href="#链表基本概念"></a> 链表基本概念</h3><p>1.链表是一种简单的数据结构，功能是<strong>依靠引用关系实现多个数据的保存。</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-1.png" alt="无法加载" title="数据保存"><br>根据上图编写代码：</p><blockquote><p>要求：定义一个Node类，保存String类型数据，同时拥有下一个节点的引用。</p></blockquote><pre class="highlight"><code class="">// 每个链表由多个节点组成class Node { // 定义节点类    private String data; // 要保存的数据    private Node next;   // 要保存的下一个节点    // 每个Node对象都必须保存相应的数据    public Node(String data) { // 有数据才有Node        this.data = data;    }    public void setNext(Node next) {        this.next = next;    }    public Node getNext() {        return this.next;    }    public String getData() {        return this.data;    }}</code></pre><p><code>Node</code>类专门负责保存节点关系，需要其他类负责Node之间的关系匹配。<br><strong>范例</strong>：使用循环取出数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Node root = new Node(&quot;火车头&quot;);        Node n1 = new Node(&quot;车厢A&quot;);        Node n2 = new Node(&quot;车厢B&quot;);        root.setNext(n1);        n1.setNext(n2);        // 2. 取出数据        Node currentNode = root; //从根节点开始读取数据        while (currentNode != null) { // 当前节点存在数据            System.out.println(currentNode.getData());            // 将下一节点设置为当前节点            currentNode = currentNode.getNext();        }    }}</code></pre><p>利用循环取出数据不够便捷，应使用递归。<br><strong>范例</strong>：使用递归取出数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Node root = new Node(&quot;火车头&quot;);        Node n1 = new Node(&quot;车厢A&quot;);        Node n2 = new Node(&quot;车厢B&quot;);        root.setNext(n1);        n1.setNext(n2);        print(root);    }    public static void print(Node current){        if (current == null){ // 节点不存在            return ; // 结束方法调用        }        System.out.println(current.getData());        print(current.getNext()); // 递归调用    }}</code></pre><p><strong>因为循环次数未知，所以使用while循环。节点操作中，递归比while循环更直观。</strong></p><blockquote><p><strong>问题：为什么要设置Node类</strong><br>答：数据本身不具有先后关系，因此需要使用Node类封装份数据，同时利用Node类指向下一节点。</p></blockquote><h3 id="链表基本实现"><a class="markdownIt-Anchor" href="#链表基本实现"></a> 链表基本实现</h3><p>通过分析发现：</p><blockquote><p>(1)用户操作过程中，Node类应该是不可见的，即用户无需关注Node类的结构<br>(2)Node之间的关系不应该由用户定义，而应该由一个专门的类处理。</p></blockquote><p><strong>范例</strong>：定义Link类，隐藏Node类<br>程序要描述的步骤如下：<br><strong>第一步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-2.png" alt="无法加载" title="数据保存"><br><strong>第二步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-3.png" alt="无法加载" title="数据保存"><br><strong>第三步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-4.png" alt="无法加载" title="数据保存"><br><strong>第四步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-5.png" alt="无法加载" title="数据保存"></p><pre class="highlight"><code class="">// 处理Node对象间关系class Link {    private Node root; // 根节点    // 设置数据    public void add(String data) {        // 为了设置数据的先后关系，将data包装在Node对象中        Node newNode = new Node(data);        if (this.root == null) { // 保存数据时，根节点不存在            // 该判断执行一次，因为链表只有一个根节点            this.root = newNode; // 将新节点设置为根节点        } else { // 根节点存在            // 新节点应交给Node决定            // 从root之后设置合适的位置            this.root.addNode(newNode);        }    }    // 输出数据    public void print() {        if (this.root != null) {            this.root.printNode();        }    }}</code></pre><p><strong>范例</strong>:根据Link类，修改Node类</p><pre class="highlight"><code class="">class Node {     private String data;     private Node next;      public Node(String data) {         this.data = data;    }    public void setNext(Node next) {        this.next = next;    }    public Node getNext() {        return this.next;    }    public String getData() {        return this.data;    }    // 添加节点    // 第一次Link调用: this = link.root    // 第二次Node调用：this = link.root.next    // 第三次Node调用：this = link.root.next.next    public void addNode(Node newNode) {        if (this.next == null) { // 当前节点的next为空            this.next = newNode; // 保存为新节点        } else {             // 当前节点的next的next继续保存            this.next.addNode(newNode);        }    }    // 第一次Link调用: this = link.root    // 第二次Node调用：this = link.root.next    // 第三次Node调用：this = link.root.next.next    public void printNode() {        System.out.println(this.data); // 输出当前节点数据        if (this.next != null) { // 当前节点有next            this.next.printNode(); // 输出next节点信息        }    }}</code></pre><p><strong>范例</strong>：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link(); // 负责数据操作        // 增加数据        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);        // 输出数据        link.print();    }}</code></pre><p>由上述代码可知链表操作的基本特点：</p><blockquote><p>（1）对于客户端而言Node是不可见的，只能利用Link中的方法<br>（2）Link类的功能是控制Node对象的产生和根节点的使用；<br>（3）Node类的功能是保存数据以及配置引用关系。</p></blockquote><h3 id="可用链表基本结构"><a class="markdownIt-Anchor" href="#可用链表基本结构"></a> 可用链表基本结构</h3><p>1.可用链表指的是能实现数据的增删改查的链表。<br>2.可用链表开发要求：Node类负责节点数据的保存以及节点关系的匹配，因此Node类不能被单独使用，即外部不能绕过Link去使用Node<br><strong>范例</strong>：修改Node结构，使得Node类只能被Link类使用</p><blockquote><p>思路：将Node类变为private定义的内部类。</p></blockquote><pre class="highlight"><code class="">class Link { // 链表类，外部可见    // Node定义在内部让其只为Link服务    private class Node {         private String data; // 保存数据        private Node next; // 引用关系        public Node(String data) {             this.data = data;        }    }    // ====================以上为内部类=====================    private Node root; // 根节点}</code></pre><p>上述代码即为可用链表的基本结构，后续为其增加功能代码。</p><h3 id="增加数据功能"><a class="markdownIt-Anchor" href="#增加数据功能"></a> 增加数据功能</h3><blockquote><p>思路：数据的增加应由Link负责节点对象的产生，以及根节点的维护。节点间的关系匹配，由Node类处理。</p></blockquote><p><strong>范例</strong>：Node类中添加<code>addNode()</code>，Link类中添加<code>add()</code></p><pre class="highlight"><code class="">// 设置关系public void addNode(Node newNode) {    if (this.next == null) {        this.next = newNode;    } else {        this.next.addNode(newNode);    }}public void add(String data) {    if (data == null) { // 输入数据为空        return;    }    Node newNode = new Node(data); // 要保存的数据    if (this.root == null) { // 根节点不存在        this.root = newNode; // 设为根节点    } else { //  根节点存在，交由Node处理        this.root.addNode(newNode);    }}</code></pre><p>范例：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link();        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);    }}</code></pre><h3 id="获取链表长度"><a class="markdownIt-Anchor" href="#获取链表长度"></a> 获取链表长度</h3><blockquote><p>思路：每个链表对象都只有一个root，可以在Link类中设置count属性，随后每次添加数据后，count自增。</p></blockquote><p>范例：修改Link类<br>（1）增加count属性:<code>private int count = 0; // 节点的个数</code><br>（2）在add()添加统计节点个数的操作</p><pre class="highlight"><code class="">public void add(String data) {   if (data == null) {        return;   }   Node newNode = new Node(data);    if (this.root == null) {        this.root = newNode;    } else { //        this.root.addNode(newNode);   }   this.count++; // 每次增加节点，count+1}</code></pre><p>（3）添加获取链表长度的方法size()</p><pre class="highlight"><code class="">public int size() {    return this.count;}</code></pre><p>（4）判断链表是否为空，有两种方式，一是判断root是否为null，二是判断count是否为0，在此采用第二种方式，在Link类中添加isEmpty()</p><pre class="highlight"><code class="">public boolean isEmpty() {    return this.count == 0;}</code></pre><h3 id="内容查询"><a class="markdownIt-Anchor" href="#内容查询"></a> 内容查询</h3><blockquote><p>思路：判断链表中是否存在某数据，以String为例，仅需遍历链表中的数据，与要查询的数据记性匹配（使用equals(String str)），如果匹配成功返回true，反之返回false。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-6.png" alt="无法加载" title="内容查询"><br>根据上图编写代码：<br>（1）Link中添加contains()</p></blockquote><pre class="highlight"><code class="">public boolean contains(String data) {    if (data == null || root == null) {        return false;    }    return this.root.containsNode(data);}</code></pre><p>Link从root节点开始查询数据是否存在，数据不存在，Node开始查询非根节点。<br>（2）Node中添加containsNode()</p><pre class="highlight"><code class="">public boolean containsNode(String data) {    if (data.equals(this.data)) { // 当前数据等于要目标数据        return true; // 结束查询    } else { // 当前数据不等于目标数据        if (this.next != null) { // 有后续节点            return this.next.containsNode(data);        } else {             return false;        }    }}</code></pre><p>（3）测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link();        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);        System.out.println(link.contains(&quot;火车头&quot;));    }}</code></pre><blockquote><p>案例中使用的是String类型数据，所以判断数据使用equals(String str)。如果判断的是自定义类型数据，就需要定义一个对象比较的方法，方法名暂定为compare()。</p></blockquote><h3 id="根据索引取得数据"><a class="markdownIt-Anchor" href="#根据索引取得数据"></a> 根据索引取得数据</h3><blockquote><p>链表中保存有多个对象。数组也可以保存多个对象。链表和数组相比优势在于没有长度限制。因此链表相当于一个动态对象数组，具备像数组那样根据索引取得元素的功能。<br>由于是动态对象数组，所以元素的索引也是动态生成的。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-7.png" alt="无法加载" title="内容查询"><br>根据上图，编写代码：<br>（1）Link中增加foot属性，表示Node的索引:<code>private int foot = 0; // 索引</code><br>每次查询前，应该重置为0.链表查询数据前应先判断要查询的索引小于索引总数。</p></blockquote><pre class="highlight"><code class="">public String get(int index) {    if (index &gt; this.count) { // 超出查询范围        return null;    }    this.foot = 0;    return this.root.getNode(index); // 查询交给Node类}</code></pre><p>（2）Node定义getNode()，内部类和外部类间可以方便地进行私有属性的访问。</p><pre class="highlight"><code class="">public String getNode(int index) {    // 当前foot内容与要查询的索引比较    // foot自增，目的是下次查询方便    if (Link.this.foot++ == index) {        return this.data;    } else {        return this.next.getNode(index);    }}</code></pre><h3 id="修改链表数据"><a class="markdownIt-Anchor" href="#修改链表数据"></a> 修改链表数据</h3><blockquote><p>修改和查询思路差不多，不同的是查询是当满足索引值时，返回数据；修改是满足索引时，对数据重新赋值。</p></blockquote><p>（1）Link添加<code>set(int index, String data)</code></p><pre class="highlight"><code class="">public void set(int index, String data) {    if (index &gt; this.count) {        return;    }    this.foot = 0; // 重置foot,作为索引    this.root.setNode(index, data); // Node进行修改数据}</code></pre><p>（2）Node添加<code>setNode(int index, String data)</code></p><pre class="highlight"><code class="">public void setNode(int index, String data) {    if (Link.this.foot++ == index) {        this.data = data;    } else {        this.next.setNode(index, data);    }}</code></pre><h3 id="删除链表数据"><a class="markdownIt-Anchor" href="#删除链表数据"></a> 删除链表数据</h3><blockquote><p>删除链表数据应分为两种情况：<br>（1）要删除的是根节点，root.next()变为root，在Link中处理，因为由Link来维护root；<br>（2）要删除的是非根节点，当前节点的上一节点.next()=当前节点.next()，即空出了当前节点。非根节点应交由Node处理。</p></blockquote><p>1.Node添加removeNode(Node previous, String data)</p><pre class="highlight"><code class="">public void removeNode(Node previous, String data) {    // 参数中传递上一个节点和要删除的数据    if (data.equals(this.data)) {        previous.next = this.next;    } else {        this.next.removeNode(this, data);    }}</code></pre><ol start="2"><li>Link添加remove(String data)</li></ol><pre class="highlight"><code class="">public void remove(String data) {    if (this.contains(data)) { // 判断数据是否存在        if (data.equals(this.root.data)) { // 判断数据是否是root数据            this.root = this.root.next;        } else {            // root是Node对象，此处直接访问内部类私有操作            this.root.next.removeNode(this.root, data);        }this.count -- ; // 删除后数据个数减少    }}</code></pre><h3 id="对象数组转换"><a class="markdownIt-Anchor" href="#对象数组转换"></a> 对象数组转换</h3><blockquote><p>开发中，类中不应该有输出语句。想输出数据应将数据返回到调用处。链表属于动态数组，因此可以将链表以对象数组的形式返回。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-8.png" alt="无法加载" title="对象数组转换"><br>由上图可知，Link的<code>toArray()</code>要返回一个对象数组，且该数组也要由Node操作。因此该数组应定义为Link的属性。<br>（1）Link添加一个数组属性，便于Node和Link访问。添加toArray()</p></blockquote><pre class="highlight"><code class="">private String[] retArray; // 返回的数组public String[] toArray() {    if (this.root == null) {        return null;    }    this.foot = 0; // 需要脚标控制    this.retArray = new String[this.count]; // 根据保存内容开辟数组    this.root.toArrayNode();    return this.retArray;}</code></pre><p>（2）Node添加toArrayNode()进行数组数据保存</p><pre class="highlight"><code class="">public void toArrayNode() {    Link.this.retArray[Link.this.foot++] = this.data;    if (this.next != null) {        this.next.toArrayNode();    }}</code></pre><p><strong>链表数据变为对象数组取出是重要功能！</strong></p><h3 id="链表使用"><a class="markdownIt-Anchor" href="#链表使用"></a> 链表使用</h3><blockquote><p>上述链表只能操作String数据。下面要使用链表操作自定义类，由于链表具有contains()，因此类中需定义对象比较的方法。</p></blockquote><p>（1）定义Book类（setter/getter暂时省略）</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String getInfo() {        return &quot;书名：&quot; + this.title + &quot;,价格&quot; + this.price;    }    public boolean compare(Book book) {        if (book == null) {            return false;        }        if (this == book) {            return true;        }        if (this.title.equals(book.title)                &amp;&amp; this.price == book.price) {            return true;        } else {            return false;        }    }}</code></pre><p>（2）修改链表</p><pre class="highlight"><code class="">class Link {     private class Node { // 节点类        private Book data; // 保存数据        private Node next; // 引用关系        public Node(Book data) {             this.data = data;        }        // 设置关系        public void addNode(Node newNode) {            if (this.next == null) {                this.next = newNode;            } else {                this.next.addNode(newNode);            }        }        // 数据查询        public boolean containsNode(Book data) {            if (data.equals(this.data)) { // 当前数据等于要目标数据                return true; // 结束查询            } else { // 当前数据不等于目标数据                if (this.next != null) { // 有后续节点                    return this.next.containsNode(data);                } else { // 没有后续节点                    return false;                }            }        }        public Book getNode(int index) {            // 当前foot内容与要查询的索引比较            // foot自增，目的是下次查询方便            if (Link.this.foot++ == index) {                return this.data;            } else {                return this.next.getNode(index);            }        }        // 修改节点信息        public void setNode(int index, Book data) {            if (Link.this.foot++ == index) {                this.data = data;            } else {                this.next.setNode(index, data);            }        }        // 删除非根节点        public void removeNode(Node previous, Book data) {            // 参数中传递上一个节点和要删除的数据            if (data.equals(this.data)) {                previous.next = this.next;            } else {                this.next.removeNode(this, data);            }        }        public void toArrayNode() {            Link.this.retArray[Link.this.foot++] = this.data;            if (this.next != null) {                this.next.toArrayNode();            }        }    }    // ====================以上为内部类=====================    private Node root; // 根节点    private int count = 0; // 节点的个数    private int foot = 0; // 索引    private Book[] retArray; // 返回的数组    public void add(Book data) {        if (data == null) { // 输入数据为空            return;        }        Node newNode = new Node(data); // 要保存的数据        if (this.root == null) { // 根节点不存在            this.root = newNode; // 设为根节点        } else { //  根节点存在，交由Node处理            this.root.addNode(newNode);        }        this.count++; // 每次增加节点，count+1    }    // 获取链表长度    public int size() {        return this.count;    }    // 判断是否为空链表    public boolean isEmpty() {        return this.count == 0;    }    // 判断数据是否存在    public boolean contains(Book data) {        if (data == null || root == null) {            return false;        }        return this.root.containsNode(data);    }    // 根据索引获取信息    public Book get(int index) {        if (index &gt; this.count) { // 超出查询范围            return null;        }        this.foot = 0;        return this.root.getNode(index); // 查询交给Node类    }    // 设置信息    public void set(int index, Book data) {        if (index &gt; this.count) {            return;        }        this.foot = 0; // 重置foot,作为索引        this.root.setNode(index, data); // Node进行修改数据    }    // 判断删除节点是否为root    public void remove(Book data) {        if (this.contains(data)) { // 判断数据是否存在            if (data.equals(this.root.data)) { // 判断数据是否是root数据                this.root = this.root.next;            } else {                // root是Node对象，此处直接访问内部类私有操作                this.root.next.removeNode(this.root, data);            }            this.count--; // 删除后数据个数减少        }    }    public Book[] toArray() {        if (this.root == null) {            return null;        }        this.foot = 0; // 需要脚标控制        this.retArray = new Book[this.count]; // 根据保存内容开辟数组        this.root.toArrayNode();        return this.retArray;    }}</code></pre><p>（3）测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link all = new Link();        all.add(new Book(&quot;Java开发&quot;, 69.8));        all.add(new Book(&quot;JSP&quot;, 78.8));        all.add(new Book(&quot;C++开发&quot;, 19.8));        System.out.println(&quot;保存书的个数：&quot; + all.size());        System.out.println(all.contains(new Book(&quot;Java开发&quot;, 69.8)));        all.remove(new Book(&quot;C++开发&quot;, 19.8));        Book[] books = all.toArray();        for (int x = 0; x &lt; books.length; x++) {            System.out.println(books[x].getInfo());        }    }}</code></pre><p>链表的最佳应用就是横向替换对象数组。</p><h3 id="在映射中使用链表"><a class="markdownIt-Anchor" href="#在映射中使用链表"></a> 在映射中使用链表</h3><blockquote><p>链表属于动态对象数组。之前进行数据表映射时，都会出现对象数组的概念，现在就用链表来进行对象保存。本节以一对多为例，即用前文中的省份-城市表为例：</p></blockquote><p>（1）对于使用链表的类，要添加对象比较的方法</p><pre class="highlight"><code class="">class Province {    private int pid;    private String pname;    private Link cities = new Link();    public Link getCities() {        return this.cities;    }    //getter/setter,无参构造方法略    public Province(int pid, String pname) {        this.pid = pid;        this.pname = pname;    }    public boolean compare(Province province) {        if (province == null) {            return false;        }        if (this == province) {            return true;        }        if (this.pid == province.pid &amp;&amp; this.pname.equals(province.pname)) {            return true;        } else {            return false;        }    }    public String getInfo() {        return &quot;省份ID：&quot; + this.pid + &quot;,省份名称：&quot; + this.pname;    }}class City {    private int cid;    private String cname;    private Province province;    public void setProvince(Province province) {        this.province = province;    }    public Province getProvince() {        return this.province;    }    //getter/setter,无参构造方法略    public City(int cid, String cname) {        this.cid = cid;        this.cname = cname;    }    public String getInfo() {        return &quot;城市ID：&quot; + this.cid + &quot;,城市名称：&quot; + this.cname;    }    public boolean compare(City city) {        if (city == null) {            return false;        }        if (this == city) {            return true;        }        if (this.cid == city.cid &amp;&amp; this.cname.equals(city.cname)                &amp;&amp; this.province.compare(city.province)) {            return true;        } else {            return false;        }    }}</code></pre><p>此时只需将链表中的Book改为City即可。<br>在此时发现问题：每定义一个新的类，链表就需要重新进行修改。方法解决了代码重复问题。但是该问题不属于代码重复，属于数据类型不同意，该问题需要依靠面向对象的特性的来结局。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><blockquote><p>（1）本章所讲的只是最基础的单向链表；<br>（2）链表中应有如下方法：</p></blockquote><table><thead><tr><th>No.</th><th style="text-align:left">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">public void add(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">向链表中添加数据</td></tr><tr><td>2</td><td style="text-align:left">public int size()</td><td style="text-align:center">普通</td><td style="text-align:left">取得链表中数据个数</td></tr><tr><td>3</td><td style="text-align:left">public boolean isEmpty()</td><td style="text-align:center">普通</td><td style="text-align:left">判断是否为空链表</td></tr><tr><td>4</td><td style="text-align:left">public boolean contains(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">判断数据是否存在</td></tr><tr><td>5</td><td style="text-align:left">public 数据类型 get(int index)</td><td style="text-align:center">普通</td><td style="text-align:left">根据索引取得数据</td></tr><tr><td>6</td><td style="text-align:left">public void set(int index,数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">修改数据</td></tr><tr><td>7</td><td style="text-align:left">public void remove(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">删除指定数据</td></tr><tr><td>8</td><td style="text-align:left">public 数据类型 [] toArray()</td><td style="text-align:center">普通</td><td style="text-align:left">将链表以对象数组的形式转换</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt; 链表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;链表是引用的加强应用.&lt;br&gt;
知识点前提：依赖于引用传递；this表示当前对象。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(九)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B9%9D)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(九)/</id>
    <published>2017-10-15T01:28:21.489Z</published>
    <updated>2017-10-21T05:58:17.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h2><blockquote><p>代码块是<code>{}</code>定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：<strong>普通代码块，构造块，静态块和同步代码块</strong>。</p></blockquote><h3 id="普通代码块"><a class="markdownIt-Anchor" href="#普通代码块"></a> 普通代码块</h3><p>1.写在方法中的代码块，称为<strong>普通代码块</strong>。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        { // 普通代码块            int num = 10; // 局部变量            System.out.println(&quot;num = &quot; + num); // 10        }        int num = 100; // 全局变量        System.out.println(&quot;num = &quot; + num); // 100    }}</code></pre><p><strong>普通代码块的功能</strong>是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。</p><h3 id="构造块"><a class="markdownIt-Anchor" href="#构造块"></a> 构造块</h3><p>1.写在类中的代码块，称为<strong>构造块</strong>。</p><pre class="highlight"><code class="">class Book {    public Book(){ // 构造方法        System.out.println(&quot;A. Book类的构造方法&quot;);    }    { // 构造块        System.out.println(&quot;B. Book类的构造块&quot;);    }}public class Demo {    public static void main(String[] args) {        new Book();        // B. Book类的构造块        // A. Book类的构造方法    }}</code></pre><p>输出结果显示：<strong>构造块的调用优先于构造方法。</strong></p><h3 id="静态块"><a class="markdownIt-Anchor" href="#静态块"></a> 静态块</h3><p>static定义的代码块，称为<strong>静态块</strong>。静态块的使用，分为两种情况：<br>1.在非主类中使用</p><pre class="highlight"><code class="">class Book {    public Book(){ // 构造方法        System.out.println(&quot;A. Book类的构造方法&quot;);    }    { // 构造块        System.out.println(&quot;B. Book类的构造块&quot;);    }    static {        System.out.println(&quot;C. Book类的静态块&quot;);    }}public class Demo {    public static void main(String[] args) {        new Book(); // C B A        new Book(); // B A    }}</code></pre><p>结果显示：**静态块优先于构造块。**且不论实例化多少个对象，<strong>静态块只执行一次</strong>。static主要功能是为类中的static属性初始化。</p><pre class="highlight"><code class="">class Book {    public static String msg;    static {        msg = &quot;Hello&quot;.substring(0,2);        System.out.println(&quot;C. Book类的静态块&quot;);    }}public class Demo {    public static void main(String[] args) {        System.out.println(Book.msg);    }}</code></pre><p>2.在主类中定义</p><pre class="highlight"><code class="">public class Demo {    static {        System.out.println(&quot;**************&quot;);    }    public static void main(String[] args) {        System.out.println(&quot;Hello World !&quot;);        // **************        // Hello World !    }}</code></pre><p>结果显示：静态块优先于<code>main()</code>方法执行。在编写测试时，可以使用静态块。</p><h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2><blockquote><p>从开发角度来说，尽量不要使用内部类</p></blockquote><h3 id="内部类基本概念"><a class="markdownIt-Anchor" href="#内部类基本概念"></a> 内部类基本概念</h3><p>1.<strong>内部类</strong>是指在一个类的内部定义其他的类。<br><strong>范例</strong>：内部类</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        public void print() {            System.out.println(msg);        }    }    public void fun() {        // 实例化内部类对象，调用print()方法        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        // 实例化外部类对象        Outer out = new Outer();        out.fun(); // 调用外部类方法，Hello World    }}</code></pre><p>上述代码牺牲了程序的结构，实现了一个重要功能。<br>2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。<br><strong>范例</strong>：取出内部类</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public void fun() {        new Inner().print();    }}class Inner {     public void print() {        System.out.println(msg);    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun(); // 报错，msg属于Outer，Inner无法调用    }}</code></pre><p>（1）要想使得<code>Inner</code>调用<code>msg</code>，就需在<code>Outer</code>中写一个<code>getMsg()</code></p><pre class="highlight"><code class="">public String getMsg(){    return this.msg;}</code></pre><p>（2）<code>Inner</code>要调用<code>Outer</code>的<code>getMsg()</code>方法，必须实例化一个<code>Outer</code>对象</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public String getMsg(){        return this.msg;    }    public void fun() {        new Inner().print();    }}class Inner {    public void print() {        System.out.println(new Outer().getMsg());    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public String getMsg() {        return this.msg;    }    public void fun() {        new Inner(this).print();    }}class Inner {    private Outer out;    public Inner(Outer out) {        this.out = out;    }    public void print() {        System.out.println(this.out.getMsg());    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>由此可得内部类的特点：</p><blockquote><p>内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。</p></blockquote><p><strong>范例</strong>：访问内部类私有属性</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        private  String info = &quot;世界你好&quot;;        public void print() {            System.out.println(msg);        }    }    public void fun() {        // 实例化内部类对象        Inner in = new Inner();        // 使用内部类对象访问内部类私有属性        System.out.println(in.info);    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>3.观察代码</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        private  String info = &quot;世界你好&quot;;        public void print() {            System.out.println(this.msg); // 报错，找不到msg        }    }    public void fun() {        new Inner().print();    }}</code></pre><p><strong>报错原因</strong>：<code>this.msg</code>指向的是<code>Inner</code>类，而<code>Inner</code>类中没有<code>msg</code>属性。因此要访问<code>Outer</code>的<code>msg</code>属性，需要使用<code>Outer.this.msg</code>.</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        public void print() {            // 外部类.this = 外部类的当前对象            System.out.println(Outer.this.msg);         }    }    public void fun() {        new Inner().print();    }}</code></pre><p>4.内部类的class文件名: <code>Outer$Inner.class</code><br>直接实例化内部类对象语法：<code>外部类.内部类 对象名 = new 外部类().new 内部类();</code><br><strong>范例</strong>：实例化内部类对象</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Outer.Inner in = new Outer().new Inner();        in.print();    }}</code></pre><p>上述代码说明：</p><blockquote><p>要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。</p></blockquote><p>5.内部类只想被外部类使用，不能被外部调用，应使用<code>private</code>定义</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    private class Inner { // 内部类        public void print() {            // 外部类.this = 外部类的当前对象            System.out.println(Outer.this.msg);       }    }}</code></pre><h3 id="static定义内部类"><a class="markdownIt-Anchor" href="#static定义内部类"></a> static定义内部类</h3><p>使用static定义的属性或方法不受实例化对象控制，因此使用<strong>static定义的内部类也不受外部类实例化对象控制。</strong><br>1.static定义的内部类只能访问外部类中static定义的属性或方法</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    static class Inner { // 内部类        public void print() {            System.out.println(msg); // 报错，无法引用非静态变量msg        }    }}</code></pre><p>2.static定义的内部类，相当于外部类<br>取得static定义的内部类对象语法：<code>外部类.内部类 对象 = new 外部类.内部类();</code>由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于<strong>内部类成了一个外部类。</strong></p><pre class="highlight"><code class="">class Outer { // 外部类    private static String msg = &quot;Hello World&quot;;    static class Inner { // 内部类        public void print() {            System.out.println(msg);        }    }}public class Demo {    public static void main(String[] args) {        Outer.Inner in = new Outer.Inner();        in.print();    }}</code></pre><h3 id="方法中定义内部类"><a class="markdownIt-Anchor" href="#方法中定义内部类"></a> 方法中定义内部类</h3><p>1.内部类可定义在外部类中的任意位置。<strong>在方法中定义内部类</strong>是最常见的形式。</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun() {        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(msg);            }        }        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        new Outer().fun();    }}</code></pre><p>2.方法可以接收参数，也可以定义变量<br><strong>范例</strong>：访问方法中定义的参数或变量</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun(int num) { // 方法参数        double score = 99.9; // 方法变量        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(&quot;属性：&quot; + msg);                System.out.println(&quot;方法参数：&quot; + num);                System.out.println(&quot;方法变量：&quot; + score);            }        }        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        new Outer().fun(100);    }}</code></pre><p><strong>方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后</strong>！在JDK1.8之前的版本严格要求：方法中的内部类只能访问<code>final</code>标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式：</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun(final int num) { // 方法参数       final double score = 99.9; // 方法变量        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(&quot;属性：&quot; + msg);                System.out.println(&quot;方法参数：&quot; + num);                System.out.println(&quot;方法变量：&quot; + score);            }        }        new Inner().print();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码块&quot;&gt;&lt;/a&gt; 代码块&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块是&lt;code&gt;{}&lt;/code&gt;定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：&lt;stron
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(八)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AB)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(八)/</id>
    <published>2017-10-14T02:34:53.423Z</published>
    <updated>2017-10-21T05:58:52.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象比较"><a class="markdownIt-Anchor" href="#对象比较"></a> 对象比较</h2><p>1.数字比较用<code>==</code>，字符串比较用<code>equals(String str)</code>。</p><blockquote><p>要进行对象比较，必须对对象中所有属性的值进行比较。</p></blockquote><p><strong>范例</strong>：对象比较的基本方式</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    //省略无参构造方法和setter方法    public String getTitle() {        return this.title;    }    public double getPrice() {        return this.price;    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book(&quot;Java开发&quot;, 79.5);        Book bkB = new Book(&quot;JSP&quot;, 45.6);        if (bkA.getTitle().equals(bkB.getTitle())                &amp;&amp; bkA.getPrice() == bkB.getPrice()) {            System.out.println(&quot;bkA和bkB是同一个对象！&quot;);        } else {            System.out.println(&quot;bkA和bkB是不同对象！&quot;);        }    }}</code></pre><p>上述程序存在问题：主方法相当于客户端，客户端的程序逻辑应该越简单越好。所以对象比较应该由对象自己完成，即<strong>对象所对应的类应该提供对象比较的方法。</strong></p><blockquote><p>附：类的属性使用private封装，那么在类的外部就不能通过对象直接调用属性</p></blockquote><pre class="highlight"><code class="">class Info{    private String msg = &quot;Hello&quot;;    public void print(){        System.out.println(&quot;msg = &quot; + this.msg);    }}public class Demo {    public static void main(String[] args) {        Info x = new Info();        x.msg = &quot;sss&quot;; // 报错，无法访问private属性        x.print();    }}</code></pre><blockquote><p>附：将一个对象作为参数传回类的方法中，相当于取消封装，使得对象可以直接访问属性。</p></blockquote><pre class="highlight"><code class="">class Info {    private String msg = &quot;Hello&quot;;    public void print() {        System.out.println(&quot;msg = &quot; + this.msg);    }    public void fun(Info temp) {        // 在类的内部直接利用对象访问私有属性        temp.msg = &quot;修改内容&quot;;    }}public class Demo {    public static void main(String[] args) {        Info x = new Info();        x.fun(x);        x.print(); // msg = 修改内容    }}</code></pre><blockquote><p>附：<strong>一个类接收本类对象</strong>形式的代码在对象比较时很常见。</p></blockquote><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    //省略无参构造方法和setter方法    public String getTitle() {        return this.title;    }    public double getPrice() {        return this.price;    }    // 类接收自身对象，对象可以直接访问属性，不需要getter方法    // compare()有两个功能：一带回了要比较的信息；二方便属性访问    public boolean compare(Book book) {        if (book == null) { // 要比较的对象为空            return false; // 没必要比较        }        if (this == book) { // 内存地址相同            return true; //避免具体比较，节约时间        }        // 执行“bkA.equals(bkB)”时，有两个对象：        // 一个为当前对象this(调用方法的对象，即bkA）        // 一个为传递对象book(引用传递，即bkB）        if (this.title.equals(book.title)                &amp;&amp; this.price == book.price) {            return true;        } else {            return false;        }    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book(&quot;Java开发&quot;, 79.5);        Book bkB = new Book(&quot;JSP&quot;, 45.6);        if (bkA.compare(bkB)) {            System.out.println(&quot;bkA和bkB是同一个对象！&quot;);        } else {            System.out.println(&quot;bkA和bkB是不同对象！&quot;);        }    }}</code></pre><blockquote><p>总结<br>（1）对象比较的方法必须定义在类中；<br>（2）对象比较时一定要判断是否为<code>null</code>，内存地址是否相同，属性是否相同。</p></blockquote><h2 id="关键字static"><a class="markdownIt-Anchor" href="#关键字static"></a> 关键字static</h2><h3 id="static-定义属性"><a class="markdownIt-Anchor" href="#static-定义属性"></a> static 定义属性</h3><blockquote><p>问题引出：</p></blockquote><pre class="highlight"><code class="">class Book {    private String title;    private double price;    // 为操作方便，暂不封装    String pub = &quot;清华大学出版社&quot;;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String getInfo(){        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book(&quot;Java开发&quot;, 79.5);        Book bkB = new Book(&quot;JSP&quot;, 45.6);        System.out.println(bkA.getInfo()); // 清华大学出版社        System.out.println(bkB.getInfo()); // 清华大学出版社        bkB.pub = &quot;北京大学出版社&quot;;        System.out.println(bkA.getInfo()); // 清华大学出版社        System.out.println(bkB.getInfo()); // 北京大学出版社    }}</code></pre><blockquote><p>对上述代码进行内存分析：<br><img src="/article/Java/Java Base/Java基础知识(八)/12-1.png" alt="无法加载" title="内存分析"><br>通过内存分析，发现属性重复：每个对象各自占有相同的属性值。假如有1000个该对象，要修改所有对象的pub属性，就需要分别进行修改。因此如果将pub属性定为普通属性，那每个堆内存都保存有各自的pub值。</p></blockquote><p>1.但所有对象的pub值都一样，应将其定为一个共享的属性，即所有对象都指向同一块pub属性。可以利用<code>static</code>定义共享属性。</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    // 为操作方便，暂不封装    static String pub = &quot;清华大学出版社&quot;;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String getInfo(){        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book(&quot;Java开发&quot;, 79.5);        Book bkB = new Book(&quot;JSP&quot;, 45.6);        System.out.println(bkA.getInfo()); // 清华大学出版社        System.out.println(bkB.getInfo()); // 清华大学出版社        bkB.pub = &quot;北京大学出版社&quot;;        System.out.println(bkA.getInfo()); // 北京大学出版社        System.out.println(bkB.getInfo()); // 北京大学出版社    }}</code></pre><p>使用<code>static</code>定义属性后，只要有一个对象修改属性值，那么所有对象的该属性值都会改变，内存分析如下：<br><img src="/article/Java/Java Base/Java基础知识(八)/12-2.png" alt="无法加载" title="内存分析"><br>2. <code>static</code>定义的属性与普通属性区别在于<strong>保存数据的内存区域不同。</strong><br><code>static</code>定义的是公共属性，任由某个对象直接修改属性值是不合理的，应该由所有对象的代表进行属性访问，即用类访问。<strong>因此<code>static</code>定义的属性，可直接用类名调用：</strong><code>Book.pub = &quot;北京大学出版社&quot;;</code><br>3. <code>static</code>属性与普通属性的区别在于：普通属性必须由实例化的对象调用，而在没有实例化对象的情况下，static属性依然可以被调用。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 没有实例化对象的情况下，输出pub的内容        System.out.println(Book.pub);    }}</code></pre><p>由结果可知：<strong><code>static</code>虽然定义在类中，但不受对象控制，是独立于类存在的。</strong><br>4. 何时使用static定义属性<br>编写类时，<code>static</code>不是首选修饰符，<strong>当需要描述共享信息时，才使用static，方便集体修改，不用重复开辟内存空间。</strong></p><h3 id="static-定义方法"><a class="markdownIt-Anchor" href="#static-定义方法"></a> static 定义方法</h3><p>1.<code>static</code>定义的方法也可以直接被类名调用</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    // 为操作方便，暂不封装    private static String pub = &quot;清华大学出版社&quot;;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public static void setPub(String p){        pub = p;    }    public String getInfo(){        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;    }}public class Demo {    public static void main(String[] args) {        // 没有实例化对象的情况下，调用方法        Book.setPub(&quot;北京大学出版社&quot;);        Book bkA = new Book(&quot;Java开发&quot;, 79.5);        System.out.println(bkA.getInfo()); // 北京大学出版社    }}</code></pre><p>上述代码存在问题：类中有两种方法，static方法和普通方法，两种方法间的访问受到限制。<br>（1）static方法不能直接使用非static属性或方法，只能调用static属性或方法。</p><pre class="highlight"><code class="">public static void setPub(String p){   pub = p;   title = &quot;sss&quot;; // 报错，无法引用非静态变量   getInfo(); // 报错，无法引用非静态方法   System.out.println(this); // 报错，无法引用非静态变量}</code></pre><p>（2）普通方法可以使用static属性或方法</p><pre class="highlight"><code class="">public String getInfo(){    setPub(&quot;&quot;); // 不报错    return &quot;,出版社：&quot; + this.pub; // 不报错}</code></pre><p>出现上述限制的原因：</p><blockquote><p>|- 普通属性和方法必须在对象实例化后分配了堆内存空间，才可以使用；<br>|- static定义的方法和属性，不受实例化对象控制，可在没有实例化对象情况下访问。</p></blockquote><p>2.一个方法定义在主类中，并由主方法直接调用，该方法定义格式如下：</p><pre class="highlight"><code class="">public static 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) {    方法体;     [return [返回值] ;] // []中内容可写可不写}</code></pre><p>一个方法定义在类中，由对象直接调用，其语法格式如下：</p><pre class="highlight"><code class="">public 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) {    方法体;     [return [返回值] ;] // []中内容可写可不写}</code></pre><p>观察代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        fun();    }    public static void fun() {        System.out.println(&quot;Hello World !&quot;);    }}</code></pre><p>没有static定义的fun()必须通过对象调用，主方法要使用fun()必须实例化对象</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 产生对象，再利用对象调用非static方法        new Demo().fun();    }    public void fun() {        System.out.println(&quot;Hello World !&quot;);    }}</code></pre><ol start="3"><li>定义类中方法时，<code>static</code>不是首选修饰符，因为每个对象可以利用自己的属性实现方法的不同调用。</li></ol><pre class="highlight"><code class="">class Flag {    private boolean flag;    public Flag(boolean flag) {        this.flag = flag;    }    public void fun() {        if (this.flag) {            System.out.println(&quot;可以操作&quot;);        } else {            System.out.println(&quot;不可以操作&quot;);        }    }}public class Demo {    public static void main(String[] args) {        Flag fA = new Flag(true);        Flag fB = new Flag(false);        fA.fun();        fB.fun();    }}</code></pre><p>当一个类中没有属性，只有方法时，建议将所有方法定义为static方法。这样就不用每次调用时都需要有实例化对象。</p><pre class="highlight"><code class="">class MyMath {    public static int add(int x, int y) {        return x + y;    }}public class Demo {    public static void main(String[] args) {        System.out.println(MyMath.add(10, 20));    }}</code></pre><h3 id="主方法"><a class="markdownIt-Anchor" href="#主方法"></a> 主方法</h3><p>1.主方法的组成：</p><table><thead><tr><th style="text-align:center">组成</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">主方法是程序的开始，所以主方法必须是可见、public（公共的）的</td></tr><tr><td style="text-align:center">static</td><td style="text-align:center">证明此方法可直接由类名调用</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">主方法是程序的开始，因此不能回头，执行完为止，所以不能有返回值</td></tr><tr><td style="text-align:center">main</td><td style="text-align:center">系统规定好的方法名，不能修改</td></tr><tr><td style="text-align:center">String [] args</td><td style="text-align:center">指的是程序运行时传递的参数</td></tr></tbody></table><p><strong>范例</strong>：对主方法传入参数</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        for (int x = 0; x &lt; args.length ; x++) {            System.out.println(args[x]); // 未输出参数，为空        }    }}</code></pre><p>多个参数时，必须使用空格分割。<code>cmd执行的是java Demo 1 3 4 6</code><br>输出为：<code>1 3 4 6</code><br>如果参数本身带有空格，需用<code>&quot;&quot;</code>描述<br>cmd执行的是<code>java Demo &quot;Hello world&quot; &quot;Hello Java&quot;</code></p><h3 id="static应用案例"><a class="markdownIt-Anchor" href="#static应用案例"></a> static应用案例</h3><blockquote><p>已知：<br>（1）多个对象，都使用同一个static属性；<br>（2）static定义方法可以避免实例化对象调用方法的限制。</p></blockquote><p>1.实现对实例化对象个数的统计</p><blockquote><p>要求：每实例化一个对象，就输出&quot;这是第x个实例化对象&quot;<br>思路：每次实例化对象，就会调用构造方法，因此可在构造方法中增加一个统计数据的操作，每当新对象产生，该属性值就自增加一。</p></blockquote><pre class="highlight"><code class="">class Book {    private static int num = 0;    public Book() {        num++;        System.out.println(&quot;这是第&quot; + num + &quot;个实例化对象&quot;);    }}public class Demo {    public static void main(String[] args) {        new Book();        new Book();        new Book();    }}</code></pre><p>2.实现属性的自动设置</p><blockquote><p>要求：类中有一个无参构造方法，一个有参构造方法，有参构造方法的功能是传递title值。不论调用的哪个构造方法，均可为title赋值，且属性值尽量不重复。</p></blockquote><pre class="highlight"><code class="">class Book {    private String title;    private static int num = 0;    public Book() {        this(&quot;Title:No.&quot; + num++);    }    public Book(String title){        this.title = title;    }    public String getTitle(){        return  this.title;    }}public class Demo {    public static void main(String[] args) {        System.out.println(new Book(&quot;Java开发&quot;).getTitle()); // Java开发        System.out.println(new Book().getTitle()); // Title:No.0        System.out.println(new Book().getTitle()); // Title:No.1    }}</code></pre><blockquote><p>总结<br>（1）类定义属性或方法首时选不是static属性或方法；<br>（2）static属性或方法可直接用类名调用；<br>（3）static属性保存在全局数据区。<br>（4）内存区有四种: 栈内存（对象的地址），堆内存（普通属性），全局数据区（static属性），全局代码区（所有的方法）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象比较&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#对象比较&quot;&gt;&lt;/a&gt; 对象比较&lt;/h2&gt;
&lt;p&gt;1.数字比较用&lt;code&gt;==&lt;/code&gt;，字符串比较用&lt;code&gt;equals(String str)&lt;/code&gt;。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(七)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%83)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(七)/</id>
    <published>2017-10-14T02:00:14.040Z</published>
    <updated>2017-10-21T05:58:03.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用传递分析实例"><a class="markdownIt-Anchor" href="#引用传递分析实例"></a> 引用传递分析实例</h2><h3 id="引用传递"><a class="markdownIt-Anchor" href="#引用传递"></a> 引用传递</h3><p>1.引用传递核心意义：同一块堆内存可以被不同栈内存所指向，不同栈内存可以对同一块堆内存进行修改。<br><strong>范例</strong>：引用传递</p><pre class="highlight"><code class="">public class Message {    private int num = 10;    public Message(int num) {        this.num = num;    }    public int getNum() {        return num;    }    public void setNum(int num) {        this.num = num;    }}public class TMessage {    public static void main(String[] args) {        Message msg = new Message(30);        System.out.println(msg.getNum()); // 30        fun(msg); // 引用传递        System.out.println(msg.getNum()); // 100    }    public static void fun(Message temp) {        temp.setNum(100);    }}</code></pre><p>对上述代码进行内存分析：<br><img src="/article/Java/Java Base/Java基础知识(七)/10-1.png" alt="无法加载" title="内存分析"><br>2.引用</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String msg  = &quot;Hello&quot;;        fun(msg);        System.out.println(msg); // Hello    }    public static void fun(String temp) {        temp = &quot;World&quot;;    }}</code></pre><p>出现上述结果原因：String对象的内容一旦声明不可改变，对象内容的改变依靠的是引用地址的改变。内存分析如下：<br><img src="/article/Java/Java Base/Java基础知识(七)/10-2.png" alt="无法加载" title="内存分析"><br>3.引用传递</p><pre class="highlight"><code class="">public class Message {    private String info = &quot;nihao&quot;;    public Message(String info) {        this.info = info;    }    public String getInfo() {        return info;    }    public void setInfo(String info) {        this.info = info;    }}public class TMessage {    public static void main(String[] args) {        Message msg = new Message(&quot;Hello&quot;);        System.out.println(msg.getInfo()); // Hello        fun(msg);        System.out.println(msg.getInfo()); // World    }    public static void fun(Message temp) {        temp.setInfo(&quot;World&quot;);    }}</code></pre><p>内存分析如下：<br><img src="/article/Java/Java Base/Java基础知识(七)/10-3.png" alt="无法加载" title="内存分析"><br><strong>上述内存分析，是按照int型数据的特点进行的。实</strong>际info是String对象，应该按照如下方式进行分析：<br><img src="/article/Java/Java Base/Java基础知识(七)/10-4.png" alt="无法加载" title="内存分析"><br><strong>结论</strong>：虽然<code>String</code>是一个类，属于引用数据类型，但由于其内容不可改的特点，我们常将其当作基本数据类型。即每个String变量只能保存一个数据。</p><h3 id="引用传递实例"><a class="markdownIt-Anchor" href="#引用传递实例"></a> 引用传递实例</h3><blockquote><p>要求：通过面向对象的方式描述每个人有车或没车。</p></blockquote><p><strong>实现步骤</strong>：<br>1.创建数据库：应设计两张表:<code>汽车表</code>和<code>人员表</code>;<br>2.根据数据表，定义两个类：</p><blockquote><p>（编写简单java类时，可按照数据表的设计来写，规则如下：<br>类名 = 表名；<br>属性名(类型) = 表字段(类型);<br>一个实例化对象 = 一行记录；<br>多个实例化对象 = 多行记录<br>引用关系 = 外键描述）</p></blockquote><pre class="highlight"><code class="">public class Member {    private int mId;    private String name;}public class Car {    private String pName;}</code></pre><p>3.利用<code>引用</code>来描述两个类的外键，从而使得两个类有联系</p><pre class="highlight"><code class="">public class Member {    private int mId;    private String name;    // 有Car类实例化对象表示有车    // Car为null表示没车    private Car car;    public Member(int mId, String name) {        this.mId = mId;        this.name = name;    }    public String getInfo() {        return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name;    }}public class Car {    private Member member; // 车属于一个人    private String pName;    public Car(String pName) {        this.pName = pName;    }    public String getInfo() {        return &quot;车名：&quot; + this.pName;    }}</code></pre><p>4.当两个类的对象产生，为这两个对象设置彼此的关系：</p><pre class="highlight"><code class="">public class Member {    private int mId;    private String name;    // 有Car类实例化对象表示有车    // Car为null表示没车    private Car car;    public Member(int mId, String name) {        this.mId = mId;        this.name = name;    }    public Car getCar() {        return car;    }    public void setCar(Car car) {        this.car = car;    }    public String getInfo() {        return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name;    }}public class Car {    private Member member; // 车属于一个人    private String pName;    public Car(String pName) {        this.pName = pName;    }    public String getInfo() {        return &quot;车名：&quot; + this.pName;    }    public Member getMember() {        return member;    }    public void setMember(Member member) {        this.member = member;    }}</code></pre><p><strong>5.测试</strong><br>测试分为两步：</p><blockquote><p>（1）根据定义的结构关系设置数据<br>（2）根据定义的结构关系取出数据</p></blockquote><pre class="highlight"><code class="">public class TCar {    public static void main(String[] args) {        // 1. 设置数据        Member m = new Member(1,&quot;张三&quot;);        Car c = new Car(&quot;宝马&quot;);        // 设置车与人的关系：张三有辆宝马        m.setCar(c);        c.setMember(m);        // 2. 取出数据        // 通过人找到车        System.out.println(m.getCar().getInfo());        // 通过车找到人        System.out.println(c.getMember().getInfo());    }}</code></pre><p>6.进一步设计：每个人都有孩子，孩子还可能有车</p><blockquote><p>思路：<br>（1）设计一个孩子类，如有孙子，在设计孙子类，以此类推。该方案过于冗余，不合适；<br>（2）在Member类中设计属性child，类型为Member：</p></blockquote><pre class="highlight"><code class="">private Member child; // 孩子public Member getChild() {    return child;}public void setChild(Member child) {    this.child = child;}</code></pre><p><strong>测试</strong>：</p><pre class="highlight"><code class="">public class TCar {    public static void main(String[] args) {        // 1. 设置数据        Member m = new Member(1,&quot;张三&quot;);        Member child =  new Member(1,&quot;张四&quot;);        Car c = new Car(&quot;宝马&quot;);        Car cc  =new Car(&quot;法拉利&quot;);        // 设置车与人的关系：张三有辆宝马        m.setCar(c);        c.setMember(m);        // 设置车与人的关系：张四有辆法拉利        child.setCar(cc);        c.setMember(child);        // 设置人与人的关系：张四是张三的儿子        m.setChild(child);        // 2. 取出数据        // 通过人找到车        System.out.println(m.getCar().getInfo());        // 通过车找到人        System.out.println(c.getMember().getInfo());        // 通过人找到孩子        System.out.println(m.getChild().getInfo());        // 通过人找到孩子的车        System.out.println(m.getChild().getCar().getInfo());    }}</code></pre><p>7.利用引用描述电脑：电脑由主机、键盘、内存、CPU、显卡等组成，下面用伪代码描述：</p><pre class="highlight"><code class="">class 键盘{}class 鼠标{}class CPU{}class 硬盘{}class 内存{}class 显示器{}class 主机{}class 主板{}class 主机{    private CPU 对象[];    private 硬盘 对象[];    private 主板 对象;    private 内存 对象[];}class 电脑{    private 主机 对象;    private 显示器 对象;    private 键盘 对象;    private 鼠标 对象;}</code></pre><p>上述设计思路称为<code>合成设计模式</code>。<strong>引用</strong>是实现两个不同类之间互相关联的主要手段。</p><h3 id="数据表与简单java类映射"><a class="markdownIt-Anchor" href="#数据表与简单java类映射"></a> 数据表与简单Java类映射</h3><blockquote><p><strong>要求</strong>：通过程序描述部门和雇员关系<br><strong>属性</strong>：<br>·dept：deptno,dname,loc;<br>·emp：empno, ename,job,sal,comm,deptno,mgr<br><strong>关系</strong>：<br>·一个部门有多个雇员；<br>·一个雇员有一个或零个领导。</p></blockquote><p>第一步： 根据数据表创建简单java类</p><pre class="highlight"><code class="">/** * 部门类 */public class Dept {    private int depNo; // 编号    private String dName; // 名字    private String address; // 地址    // setter,getter,无参构造方法略    public Dept(int depNo, String dName, String address) {        this.depNo = depNo;        this.dName = dName;        this.address = address;    }    public String getInfo() {        return &quot;部门编号：&quot; + this.depNo +                &quot;,部门名称：&quot; + this.dName +                &quot;,地址：&quot; + this.address;    }}/** * 员工类 */public class Emp {    private int eNo; // 编号    private String eName; // 姓名    private String job; // 职位    private double sal; // 工资    private double comm; // 佣金    // setter,getter,无参构造方法略    public Emp(int eNo, String eName, String job, double sal, double comm) {        this.eNo = eNo;        this.eName = eName;        this.job = job;        this.sal = sal;        this.comm = comm;    }        public String getInfo() {        return &quot;编  号&quot; + this.eNo + &quot;\n&quot; +                &quot;姓 名&quot; + this.eName + &quot;\n&quot; +                &quot;职 位&quot; + this.job + &quot;\n&quot; +                &quot;工 资&quot; + this.sal + &quot;\n&quot; +                &quot;佣 金&quot; + this.comm;    }}</code></pre><p>第二步：设置外键关系<br>· 一个雇员属于一个部门，应在雇员类中保存部门信息</p><pre class="highlight"><code class="">private Dept dept; // 对应的部门信息public Dept getDept() {    return dept;}public void setDept(Dept dept) {    this.dept = dept;}</code></pre><p>· 一个部门有的多个雇员，可用数组在部门类中保存雇员信息：</p><pre class="highlight"><code class="">private Emp emps[]; // 多个雇员信息public Emp[] getEmps() {    return emps;}public void setEmps(Emp[] emps) {    this.emps = emps;}</code></pre><p>· 一个雇员有一个领导（定义在Emp类中）</p><pre class="highlight"><code class="">private Emp mgr; // 领导信息public Emp getMgr() {    return mgr;}public void setMgr(Emp mgr) {    this.mgr = mgr;}</code></pre><p>第三步：测试<br>（1）设置数据：</p><pre class="highlight"><code class="">public class Demo {   public static void main(String[] args) {       // 1. 产生对象       Dept dept = new Dept(10, &quot;财务部&quot;, &quot;北京&quot;); // 部门信息       //  员工信息       Emp eA = new Emp(1111, &quot;张三&quot;, &quot;保安&quot;, 800.0, 0.0);       Emp eB = new Emp(1101, &quot;李四&quot;, &quot;秘书&quot;, 2800.0, 500.0);       Emp eC = new Emp(1001, &quot;王五&quot;, &quot;经历&quot;, 6800.0, 1500.0);       // 2. 设置员工与领导关系       eA.setMgr(eB);       eB.setMgr(eC);       // 3. 设置员工和部门关系       eA.setDept(dept);       eB.setDept(dept);       eC.setDept(dept);       dept.setEmps(new Emp[]{eA, eB, eC});   }}</code></pre><p>（2）：根据给定的结构取出数据，要求如下：</p><blockquote><p>|-根据一个雇员查询他所对应的领导信息和部门信息；<br>|-根据一个部门查询所有雇员以及其所对应的领导信息；</p></blockquote><pre class="highlight"><code class="">// 第二步：取出数据// 1. 通过员工找到领导信息和部门信息System.out.println(eA.getInfo()); // 获取员工信息System.out.println(&quot;\t|-&quot; + eA.getMgr().getInfo()); // 获取领导信息System.out.println(&quot;\t|-&quot; + eA.getDept().getInfo()); // 获取部门信息// 2. 根据部门找到所有员工及其领导信息System.out.println(&quot;---------------------------------------------&quot;);System.out.println(dept.getInfo());for (int x = 0; x &lt; dept.getEmps().length; x++) {    System.out.println(&quot;\t|-&quot; + dept.getEmps()[x].getInfo()); // 获取员工信息    if (dept.getEmps()[x].getMgr() != null) {        System.out.println(&quot;\t\t|-&quot; + dept.getEmps()[x].getMgr().getInfo()); // 获取领导信息    }}</code></pre><p>上述代码都是依靠代码链取出数据。</p><h3 id="一对多映射"><a class="markdownIt-Anchor" href="#一对多映射"></a> 一对多映射</h3><blockquote><p>要求：通过程序描述省份和城市的关系<br>1.通过一个城市找到它对应的省份信息；<br>2.通过一个省份找到所有城市的信息。</p></blockquote><pre class="highlight"><code class="">class Province {    private int pId;    private String pName;    private City cities[];    // getter,setter,无参构造方法略    public Province(int pId, String pName) {        this.pId = pId;        this.pName = pName;    }    public City[] getCities() {        return cities;    }    public void setCities(City[] cities) {        this.cities = cities;    }    public String getInfo() {        return &quot;省份ID：&quot; + this.pId + &quot;，省名：&quot; + this.pName;    }}class City {    private int cId;    private String cName;    private Province province;    // getter,setter,无参构造方法略    public City(int cId, String cName) {        this.cId = cId;        this.cName = cName;    }    public Province getProvince() {        return province;    }    public void setProvince(Province province) {        this.province = province;    }    public String getInfo() {        return &quot;城市ID：&quot; + this.cId + &quot;，市名：&quot; + this.cName;    }}public class Demo {    public static void main(String[] args) {        Province province = new Province(350, &quot;福建省&quot;);        City cA = new City(1, &quot;福州&quot;);        City cB = new City(2, &quot;厦门&quot;);        City cC = new City(3, &quot;泉州&quot;);        cA.setProvince(province);        cB.setProvince(province);        cC.setProvince(province);        province.setCities(new City[]{cA, cB, cC});        System.out.println(cA.getInfo());        System.out.println(&quot;\t|-&quot; + cA.getProvince().getInfo());        System.out.println(&quot;==================================&quot;);        System.out.println(province.getInfo());        for (int x = 0; x &lt; province.getCities().length; x++) {            System.out.println(&quot;\t|-&quot; + province.getCities()[x].getInfo());        }    }}</code></pre><p>上述代码存在不足：<strong>每次添加城市，就要修改数组的引用关系</strong></p><h3 id="双向一对多映射"><a class="markdownIt-Anchor" href="#双向一对多映射"></a> 双向一对多映射</h3><blockquote><p>要求：通过程序描述类型-子类型-商品的关系<br>（1）通过一个类型找到它对应的子类型；<br>（2）过一个类型找到它所对应的商品；<br>（3）通过一个子类型找到所有对应的商品。</p></blockquote><pre class="highlight"><code class=""> class Type {    private int tId;    private String tName;    private SonType sonTypes[];    private Product products[];    // getter,setter,无参构造方法略    public Type(int tId, String tName) {        this.tId = tId;        this.tName = tName;    }    public SonType[] getSontypes() {        return this.sonTypes;    }    public void setSontypes(SonType[] sontypes) {        this.sonTypes = sontypes;    }    public Product[] getProducts() {        return products;    }    public void setProducts(Product[] products) {        this.products = products;    }    public String getInfo() {        return &quot;类型编号：&quot; + this.tId + &quot;,类型名称：&quot; + this.tName;    }}class SonType {    private int sId;    private String sName;    private Type type;    private Product products[];    // getter,setter,无参构造方法略    public SonType(int sId, String sName) {        this.sId = sId;        this.sName = sName;    }    public int getsId() {        return sId;    }    public void setsId(int sId) {        this.sId = sId;    }    public Type getType() {        return type;    }    public void setType(Type type) {        this.type = type;    }    public Product[] getProducts() {        return products;    }    public void setProducts(Product[] products) {        this.products = products;    }    public String getInfo() {        return &quot;子类型编号：&quot; + this.sId + &quot;,子类型名称：&quot; + this.sName;    }}class Product {    private int pId;    private String name;    private double price;    private Type type;    private SonType sonType;    // getter,setter,无参构造方法略    public Product(int pId, String name, double price) {        this.pId = pId;        this.name = name;        this.price = price;    }    public Type getType() {        return type;    }    public void setType(Type type) {        this.type = type;    }    public SonType getSonType() {        return sonType;    }    public void setSonType(SonType sonType) {        this.sonType = sonType;    }    public String getInfo() {        return &quot;商品编号：&quot; + this.pId + &quot;,商品名称：&quot; + this.name + &quot;,价格：&quot; + this.price;    }}public class Demo {    public static void main(String[] args) {        Type type = new Type(1, &quot;家电类&quot;);        SonType stA = new SonType(11, &quot;小型家电&quot;);        SonType stB = new SonType(12, &quot;大型家电&quot;);        Product pA = new Product(111, &quot;剃须刀&quot;, 99.0);        Product pB = new Product(112, &quot;热水壶&quot;, 29.0);        Product pC = new Product(121, &quot;电冰箱&quot;, 1199.0);        Product pD = new Product(122, &quot;电热水器&quot;, 399.0);        stA.setType(type);        stB.setType(type);        pA.setType(type);        pB.setType(type);        pC.setType(type);        pD.setType(type);        type.setSontypes(new SonType[]{stA, stB});        type.setProducts(new Product[]{pA, pB, pC, pD});        pA.setSonType(stA);        pB.setSonType(stA);        pC.setSonType(stB);        pD.setSonType(stB);        stA.setProducts(new Product[]{pA, pB});        stB.setProducts(new Product[]{pC, pD});        System.out.println(type.getInfo());        for (int x = 0; x &lt; type.getSontypes().length; x++) {            System.out.println(&quot;\t|- &quot; + type.getSontypes()[x].getInfo());        }        System.out.println(&quot;--------------------------------------&quot;);        System.out.println(type.getInfo());        for (int x = 0; x &lt; type.getProducts().length; x++) {            System.out.println(&quot;\t|- &quot; + type.getProducts()[x].getInfo());            System.out.println(&quot;\t\t|- &quot; + type.getProducts()[x].getSonType().getInfo());        }        System.out.println(&quot;--------------------------------------&quot;);        System.out.println(stA.getInfo());        for (int x = 0; x &lt; stA.getProducts().length; x++) {            System.out.println(&quot;\t|- &quot; + stA.getProducts()[x].getInfo());        }    }}</code></pre><h3 id="多对多映射"><a class="markdownIt-Anchor" href="#多对多映射"></a> 多对多映射</h3><blockquote><p>要求：通过程序描述管理员-角色-组-权限的关系；<br>（1）根据一个管理员找到它对应的角色，以及每个角色包含的所有权限组的信息，以及每个权限组所包含的权限的内容；<br>（2）根据一个权限组找到所有具备此权限组的角色以及每个角色所拥有的管理员信息；<br><code>角色_权限组</code>表是关系表，保存的是两个外键的关联关系，不需要为其生成映射类。只有实体表才需要生成映射类，多对多的中间转换表只需通过类属性的关系引用即可。</p></blockquote><pre class="highlight"><code class="">class Admin {    private String aid;    private String password;    private Role role;    public void setRole(Role role) {        this.role = role;    }    public Role getRole() {        return this.role;    }    public Admin(String aid, String password) {        this.aid = aid;        this.password = password;    }    public String getInfo() {        return &quot;管理员编号:&quot; + this.aid + &quot;，管理员密码：&quot; + this.password;    }}class Role {    private int rid;    private String title;    private Admin admins[];    private Group groups[];    public void setAdmins(Admin admins[]) {        this.admins = admins;    }    public Admin[] getAdmins() {        return this.admins;    }    public void setGroups(Group groups[]) {        this.groups = groups;    }    public Group[] getGroups() {        return this.groups;    }    public Role(int rid, String title) {        this.rid = rid;        this.title = title;    }    public String getInfo() {        return &quot;角色编号：&quot; + this.rid + &quot;，角色名称&quot; + this.title;    }}class Group {    private int gid;    private String title;    private Role roles[];    private Action actions[];    public void setActions(Action actions[]) {        this.actions = actions;    }    public Action[] getActions() {        return this.actions;    }    public void setRoles(Role roles[]) {        this.roles = roles;    }    public Role[] getRoles() {        return this.roles;    }    public Group(int gid, String title) {        this.gid = gid;        this.title = title;    }    public String getInfo() {        return &quot;权限组编号：&quot; + this.gid + &quot;，权限组名称：&quot; + this.title;    }}class Action {    private int aid;    private String title;    private String url;    private Group group;    public void setGroup(Group group) {        this.group = group;    }    public Group getGroup() {        return this.group;    }    public Action(int aid, String title, String url) {        this.aid = aid;        this.title = title;        this.url = url;    }    public String getInfo() {        return &quot;权限编号：&quot; + this.aid + &quot;权限名称：&quot; + this.title + &quot;,权限路径：&quot; + this.url;    }}public class Demo {    public static void main(String[] args) {        Admin a1 = new Admin(&quot;admin&quot;, &quot;123456&quot;);        Admin a2 = new Admin(&quot;root&quot;, &quot;654321&quot;);        Admin a3 = new Admin(&quot;guest&quot;, &quot;654321&quot;);        Role r1 = new Role(1, &quot;系统管理员&quot;);        Role r2 = new Role(1, &quot;信息管理员&quot;);        Group g1 = new Group(10, &quot;信息管理&quot;);        Group g2 = new Group(11, &quot;用户管理&quot;);        Group g3 = new Group(12, &quot;数据管理&quot;);        Group g4 = new Group(13, &quot;接口管理&quot;);        Group g5 = new Group(14, &quot;备份管理&quot;);        Action ac1 = new Action(1001, &quot;新闻发布&quot;, &quot;-&quot;);        Action ac2 = new Action(1002, &quot;新闻列表&quot;, &quot;-&quot;);        Action ac3 = new Action(1003, &quot;新闻审核&quot;, &quot;-&quot;);        Action ac4 = new Action(1004, &quot;增加用户&quot;, &quot;-&quot;);        Action ac5 = new Action(1005, &quot;用户列表&quot;, &quot;-&quot;);        Action ac6 = new Action(1006, &quot;登陆日志&quot;, &quot;-&quot;);        Action ac7 = new Action(1007, &quot;雇员数据&quot;, &quot;-&quot;);        Action ac8 = new Action(1008, &quot;部门数据&quot;, &quot;-&quot;);        Action ac9 = new Action(1009, &quot;公司数据&quot;, &quot;-&quot;);        Action ac10 = new Action(1010, &quot;服务传输&quot;, &quot;-&quot;);        Action ac11 = new Action(1011, &quot;短信平台&quot;, &quot;-&quot;);        Action ac12 = new Action(1012, &quot;全部备份&quot;, &quot;-&quot;);        Action ac13 = new Action(1013, &quot;局部备份&quot;, &quot;-&quot;);        a1.setRole(r1);        a2.setRole(r2);        a3.setRole(r2);        r1.setAdmins(new Admin[]{a1});        r2.setAdmins(new Admin[]{a2, a3});        r1.setGroups(new Group[]{g1, g2, g3, g4, g5});        r2.setGroups(new Group[]{g1, g2});        g1.setRoles(new Role[]{r1, r2});        g2.setRoles(new Role[]{r1, r2});        g3.setRoles(new Role[]{r1});        g4.setRoles(new Role[]{r1});        g5.setRoles(new Role[]{r1});        g1.setActions(new Action[]{ac1, ac2, ac3});        g2.setActions(new Action[]{ac4, ac5, ac6});        g3.setActions(new Action[]{ac7, ac8, ac9});        g4.setActions(new Action[]{ac10, ac11});        g5.setActions(new Action[]{ac12, ac13});        ac1.setGroup(g1);        ac2.setGroup(g1);        ac3.setGroup(g1);        ac4.setGroup(g2);        ac5.setGroup(g2);        ac6.setGroup(g2);        ac7.setGroup(g3);        ac8.setGroup(g3);        ac9.setGroup(g3);        ac10.setGroup(g4);        ac11.setGroup(g4);        ac12.setGroup(g5);        ac13.setGroup(g5);        System.out.println(a1.getInfo());        System.out.println(a1.getRole().getInfo());        for (int x = 0; x &lt; a1.getRole().getGroups().length; x++) {            System.out.println(&quot;\t|-&quot; + a1.getRole().getGroups()[x].getInfo());            for (int y = 0; y &lt; a1.getRole().getGroups()[x].getActions().length; y++) {                System.out.println(&quot;\t\t|-&quot; + a1.getRole().getGroups()[x].getActions()[y].getInfo());            }        }        System.out.println(&quot;-------------------------------------------------&quot;);        System.out.println(g2.getInfo());        for (int x = 0; x &lt; g2.getRoles().length; x++) {            System.out.println(g2.getRoles()[x].getInfo());            for (int y = 0; y &lt; g2.getRoles()[x].getAdmins().length; y++) {                System.out.println(&quot;\t\t|-&quot; + g2.getRoles()[x].getAdmins()[y].getInfo());            }            System.out.println();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用传递分析实例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引用传递分析实例&quot;&gt;&lt;/a&gt; 引用传递分析实例&lt;/h2&gt;
&lt;h3 id=&quot;引用传递&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引用传递&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Centos7上部署Docker私有仓库</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Centos7%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Centos7上部署Docker私有仓库/</id>
    <published>2017-10-11T11:45:51.144Z</published>
    <updated>2017-10-11T12:00:20.426Z</updated>
    
    <content type="html"><![CDATA[<p>Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。</p><h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2><h3 id="系统要求"><a class="markdownIt-Anchor" href="#系统要求"></a> 系统要求</h3><table><thead><tr><th style="text-align:center">要求</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">系统</td><td style="text-align:center">Centos 7</td></tr><tr><td style="text-align:center">内核</td><td style="text-align:center">4.13.5-1.el7.elrepo.x86_64</td></tr><tr><td style="text-align:center">仓库地址</td><td style="text-align:center">10.0.0.128:5000</td></tr><tr><td style="text-align:center">docker</td><td style="text-align:center">1.12.6</td></tr></tbody></table><h3 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h3><pre class="highlight"><code class="">$ systemctl stop firewalld.service$ systemctl disable firewalld.service$ vim /etc/sysconfig/selinux  SELINUX=disabled</code></pre><h2 id="搭建docker私有仓库"><a class="markdownIt-Anchor" href="#搭建docker私有仓库"></a> 搭建Docker私有仓库</h2><h3 id="搭建仓库"><a class="markdownIt-Anchor" href="#搭建仓库"></a> 搭建仓库</h3><pre class="highlight"><code class="">$ docker pull registry  // 拉取官方镜像$ docker run -d -p 5000:5000 --restart=always --name myHub registry   // 运行官方镜像$ curl localhost:5000/v2/_catalog  // 查看私有镜像仓库,此时为空{&quot;repositories&quot;:[]}</code></pre><h3 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h3><pre class="highlight"><code class="">$ vim /etc/sysconfig/docker  OPTIONS='--insecure-registry 10.0.0.128:5000'$ systemctl restart docker</code></pre><h3 id="上传镜像到私有仓库"><a class="markdownIt-Anchor" href="#上传镜像到私有仓库"></a> 上传镜像到私有仓库</h3><pre class="highlight"><code class="">$ docker tag mysql 10.0.0.128:5000/mysql:0.1  // docker tage image_name registry_ip:port/images_name:tag$ docker push 10.0.0.128:5000/mysql:0.1  // 上传镜像$ curl localhost:5000/v2/_catalog   // 查看仓库镜像                             {&quot;repositories&quot;:[&quot;mysql&quot;]}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境准备&quot;&gt;&lt;/a&gt; 环境准备&lt;/h2&gt;
&lt;h3 id=&quot;系统要求&quot;&gt;&lt;a c
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="http://yov.oschina.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(六)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AD)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(六)/</id>
    <published>2017-10-09T01:00:49.117Z</published>
    <updated>2017-10-21T05:58:59.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字this"><a class="markdownIt-Anchor" href="#关键字this"></a> 关键字this</h2><h3 id="this调用属性"><a class="markdownIt-Anchor" href="#this调用属性"></a> this调用属性</h3><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String t, double p) {        title = t;        price = p;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}public class Demo {    public static void main(String[] args) {        Book book = new Book(&quot;Java开发&quot;, 66.6);        System.out.println(book.getInfo());    }}</code></pre><p>上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。<strong>构造方法的功能是为类的属性初始化，参数名最好与属性名一致。</strong></p><pre class="highlight"><code class="">public Book(String title, double price) {    title = title;    price = price;}</code></pre><p>修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的<code>{}</code>的变量名，即数据传到构造方法后，并未传到属性中。<strong>为了明确要访问的变量是类的属性，应在变量名前加<code>this</code>。</strong></p><pre class="highlight"><code class="">public Book(String title, double price) {    this.title = title;    this.price = price;}</code></pre><p><strong>在开发中，只要访问类中属性，前面必须加<code>this</code>。</strong></p><h3 id="this调用方法"><a class="markdownIt-Anchor" href="#this调用方法"></a> this调用方法</h3><p>1.<code>this</code>指的是当前对象，一个类除了属性还有方法，因此可以利用<code>this</code>调用方法。</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public void print() {        System.out.println(&quot;*********&quot;);    }    // setter和getter方法略    public String getInfo() {        this.print();        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}</code></pre><p>在类中调用普通方法，加不加<code>this</code>都一样。但为了代码的严谨性，最好加<code>this</code>。<br>2.this调用构造方法<br>多个构造方法间互相调用: <code>this(参数1, 参数2…);</code><br><strong>范例</strong>：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息<code>一个新的Book类对象产生</code></p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book() {        System.out.println(&quot;一个新的Book类对象产生&quot;);    }    public Book(String title) {        System.out.println(&quot;一个新的Book类对象产生&quot;);        this.title = title;    }    public Book(String title, double price) {        System.out.println(&quot;一个新的Book类对象产生&quot;);        this.title = title;        this.price = price;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}</code></pre><p>上述代码中存在重复，要消除重复代码：</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book() {        System.out.println(&quot;一个新的Book类对象产生&quot;);    }    public Book(String title) {        this(); // 调用本类中的无参构造        this.title = title;    }    public Book(String title, double price) {        this(title); // 调用本类中的单参构造方法        this.price = price;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}</code></pre><p>上述代码中存在限制：</p><blockquote><p>（1）利用<code>this</code>调用构造方法的语句只能放在构造方法首行；<br>（2）普通方法无法调用构造方法；<br>（3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。</p></blockquote><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book() { // 报错，构造递归调用        this(&quot;Book&quot;,1.1);        System.out.println(&quot;一个新的Book类对象产生&quot;);    }    public Book(String title) {        this(); // 调用本类中的无参构造        this.title = title;    }    public Book(String title, double price) {        this(title); // 调用本类中的单参构造方法        this.price = price;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}</code></pre><p>上述代码会出现”构造方法递归调用”错误，说明<strong>构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。</strong><br>3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法;</p><blockquote><p>（1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”；<br>（2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”；<br>（3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”；<br>（4）四参构造</p></blockquote><p><strong>实现方式1：不使用this</strong></p><pre class="highlight"><code class="">class Emp {    private int empNo;    private String eName;    private double sal;    private String dept;    public Emp() {        this.empNo = 0;        this.eName = &quot;无名氏&quot;;        this.sal = 0.0;        this.dept = &quot;未定&quot;;    }    public Emp(int empNo) {        this.empNo = empNo;        this.eName = &quot;临时工&quot;;        this.sal = 800.0;        this.dept = &quot;后勤部&quot;;    }    public Emp(int empNo, String eName) {        this.empNo = empNo;        this.eName = eName;        this.sal = 2000.0;        this.dept = &quot;技术部&quot;;    }    public Emp(int empNo, String eName, double sal, String dept) {        this.empNo = empNo;        this.eName = eName;        this.sal = sal;        this.dept = dept;    }    // setter和getter方法略    public String getInfo() {        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +                &quot;部   门：&quot; + this.dept;    }}</code></pre><p><strong>实现方式2：使用this</strong></p><pre class="highlight"><code class="">class Emp {    private int empNo;    private String eName;    private double sal;    private String dept;    public Emp() {        this(0,&quot;无名氏&quot;,0.0,&quot;&quot;);    }    public Emp(int empNo) {        this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;);    }    public Emp(int empNo, String eName) {        this(empNo,eName,2000.0,&quot;技术部&quot;);    }    public Emp(int empNo, String eName, double sal, String dept) {        this.empNo = empNo;        this.eName = eName;        this.sal = sal;        this.dept = dept;    }    // setter和getter方法略    public String getInfo() {        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +                &quot;部   门：&quot; + this.dept;    }}</code></pre><p><strong>通过构造方法互相调用解决了代码重复问题。</strong></p><h3 id="当前对象"><a class="markdownIt-Anchor" href="#当前对象"></a> 当前对象</h3><p><strong>当前对象指的是当前正在调用类中属性或方法的对象</strong></p><pre class="highlight"><code class="">class Book {    public void print() {        // 哪个对象调用了print(),this就与该对象指向同一块内存地址        // this就是当前调用方法的对象        System.out.println(&quot;this = &quot; + this);    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        System.out.println(&quot;bkA = &quot; + bkA);          // bkA = com.java.demo.Book@1540e19d        bkA.print();         // this = com.java.demo.Book@1540e19d        System.out.println( &quot;===============&quot;);        Book bkB = new Book();         // bkB = com.java.demo.Book@677327b6        System.out.println(&quot;bkB = &quot; + bkB);         // this = com.java.demo.Book@677327b6        bkB.print();    }}</code></pre><pre class="highlight"><code class="">class A{    private B b;    public A(){ // 2.执行A类构造方法        // 3. 实例化B类对象b，调用B类构造方法        this.b = new B(this); //此时this是temp        this.b.get(); // 5. 通过b调用B类的get()    }    public void print(){ //8. 执行该方法        System.out.println(&quot;Hello World !&quot;);    }}class B{    private A a;    public B(A a){ // A a = temp        this.a = a; // 4. 执行B类构造方法    }    public void get(){ // 6. 执行该方法        this.a.print(); // 7. 调用A类的print()    }}public class Demo {    public static void main(String[] args) {        // 1.实例化A类对象，调用A类的无参构造方法        A temp = new A(); // Hello World !    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关键字this&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键字this&quot;&gt;&lt;/a&gt; 关键字this&lt;/h2&gt;
&lt;h3 id=&quot;this调用属性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#this调用
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(五)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%94)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(五)/</id>
    <published>2017-10-03T13:33:39.028Z</published>
    <updated>2017-10-21T05:58:42.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string类的特点及使用"><a class="markdownIt-Anchor" href="#string类的特点及使用"></a> String类的特点及使用</h2><blockquote><p>JDK_API文档由下面几部分组成：<br>（1）类的定义以及相关的继承结构<br>（2）类的简短说明<br>（3）类的成员组成<br>（4）类所提供的构造方法<br>（5）类所提供的普通方法<br>（6）类的成员，构造方法，普通方法的详细说明<br><code>deprecated</code>标记表示不再建议使用。</p></blockquote><h3 id="string对象的两种实例化方式"><a class="markdownIt-Anchor" href="#string对象的两种实例化方式"></a> String对象的两种实例化方式</h3><p>1.<code>String</code>是字符串类,下面将类的角度与内存关系分析其作用：<br>（1）直接赋值<code>String value_name = &quot;字符串&quot;</code></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;Hello World !&quot;; // 直接赋值        System.out.println(str);    }}</code></pre><p>（2）构造方法<code>public String (String str);</code></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = new String(&quot;Hello World !&quot;);        System.out.println(str);    }}</code></pre><h3 id="字符串比较"><a class="markdownIt-Anchor" href="#字符串比较"></a> 字符串比较</h3><p>1.判断两个int数据是否相等：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int x = 10;        int y = 10;        System.out.println(x == y); // true    }}</code></pre><p>使用<code>==</code>判断String对象是否相等：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;Hello&quot;;        String strB = new String(&quot;Hello&quot;);        String strC = strB;        System.out.println(strA == strB); // false        System.out.println(strA == strC); // false        System.out.println(strB == strC); // true    }}</code></pre><p>对上述代码进行内存分析：<br><img src="/article/Java/Java Base/Java基础知识(五)/8-1.png" alt="无法加载" title="内存分析"><br>由内存分析可知，String对象使用<code>==</code>比较时，比较的是对象的<strong>栈内存地址的值</strong>。<br>2.要比较字符串的内容，应使用String类中的方法<code>public boolean equals（String str）</code></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;Hello&quot;;        String strB = new String(&quot;Hello&quot;);        String strC = strB;        System.out.println(strA.equals(strB)); // true        System.out.println(strA.equals(strC)); // true    }}</code></pre><p>开发中，字符串比较应用<code>equals(String str)</code>.<br>3.<strong>章节例题：<code>==</code>与<code>equals(String str)</code>的区别</strong><br><code>==</code>是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值;<br><code>equals(String str)</code>是String类的方法，用于比较字符串内容。</p><h3 id="string常量是匿名对象"><a class="markdownIt-Anchor" href="#string常量是匿名对象"></a> String常量是匿名对象</h3><p>1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但<strong>不属于基本数据类型，而是将字符串作为String类的匿名对象。</strong><br><strong>范例</strong>：验证字符串是匿名对象</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;Hello&quot;;        System.out.println(&quot;Hello&quot;.equals(str));    }}</code></pre><p>2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化.</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String input = null; // 假设该内容是用户输入的        if (input.equals(&quot;hello&quot;)){            System.out.println(&quot;Hello World !&quot;);            // 报错，NullPointerException        }    }}</code></pre><p>为预防用户输入错误导致input为null，而后调用<code>equals()</code>，出现空指针异常，应使用如下代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String input = null; // 假设该内容是用户输入的        if (&quot;hello&quot;.equals(input)){            System.out.println(&quot;Hello World !&quot;);        }    }}</code></pre><p>使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将<strong>指定字符串放在equals()前</strong>。</p><h3 id="两种实例化方式的区别"><a class="markdownIt-Anchor" href="#两种实例化方式的区别"></a> 两种实例化方式的区别</h3><p>1.<strong>直接赋值</strong><br>直接赋值就是给字符串匿名对象设置对象名。<br>此时内存中会开辟堆内存，并且有一块栈内存指向堆内存：<br><img src="/article/Java/Java Base/Java基础知识(五)/8-2.png" alt="无法加载" title="内存分析"><br>观察下列代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;hello&quot;;        String strB = &quot;hello&quot;;        String strC = &quot;hello&quot;;        String strD = &quot;world&quot;;        System.out.println(strA == strB); // true        System.out.println(strA == strC); // true        System.out.println(strB == strC); // true        System.out.println(strA == strD); // false    }}</code></pre><p>由上述结果可知，strA，strB，strC都指向同一块堆内存：<br><img src="/article/Java/Java Base/Java基础知识(五)/8-3.png" alt="无法加载" title="内存分析"><br><strong>共享设计模式</strong>：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。<br>2.<strong>构造方法实例化</strong><br>使用构造方法定义String对象，就需要每次开辟新的堆内存。<br><img src="/article/Java/Java Base/Java基础知识(五)/8-4.png" alt="无法加载" title="内存分析"><br>由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = new String(&quot;hello&quot;);        String strB = &quot;hello&quot;;        System.out.println(strA == strB); // false    }}</code></pre><p>除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用<code>public String intern()</code>手工入池。</p><p>3.<strong>章节小题：String对象两种定义方式的区别</strong><br>· 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用；<br>· 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。</p><h3 id="字符串内容不可改变"><a class="markdownIt-Anchor" href="#字符串内容不可改变"></a> 字符串内容不可改变</h3><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;Hello&quot;;        str += &quot; World&quot;;        str += &quot; !!!&quot;;        System.out.println(str);    }}</code></pre><p>对上述代码进行内存分析：<br><img src="/article/Java/Java Base/Java基础知识(五)/8-5.png" alt="无法加载" title="内存分析"><br>分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。</p><h3 id="string类常用方法字符与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字符与字符串"></a> String类常用方法(字符与字符串)</h3><p>很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法：</p><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String (char[] value)</td><td style="text-align:center">构造</td><td style="text-align:center">将字符数组变为String类对象</td></tr><tr><td>2</td><td style="text-align:center">public String (char[] value ,int offset,int count)</td><td style="text-align:center">构造</td><td style="text-align:center">将部分字符数组变为String对象</td></tr><tr><td>3</td><td style="text-align:center">public char charAt (int index)</td><td style="text-align:center">普通</td><td style="text-align:center">返回指定索引对应的字符信息</td></tr><tr><td>4</td><td style="text-align:center">public char[] toCharArray()</td><td style="text-align:center">普通</td><td style="text-align:center">将字符串以字符数组的形式返回</td></tr></tbody></table><p><strong>范例</strong>：取出指定索引的字符</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;Hello&quot;;        char c = str.charAt(0);        System.out.println(c); // H    }}</code></pre><p><strong>范例</strong>：将字符串转大写</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;hello&quot;;        char [] data = str.toCharArray(); // 字符串转为字符数组        for (int x = 0; x &lt; data.length ; x++) {            data[x] -= 32; // 小写编码 - 32 = 大写编码        }        // 将字符数组变为字符串        System.out.println(new String(data)); // HELLO        // 将部分字符数组变为String对象        System.out.println(new String(data, 1, 2)); // EL    }}</code></pre><p><strong>范例</strong>：判断一个字符换是否为纯数字<br><em>思路</em>：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;3146017052&quot;;        if (isNumber(str)) {            System.out.println(&quot;字符串全部由数字组成&quot;);        } else {            System.out.println(&quot;字符串不是全部由数字组成&quot;);        }    }    // 定义判断字符串是否由数字组成的方法    public static boolean isNumber(String temp) {        // 首先将字符串变为字符数组        char[] data = temp.toCharArray();        // 一一比较字符        for (int x = 0; x &lt; data.length; x++) {            if (data[x] &gt; '9' || data[x] &lt; '0') {                return false;            }        }        // 全部为数字则返回true        return true;    }}</code></pre><p><strong>建议</strong>：返回值为<code>boolean</code>的方法命名为<code>isXxx</code>。</p><h3 id="string类常用方法字节与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字节与字符串"></a> String类常用方法(字节与字符串)</h3><p>字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。</p><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String (byte[] bytes)</td><td style="text-align:center">构造</td><td style="text-align:center">将字节数组变为字符串</td></tr><tr><td>2</td><td style="text-align:center">public String (byte[] bytes ,int offset,int length)</td><td style="text-align:center">构造</td><td style="text-align:center">将部分字节数组变为字符串</td></tr><tr><td>3</td><td style="text-align:center">public byte[] getBytes (String charsetName) throws UnsupportedEncodingException</td><td style="text-align:center">普通</td><td style="text-align:center">进行编码转换</td></tr><tr><td>4</td><td style="text-align:center">public byte[] getBytes()</td><td style="text-align:center">普通</td><td style="text-align:center">将字符串变为字节数组</td></tr></tbody></table><p><strong>范例</strong>：字符串与字节数组的转换</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        byte [] data = str.getBytes(); // 将字符串转为字节数组        for (int x = 0; x &lt; data.length ; x++) {            data[x] -= 32; // 将小写字母转为大写字母        }        System.out.println(new String(data)); // HELLOWORLD        System.out.println(new String(data,5,5)); // WORLD    }}</code></pre><h3 id="string类常用方法字符串比较"><a class="markdownIt-Anchor" href="#string类常用方法字符串比较"></a> String类常用方法(字符串比较)</h3><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public boolean equals(String anotherString)</td><td style="text-align:center">普通</td><td style="text-align:center">进行内容判断，区分大小写</td></tr><tr><td>2</td><td style="text-align:center">public boolean equalsIgnoreCase(String anotherString)</td><td style="text-align:center">普通</td><td style="text-align:center">进行内容判断，不区分大小写</td></tr><tr><td>3</td><td style="text-align:center">public int compareTo (String anotherString)</td><td style="text-align:center">普通</td><td style="text-align:center">判断两个字符串的大小（按照字符编码）,返回值为0,1,-1</td></tr></tbody></table><p><strong>范例</strong>：equals()判断</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;Hello&quot;;        String strB = &quot;hello&quot;;        System.out.println(strA.equals(strB)); // false,说明区分大小写    }}</code></pre><p><strong>范例</strong>：equalsIgnoreCase()判断</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;Hello&quot;;        String strB = &quot;hello&quot;;        System.out.println(strA.equals(strB)); // false,说明区分大小写        System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写    }}</code></pre><p><strong>范例</strong>：compareTo()</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;Hello&quot;;        String strB = &quot;hello&quot;;        System.out.println(strA.compareTo(strB)); // -32        if (strA.compareTo(strB) &gt; 0){            System.out.println(&quot;大于&quot;);        } else if (strA.compareTo(strB) == 0){            System.out.println(&quot;两个字符串相等&quot;);        } else {            System.out.println(&quot;小于&quot;);        }    }}</code></pre><p>只有String对象才能进行大小判断。</p><h3 id="string类常用方法字符串查找"><a class="markdownIt-Anchor" href="#string类常用方法字符串查找"></a> String类常用方法(字符串查找)</h3><p>要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法：</p><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public boolean contains (String s)</td><td style="text-align:center">普通</td><td style="text-align:center">判断指定内容是否存在</td></tr><tr><td>2</td><td style="text-align:center">public int indexOf(String s)</td><td style="text-align:center">普通</td><td style="text-align:center">由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。</td></tr><tr><td>3</td><td style="text-align:center">public int indexOf(String s,int fromIndex)</td><td style="text-align:center">普通</td><td style="text-align:center">从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1</td></tr><tr><td>4</td><td style="text-align:center">public int lastindexOf(String s)</td><td style="text-align:center">普通</td><td style="text-align:center">由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td></tr><tr><td>5</td><td style="text-align:center">public int lastindexOf(String s, int fromIndex)</td><td style="text-align:center">普通</td><td style="text-align:center">由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td></tr><tr><td>6</td><td style="text-align:center">public boolean startsWith (String prefix)</td><td style="text-align:center">普通</td><td style="text-align:center">判断是否以指定字符串开头</td></tr><tr><td>7</td><td style="text-align:center">public boolean startsWith (String prefix，int toffset)</td><td style="text-align:center">普通</td><td style="text-align:center">从指定位置开始判断是否是以指定字符串开头</td></tr><tr><td>8</td><td style="text-align:center">public boolean endsWith(String suffix)</td><td style="text-align:center">普通</td><td style="text-align:center">判断是否以指定字符串结尾</td></tr></tbody></table><p><strong>范例</strong>：查找字符串位置</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        // 返回满足条件的单词的首字母索引        System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引        // 从索引5开始查满足条件单词的索引        System.out.println(str.indexOf(&quot;l&quot;,5)); // 8        // 从后向前查        System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8    }}</code></pre><p>在某些程序中，需要查找指定字符串是否存在，早期方法如下：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        if (str.indexOf(&quot;world&quot;) != -1){            System.out.println(&quot;该字符串存在&quot;);        } else {            System.out.println(&quot;该字符串不存在&quot;);        }    }}</code></pre><p>JDK1.5出现<code>contains()</code>，使用如下：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        if (str.contains(&quot;world&quot;)) {            System.out.println(&quot;该字符串存在&quot;);        } else {            System.out.println(&quot;该字符串不存在&quot;);        }    }}</code></pre><p><strong>范例</strong>：开头或结尾判断内容</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        // 从开头开始查        System.out.println(str.startsWith(&quot;he&quot;));        // 从索引2开始查找        System.out.println(str.startsWith(&quot;ll&quot;,2));        // 从结尾开始查找        System.out.println(str.endsWith(&quot;ld&quot;));    }}</code></pre><h3 id="string类常用方法字符串替换"><a class="markdownIt-Anchor" href="#string类常用方法字符串替换"></a> String类常用方法(字符串替换)</h3><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String replaceAll(String regex，String replacement)</td><td style="text-align:center">普通</td><td style="text-align:center">全部替换</td></tr><tr><td>2</td><td style="text-align:center">public String replaceFirst(String regex，String replacement)</td><td style="text-align:center">普通</td><td style="text-align:center">替换首个满足条件的内容</td></tr></tbody></table><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        // 替换所有        String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d        // 只替换第一个        String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld        System.out.println(resultA);        System.out.println(resultB);    }}</code></pre><h3 id="string类常用方法字符串截取"><a class="markdownIt-Anchor" href="#string类常用方法字符串截取"></a> String类常用方法(字符串截取)</h3><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String substring(int beginIndex)</td><td style="text-align:center">普通方法</td><td style="text-align:center">从指定索引截取到结尾</td></tr><tr><td>2</td><td style="text-align:center">public String substring(int beginIndex,int endIndex)</td><td style="text-align:center">普通方法</td><td style="text-align:center">截取指定范围内的内容</td></tr></tbody></table><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;helloworld&quot;;        // 从索引5开始截取直到结尾        String resultA = str.substring(5);         // 截取索引5到8之间        String resultB = str.substring(5,8);         System.out.println(resultA); // world        System.out.println(resultB); // wor    }}</code></pre><h3 id="string类常用方法字符串拆分"><a class="markdownIt-Anchor" href="#string类常用方法字符串拆分"></a> String类常用方法(字符串拆分)</h3><table><thead><tr><th>No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String[] split (String regex)</td><td style="text-align:center">普通方法</td><td style="text-align:center">按照指定的字符串进行全部拆分</td></tr><tr><td>2</td><td style="text-align:center">public String[] split (String regex，int limit)</td><td style="text-align:center">普通方法</td><td style="text-align:center">按照指定的字符串进行部分拆分，最后一个数组长度由limit决定</td></tr></tbody></table><p><strong>范例</strong>：全部拆分</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;hello world&quot;;        // 按照空格拆分单词        String result[] = str.split(&quot; &quot;);        for (int x = 0; x &lt; result.length; x++) {            System.out.println(result[x]);            // 结果：hello            // world        }    }}</code></pre><p>在拆分的时候，只写一个空字符串（<code>&quot;&quot;</code>不是<code>null</code>），表示按照每一个字符进行拆分。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;hello world&quot;;        // 按照空字符串拆分        String result[] = str.split(&quot;&quot;);        for (int x = 0; x &lt; result.length; x++) {            System.out.println(result[x]);            // 结果：h e l l o w o r l d        }    }}</code></pre><p><strong>范例</strong>：部分拆分</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;hello world nihao mldn&quot;;        // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆        String result[] = str.split(&quot; &quot;,3);        for (int x = 0; x &lt; result.length; x++) {            System.out.println(result[x]);            // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot;        }    }}</code></pre><p><strong>范例</strong>：IP地址拆分</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;192.168.1.1&quot;;        String result[] = str.split(&quot;\\.&quot;);        for (int x = 0; x &lt; result.length; x++) {            System.out.println(result[x]);            // 结果为：192 168 1 1        }    }}</code></pre><p>上述代码中，只用<code>.</code>无法拆分，当遇到这种拆分时，需要使用<code>\\.</code>进行转义后拆分。<br><strong>范例</strong>：拆分“张三:20|李四:25|王五:23”</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;张三:20|李四:25|王五:23&quot;;        String result[] = str.split(&quot;\\|&quot;);        for (int x = 0; x &lt; result.length; x++) {            String temp[] = result[x].split(&quot;:&quot;);            System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]);        }    }}</code></pre><h3 id="string类其他方法"><a class="markdownIt-Anchor" href="#string类其他方法"></a> String类其他方法</h3><table><thead><tr><th>No.</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">public String concat (String str)</td><td style="text-align:center">普通方法</td><td style="text-align:center">字符串连接</td></tr><tr><td>2</td><td style="text-align:center">public String toLowerCase ()</td><td style="text-align:center">普通方法</td><td style="text-align:center">把字符串转为小写</td></tr><tr><td>3</td><td style="text-align:center">public String toUpperCase ()</td><td style="text-align:center">普通方法</td><td style="text-align:center">把字符串转为大写</td></tr><tr><td>4</td><td style="text-align:center">public String trim ()</td><td style="text-align:center">普通方法</td><td style="text-align:center">去掉字符串中左右两边的空格，中间空格保留</td></tr><tr><td>5</td><td style="text-align:center">public int length()</td><td style="text-align:center">普通方法</td><td style="text-align:center">取得字符串长度</td></tr><tr><td>6</td><td style="text-align:center">public String intern ()</td><td style="text-align:center">普通方法</td><td style="text-align:center">数据入池操作</td></tr><tr><td>7</td><td style="text-align:center"></td><td style="text-align:center">public boolean isEmpty ()</td><td style="text-align:center">普通方法</td></tr></tbody></table><p><strong>范例</strong>：字符串连接</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String strA = &quot;hello&quot;;        String strB = strA + &quot; world&quot;;        String strC = &quot;hello&quot; + &quot;world&quot;;        String strD = &quot;hello world&quot;;        String strE = strA.concat(&quot; world&quot;);        System.out.println(strB == strC); // false        System.out.println(strB == strD); // false        System.out.println(strB == strE); // false        System.out.println(strC == strD); // false        System.out.println(strC == strE); // false        System.out.println(strD == strE); // false    }}</code></pre><p><strong>范例</strong>：字符串进行大小写转换</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;*Hello*&quot;;        // 只转换小写字母        System.out.println(str.toUpperCase()); // *HELLO*        // 只转换大写字母        System.out.println(str.toLowerCase()); // *hello*    }}</code></pre><p><strong>范例</strong>：去掉空格</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot; Hello World &quot;;        System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】        System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】    }}</code></pre><p>用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了<code>trim()</code>。<br><strong>范例</strong>：取得字符串长度</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;Hello World&quot;;        System.out.println(str.length()); // 11    }}</code></pre><p>某些情况要求用户输入的数据长度有限制，可以利用此方法判断。<br><strong>范例</strong>：判断是否是空字符串</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;&quot;;        System.out.println(str.isEmpty()); // true        System.out.println(&quot;&quot;.equals(str)); // true    }}</code></pre><p><strong>范例</strong>：实现首字母大写，其余字母小写</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;hElLo&quot;;        System.out.println(initcap(str)); // Hello    }    public static String initcap(String temp) {        // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写        return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;string类的特点及使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#string类的特点及使用&quot;&gt;&lt;/a&gt; String类的特点及使用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK_API文档由下面几部分组成：&lt;br&gt;
（1）
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(四)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%9B)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(四)/</id>
    <published>2017-10-03T12:47:52.401Z</published>
    <updated>2017-10-21T05:59:15.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的定义及使用"><a class="markdownIt-Anchor" href="#数组的定义及使用"></a> 数组的定义及使用</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>1.<strong>数组</strong>是一组变量的集合。数组属于引用数据类型。<br>2.数组的定义语法<br>（1）声明并开辟数组： <code>数组类型 数组名[] = new 数据类型[数组长度]</code><br>（2）分步完成：</p><pre class="highlight"><code class="">// 声明数组数组类型 数组名[] = null;// 开辟数组数组名 = new 数据类型 [数组长度]</code></pre><p>3.数组开辟空间用，可利用<code>数组名[下标|索引]</code>访问，<strong>下标从0开始</strong>。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现<strong>数组越界异常（ArrayIndexOutOfBoundsException）。</strong><br>4.数组是顺序结构且长度固定，可使用循环语句输出，可用<code>数组名.length</code>获取数组长度。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[] = new int[3]; // 声明并开辟一个长度为3的数组        datas[0] = 1; // 为数组赋值，如不赋值，默认值为0        datas[1] = 2;        datas[2] = 3;        // for循环输出数组内容，datas.length获取数组长度        for (int x = 0; x &lt; datas.length; x++) {            System.out.println(datas[x]);        }    }}</code></pre><p>5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。<br><img src="/article/Java/Java Base/Java基础知识(四)/7-1.png" alt="无法加载" title="数组内存分析"><br><strong>范例</strong>：分步完成</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[] = null; // 声明数组        datas = new int[3]; // 开辟一个长度为3的数组        datas[0] = 1;        datas[1] = 2;        datas[2] = 3;        for (int x = 0; x &lt; datas.length; x++) {            System.out.println(datas[x]);        }    }}</code></pre><p><img src="/article/Java/Java Base/Java基础知识(四)/7-2.png" alt="无法加载" title="数组内存分析"><br>6.数组可以进行引用传递。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[] = new int[3];        datas[0] = 1;        datas[1] = 2;        datas[2] = 3;        int temp[] = datas; // 引用传递        temp[0] = 99;        for (int x = 0; x &lt; datas.length; x++) {            System.out.println(datas[x]); // 99 2 3        }    }}</code></pre><p><img src="/article/Java/Java Base/Java基础知识(四)/7-3.png" alt="无法加载" title="数组内存分析"><br>以上都是<code>动态初始化数组</code>，即先开辟数组，再为数组赋值。<br>7.静态初始化数组：<br>在定义数组的同时为其赋值，语法：<br>（1）<code>数组类型 数组名[] = {v1, v2 ,…,vn};</code><br>（2）<code>数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn};</code><br><strong>范例</strong>：静态初始化数组</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[] = new int[]{1, 2, 3}; // 静态初始化数组        for (int x = 0; x &lt; datas.length; x++) {            System.out.println(datas[x]);        }    }}</code></pre><p>数组支持顺序数据访问，最大缺点是<strong>长度不能改变</strong>，因此在开发中不直接使用数组，但会使用数组的概念。</p><h3 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h3><p>1.<strong>一维数组就是一行数据：</strong></p><table><thead><tr><th>索引</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td>数据</td><td style="text-align:center">0</td><td style="text-align:center">10</td><td style="text-align:center">20</td><td style="text-align:center">30</td></tr></tbody></table><p>在一维数组中要查询一个数据，只要确定其索引即可。<br><strong>二维数组，是一个数据表：</strong></p><table><thead><tr><th>索引</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">10</td><td style="text-align:center">20</td><td style="text-align:center">30</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td>2</td><td style="text-align:center">12</td><td style="text-align:center">123</td><td style="text-align:center">231</td><td style="text-align:center">233</td></tr></tbody></table><p>二维数组中要查询一个数据，需要定位列和行。二维数组中第一个<code>[]</code>确定行，第二个<code>[]</code>确定列。<br>2. 二维数组定义语法：</p><pre class="highlight"><code class="">// 动态初始化：数据类型 数组名称[][]=new 数据类型[行数][列数];// 静态初始化：数据类型 数组名称[][]=new 数据类型[][]{数组元素} ;</code></pre><p>由此可以发现，二维数组就是将多个一维数组变为一个数组。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[][] = new int[][]{        {1, 2, 3},         {4, 5, 6},         {7, 8, 9}        };         // 外层循环控制数组的行        for (int x = 0; x &lt; datas.length; x++) {            // 内层循环控制数组的列            for (int y = 0; y &lt; datas[x].length ; y++) {                System.out.print(datas[x][y] + &quot;\t&quot;);            }            System.out.println();        }    }}</code></pre><h3 id="数组与方法的引用"><a class="markdownIt-Anchor" href="#数组与方法的引用"></a> 数组与方法的引用</h3><p>1.方法的参数可以是数组：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int datas[] = new int[]{1, 2, 3};        change(datas);        for (int x = 0; x &lt; datas.length; x++) {            System.out.println(datas[x]);        }    }    public static void change(int temp[]) {        for (int x = 0; x &lt; temp.length; x++) {            temp[x] *= 2; // 数组元素乘2保存        }    }}</code></pre><p><strong>内存分析：</strong><br><img src="/article/Java/Java Base/Java基础知识(四)/7-4.png" alt="无法加载" title="数组内存分析"><br><code>change()</code>执行完毕后，<code>temp</code>不再指向<code>datas</code>的堆内存，但<code>change()</code>对<code>datas</code>数据的修改被保存下来。<br>2.<strong>数组排序（冒泡排序）</strong>：<br>数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。</p><pre class="highlight"><code class="">public class ArrayDemo {    public static void main(String[] args) {        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};        for (int x = 0; x &lt; datas.length; x++) {            for (int y = 0; y &lt; datas.length - 1; y++) {                if (datas[y] &gt; datas[x]) {                    int t = datas[y];                    datas[y] = datas[x];                    datas[x] = t;                }            }            // 为更好地理解冒泡排序，输出每轮排序的结果            System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;);            print(datas);            System.out.println();        }        print(datas);    }    // 数组输出的方法    public static void print(int temp[]) {        for (int x = 0; x &lt; temp.length; x++) {            System.out.print(temp[x] + &quot; &quot;);        }    }}</code></pre><p><strong>建议</strong>：<code>main()</code>是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。</p><pre class="highlight"><code class="">public class ArrayDemo {    public static void main(String[] args) {        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};        sort(datas);        print(datas);    }    // 数组冒泡排序方法    public static void sort(int temp[]) {        for (int x = 0; x &lt; temp.length; x++) {            for (int y = 0; y &lt; temp.length - 1; y++) {                if (temp[y] &gt; temp[x]) {                    int t = temp[y];                    temp[y] = temp[x];                    temp[x] = t;                }            }        }    }    // 数组输出的方法    public static void print(int temp[]) {        for (int x = 0; x &lt; temp.length; x++) {            System.out.print(temp[x] + &quot; &quot;);        }    }}</code></pre><p>3.<strong>数组转置</strong><br>转置的概念（一维数组）：·</p><table><thead><tr><th>原始数组</th><th style="text-align:right">1，2，3，4，5，6，7，8</th></tr></thead><tbody><tr><td>转置后</td><td style="text-align:right">8，7，6，5，4，3，2，1</td></tr></tbody></table><p><strong>转置操作的两个思路：</strong><br>（1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用：</p><pre class="highlight"><code class=""> public class ArrayDemo {    public static void main(String[] args) {        int datas[] = new int[]{1,2,3,4,5,6,7,8};        datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾    }    // 数组逆序输出方法一    public static int [] reverseOne(int temp[]) {        // 定义新数组，长度与原始数组一致        int temps[] = new int[temp.length];        int foot = temp.length - 1; // 控制原始数组的索引        for (int x = 0; x &lt; temps.length ; x++) {            temps[x] = temp[foot]; // 新数组按照原始数组倒序排列            foot --;        }        return temps;    }}</code></pre><p>上述代码实现转置，但产生了垃圾，不合理。<br>（2）利用算法，直接在数组上完成转置：<br>不论数组个数是奇数还是偶数,<code>转换次数 = 数组长度 / 2</code>;</p><pre class="highlight"><code class="">// 数组逆序输出方法public static void reverse(int temp[]) {    int len = temp.length / 2;    int head = 0;    int tail = temp.length - 1;    for (int x = 0; x &lt; len; x++) {        int t = temp[head];        temp[head] = temp[tail];        temp[tail] = t;        head++;        tail--;    }}</code></pre><p>4.<strong>行列数相等的二维数组转置：</strong></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int data[][] = new int[][]{        {1, 2, 3},         {4, 5, 6},         {7, 8, 9}        };        reverse(data);        print(data);    }    // 专门实现数组的倒置操作    public static void reverse(int arr[][]) {        for (int x = 0; x &lt; arr.length; x++) {            for (int y = x; y &lt; arr.length; y++) {                if (x != y) { //行和列相同，进行交换                    int temp = arr[x][y];                    arr[x][y] = arr[y][x];                    arr[y][x] = temp;                }            }        }    }    // 专门输出的方法    public static void print(int temp[][]) {        for (int x = 0; x &lt; temp.length; x++) {            for (int y = 0; y &lt; temp[x].length; y++) {                System.out.print(temp[x][y] + &quot;、&quot;);            }            System.out.println();        }        System.out.println();    }}</code></pre><p><strong>转置过程</strong>：</p><pre class="highlight"><code class="">1[0][0]  2[0][1]  3[0][2]4[1][0]  5[1][1]  6[1][2]7[2][0]  8[2][1]  9[2][2]第一次转换（x=0，y=x=0，循环3次） ·y的第一次循环（x==y）  1[0][0]  2[0][1]  3[0][2]  4[1][0]  5[1][1]  6[1][2]  7[2][0]  8[2][1]  9[2][2] ·y的第二次循环（x=0，y=1，进行交换）  1[0][0]  4[1][0]  3[0][2]  2[0][1]  5[1][1]  6[1][2]  7[2][0]  8[2][1]  9[2][2] ·y的第三次循环（x=0，y=2，进行交换）  1[0][0]  4[1][0]  7[2][0]  2[0][1]  5[1][1]  6[1][2]  3[0][2]  8[2][1]  9[2][2]第二次转换（x=1，y=x=1，循环2次） ·y的第一次循环（x=1，y=1，不交换）  1[0][0]  4[1][0]  7[2][0]  2[0][1]  5[1][1]  6[1][2]  3[0][2]  8[2][1]  9[2][2] ·y的第二次循环（x=1，y=2，进行交换）  1[0][0]  4[1][0]  7[2][0]  2[0][1]  5[1][1]  8[2][1]  3[0][2]  6[1][2]  9[2][2]第三次转换（x=2，y=x=2，循环11次） ·y的第二次循环（x=2，y=2，不交换）  1[0][0]  4[1][0]  7[2][0]  2[0][1]  5[1][1]  8[2][1]  3[0][2]  6[1][2]  9[2][2]</code></pre><p>行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。<br>5.方法返回数组：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int data[] = init(); // 接收数组        print(data);        System.out.println(init().length);    }    public static int[] init() {        return new int[]{1, 2, 3}; // 方法返回数组    }    public static void print(int temp[]) {        for (int x = 0; x &lt; temp.length; x++) {            System.out.print(temp[x] + &quot;、&quot;);        }        System.out.println();    }}</code></pre><h3 id="操作数组的方法"><a class="markdownIt-Anchor" href="#操作数组的方法"></a> 操作数组的方法</h3><p>1.Java对数组提供类库支持，下面介绍两个类库中的方法：<br>（1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。<br>语法：<code>System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)</code>。<br>范例：数组拷贝<br>·数组A：1，2，3，4，5，6，7，8；<br>·数组B：11，22，33，44，55，66，77，88；<br>·拷贝后的数组B:11，22，5，6，7，66，77，88</p><pre class="highlight"><code class=""> public class Demo {    public static void main(String[] args) {        int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8};        int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88};        System.arraycopy(dataA, 4, dataB, 2, 3);        ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法    }}</code></pre><p>（2）数组排序：<br>语法：<code>java.util.Arrays.sort(数组名)</code></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5};        java.util.Arrays.sort(dataA);        ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法    }}</code></pre><h3 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h3><p>1.<strong>对象数组</strong>是将多个对象交由数组处理。<br>2.对象数组的定义与一般数组一致：<br><strong>范例</strong>： 动态初始化对象数组</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}public class Demo {    public static void main(String[] args) {        Book books[] = new Book[3];        books[0] = new Book(&quot;Java开发&quot;, 66.6);        books[1] = new Book(&quot;JSP&quot;, 6.6);        books[2] = new Book(&quot;C++&quot;, 16.6);        for (int x = 0; x &lt; books.length; x++) {            System.out.println(books[x].getInfo()); //未实例化对象时，输出值全为null        }    }  }</code></pre><p><strong>范例</strong>：静态初始化对象数组：</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    // setter和getter方法略    public String getInfo() {        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;    }}public class Demo {    public static void main(String[] args) {        Book books[] = new Book[]{                new Book(&quot;Java开发&quot;, 66.6),                new Book(&quot;JSP&quot;, 6.6),                new Book(&quot;C++&quot;, 16.6)        };        for (int x = 0; x &lt; books.length; x++) {            //未实例化对象时，输出值全为null            System.out.println(books[x].getInfo());         }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组的定义及使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组的定义及使用&quot;&gt;&lt;/a&gt; 数组的定义及使用&lt;/h2&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(三)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(三)/</id>
    <published>2017-10-02T07:31:57.908Z</published>
    <updated>2017-10-21T05:58:05.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法的定义与使用"><a class="markdownIt-Anchor" href="#方法的定义与使用"></a> 方法的定义与使用</h2><h3 id="方法的基本概念"><a class="markdownIt-Anchor" href="#方法的基本概念"></a> 方法的基本概念</h3><ol><li><strong>方法</strong>就是<code>将一段可重复使用的代码封装</code>。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是<code>定义在主类中，由主方法直接调用</code>的方法。此类方法的语法：</li></ol><pre class="highlight"><code class="">public static 返回值类型 method_name(v_type v1, v_type v2,...) {    方法体; // 方法要进行的若干操作    [return [返回值] ;] // []中内容可写可不写}</code></pre><p><strong>返回值类型:</strong></p><table><thead><tr><th>数据类型(基本数据类型、引用数据类型)</th><th style="text-align:right">无返回值(void)</th></tr></thead><tbody><tr><td>如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容</td><td style="text-align:right">不需要return语句，但可用return结束方法调用</td></tr></tbody></table><ol start="2"><li>方法名的命名规则：<code>第一个单词小写，随后每个单词首字母大写</code>。<br><strong>范例</strong>：定义无参无返回值方法</li></ol><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        print(); // 直接调用    }    public static void print(){        System.out.println(&quot;无参无返回值方法&quot;);    }}</code></pre><p><strong>范例</strong>：定义含参无返回值方法</p><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        compare(10.2); // 调用时必须写入参数        compare(-10.2);    }    public static void compare(double x){        String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;;        System.out.println(str);    }}</code></pre><p>有了参数后，方法就可以根据不同的参数内容进行数据的处理。<br><strong>范例</strong>：定义含参数有返回值方法</p><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        //定义变量接收返回值，而后输出        int result = add(10, 20);        System.out.println(result);        // 直接输出返回值        System.out.println(add(10, 20));    }    public static int add(int x, int y) {        return x + y;    }}</code></pre><ol start="3"><li>一个方法使用<code>void</code>定义，该方法无法使用return返回值，但可以使用return结束调用。</li></ol><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        print(1100); // x = 1100        print(3); // 结束调用,不输出x    }    public static void print(int x) {        if (x == 3) {            System.out.println(&quot;结束调用,不输出x&quot;);            return;        }        System.out.println(&quot;x = &quot; + x);    }}</code></pre><p><strong>只有返回值类型为void时，才可使用return结束方法的调用。</strong></p><h3 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h3><ol><li>假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为<code>方法重载（overloading）</code>。</li><li>方法重载要求<code>方法名一致，参数类型或个数不同</code>。</li></ol><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        // 根据参数的个数或类型，调用不同方法        add(10,20);        add(10.2,20.2);        add(10,20,30);    }    // 方法名相同，参数的类型或个数不同    public static void add(int x, int y) {        System.out.println(&quot;两个整数相加：&quot; + (x + y));    }    public static void add(double x, double y) {        System.out.println(&quot;两个小数相加：&quot; + (x + y));    }    public static void add(int x, int y, int z) {        System.out.println(&quot;三个整数相加：&quot; + (x + y + z));    }}</code></pre><p><code>System.out.println()</code>可以输出不同类型数据，可知此方法是一个被重载后的方法。</p><ol start="3"><li>方法重载的说明：<br>（1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致；<br>（2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。</li></ol><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {    }    // 报错,已在类中定义了方法 add(int,int)    // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同    public static int add(int x, int y) {        return x + y;    }    public static double add(int x, int y) {        return x + y;    }}</code></pre><h3 id="递归调用"><a class="markdownIt-Anchor" href="#递归调用"></a> 递归调用</h3><ol><li>递归调用是指<code>方法调用自身</code>。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。<br><strong>范例</strong>：递归实现1~100的累加操作</li></ol><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {        System.out.println(sum(100));    }    public static int sum(int num){        if (num == 1) { // 结束递归调用            return 1;        }        // 递归调用        return num + sum(num - 1);     }}</code></pre><p><strong>代码的执行步骤：</strong></p><table><thead><tr><th>No.</th><th style="text-align:center">内容</th><th style="text-align:right">返回值</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">主方法调用sum(100)</td><td style="text-align:right">100+sum(99)</td></tr><tr><td>2</td><td style="text-align:center">递归调用sum(99)</td><td style="text-align:right">100 + 99 + sum（98)</td></tr><tr><td>3</td><td style="text-align:center">递归调用sum(98)</td><td style="text-align:right">100 + 99 + 98+ sum(97)</td></tr><tr><td>…</td><td style="text-align:center">依此类推</td><td style="text-align:right">…</td></tr><tr><td>最后一次</td><td style="text-align:center">递归调用sum(1)</td><td style="text-align:right">sum=100+99+98+…+2+1,结束递归</td></tr></tbody></table><h2 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h2><h3 id="面向对象简介"><a class="markdownIt-Anchor" href="#面向对象简介"></a> 面向对象简介</h3><blockquote><p>面向过程：指的是针对某一个问题单独提出解决方案和代码开发。<br>面向对象：以组件化的形式进行代码设计，优点是代码可重用。<br>面向对象语言的特征：<br>（1）<code>封装性</code>：保护内部结构安全性。<br>（2）<code>继承性</code>：在已有的程序结构上扩充新的功能。<br>（3）<code>多态性</code>：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果<br>面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。</p></blockquote><h3 id="类与对象-2"><a class="markdownIt-Anchor" href="#类与对象-2"></a> 类与对象</h3><p>1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。<br>2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含<code>特征(属性)</code>外，还包括许多<code>行为(方法)</code>。根据这个类产生的对象都具有相同的行为。<br>3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。<br>4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。</p><h3 id="类与对象的定义及使用"><a class="markdownIt-Anchor" href="#类与对象的定义及使用"></a> 类与对象的定义及使用</h3><p>1.定义类使用<code>class class_name {}</code>语句完成。类的组成：<br>(1)<code>field</code>（属性，成员，变量）：一堆变量的集合；<br>(2)<code>method</code>（方法，行为）：由对象调用。<br><strong>范例</strong>：定义类</p><pre class="highlight"><code class="">package com.java.entity;public class Book {   // 定义属性   public String title;   public double price;   // 定义方法   public void getInfo(){       System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);   }}</code></pre><p>2.要使用类，必须要有对象，对象定义的语法有如下两种：<br>(1)声明并实例化对象：<code>class_name object_name = new class_name()</code>；<br>(2)分步完成： 第一步-声明对象：<code>class_name object_name = null</code>;<br>第二部-实例化对象：<code>object_name =new class_name()</code>;<br>引用数据类型与基本数据类型最大区别是<strong>需要内存的开辟及使用</strong>，所以关键字<code>new</code>的主要功能就是开辟内存空间。<br>3.当一个对象实例化后，利用如下方式操作类：<br>(1)<code>object_name.field</code>：操作类中的属性；<br>(2)<code>object_name.method()</code>：调用类中的方法。<br><strong>范例</strong>：使用类</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Book book = new Book(); // 声明并实例化对象        book.title = &quot;Java开发&quot;; // 定义属性        book.price = 66.6;        book.getInfo(); // 调用方法    }}</code></pre><p>4.堆内存和栈内存的概念：</p><table><thead><tr><th>堆内存</th><th style="text-align:right">栈内存</th></tr></thead><tbody><tr><td>保存对象的属性内容，使用关键字new开辟</td><td style="text-align:right">栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字</td></tr></tbody></table><p><img src="/article/Java/Java Base/Java基础知识(三)/6-1.png" alt="无法加载" title="内存分析"><br><strong>范例</strong>：分步使用实例化对象</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Book book = null; // 声明对象        book = new Book(); // 实例化对象        book.title = &quot;Java开发&quot;;        book.price = 66.6;        book.getInfo();    }}</code></pre><p><strong>内存分析</strong>：使用关键字<strong>new</strong>开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为<strong>默认值</strong>。<br><img src="/article/Java/Java Base/Java基础知识(三)/6-2.png" alt="无法加载" title="内存分析"><br>使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）”</p><h3 id="对象引用分析"><a class="markdownIt-Anchor" href="#对象引用分析"></a> 对象引用分析</h3><p>1.在引用分析中，每次使用<code>new</code>关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么<strong>两个对象占据的是不同的堆内存，因此不会互相影响。</strong><br><strong>范例</strong>：声明两个对象</p><pre class="highlight"><code class="">public class Demo {   public static void main(String[] args) {       Book bkA = new Book();       Book bkB = new Book();       bkA.title = &quot;Java开发&quot;;       bkA.price = 66.6;       bkA.getInfo();       bkB.title = &quot;C++开发&quot;;       bkB.price = 22.6;       bkB.getInfo();   }}</code></pre><p><img src="/article/Java/Java Base/Java基础知识(三)/6-3.png" alt="无法加载" title="内存分析"><br>2. <strong>范例</strong>：对象引用传递</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        Book bkB = null;        bkA.title = &quot;Java开发&quot;;        bkA.price = 66.6;        bkA.getInfo(); // 66.6        bkB = bkA; // 引用传递        bkB.price = 90.5;        bkA.getInfo(); // 90.5        bkB.getInfo(); // 90.5    }}</code></pre><p><img src="/article/Java/Java Base/Java基础知识(三)/6-4.png" alt="无法加载" title="内存分析"><br>由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。<strong>在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。</strong><br>3. <strong>范例</strong>：引用传递</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        Book bkB = new Book();        bkA.title = &quot;Java开发&quot;;        bkA.price = 66.6;        bkB.title = &quot;C++开发&quot;;        bkB.price = 90.5;        bkB = bkA; // 引用传递        bkB.price = 100;        bkA.getInfo(); // 100        bkB.getInfo(); // 100    }}</code></pre><p><img src="/article/Java/Java Base/Java基础知识(三)/6-5.png" alt="无法加载" title="内存分析"><br>通过内存分析可知，<strong>在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。</strong></p><h3 id="封装性"><a class="markdownIt-Anchor" href="#封装性"></a> 封装性</h3><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        bkA.title = &quot;Java开发&quot;;        bkA.price = -66.6;        bkA.getInfo();    }}</code></pre><p>上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为<strong>对象可以在类的外部直接访问属性。</strong><br>1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。</p><pre class="highlight"><code class="">public class Book {    private String title;    private double price;    public void getInfo(){        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性    }}</code></pre><p>此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：<strong>类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter()</strong>.<br>2. 以Book类中的title属性为例，定义setter()/getter()：</p><table><thead><tr><th></th><th style="text-align:center">setter()</th><th style="text-align:center">getter()</th></tr></thead><tbody><tr><td>作用</td><td style="text-align:center">设置属性值</td><td style="text-align:center">取得属性值</td></tr><tr><td>语法</td><td style="text-align:center">public void setTitle(String t)</td><td style="text-align:center">public void getTitle()</td></tr><tr><td>是否含参</td><td style="text-align:center">有参</td><td style="text-align:center">无参</td></tr></tbody></table><pre class="highlight"><code class="">package com.java.entity;public class Book {    private String title;    private double price;    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public double getPrice() {        return price;    }    public void setPrice(double price) {        this.price = price;    }    public void getInfo(){        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);    }}</code></pre><p>如果要添加如价格不能为负数的功能，应在setter()中添加：</p><pre class="highlight"><code class="">public void setPrice(double price) {    if (price &gt; 0.0){        this.price = price;     }}</code></pre><p>对于数据的验证，开发中应有其他辅助代码完成，<strong>setter()只是简单地设置数据，getter()只用于返回数据。</strong></p><h3 id="构造方法与匿名对象"><a class="markdownIt-Anchor" href="#构造方法与匿名对象"></a> 构造方法与匿名对象</h3><blockquote><p>定义对象的语法：类名称 对象名称 = new 类名称();<br>①类名称：定义对象的类型；<br>②对象名称：标识符，要使用对象，需要有一个对象名；<br>③new：用于开辟堆内存空间，实例化对象；<br>④类名称()：一个方法名和类名称一样的方法，这就是构造方法。<br>通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为<strong>Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。</strong><br>1.构造方法的定义原则：<strong>方法名称与类名称相同，没有返回值。</strong></p></blockquote><pre class="highlight"><code class="">class Book {    public Book() { // 系统自动生成的构造方法    }}</code></pre><p>2.构造方法在对象使用new实例化时调用。<br><strong>范例</strong>：证明构造方法被调用</p><pre class="highlight"><code class="">public class Book {   public Book() {       System.out.println(&quot;构造方法被调用&quot;);   }}public class Demo {   public static void main(String[] args) {       Book book = null ; // 声明对象       book = new Book(); // 实例化对象时调用构造方法       //结果：构造方法被调用   }}</code></pre><p>构造方法与普通方法的最大区别：<strong>构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。</strong><br>3.<strong>范例</strong>：自定义构造方法</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法    public Book(String t, double p) {        title = t;        price = p;    }    public void getInfo() {        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);    }}public class Demo {    public static void main(String[] args) {        Book book = new Book(&quot;Java开发&quot;, 66.6);        book.getInfo();    }}</code></pre><p>由上述代码可知构造方法的作用：<code>在类对象实例化时设置属性的初始值，即构造方法用于属性初始化</code>。<br>4.构造方法也属于方法，因此可以进行重载。<br><strong>范例</strong>：构造方法重载</p><pre class="highlight"><code class="">class Book {    public Book() {        System.out.println(&quot;系统自动生成的构造方法&quot;);    }    // 进行方法重载的构造方法    public Book(String t, double p) {        System.out.println(&quot;方法重载后的构造方法&quot;);    }}public class Demo {    public static void main(String[] args) {        Book bookA = new Book(); // 系统自动生成的构造方法        Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法    }}</code></pre><p>重载方法时要求：<strong>按照参数个数，对方法进行升序或者降序排列。</strong><br>5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：<code>类的加载，内存的分配，默认值的设置，构造方法</code>。</p><pre class="highlight"><code class="">class Book {    private String title = &quot;Java开发&quot;; // 设置默认值    private double price;    public Book() {    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public double getPrice() {        return price;    }    public void setPrice(double price) {        if (price &gt; 0.0){            this.price = price;        }    }    public void getInfo() {        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);    }}public class Demo {    public static void main(String[] args) {        Book bkA = new Book();        bkA.getInfo(); // 书名：Java开发,价格：0.0    }}</code></pre><p>本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。<strong>真实的对象信息都保存在堆内存中。</strong><br>6.匿名对象：<code>没有栈内存指向的对象，即没有标识符的对象</code>。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        new Book(&quot;Java开发&quot;,6.6).getInfo();    }}</code></pre><p>由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。<br><strong>何时使用匿名对象</strong>：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。</p><h3 id="简单java类实践"><a class="markdownIt-Anchor" href="#简单java类实践"></a> 简单Java类实践</h3><p><strong>题目要求</strong>：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。<br><strong>提示</strong>：这种类被称为<code>简单java类</code>，因为这种类不包含过于复杂的程序逻辑。</p><blockquote><p>对于简单Java类而言，它的要求如下：<br>·类名必须有意义；<br>·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法；<br>·类中可以有多个构造方法，但必须保留无参构造方法；<br>·类中不允许出现输出语句，信息输出必须交给调用处。<br>·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。</p></blockquote><p><strong>第一步：定义类</strong></p><pre class="highlight"><code class="">public class Emp {    private int eId; // 编号    private String eName; // 姓名    private String job; // 职位    private double sal; // 工资    private double comm; // 佣金    // 定义构造方法    public Emp() {    }        public Emp(int eId, String eName, String job, double sal, double comm) {        this.eId = eId;        this.eName = eName;        this.job = job;        this.sal = sal;        this.comm = comm;    }    // 定义setter和getter方法    public int geteId() {        return eId;    }    public void seteId(int eId) {        this.eId = eId;    }    public String geteName() {        return eName;    }    public void seteName(String eName) {        this.eName = eName;    }    public String getJob() {        return job;    }    public void setJob(String job) {        this.job = job;    }    public double getSal() {        return sal;    }    public void setSal(double sal) {        this.sal = sal;    }    public double getComm() {        return comm;    }    public void setComm(double comm) {        this.comm = comm;    }    // 定义普通方法    public String getInfo() {        return &quot;编  号&quot; + this.eId + &quot;\n&quot; +                &quot;姓 名&quot; + this.eName + &quot;\n&quot; +                &quot;职 位&quot; + this.job + &quot;\n&quot; +                &quot;工 资&quot; + this.sal + &quot;\n&quot; +                &quot;佣 金&quot; + this.comm;    }}</code></pre><p><strong>第二步：测试</strong></p><pre class="highlight"><code class="">public class TEmp {    public static void main(String[] args) {        Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0);        System.out.println(e.getInfo()); // 获取全部信息        System.out.println(e.geteId()); // 通过getter()获取单一信息    }}</code></pre><p>类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法的定义与使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#方法的定义与使用&quot;&gt;&lt;/a&gt; 方法的定义与使用&lt;/h2&gt;
&lt;h3 id=&quot;方法的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#方法的基
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes安装及使用</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Kubernetes%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Kubernetes安装及使用/</id>
    <published>2017-09-30T08:11:30.178Z</published>
    <updated>2017-09-30T08:44:56.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p><strong>系统要求</strong>: CentOS 7<br><strong>软件版本</strong>: 1.5.2</p><h2 id="配置目标"><a class="markdownIt-Anchor" href="#配置目标"></a> 配置目标:</h2><table><thead><tr><th></th><th style="text-align:center">master端</th><th style="text-align:right">node端</th></tr></thead><tbody><tr><td>IP</td><td style="text-align:center">10.0.0.100</td><td style="text-align:right">10.0.0.101</td></tr><tr><td>etcd</td><td style="text-align:center">✔</td><td style="text-align:right"></td></tr><tr><td>flannel</td><td style="text-align:center">✔</td><td style="text-align:right">✔</td></tr><tr><td>kube-apiserver</td><td style="text-align:center">✔</td><td style="text-align:right"></td></tr><tr><td>kube-controller-manager</td><td style="text-align:center">✔</td><td style="text-align:right"></td></tr><tr><td>kube-scheduler</td><td style="text-align:center">✔</td><td style="text-align:right"></td></tr><tr><td>kubelet</td><td style="text-align:center">✔</td><td style="text-align:right">✔</td></tr><tr><td>kube-proxy</td><td style="text-align:center">✔</td><td style="text-align:right">✔</td></tr><tr><td>docker</td><td style="text-align:center">✔</td><td style="text-align:right">✔</td></tr></tbody></table><h2 id="共同配置即master和node都需要进行的操作"><a class="markdownIt-Anchor" href="#共同配置即master和node都需要进行的操作"></a> 共同配置（即master和node都需要进行的操作）</h2><p>(1)修改/etc/hosts文件，添加master和node节点IP</p><pre class="highlight"><code class="">$ echo &quot;10.0.0.100 centos-master  10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts$ cat /etc/hosts  10.0.0.100 centos-master  10.0.0.101 centos-minion</code></pre><p>(2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services</p><pre class="highlight"><code class=""># 关闭fierwalld$ systemctl stop firewalld$ systemctl disable firewalld# 安装iptables，启动该服务并设置开机自启动$ yum install iptables$ systemctl start iptables$ systemctl enable iptables# 关闭iptables-services$ systemctl disable iptables-services $ systemctl stop iptables-services # 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot;# 解决方法：修改SElinux配置$ vi /etc/selinux/config  # SELINUX=enforcing    #注释掉  # SELINUXTYPE=targeted #注释掉    SELINUX=disabled #增加  :wq! #保存退出$ setenforce 0 #使配置立即生效</code></pre><p>(3)安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境配置&quot;&gt;&lt;/a&gt; 环境配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;系统要求&lt;/strong&gt;: CentOS 7&lt;br&gt;
&lt;strong&gt;软件版本&lt;/strong&gt;: 1.5.2&lt;/
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Kubernetes" scheme="http://yov.oschina.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker Hub Mysql官方镜像实现首次启动后初始化库表</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Docker%20Hub%20mysql%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%AE%9E%E7%8E%B0%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%93%E8%A1%A8/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表/</id>
    <published>2017-09-29T11:59:23.363Z</published>
    <updated>2017-09-30T04:25:40.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>在Docker Hub中查看MySQL官方镜像的Dockerfile:</p><pre class="highlight"><code class="">COPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</code></pre><p>镜像启动时，会运行<code>entrypoint.sh</code>脚本，该脚本的shell命令中:</p><pre class="highlight"><code class="">echo    for f in /docker-entrypoint-initdb.d/*; docase &quot;$f&quot; in*.sh)     echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;;*.sql)    echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;;*.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;;*)        echo &quot;$0: ignoring $f&quot; ;;esacechodone</code></pre><p>上述shell命令会遍历<code>/docker-entrypoint-initdb.d/</code>文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。</p><h2 id="实现首次启动后初始化库表"><a class="markdownIt-Anchor" href="#实现首次启动后初始化库表"></a> 实现首次启动后初始化库表</h2><h3 id="创建mysql_data文件夹将datasql放入"><a class="markdownIt-Anchor" href="#创建mysql_data文件夹将datasql放入"></a> 创建mysql_data文件夹，将data.sql放入：</h3><pre class="highlight"><code class="data.sql">-- 创建数据库 DROP database IF EXISTS `docker_database`;create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL,PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES    (0,'Tom',18);</code></pre><h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3><pre><code>$ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456  mysql </code></pre><h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3><pre><code>$ docker exec -it sql /bin/bash</code></pre><pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u root -p Enter password:mysql&gt; use docker_database;mysql&gt; show tables;+---------------------------+| Tables_in_docker_database |+---------------------------+| person                    |+---------------------------+1 row in set (0.00 sec)mysql&gt; select * from person;+----+------+------+| id | name | age  |+----+------+------+|  0 | Tom  |   18 |+----+------+------+1 row in set (0.00 sec)mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);Query OK, 1 row affected (0.06 sec)mysql&gt; select * from person;                                +----+------+------+| id | name | age  |+----+------+------+|  0 | Tom  |   18 ||  1 | Jane |   17 |+----+------+------+2 rows in set (0.00 sec)</code></pre><p>重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。</p><h2 id="指定sql文件运行顺序"><a class="markdownIt-Anchor" href="#指定sql文件运行顺序"></a> 指定sql文件运行顺序</h2><p><code>entrypoint.sh</code>脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法：</p><ol><li>将文件按照预期顺序，进行命名，比如1_xx,2_xx;</li><li>将必须有前后顺序的sql文件合并在一个sql文件中;</li><li>将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。<br>假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh</li></ol><pre class="highlight"><code class="data.sh">#!/bin/bashmysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOFsource /usr/local/work/database.sql;source /usr/local/work/table.sql;source /usr/local/work/data.sql; </code></pre><p>启动容器：</p><pre><code>$ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql</code></pre><p>数据结果应与上述一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;在Docker Hub中查看MySQL官方镜像的Dockerfile:&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code cla
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="http://yov.oschina.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker实现mysql容器启动后自动建库</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E5%AE%9E%E7%8E%B0mysql%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BB%BA%E5%BA%93/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Docker实现mysql容器启动后自动建库/</id>
    <published>2017-09-28T09:22:57.955Z</published>
    <updated>2017-09-30T01:47:23.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>通过Dockerfile创建一个mysql镜像,该镜像具有如下功能：</p><blockquote><p>mysql容器启动时，会自动执行指定的sql文件;<br>每次启动该容器，数据都进行初始化，删除所有的修改。</p></blockquote><h2 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h2><h3 id="创建dockerfile"><a class="markdownIt-Anchor" href="#创建dockerfile"></a> 创建Dockerfile</h3><pre><code>$ vim Dockerfile</code></pre><pre class="highlight"><code class=""># 指定基础镜像，选用docker官方最新mysql镜像FROM docker.io/mysql:latest# 环境变量设置，设置mysql登陆时不需密码ENV MYSQL_ALLOW_EMPTY_PASSWORD yes# 复制文件到容器中，要复制的文件有：启动脚本和sql文件COPY setup.sh /mysql/setup.shCOPY data.sql /mysql/data.sqlCOPY privileges.sql /mysql/privileges.sql# 容器启动命令启动脚本CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;]</code></pre><h3 id="创建privilegessql用于修改mysql权限"><a class="markdownIt-Anchor" href="#创建privilegessql用于修改mysql权限"></a> 创建privileges.sql用于修改mysql权限</h3><pre><code>$vim privileges.sql</code></pre><pre class="highlight"><code class="">use mysql; select host, user from user; -- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456：-- 如果用户docker不存在，则创建用户dockergrant all on docker_database.* to docker@'%' identified by '123456' with grant option; -- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： flush privileges;</code></pre><h3 id="创建datasql导入数据"><a class="markdownIt-Anchor" href="#创建datasql导入数据"></a> 创建data.sql导入数据</h3><pre><code>$ vim data.sql</code></pre><pre class="highlight"><code class="">-- 创建数据库 DROP database IF EXISTS `docker_database`;create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL,PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES    (0,'Tom',18);</code></pre><h3 id="创建容器启动脚本setupsh"><a class="markdownIt-Anchor" href="#创建容器启动脚本setupsh"></a> 创建容器启动脚本<code>setup.sh</code></h3><pre><code>$ vim setup.sh</code></pre><pre class="highlight"><code class=""># !/bin/bash set -e # 查看mysql服务的状态，方便调试echo `service mysql status` echo '1.启动mysql' # 启动mysql service mysql start # 使进程休眠sleep 3 echo `service mysql status` echo '2.开始导入数据' #导入sql文件mysql &lt; /mysql/data.sql echo '3.导入数据完毕....' sleep 3 echo `service mysql status` # 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 echo '4.开始修改密码....' # 导入修改mysql权限设置的文件mysql &lt; /mysql/privileges.sql echo '5.修改密码完毕....' #sleep 3 echo `service mysql status` echo 'mysql容器启动完毕,且数据导入成功' </code></pre><h3 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h3><p>创建镜像并命名为mysql:9.29</p><pre><code>$ docker build -t mysql:9.29 .</code></pre><h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2><h3 id="启动mysql929镜像生成容器"><a class="markdownIt-Anchor" href="#启动mysql929镜像生成容器"></a> 启动mysql:9.29镜像，生成容器</h3><pre><code>$ docker run --name sql -d -p 23306:3306 mysql:9.296da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41</code></pre><h3 id="查看容器日志"><a class="markdownIt-Anchor" href="#查看容器日志"></a> 查看容器日志</h3><pre><code>$ docker log sql</code></pre><pre class="highlight"><code class="">1.启动mysql....2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=457902017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903.2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode.2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode...MySQL Community Server 5.7.19 is started.MySQL Community Server 5.7.19 is running.2.开始导入数据....3.导入数据完毕....MySQL Community Server 5.7.19 is running.4.开始修改密码....hostuserlocalhostmysql.sessionlocalhostmysql.syslocalhostroot5.修改密码完毕....MySQL Community Server 5.7.19 is running.mysql容器启动完毕,且数据导入成功</code></pre><p>容器启动过程与setup.sh中编写的步骤完全一致。</p><h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3><pre><code>$ docker exec -it sql /bin/bash </code></pre><pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p Enter password:mysql&gt; use docker_database;mysql&gt; show tables;+---------------------------+| Tables_in_docker_database |+---------------------------+| person                    |+---------------------------+1 row in set (0.00 sec)mysql&gt; select * from person;+----+------+------+| id | name | age  |+----+------+------+|  0 | Tom  |   18 |+----+------+------+1 row in set (0.00 sec)</code></pre><h3 id="验证重启mysql容器数据库初始化"><a class="markdownIt-Anchor" href="#验证重启mysql容器数据库初始化"></a> 验证重启mysql容器，数据库初始化</h3><p>插入数据</p><pre><code>mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);Query OK, 1 row affected (0.06 sec)</code></pre><pre class="highlight"><code class="">mysql&gt; select * from person;                                +----+------+------+| id | name | age  |+----+------+------+|  0 | Tom  |   18 ||  1 | Jane |   17 |+----+------+------+2 rows in set (0.00 sec)</code></pre><p>重新启动容器</p><pre><code>$ docker stop sql$ docker start sql$ docker exec -it sql /bin/bash </code></pre><pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p Enter password:mysql&gt; use docker_database;mysql&gt; show tables;+---------------------------+| Tables_in_docker_database |+---------------------------+| person                    |+---------------------------+1 row in set (0.00 sec)mysql&gt; select * from person;+----+------+------+| id | name | age  |+----+------+------+|  0 | Tom  |   18 |+----+------+------+1 row in set (0.00 sec)</code></pre><p>重启容器后，数据初始化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;通过Dockerfile创建一个mysql镜像,该镜像具有如下功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql容器启动时，会自动执行指
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="http://yov.oschina.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>利用TestNG进行单元测试</title>
    <link href="http://yov.oschina.io/article/%E6%B5%8B%E8%AF%95/Test/%E5%88%A9%E7%94%A8TestNG%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yov.oschina.io/article/测试/Test/利用TestNG进行单元测试/</id>
    <published>2017-09-26T12:41:55.450Z</published>
    <updated>2017-09-30T08:44:05.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="testng简介"><a class="markdownIt-Anchor" href="#testng简介"></a> TestNG简介</h2><p>TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。</p><h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2><table><thead><tr><th>Annotation</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td><code>@BeforeSuite</code></td><td style="text-align:right">被注释的方法将在所有测试运行前运行</td></tr><tr><td><code>@AfterSuite</code></td><td style="text-align:right">被注释的方法将在所有测试运行后运行</td></tr><tr><td><code>@BeforeTest</code></td><td style="text-align:right">被注释的方法将在测试运行前运行</td></tr><tr><td><code>@AfterTest</code></td><td style="text-align:right">被注释的方法将在测试运行后运行</td></tr><tr><td><code>@BeforeGroups</code></td><td style="text-align:right">被注释的方法将在gourp中方法运行前运行</td></tr><tr><td><code>@AfterGroups</code></td><td style="text-align:right">被注释的方法将在gourp中方法运行后运行</td></tr><tr><td><code>@BeforeClass</code></td><td style="text-align:right">被注释的方法将在当前类的第一个方法运行前运行</td></tr><tr><td><code>@AfterClass</code></td><td style="text-align:right">被注释的方法将在当前类的所有方法运行后运行</td></tr><tr><td><code>@BeforeMethod</code></td><td style="text-align:right">被注释的方法将在每一个方法运行前运行</td></tr><tr><td><code>@AfterMethod</code></td><td style="text-align:right">被注释的方法将在每一个方法运行后运行</td></tr><tr><td><code>@DataProvider</code></td><td style="text-align:right">被注释的方法用于为其他方法提供数据</td></tr><tr><td><code>@Factory</code></td><td style="text-align:right">被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[]</td></tr><tr><td><code>@Parameters</code></td><td style="text-align:right">传递参数给测试方法</td></tr></tbody></table><h3 id="使用testng进行单元测试"><a class="markdownIt-Anchor" href="#使用testng进行单元测试"></a> 使用TestNG进行单元测试</h3><pre class="highlight"><code class="">@Test()  // Test中所有方法变为测试方法public class Test {@Test(enable = false)  // 该注释后，test1()测试时被忽略，相当于普通方法public void test1(){}        @BeforeTest()          // 该注释后，test3(),test4()执行前，test2()先执行public void test2(){}    @public void test3(){}public void test4(){}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;testng简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#testng简介&quot;&gt;&lt;/a&gt; TestNG简介&lt;/h2&gt;
&lt;p&gt;TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。&lt;/p&gt;
&lt;h2 id=&quot;anno
      
    
    </summary>
    
      <category term="测试" scheme="http://yov.oschina.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="TestNG" scheme="http://yov.oschina.io/tags/TestNG/"/>
    
  </entry>
  
  <entry>
    <title>Git使用(Linux)</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8(Linux)/"/>
    <id>http://yov.oschina.io/article/工具/Git使用(Linux)/</id>
    <published>2017-09-25T09:36:06.108Z</published>
    <updated>2017-09-26T12:52:36.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境安装"><a class="markdownIt-Anchor" href="#环境安装"></a> 环境安装</h2><p>安装git</p><pre class="highlight"><code class="">sudo apt-get install git</code></pre><p>配置git用户名</p><pre class="highlight"><code class="">git config –global user.name &quot;user_name&quot;</code></pre><p>配置用户邮箱地址</p><pre class="highlight"><code class="">git config –global user.email &quot;user_mail&quot;</code></pre><h2 id="创建本地仓库"><a class="markdownIt-Anchor" href="#创建本地仓库"></a> 创建本地仓库</h2><p>创建空目录</p><pre class="highlight"><code class="">mkdir folder_name</code></pre><p>进入空目录</p><pre class="highlight"><code class="">cd folder_name</code></pre><p>显示当前目录</p><pre class="highlight"><code class="">pwd</code></pre><p>把当前目录变为Git仓库</p><pre class="highlight"><code class="">git init</code></pre><p>把文件添加到Git仓库</p><pre class="highlight"><code class="">git add file</code></pre><p>把文件提交到Git仓库</p><pre class="highlight"><code class="">git commit -m &quot;commit_message&quot;</code></pre><h2 id="版本库操作"><a class="markdownIt-Anchor" href="#版本库操作"></a> 版本库操作</h2><p>查看修改内容</p><pre class="highlight"><code class="">git diff file_name</code></pre><p>查看工作区状态</p><pre class="highlight"><code class="">git status</code></pre><p>查看历史记录</p><pre class="highlight"><code class="">git log</code></pre><p>查看精简历史记录</p><pre class="highlight"><code class="">git log --pretty=oneline</code></pre><p>回退到上一个版本</p><pre class="highlight"><code class="">git reset --hard HEAD^</code></pre><p>回到某个指定版本</p><pre class="highlight"><code class="">git reset –-hard commit-id(git log查看)</code></pre><p>查看命令记录</p><pre class="highlight"><code class="">git reflog</code></pre><p>撤销全部工作区修改</p><pre class="highlight"><code class="">git checkout --file</code></pre><p>将暂存区修改撤销放回工作区</p><pre class="highlight"><code class="">git reset HEAD 文件</code></pre><p>linux删除文件</p><pre class="highlight"><code class="">rm file</code></pre><p>git库删除文件</p><pre class="highlight"><code class="">git rm file</code></pre><p>下载他人项目</p><pre class="highlight"><code class="">git clone https://github.com/xxx/xxx.git new_git_name</code></pre><h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2><p>创建并切换到分支</p><pre class="highlight"><code class="">git checkout -b dev_name</code></pre><p>查看当前分支</p><pre class="highlight"><code class="">git branch (*表示当前分支)</code></pre><p>切换分支</p><pre class="highlight"><code class="">git checkout dev_name</code></pre><p>合并指定分支到当前分支(fast forward 模式)</p><pre class="highlight"><code class="">git merge dev_name</code></pre><p>删除分支</p><pre class="highlight"><code class="">git branch -d dev_name</code></pre><p>合并分支时冲突,修改文件后,再提交<br>查看分支合并图</p><pre class="highlight"><code class="">git log --graph --pretty=oneline --addrev-commit</code></pre><p>合并分支（普通模式）</p><pre class="highlight"><code class="">git merge -- no-ff -m &quot;commit_message&quot; dev</code></pre><h2 id="多人合作"><a class="markdownIt-Anchor" href="#多人合作"></a> 多人合作</h2><p>查看远程库信息</p><pre class="highlight"><code class="">git remote -v</code></pre><p>推送主分支</p><pre class="highlight"><code class="">git push origin master</code></pre><p>推送其他分支</p><pre class="highlight"><code class="">git push origin dev_name</code></pre><p>创建本地分支</p><pre class="highlight"><code class="">git checkout -b dev_name origin/dev_name</code></pre><p>指定本地分支与远程分支的链接</p><pre class="highlight"><code class="">git branch --set-upstream-to=origin/dev_name</code></pre><p>获取远程库内容</p><pre class="highlight"><code class="">git pull  </code></pre><p>解决冲突后commit，再上传</p><pre class="highlight"><code class="">git push origin dev_name</code></pre><h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2><p>创建标签</p><pre class="highlight"><code class="">git tag tag_name</code></pre><p>给指定提交打标签</p><pre class="highlight"><code class="">git tag tag_name commit-id</code></pre><p>创建带说明的标签</p><pre class="highlight"><code class="">git tag -a tag_name -m &quot;message&quot; commit-id</code></pre><p>查看标签说明</p><pre class="highlight"><code class="">git show tag_name</code></pre><p>删除标签</p><pre class="highlight"><code class="">git tag -d tag_name</code></pre><p>推送标签</p><pre class="highlight"><code class="">git push origin tag_name</code></pre><p>一次性推送所有标签</p><pre class="highlight"><code class="">git push origin --tags</code></pre><p>删除标签（本地）</p><pre class="highlight"><code class="">git tag -d tag_name</code></pre><p>删除远程标签</p><pre class="highlight"><code class="">git push origin :refs/tags/tag_name</code></pre><h2 id="自定义git"><a class="markdownIt-Anchor" href="#自定义git"></a> 自定义Git</h2><p>使git显示不同颜色</p><pre class="highlight"><code class="">git config --global color.ui true</code></pre><p>忽略某些文件时，需要编写.gitignore<br>强制添加被忽略文件</p><pre class="highlight"><code class="">git add -f file</code></pre><p>检查某个文件符合被忽略要求</p><pre class="highlight"><code class="">git check-ignore -v file</code></pre><p>配置命令别名</p><pre class="highlight"><code class="">git config --global alias.别名 命令</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境安装&quot;&gt;&lt;/a&gt; 环境安装&lt;/h2&gt;
&lt;p&gt;安装git&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;&quot;&gt;sudo apt-get insta
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://yov.oschina.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker的安装说明</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Docker的安装说明/</id>
    <published>2017-09-24T10:43:23.794Z</published>
    <updated>2017-10-19T02:19:59.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装及部署docker"><a class="markdownIt-Anchor" href="#安装及部署docker"></a> 安装及部署Docker</h2><h3 id="系统和资源说明"><a class="markdownIt-Anchor" href="#系统和资源说明"></a> 系统和资源说明</h3><p>Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。<br>资源需求：Docker1.12.6</p><h3 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h3><p>(1)安装</p><pre><code>$ yum install docker</code></pre><p>(2)设置开机启动Docker Daemon进程</p><pre><code>$ systemctl start docker.service   // 启动docker$ systemctl enable docker.service  // 设置Docker开机自启动$ systemctl disable firewalld      // 关闭防火墙$ yum -y install iptables-services // 安装iptable服务$ systemctl start iptables.service   // 启动iptable$ systemctl enable iptables.service  // 设置iptable开机自启动</code></pre><p>(3)安装成功的Docker</p><pre><code>$ docker version</code></pre><img src="/article/容器/Docker/Docker的安装说明/success.png" alt="Docker安装成功">  <p>(4)建立docker用户组，将使用docker的用户加入docker用户组。</p><pre><code>$ groupadd docker$ usermod -aG docker $USER</code></pre><h3 id="docker的代理配置"><a class="markdownIt-Anchor" href="#docker的代理配置"></a> Docker的代理配置</h3><pre><code>$ vim /usr/lib/systemd/system/docker.service[Service]Environment=”HTTP_PROXY=http://192.168.13.19:7777”Environment=”HTTPS_PROXY=http://192.168.13.19:7777”Type=notify</code></pre><h3 id="docker配置加速器"><a class="markdownIt-Anchor" href="#docker配置加速器"></a> Docker配置加速器</h3><p>国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了<a href="https://cr.console.aliyun.com">阿里云加速器</a> 注册用户并且申请加速器后，会获得　<a href="https://xxx.mirror.aliyuncs.com">https://xxx.mirror.aliyuncs.com</a> 这样的地址。<br><img src="/article/容器/Docker/Docker的安装说明/dockerhub.png" alt="Docker加速器"></p><pre><code>$ vim /usr/lib/systemd/system/docker.service  ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com$ systemctl daemon-reload  //　重新加载配置$ systemctl restart docker //　重启docker</code></pre><h3 id="docker配置文件说明"><a class="markdownIt-Anchor" href="#docker配置文件说明"></a> Docker配置文件说明</h3><pre><code>$ vim /etc/sysconfig/dockerOPTIONS=' --selinux-enabled  //　是否开启selinux，默认开启 --insecure registry ip:port // 添加私人仓库地址 --bip=ip // 表示网桥docker0的CIDR地址'</code></pre><h2 id="docker的常用命令"><a class="markdownIt-Anchor" href="#docker的常用命令"></a> Docker的常用命令</h2><h3 id="docker信息查看"><a class="markdownIt-Anchor" href="#docker信息查看"></a> Docker信息查看</h3><p>(1)查看docker进程状态</p><pre><code>$ systemctl status docker</code></pre><p>(2)查看docker的具体信息</p><pre><code>$ docker info</code></pre><p>(3)查看docker的版本信息</p><pre><code>$ docker version</code></pre><h3 id="docker的镜像操作"><a class="markdownIt-Anchor" href="#docker的镜像操作"></a> Docker的镜像操作</h3><p>(1)查找镜像</p><pre><code>$ docker search image_name</code></pre><p>(2)拉取镜像</p><pre><code>$ docker pull image_name:tag</code></pre><p>(3)列出本地镜像</p><pre><code>$ docker images</code></pre><p>列表参数说明</p><blockquote><p>Repository：镜像的仓库源<br>Tag：镜像的标签<br>Image ID： 镜像ID<br>Created： 镜像的创建时间<br>Size： 镜像大小</p></blockquote><p>(4)设置镜像标签</p><pre><code>$ docker tag image_id tag</code></pre><p>(5)利用镜像创建容器</p><pre><code>$ docker run image_name:tag command</code></pre><p>(6)提交镜像</p><pre><code>$ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name</code></pre><h3 id="docker的容器操作"><a class="markdownIt-Anchor" href="#docker的容器操作"></a> Docker的容器操作</h3><p>(1)启动容器</p><pre><code>$ docker run option host_port:contaniner_port image_name:tag command</code></pre><blockquote><p>例如：docker run -it -d -p 5000:5000 java java -version<br>-d：后台运行容器<br>-p:将容器端口映射到宿主机端口<br>-it:进行交互式操作<br>command: 执行java -version命令</p></blockquote><p>(2)查看容器</p><pre><code>$ docker ps // 查看正在运行的容器</code></pre><p>(3)容器生命周期命令</p><pre><code>$ docker create image:tag  // 创建容器但不启动$ docker start container_name   // 启动容器$ docker stop contaniner_name   // 停止容器$ docker restart container_name // 重启容器$ docker pause contaniner_name  // 暂停容器内所有进程$ docker unpause contaniner_name // 恢复容器内所有进程$ docker rm contaniner  // 删除容器$ docker rm ${docker ps -a -q} // 删除所有停止的容器</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装及部署docker&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装及部署docker&quot;&gt;&lt;/a&gt; 安装及部署Docker&lt;/h2&gt;
&lt;h3 id=&quot;系统和资源说明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="http://yov.oschina.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker的简单说明</title>
    <link href="http://yov.oschina.io/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://yov.oschina.io/article/容器/Docker/Docker的简单说明/</id>
    <published>2017-09-24T09:36:05.889Z</published>
    <updated>2017-09-25T08:47:46.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker简介"><a class="markdownIt-Anchor" href="#docker简介"></a> Docker简介</h2><h3 id="docker的概念"><a class="markdownIt-Anchor" href="#docker的概念"></a> Docker的概念</h3><p><code>Docker</code>最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。<code>Docker</code>被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将<code>应用软件及其依赖软件</code>（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。</p><h3 id="dcoker的技术依赖"><a class="markdownIt-Anchor" href="#dcoker的技术依赖"></a> Dcoker的技术依赖</h3><p>Docker使用<code>Go</code>语言进行开发实现，基于Linux内核的<code>cgroup</code>、<code>namespace</code>以及AUFS类的<code>UnionFS</code>等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于<code>LXC</code>、0.7后去除LXC，使用自行开发的<code>libcontainer</code>。从1.11开始，则使用<code>runC</code>和<code>containerd</code>。</p><blockquote><p>（1）<code>cgroup</code>是将任意进程进行分组化管理的Linux内核功能。重要概念是<code>子系统</code>，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。<br>（2）<code>LXC</code>（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于<code>namespace</code>的隔离机制和<code>cgroup</code>限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。<br>（3）<code>AUFS</code>是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。<br>（4）<code>App打包</code>：Docker额外提供的Feature,标准统一的打包部署运行方案。</p></blockquote><h3 id="docker的优势"><a class="markdownIt-Anchor" href="#docker的优势"></a> Docker的优势</h3><p>Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：<code>传统虚拟机技术</code>是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而<code>容器</code>内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。</p><blockquote><p><strong>（1）更高效的利用系统资源</strong><br>由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。<br><strong>（2）更快速的启动</strong><br>Docker容器应用由于<code>直接运行于宿主内核</code>，无需启动完整的操作系统，因此可以做到<code>秒级</code>，甚至<code>毫秒级</code>的启动，大大节约了开发、测试、部署的时间。<br><strong>（3）一致的运行环境</strong><br>Docker镜像提供了<code>除内核外完整的运行时环境</code>，确保了应用运行环境的一致性。<br><strong>（4）持续交付和部署</strong><br>Docker可以通过<code>定制应用镜像</code>实现持续集成、持续交付、部署。开发人员可以通过<code>Dockerfile</code>来创建镜像，并结合<code>持续集成（Continuous integration）系统</code>进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合<code>持续部署（Continuous Delivery/Deployment）系统</code>进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。<br><strong>（5）更轻松的迁移</strong><br>由于Docker确保了运行环境的一致性，使得应用迁移更加容易。<br><strong>（6）更轻松的维护和扩展</strong><br>Docker使用的<code>分层存储以及镜像技术</code>，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易.</p></blockquote><h2 id="docker相关的基础概念"><a class="markdownIt-Anchor" href="#docker相关的基础概念"></a> Docker相关的基础概念</h2><h3 id="docker-image"><a class="markdownIt-Anchor" href="#docker-image"></a> Docker Image</h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。<code>Docker镜像（Image）</code>就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的<code>程序、库、资源、配置等文件</code>外，还包含一些为运行时准备的<code>配置参数</code>（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。</p><h3 id="分层存储"><a class="markdownIt-Anchor" href="#分层存储"></a> 分层存储</h3><blockquote><p>因为传统镜像包含操作系统<code>完整的root文件系统</code>，其体积往往庞大。因此在Docker设计时，就充分利用<code>Union FS</code>技术，将其设计为<code>分层存储</code>的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。</p></blockquote><p>镜像构建时，会<code>一层层构建</code>，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，<code>任何额外的东西应在该层构建结束前清理结束</code>。<br>分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。</p><h3 id="docker-container"><a class="markdownIt-Anchor" href="#docker-container"></a> Docker Container</h3><p><code>镜像（Image）</code>是静态定义，<code>容器（Container）</code>是镜像运行时的实体。容器可以被创建、启动、停止等。<br>容器的实质是<code>进程</code>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。<br>容器也是<code>分层存储</code>的，每个容器运行时<code>以镜像为基础层</code>，在其上创建一个当前容器的<code>存储层</code>，我们可以称这个为容器运行时读写而准备的存储层为<code>容器存储层</code>。<br>容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。</p><blockquote><p>按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。</p></blockquote><h3 id="docker-registry"><a class="markdownIt-Anchor" href="#docker-registry"></a> Docker Registry</h3><p>镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即<code>Docker Registry</code>。<br>一个<code>Docker Registry</code>包含多个<code>仓库（Repository）</code>；每个仓库包含多个标签<code>Tag</code>；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>来获取指定版本的镜像，如果不给出标签，就将以<code>latest</code>为默认标签。<br><code>Docker Registry公开服务</code>是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的<code>Docker Hub</code>。<br>除了公开服务外，用户还可以在本地搭建<code>私有的Docker Registry</code>。Docker官方提供<code>Docker Registry</code>镜像，可以直接使用作为私有Registry服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker简介&quot;&gt;&lt;/a&gt; Docker简介&lt;/h2&gt;
&lt;h3 id=&quot;docker的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#do
      
    
    </summary>
    
      <category term="容器" scheme="http://yov.oschina.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Docker" scheme="http://yov.oschina.io/tags/Docker/"/>
    
  </entry>
  
</feed>
