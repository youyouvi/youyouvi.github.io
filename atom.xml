<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember</title>
  
  <subtitle>一切有为法,如梦幻泡影。如露亦如电,应作如是观。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yov.oschina.io/"/>
  <updated>2017-12-31T07:45:02.468Z</updated>
  <id>http://yov.oschina.io/</id>
  
  <author>
    <name>子语</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go基础（一）</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/Go%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/Go基础(一)/</id>
    <published>2017-12-31T07:11:32.027Z</published>
    <updated>2017-12-31T07:45:02.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go基本语法"><a class="markdownIt-Anchor" href="#go基本语法"></a> Go基本语法</h2><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><pre class="highlight"><code class="go"><span class="comment">// 单行注释</span><span class="comment">/**/</span> 多行注释</code></pre><h3 id="go程序的一般结构"><a class="markdownIt-Anchor" href="#go程序的一般结构"></a> Go程序的一般结构</h3><p>1、Go程序是通过<code>package</code>组织的;</p><p>2、只有<code>package</code>为<code>main</code>的包才能有<code>main()</code>,即一个程序有且只有一个<code>package main</code>和一个<code>main()</code></p><pre class="highlight"><code class="go"><span class="comment">/* 多行注释 */</span><span class="comment">// 当前程序的包名,必须放在首行</span><span class="keyword">package</span> main<span class="comment">// 导入其它包</span><span class="keyword">import</span> (<span class="string">"fmt"</span><span class="comment">// 为导入的包设置别名: 别名 "包名";当别名设为"."时,可以直接调用其函数(不建议,容易混淆)</span>sys <span class="string">"os"</span>)<span class="comment">// 定义常量</span><span class="keyword">const</span> PI  = <span class="number">3.14</span><span class="comment">// 全局变量定义,可用于整个包内</span><span class="keyword">var</span> name = <span class="string">"go"</span><span class="comment">// 一般类型声明</span><span class="keyword">type</span> newType <span class="keyword">int</span><span class="comment">// 结构声明</span><span class="keyword">type</span> gopher <span class="keyword">struct</span> {}<span class="comment">// 接口声明</span><span class="keyword">type</span> golang <span class="keyword">interface</span> {}<span class="comment">// 由main作为程序的启动点</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="comment">// 导入包后必须使用,否则编译出错,调用方法: packageName.funcName</span>sys.Hostname()fmt.Println(<span class="string">"Hello "</span> + name + <span class="string">" !"</span>)}</code></pre><p>3、导入多个包时可以简写,声明多个常量、全局变量或一般类型（非接口、非结构）时也可以简写</p><pre class="highlight"><code class="go"><span class="comment">// 常量定义</span><span class="keyword">const</span> (PI = <span class="number">3.14</span>const1 = <span class="string">"1"</span>const2 = <span class="number">2</span>)<span class="comment">// 全局变量的声明与赋值,var组只能用于声明全局变量,函数内部是不可以使用的</span><span class="keyword">var</span> (name = <span class="string">"go"</span>name1 = <span class="string">"1"</span>name2 = <span class="number">2</span>)<span class="comment">// 一般类型声明</span><span class="keyword">type</span> (newType <span class="keyword">int</span>type2 <span class="keyword">float32</span>)</code></pre><h3 id="go可见性规则"><a class="markdownIt-Anchor" href="#go可见性规则"></a> Go可见性规则</h3><blockquote><p>Go中使用大小写决定常量、变量、类型、结构、接口或函数是否可以被外部包调用；</p><p>函数名首字母小写即为private，首字母大写即为public。</p></blockquote><h2 id="go数据类型"><a class="markdownIt-Anchor" href="#go数据类型"></a> Go数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">长度</th><th style="text-align:center">取值范围</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">布尔型(bool)</td><td style="text-align:center">1字节</td><td style="text-align:center">true,false</td><td style="text-align:center">不可用数字代表true或false</td></tr><tr><td style="text-align:center">整型(int/uint)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">根据运行平台可能为32或64位</td></tr><tr><td style="text-align:center">8位整型(int8/uint8)</td><td style="text-align:center">1字节</td><td style="text-align:center">-128<sub>127/0</sub>255</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节型(byte)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">uint8别名,即用法与uint8一样</td></tr><tr><td style="text-align:center">16位整型(int16/uint16)</td><td style="text-align:center">2字节</td><td style="text-align:center">-32768<sub>32787/0</sub>65535</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">32位整型(int32/uint32)</td><td style="text-align:center">4字节</td><td style="text-align:center"></td><td style="text-align:center">rune是int32别名</td></tr><tr><td style="text-align:center">64位整型(int64/uint64)</td><td style="text-align:center">8字节</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">浮点型(float32/float64)</td><td style="text-align:center">4/8字节</td><td style="text-align:center">精确到7/15小数位</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">复数(complex64/complex128)</td><td style="text-align:center">8/16字节</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">uintptr</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">足够保存指针的32位或64位整数型(根据运行平台决定位数)</td></tr><tr><td style="text-align:center">其他类型</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">array struct（结构） string</td></tr><tr><td style="text-align:center">引用类型</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">slice（切片） map chan（通道）</td></tr><tr><td style="text-align:center">接口类型(interface)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">函数类型(func)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="数据类型的零值"><a class="markdownIt-Anchor" href="#数据类型的零值"></a> 数据类型的零值</h3><p>零值不等于空值，而是变量被声明为某种数据类型后的默认值：一般值类型的默认值为0，bool为false，string为空字符串。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"fmt"</span><span class="string">"math"</span>)<span class="comment">// 为数据类型设置别名</span><span class="keyword">type</span> (文本 <span class="keyword">string</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="keyword">var</span>  a <span class="keyword">int</span><span class="comment">// 获取数据类型默认值</span>fmt.Println(a)<span class="comment">// 获取数据类型最大值</span>fmt.Println(math.MaxInt8)<span class="keyword">var</span> b 文本b = <span class="string">"中文类型名"</span>fmt.Println(b)}</code></pre><h3 id="单个变量的声明与赋值"><a class="markdownIt-Anchor" href="#单个变量的声明与赋值"></a> 单个变量的声明与赋值</h3><p>变量的声明格式: <code>var value_name value_type</code></p><p>变量的赋值格式: <code>value_name = 表达式</code></p><p>声明的同时赋值: <code>var value_name [value_type] = 表达式 (多用于全局变量)</code></p><p>变量的简短声明: <code>value_name := value （多用于局部变量）</code></p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="keyword">var</span> v1 <span class="keyword">int</span>v1 = <span class="number">1</span><span class="comment">// 可省略数据类型,由系统自动根据赋值进行判断</span><span class="keyword">var</span> v2 = <span class="number">1</span><span class="comment">// 赋值简短方式,省略var和类型 value_name := value</span>v3 := <span class="number">1</span>fmt.Println(v1)fmt.Println(v2)fmt.Println(v3)}</code></pre><h3 id="多个变量的声明与赋值"><a class="markdownIt-Anchor" href="#多个变量的声明与赋值"></a> 多个变量的声明与赋值</h3><p>1、全局变量的声明可以使用<code>var()</code>方式</p><p>2、简写全局变量的声明不可以省略<code>var</code>,但可使用并行方式</p><p>3、所有变量都可以使用类型推断</p><p>4、局部变量不能使用<code>var()</code>方式简写，只能使用并行方式</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="keyword">var</span> (<span class="comment">// 常规方式</span>aaa = <span class="string">"hello"</span><span class="comment">// 并行方式</span>sss, bbb = <span class="number">1</span>, <span class="number">2</span><span class="comment">// ccc := 3 不可省略var,因此该方式无法使用</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="comment">// 多个变量声明</span><span class="keyword">var</span> a, b, c, d <span class="keyword">int</span><span class="comment">// 多个变量赋值</span>a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span><span class="comment">// 多个变量声明的同时赋值</span><span class="keyword">var</span> e, f, g <span class="keyword">int</span> = <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span><span class="comment">// 省略变量类型,由系统推断</span><span class="keyword">var</span> i, j, k  = <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>l, m, n := <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>fmt.Println(a,b,c,d,e,f,g,i,j,k,l,m,n)}</code></pre><h3 id="变量的类型转换"><a class="markdownIt-Anchor" href="#变量的类型转换"></a> 变量的类型转换</h3><p>1、go中不存在隐式转换,所有类型转换必须显式声明</p><p>2、转换只能发生在两种相互兼容的类型之间</p><p>3、类型转换的格式: <code>valueA = valueA_type(valueB)</code></p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="comment">// 相互兼容的两种类型进行转换</span><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.1</span>b := <span class="keyword">int</span>(a)<span class="comment">// 不兼容的类型无法转换</span><span class="keyword">var</span> c <span class="keyword">bool</span> = <span class="literal">true</span>d := <span class="keyword">int</span>(c)fmt.Println(b)fmt.Println(d)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go基本语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go基本语法&quot;&gt;&lt;/a&gt; Go基本语法&lt;/h2&gt;
&lt;h3 id=&quot;注释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#注释&quot;&gt;&lt;/a&gt; 注释&lt;/h3
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Node.js安装及环境配置</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Tool/Node.js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <id>http://yov.oschina.io/article/工具/Tool/Node.js安装说明/</id>
    <published>2017-12-31T05:33:25.278Z</published>
    <updated>2017-12-31T07:05:59.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常好。</p></blockquote><h2 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h2><p>1.系统：Window10 Pro（64位）</p><p>2.Node.js：v6.11.3LTS（64位）</p><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><h3 id="下载nodejs"><a class="markdownIt-Anchor" href="#下载nodejs"></a> 下载Node.js</h3><p>打开<a href="https://nodejs.org/en/download/">Node.js官网</a>下载安装包<img src="/article/工具/Tool/Node.js安装说明/install.png" alt="无法加载" title="安装页面"></p><h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装Node.js</h3><p><img src="/article/工具/Tool/Node.js安装说明/install1.png" alt="无法加载" title="安装页面"></p><p><img src="/article/工具/Tool/Node.js安装说明/install2.png" alt="无法加载" title="安装页面"></p><p>安装目录可修改,默认为C盘:</p><p><img src="/article/工具/Tool/Node.js安装说明/install3.png" alt="无法加载" title="安装页面"></p><p><img src="/article/工具/Tool/Node.js安装说明/install4.png" alt="无法加载" title="安装页面"></p><p>安装成功:</p><p><img src="/article/工具/Tool/Node.js安装说明/success.png" alt="无法加载" title="安装成功"></p><p>安装成功则可以查看node.js版本以及npm版本:</p><p><img src="/article/工具/Tool/Node.js安装说明/version.png" alt="无法加载" title="安装成功"></p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><blockquote><p>此处配置的是npm安装的全局模块锁在路径，以及缓存cache的路径。进行该项配置是当执行<code>npm install xxxx -g</code>时，会默认安装到<code>C:\User\用户名\npm</code>路径下，占据C盘空间。</p></blockquote><h3 id="修改全局模块安装路径和缓存路径"><a class="markdownIt-Anchor" href="#修改全局模块安装路径和缓存路径"></a> 修改全局模块安装路径和缓存路径</h3><p>在node.js的安装文件中新建<code>node_cache</code>和<code>node_global</code>，在<code>node_global</code>下新建<code>node_modules</code>文件夹。随后使用cmd命令进行配置：</p><pre class="highlight"><code class="shell">npm config set prefix "D:\Program Files\nodejs\node_global"npm config set cace "D:\Program Files\nodejs\node_cache"</code></pre><h3 id="设置环境变量"><a class="markdownIt-Anchor" href="#设置环境变量"></a> 设置环境变量</h3><p>“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”</p><p>在系统变量(S)中新建<code>NODE_PATH</code>，变量值为<code>D:\Program Files\nodejs\node_global\node_modules</code>;</p><p>修改用户变量(U)中的<code>PATH</code>将<code>C:\User\用户名\npm</code>改为<code>D:\Program Files\nodejs\node_global</code></p><p>测试环境变量修改成功，使用cmd命令进行安装</p><pre class="highlight"><code class="shell">npm install express -g # -g 全局安装D:\Program Files\nodejs\node_global`-- express@4.16.2  +-- accepts@1.3.4  | +-- mime-types@2.1.17  | | `-- mime-db@1.30.0  | `-- negotiator@0.6.1  +-- array-flatten@1.1.1  +-- body-parser@1.18.2  | +-- bytes@3.0.0  | +-- http-errors@1.6.2  | | +-- inherits@2.0.3  | | `-- setprototypeof@1.0.3  | +-- iconv-lite@0.4.19  | `-- raw-body@2.3.2  +-- content-disposition@0.5.2  +-- content-type@1.0.4  +-- cookie@0.3.1  +-- cookie-signature@1.0.6  +-- debug@2.6.9  | `-- ms@2.0.0  +-- depd@1.1.1  +-- encodeurl@1.0.1  +-- escape-html@1.0.3  +-- etag@1.8.1  +-- finalhandler@1.1.0  | `-- unpipe@1.0.0  +-- fresh@0.5.2  +-- merge-descriptors@1.0.1  +-- methods@1.1.2  +-- on-finished@2.3.0  | `-- ee-first@1.1.1  +-- parseurl@1.3.2  +-- path-to-regexp@0.1.7  +-- proxy-addr@2.0.2  | +-- forwarded@0.1.2  | `-- ipaddr.js@1.5.2  +-- qs@6.5.1  +-- range-parser@1.2.0  +-- safe-buffer@5.1.1  +-- send@0.16.1  | +-- destroy@1.0.4  | `-- mime@1.4.1  +-- serve-static@1.13.1  +-- setprototypeof@1.1.0  +-- statuses@1.3.1  +-- type-is@1.6.15  | `-- media-typer@0.3.0  +-- utils-merge@1.0.1  `-- vary@1.1.2</code></pre><p>安装时不加<code>-g</code>参数则会默认安装在路径下。</p><h3 id="配置nodejs源"><a class="markdownIt-Anchor" href="#配置nodejs源"></a> 配置Node.js源</h3><p>node.js安装速度缓慢,因此需要更换npm的源,打开cmd使用如下命令:</p><pre class="highlight"><code class="shell">npm config set registry http://registry.npm.taobao.org/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Ja
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Node.js" scheme="http://yov.oschina.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Java中的小问题（不断更新中）</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98(%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java中的小问题(不断更新中)/</id>
    <published>2017-12-23T10:47:05.360Z</published>
    <updated>2017-12-24T08:49:08.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1、使用private声明main()会怎样?<br>A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。</p></blockquote><blockquote><p>2、Java中传引用和传值的区别是什么？<br>A：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。</p></blockquote><blockquote><p>3、如果要重写一个对象的equals()，还要考虑什么？<br>A：hashCode。</p></blockquote><blockquote><p>*4、Java的”一次编写，处处运行”是如何实现的？<br>A：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。</p></blockquote><blockquote><p>*5、public static void main(String args[])这段声明里每个关键字的作用<br>A：<code>public</code>: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见,所以可见性设置为pulic.<br><code>static</code>: Java平台调用这个方法时不会创建这个类的实例对象，因此这个方法必须声明为static。<br><code>void</code>: main方法没有返回值。<br><code>String</code>是命令行传进参数的类型，<code>args</code>是指命令行传进的字符串数组。</p></blockquote><blockquote><p>*6、<code>==</code>与equals()的区别<br>A：<code>==</code>比较两个对象在内存里是不是同一个对象，即内存地址是否一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .<code>==</code>比较的是引用<br>而equals()比较的是内容。<code>public boolean equals(Object obj)</code>这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,此时和==是等价的。String, BitSet, Date, 和File都对equals()进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。</p></blockquote><pre class="highlight"><code class="">public class EqualsTest {   public static void main(String[] args) {      Strings1 = &quot;abc&quot;;      Strings2 = s1;      Strings5 = &quot;abc&quot;;      Strings3 = newString(&quot;abc&quot;);      Strings4 = newString(&quot;abc&quot;);      System.out.println(&quot; == comparison:&quot; + (s1 == s5));      System.out.println(&quot; == comparison:&quot; + (s1 == s2));      System.out.println(&quot;Using equals method:&quot; + s1.equals(s2));      System.out.println(&quot; == comparison:&quot; + s3 == s4);      System.out.println(&quot;Using equals method : &quot; + s3.equals(s4));   }}</code></pre><p>结果：</p><pre class="highlight"><code class="">==comparison:true==comparison:trueUsingequals method:truefalseUsingequals method:true</code></pre><blockquote><p>7 main()去掉static修饰符会怎样？<br>A：报错，main 方法不是类 com.java.demo.Demo 中的static</p></blockquote><blockquote><p>8、为什么oracle type4驱动被称作瘦驱动？<br>A：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的,可以在运行时由浏览器下载,不依赖任何客户端的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。</p></blockquote><blockquote><p>9、final,finally,finalize()<br>A：<code>final</code>: 常量声明。 <code>finally</code>: 处理异常。 <code>finalize()</code>: 帮助进行垃圾回收。<br>接口里声明的变量默认是final的。final类无法继承,也就是没有子类。这么做是出于基本类型的安全考虑，比如String和Integer,这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。<br>finalize()在对象被销毁和回收前会被调用。<br>finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如,关闭连接通常放到finally块中完成。</p></blockquote><blockquote><p>10、什么是Java API？<br>A：Java API是大量软件组件的集合,它们提供了大量有用的功能,比如GUI组件。</p></blockquote><blockquote><p>11、GregorianCalendar类是什么东西？<br>A：GregorianCalendar提供了西方传统日历的支持。</p></blockquote><blockquote><p>12、ResourceBundle类是什么?<br>A：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。</p></blockquote><blockquote><p>13、为什么Java里没有全局变量?<br>A：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。</p></blockquote><blockquote><p>14、如何将String类型转化成Number类型？<br>A：Integer类的valueOf方法可以将String转成Number。下面是代码示例：</p></blockquote><pre class="highlight"><code class="">String numString = &quot;1000&quot;;int id = Integer.valueOf(numString).intValue();</code></pre><blockquote><p>15、SimpleTimeZone类是什么?<br>A：SimpleTimeZone提供公历日期支持。</p></blockquote><blockquote><p>16、while循环和do循环有什么不同？<br>A：while结构在循环的开始判断下一个迭代是否应该继续。<br>do/while结构在循环的结尾来判断是否将继续下一轮迭代,do结构至少会执行一次循环体。</p></blockquote><blockquote><p>17、Locale类是什么？<br>A：Locale类用来根据语言环境来动态调整程序的输出。</p></blockquote><blockquote><p>*18、面向对象编程的原则是什么?<br>A：多态,继承和封装。</p></blockquote><blockquote><p>19、简述继承性<br>A：继承使得一个类可以获取另一个类的属性和方法。使用继承可以让已经测试完备的功能得以复用,并且可以一次修改,所有继承的地方都同时生效。</p></blockquote><blockquote><p>20、什么是隐式的类型转化?<br>A：隐式的类型转化就是直接将一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。<br>代码示例：</p></blockquote><pre class="highlight"><code class="">int i = 1000;long j = i;//Implicit casting</code></pre><blockquote><p>21、sizeof是Java的关键字吗?<br>A：不是。</p></blockquote><blockquote><p>22、native方法是什么?<br>A：native方法是非Java代码实现的方法。</p></blockquote><blockquote><p>23、在System.out.println()里面,System, out, println分别是什么?<br>A：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。</p></blockquote><blockquote><p>24、多态是什么？<br>A：简单来说,多态是指一个名字多种实现,多态使得一个实体通过一个通用的方式来实现不同的操作,具体的操作是由实际的实现来决定的。<br>多态在Java里有三种表现方式：方法重载通过继承实现方法重写通过Java接口进行方法重写。</p></blockquote><blockquote><p>25、显式的类型转化是什么?<br>A：显式的类型转化是明确告诉了编译器来进行对象的转化。<br>代码示例：</p></blockquote><pre class="highlight"><code class="">long i = 700.20;int j = (int)i;</code></pre><blockquote><p>26、什么是Java虚拟机?<br>A：Java虚拟机是能移植到不同硬件平台上的软件系统。</p></blockquote><blockquote><p>27、类型向下转换是什么?<br>A：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。</p></blockquote><blockquote><p>28、Java的访问修饰符是什么?<br>A：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：<br>public: 所有类都可以访问<br>protected: 同一个包内以及所有子类都可以访问<br>private: 只有归属的类才能访问默认: 归属类及相同包下的子类可以访问</p></blockquote><blockquote><p>29、所有类的父类是什么？<br>A：Object.</p></blockquote><blockquote><p>30、Java的基本类型有哪些?<br>A：byte,char, short, int, long, float, double, boolean。</p></blockquote><blockquote><p>31、静态类型有什么特点?<br>A：static定义的变量与类绑定,即每个实例对象都共享同一个静态变量。不论有多少个实例对象,静态变量只有一个。static定义的变量通常使用类名访问,当程序运行时,这个变量就会被创建直到程序结束才会被销毁。静态变量的作用域与普通变量一致,初始值也是一致的。变量没被初始化时根据其数据类型会有一个默认值。<br>static定义的方法属于类,而不是类对象,其调用不作用于类对象,也不需要创建类实例.静态方法本身就带有final,因为重写只会发生在类实例上，即只要原方法没声明为final,非静态方法就不能重写静态方法。父类的静态方法会被子类的静态方法屏蔽，但你不能在子类把父类的静态方法改为实例方法。</p></blockquote><blockquote><p>32、&amp;操作符和&amp;&amp;操作符有什么区别?<br>A：当一个<code>&amp;</code>表达式在求值的时候，两个操作数都会被求值。<br>当一个<code>&amp;&amp;</code>表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。</p></blockquote><blockquote><p>33、Java是如何处理整型的溢出和下溢的?<br>A：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。</p></blockquote><blockquote><p>34、public static void写成static public void会怎样？<br>A：程序正常编译及运行.</p></blockquote><blockquote><p>35、声明变量和定义变量有什么不同？<br>答案：声明变量只提供变量的类型和名字,并没有进行初始化。<br>定义包括声明和初始化两个阶段：<code>String s;</code>只是变量声明,<code>String s = new String(&quot;bob&quot;);</code>或者<code>String s = &quot;bob&quot;;</code>是变量定义。</p></blockquote><blockquote><p>36、Java支持哪种参数传递类型?<br>A：Java参数都是进行传值.对于对象而言,传递的值是对象的引用,也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。</p></blockquote><blockquote><p>37、对象封装的原则是什么?<br>A：封装是将数据及操作数据的代码绑定到一个独立的单元,这样保障了数据的安全,防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。</p></blockquote><blockquote><p>38、你怎么理解变量？<br>A：变量是一块命名的内存区域,以便程序进行访问。变量用来存储数据,随着程序的执行,存储的数据也可能跟着改变。</p></blockquote><blockquote><p>39、数值提升是什么?<br>A：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中,byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。</p></blockquote><blockquote><p>40、Java的类型转化是什么?<br>A：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的类型转换，一个是隐式的。</p></blockquote><blockquote><p>41、main()方法的参数里面,字符串数组的第一个参数是什么?<br>A：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。</p></blockquote><blockquote><p>42、怎么判断数组是null还是为空?<br>A：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。</p></blockquote><blockquote><p>43、程序中可以允许多个类同时拥有都有main方法吗?<br>A：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。</p></blockquote><blockquote><p>44、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？<br>A：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。</p></blockquote><blockquote><p>45、一个类能拥有多个main方法吗？<br>A：可以，但只能有一个main方法拥有以下签名：<br>public static void main(String[] args) {}<br>否则程序将无法通过编译。编译器会警告你main方法已经存在。</p></blockquote><blockquote><p>46、简述JVM是如何工作的?<br>A：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。</p></blockquote><blockquote><p>47、如何原地交换两个变量的值？<br>A：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：</p></blockquote><pre class="highlight"><code class="">int a = 5, b = 10; a = a + b; b = a - b; a = a - b;</code></pre><p>使用异或操作也可以交换。第一个方法还可能会引起溢出。异或的方法如下：</p><pre class="highlight"><code class="">int a = 5;int b = 10;a=a^b;b=a^b;a=a^b;</code></pre><blockquote><p>48、什么是数据的封装?<br>A：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。</p></blockquote><blockquote><p>49、什么是反射API？它是如何实现的？<br>A：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。</p></blockquote><blockquote><p>50、JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？<br>A：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。</p></blockquote><blockquote><p>51、虚拟内存是什么?<br>A：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。</p></blockquote><blockquote><p>52、方法可以同时即是static又是synchronized的吗?<br>A：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于：</p></blockquote><pre class="highlight"><code class="">synchronized(XYZ.class){}</code></pre><blockquote><p>53、String和StringTokenizer的区别是什么？<br>A：StringTokenizer是一个用来分割字符串的工具类。</p></blockquote><pre class="highlight"><code class="">String Tokenizerst = new StringTokenizer(&quot;Hello World&quot;);while(st.hasMoreTokens()){   System.out.println(st.nextToken());}输出：HelloWorld</code></pre><blockquote><p>54、transient变量有什么特点?<br>A：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p></blockquote><blockquote><p>55、哪些容器使用Border布局作为它们的默认布局?<br>A：Window, Frame, Dialog。</p></blockquote><blockquote><p>56、什么是同步?<br>A：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。<br>对方法进行同步：</p></blockquote><pre class="highlight"><code class="">public synchronized void Method1(){    // Appropriate method-related code.}</code></pre><p>在方法内部对代码块进行同步：</p><pre class="highlight"><code class="">public myFunction() {   synchronized(this){     // Synchronized code here.   }}</code></pre><blockquote><p>57、问题：给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？<br>A：</p></blockquote><pre class="highlight"><code class="">public class Test{  public static void main(String[] args) {     //给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？     int a = 8;     //打印二进制     System.out.println(Integer.toBinaryString(a));   //输出  1000     System.out.println(Integer.toBinaryString(a|4)); //输出 1100  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;1、使用private声明main()会怎样?&lt;br&gt;
A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(四)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E5%9B%9B)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(四)/</id>
    <published>2017-12-23T08:17:41.083Z</published>
    <updated>2017-12-23T10:03:08.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java多线程实现"><a class="markdownIt-Anchor" href="#java多线程实现"></a> Java多线程实现</h2><p>Java可通过以下两种方式实现多线程：</p><blockquote><p>· 继承Thread类；<br>· 实现Runnable接口（此外扩充了Callable接口）</p></blockquote><h3 id="线程与进程"><a class="markdownIt-Anchor" href="#线程与进程"></a> 线程与进程</h3><p>Java支持多线程。<br>1、进程指的是一次程序的完整运行，在运行过程中内存、处理器、IO等资源都是为该进程服务。<br>DOS系统时代，有一种现象：假如病毒运行，那电脑就无法运行，因为所有资源都被病毒占用。但在windows时代，即使病毒在运行，电脑也可以运行。<br>这是因为windows系统是多进程操作系统。其资源分配方法是：在同一时间段，多进程轮流抢占资源，但在某时间点，只会有一个进程在运行<br>2、线程是在进程基础上进一步地划分的结果：即一个进程可以同时创建多个线程。线程是比进程更快的处理单元，而且所占的资源更小。多线程的应用也是性能最高的应用。</p><h3 id="thread类实现多线程"><a class="markdownIt-Anchor" href="#thread类实现多线程"></a> Thread类实现多线程</h3><p>1、<code>Thread类</code>是一个支持多线程的功能类，只要是其子类，就可以实现多线程。<br><code>class MyThread extends Thread { // 多线程操作类}</code><br>程序的起点是<code>main()</code>。而每个线程也有它的起点<code>run()</code>。多线程类必须覆写Thread类的<code>run()</code>：<code>public void run(){}</code>，该方法没有返回值，表示线程一旦开始，就需要一直运行，不能返回内容。</p><pre class="highlight"><code class="">// 线程操作主类class MyThread extends Thread {     private String name;    public MyThread(String name) {        this.name = name;    }    @Override    public void run() { // 覆写run(),作为线程的主体操作方法        for (int x = 0; x &lt; 200; x++) {            System.out.println(this.name + &quot;--&gt;&quot; + x);        }    }}public class Demo {    public static void main(String[] args) {        MyThread mA = new MyThread(&quot;线程A&quot;);        MyThread mB = new MyThread(&quot;线程B&quot;);        MyThread mC = new MyThread(&quot;线程C&quot;);        mA.run();        mB.run();        mC.run();    }}</code></pre><p>运行上述代码，输出结果是线程A、B、C依次进行循环输出。<br>2、线程与进程是一样的，都必须轮流去抢占资源，多线程的执行应该是多个线程彼此交替执行。但直接调用run()并不能启用多线程，多线程启用依靠的是Thread类的start()：<code>public void start()</code>（调用此方法，执行的方法体是run()定义的）。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread(&quot;线程A&quot;);        MyThread mtB = new MyThread(&quot;线程B&quot;);        MyThread mtC = new MyThread(&quot;线程C&quot;);        mtA.start();        mtB.start();        mtC.start();    }}</code></pre><p>上述代码结果中每个线程对象交替执行。</p><blockquote><p>问题：为什么多线程启用不是调用run()而是调用start()？<br>打开Java的源代码，观察start()的定义</p></blockquote><pre class="highlight"><code class="">public synchronized void start() {    if (threadStatus != 0)        throw new IllegalThreadStateException();    group.add(this);    boolean started = false;    try {        start0();        started = true;    } finally {        try {            if (!started) {                group.threadStartFailed(this);            }        } catch (Throwable ignore) {        }    }}private native void start0();</code></pre><p>start()利用throw抛出<code>IllegalThreadStateException</code>，本应使用<code>try…catch</code>处理，或者start()上使用<code>throws</code>声明，但此处没有这样处理，这是因为该异常是<code>RuntimeException</code>的子类，属于选择性处理。如果某一个线程重复启动，就会抛出异常。<br><code>start()</code>要调用<code>start0()</code>，而且该方法结构与抽象方法类似，唯一不同的是使用<code>native</code>声明。Java中有一个<code>JNI</code>技术（Java Native Interface），其特点是：使用Java调用本机操作系统提供的函数。其缺点：不能离开特定的操作系统。<br>如果线程要执行，需要操作系统进行资源分配，所以此操作是由JVM根据不同的操作系统实现的。即：使用Thread类的start()不仅仅要启动多线程的执行代码，还要根据不同的操作系统进行资源的分配。</p><h3 id="runnable接口实现多线程"><a class="markdownIt-Anchor" href="#runnable接口实现多线程"></a> Runnable接口实现多线程</h3><p>1、虽然Thread类可以实现多线程。但存在问题：Java存在单继承限制。任何情况下，对于类的单继承都是应该尽量回避的，多线程也一样。为了解决单继承的限制，在Java中专门提供了Runnable接口，此接口定义如下：</p><pre class="highlight"><code class="">@FunctionalInterfacepublic interface Runnable{    public void run();}</code></pre><p>接口中都是public权限，不存在default权限。那么只需要让一个类实现Runnable接扣，并覆写run()方法即可。</p><pre class="highlight"><code class="">class MyThread implements Runnable {    private String name;    public MyThread(String name) {        this.name = name;    }    @Override    public void run() {        for (int x = 0; x &lt; 10; x++) {            System.out.println(this.name + &quot;--&gt;&quot; + x);        }    }}</code></pre><p>与继承Thread类相比，此时MyThread类在结构上并没有区别，但存在一个不同：继承Thread类，可以直接继承start()，但是实现Runnable接口，并没有start()。<br>2、要想启用多线程，一定依靠Thread类完成，在Thread类定义有如下构造方法：<br><code>public Thread（Runnable target）</code>，接收的是Runable接口对象；<br>范例：启动多线程</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread(&quot;线程A&quot;);        MyThread mtB = new MyThread(&quot;线程B&quot;);        MyThread mtC = new MyThread(&quot;线程C&quot;);        new Thread(mtA).start();        new Thread(mtB).start();        new Thread(mtC).start();    }}</code></pre><p>此时就避免了单继承局限，所以实际开发中使用接口是最合适的。</p><h3 id="两种实现方式的区别"><a class="markdownIt-Anchor" href="#两种实现方式的区别"></a> 两种实现方式的区别</h3><p>Runnable接口与Thread类相比，解决了单继承的局限，所以如果要使用，一定使用Runnable接口。<br>1、观察Thread类的定义<br><code>public class Thread extends Object implements Runnable</code><br>Thread类实现了Runnable接口。<br><img src="/article/Java/Java/Java知识(四)/31-1.png" alt="无法加载" title="结构分析"><br>2、除了以上的联系外，还有一点：使用Runnable接口可以比Thread类更好地描述出数据共享这一概念。此时的数据共享指的是多个线程访问同一资源的操作。<br>范例：观察代码（每一个线程对象都必须通过start()启动）</p><pre class="highlight"><code class="">class MyThread extends Thread {    private int ticket = 10;    @Override    public void run() {        for (int x = 0; x &lt; 100; x++) {            if (this.ticket &gt; 0) {                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);            }        }    }}public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread();        MyThread mtB = new MyThread();        MyThread mtC = new MyThread();        mtA.start();        mtB.start();        mtC.start();    }}</code></pre><p>上述代码声明了三个MyThread对象，并且分别调用start()方法，启动线程，发现每个线程都在卖各自的十张票，此时的内存关系如下：<br><img src="/article/Java/Java/Java知识(四)/31-2.png" alt="无法加载" title="内存分析"><br>此时并不存在数据共享。<br>范例：利用Runnable实现</p><pre class="highlight"><code class="">class MyThread implements Runnable {    private int ticket = 10;    @Override    public void run() {        for (int x = 0; x &lt; 100; x++) {            if (this.ticket &gt; 0) {                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);            }        }    }}public class Demo {    public static void main(String[] args) { // 主类        MyThread mt = new MyThread();        new Thread(mt).start();        new Thread(mt).start();        new Thread(mt).start();    }}</code></pre><p>上述代码的内存分析如下：<br><img src="/article/Java/Java/Java知识(四)/31-3.png" alt="无法加载" title="内存年分析"><br>此时也属于三个线程对象，唯一的区别是，这三个线程对象都直接占用了同一个MyThread类对象引用，即这三个线程对象都直接访问同一个数据资源。</p><blockquote><p>请解释Thread与Runnable实现多线程的区别？（请解释多线程两种实现方式的区别？）<br>1、Thread类是Runnable接口的子类，使用Runnable接口多线程可以避免单继承局限；<br>2、Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚地描述数据共享的概念；</p></blockquote><h3 id="callable接口实现多继承"><a class="markdownIt-Anchor" href="#callable接口实现多继承"></a> Callable接口实现多继承</h3><p>1、使用Runnable实现多线程可以避免单继承局限，但是Runnable中的run()不能返回操作结果。为了解该问题，Java提供了一个新的接口<code>java.util.concurrent.Callable</code>。</p><pre class="highlight"><code class="java"><span class="meta">@FunctionalInterface</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>{    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;}</code></pre><p>call()执行完线程的主体功能之后可以返回一个结果，而返回类型由Callable的泛型决定。<br>范例：定义一个线程主体类</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) {            <span class="keyword">if</span> (<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) {                System.out.println(<span class="string">"卖票，ticket = "</span> + <span class="keyword">this</span>.ticket--);            }        }        <span class="keyword">return</span> <span class="string">"票已经卖光"</span>;    }}</code></pre><p>此时发现Thread类中没有接收Callable对象的应用。但从JDK1.5开始增加<code>java.util.concurrent.FutureTask&lt;V&gt;</code>类，这个类主要负责Callable接口对象的操作。这个类的结构：<br><code>public class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt;</code><br>而上述的<code>RunnableFuture</code>结构如下：<br><code>public interface RunnableFuture&lt;V&gt; extends Runnable,Future&lt;V&gt;</code><br>在FutureTask类中定义有构造方法：<code>public FutureTask(Callable&lt;V&gt; callable)</code>，接收的是call()的返回值。<br>范例：启动多线程</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {             MyThread mtA = new MyThread();        MyThread mtB = new MyThread();        FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mtA);        FutureTask&lt;String&gt; taskB = new FutureTask&lt;String&gt;(mtB);        // 目的是取得call()的返回值        // FutureTask是Runnable接口的子类，所以可以使用Thread的构造接收        new Thread(taskA).start(); // 启动多线程        new Thread(taskB).start();        // 多线程执行完毕后，可以通过FutureTask的父接口Future中的get()方法取得返回内容        System.out.println(&quot;A线程的返回结果:&quot; + taskA.get());        System.out.println(&quot;B线程的返回结果:&quot; + taskB.get());    }}</code></pre><p>上述代码最麻烦的地方在于需要接收返回值，并且又要与原始的多线程实现靠拢（向Thread类靠拢）。</p><h2 id="多线程常用操作方法"><a class="markdownIt-Anchor" href="#多线程常用操作方法"></a> 多线程常用操作方法</h2><p>多线程有许多方法，但大部分方法都定义在Thread类中，本章只介绍几种开发常用方法。</p><h3 id="线程命名和获取线程"><a class="markdownIt-Anchor" href="#线程命名和获取线程"></a> 线程命名和获取线程</h3><p>1、线程的每次运行结果都不同，因为其会根据实际情况进行资源抢占。因此要区分每个线程，必须依靠线程名。线程名一般是在其启动前定义。不建议更改已经启动的线程名或为不同线程设置相同的名字。</p><p>2.、对线程进行命名，可以利用Thread类的如下方法：</p><blockquote><ol><li>构造方法：<code>public Thread(Runnable target, String name);</code></li></ol><p>2）设置名字：<code>public final void setName(String name);</code></p><p>3）取得名字：<code>public final String getName();</code></p></blockquote><p><code>Runable</code>子类没有继承<code>Thread</code>类，要想获取线程名即获取当前执行方法的线程名需要利用Thread类中提供的取得当前线程对象的方法:<code>public static Thread currentThread()</code>；</p><p>**范例：**不设置线程名</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        System.out.println(Thread.currentThread().getName());    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-1</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-2</span>    }}</code></pre><p>实例化<code>Thread</code>类对象时，如果没有为其设置名字，会自动进行编号命名<code>Thread-x</code>，来保证线程名字不重复。</p><p>**范例：**设置线程名</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        System.out.println(Thread.currentThread().getName());    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>        <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>).start(); <span class="comment">// 线程B</span>    }}</code></pre><p>3、观察下述代码</p><pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>        mt.run(); <span class="comment">// 直接调用run()方法，结果为main</span>    }}</code></pre><p>上述代码说明主方法就是一个线程<code>main线程</code>，所有在主方法上创建的线程实际上都可以将其视为子线程。上述代码也说明线程一直都存在（主方法就是主线程），每当使用<code>java</code>命令去解释一个程序类时，对于操作系统而言，都相当于启动了一个进程，而main只是这进程上的一个子线程而已。</p><blockquote><p>**问题：**一个JVM进程启动时至少启动几个线程？</p><p>**答：**至少启用了2个线程</p><p>1.main线程：程序的主要执行，以及启动子线程；</p><p>2.gc线程：负责垃圾收集</p></blockquote><hr><h3 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h3><p>1、线程休眠指的是让线程的执行暂时停顿，其方法：<code>public static void sleep(longmillis) throws InterruptedException</code></p><p>**范例：**观察休眠特点</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10000</span>; x++) {            <span class="keyword">try</span> {                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让其休眠1秒</span>            } <span class="keyword">catch</span> (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);        }}}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start();    }}</code></pre><p>由于每次执行<code>run()</code>都要休眠1秒，所以执行的速度变慢。一般情况下，休眠时设置多个线程对象将导致所有线程对象一起进入<code>run()</code>（所谓一起进入实际上是因为先后进入的顺序时间间隔短，肉眼忽略，但实际上不是同时进入）。</p><h3 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h3><p>1、 线程优先级越高，越有可能先被执行。在Thread类中提供有以下两个方法设置和获取优先级：</p><blockquote><p>​       · 设置优先级：<code>public final void setPriority(int new Priority)</code>；</p><p>​       · 取得优先级：<code>public final int getPriority()</code>；</p></blockquote><p>设置和取得优先级都是使用int型数据类型，对于此内容有三种取值：</p><blockquote><p>​       · 最高优先级：<code>public static final int MAX_PRIORITY；// 值为10</code></p><p>​       · 默认优先级：<code>public static final int NORM_PRIORITY；// 值为5</code></p><p>​       · 最低优先级：<code>public static final int MIN_PRIORITY。 // 值为1</code></p></blockquote><p>**范例：**优先级</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) {            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);        }    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        Thread tA = <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>);        Thread tB = <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>);        Thread tC = <span class="keyword">new</span> Thread(mt, <span class="string">"线程C"</span>);        tA.setPriority(Thread.MAX_PRIORITY);        tA.start();        tB.start();        tC.start();    }}</code></pre><p>**范例：**主线程优先级</p><pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{      <span class="comment">// 获取主线程的优先级</span>      System.out.println(Thread.currentThread().getPriority());     <span class="comment">// 5</span>    }}</code></pre><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><blockquote><p><code>Thread.currentThread()</code>可以取得当前线程类对象；</p><p><code>Thread.sleep()</code>用于线程休眠，看起来是一起休眠，实际存在时间间隔</p><p>优先级越高的线程越有可能先执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java多线程实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java多线程实现&quot;&gt;&lt;/a&gt; Java多线程实现&lt;/h2&gt;
&lt;p&gt;Java可通过以下两种方式实现多线程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;· 继承Thread类
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(三)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%89)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(三)/</id>
    <published>2017-12-20T01:31:23.603Z</published>
    <updated>2017-12-20T01:35:50.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java8特性"><a class="markdownIt-Anchor" href="#java8特性"></a> Java8特性</h2><h3 id="接口定义增强"><a class="markdownIt-Anchor" href="#接口定义增强"></a> 接口定义增强</h3><p>JDK1.8之前，接口的组成只有<code>全局变量</code>和<code>抽象方法</code>。从JDK1.8开始，接口的组成增加了。<br>假设：现有一个接口，其子类有2W个。现在发现该接口功能不足，要增加一个方法，该方法对于所有子类而言的功能是一样的（即方法体是一样的）。此时要修改每个子类的方法，要修改2W次。<br>上述问题在JDK1.8中不存在，因为其允许接口中定义普通方法，但普通方法必须使用default定义。</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法    default public void fun() { // 普通方法        System.out.println(&quot;JDK1.8&quot;);    }}class Apple implements Fruit {    @Override    public void print() {        System.out.println(&quot;苹果&quot;);    }}public class Demo {    public static void main(String[] args) {        Fruit f = new Apple();        f.fun();        f.print();    }}</code></pre><p>除了使用<code>default</code>定义方法，还可以使用<code>stati</code>c定义方法<br>范例：定义static方法</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法    default public void fun() { // 普通方法        System.out.println(&quot;JDK1.8&quot;);    }    static void get() {        System.out.println(&quot;直接由接口调用&quot;);    }}class Apple implements Fruit {    @Override    public void print() {        System.out.println(&quot;苹果&quot;);    }}public class Demo {    public static void main(String[] args) {        Fruit f = new Apple();        f.fun();        f.print();        Fruit.get();    }}</code></pre><p>JDK1.8有个新功能：内部类访问方法参数时可以不加上final关键字。<br>这些新特性，完全打破了Java已有的代码组成形式。</p><h3 id="lamda表达式"><a class="markdownIt-Anchor" href="#lamda表达式"></a> Lamda表达式</h3><p>Lamda属于函数式编程的概念，下面通过匿名内部类，来分析函数式编程的产生目的。<br>范例：匿名内部类</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        fun(new Fruit() {            @Override            public void print() {                System.out.println(&quot;水果&quot;);            }        });    }    public static void fun(Fruit fru) {        fru.print();    }}</code></pre><p>上述代码中fun()最终需要的只是输出，但是由于Java的开发结构的完整性要求，不得不在这个核心语句上嵌套更多的内容。但是该做法过于严谨复杂，在JDK1.8引入函数式编程，简化过程。<br>范例：使用Lamda表达式</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        fun(()-&gt; System.out.println(&quot;水果&quot;));    }    public static void fun(Fruit fru) {        fru.print();    }}</code></pre><p>Lamda语法有三种形式：</p><blockquote><p>·(参数)-&gt;单行语句；<br>·(参数)-&gt;｛单行语句｝；<br>·(参数)-&gt;表达式；</p></blockquote><p>范例：观察有参单行</p><pre class="highlight"><code class="">interface Fruit {    public void print(String str); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s) -&gt; System.out.println(s));    }    public static void fun(Fruit fru) {        fru.print(&quot;苹果&quot;); // 设置参数的内容    }}</code></pre><p>范例：编写多行语句</p><pre class="highlight"><code class="">interface Fruit {    public void print(String str); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s) -&gt; {            s = s.toUpperCase();            System.out.println(s);        });    }    public static void fun(Fruit fru) {        fru.print(&quot;Hello&quot;); // 设置参数的内容    }}</code></pre><p>范例：编写表达式</p><pre class="highlight"><code class="">interface Fruit {    public int add(int x, int y);}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s1, s2) -&gt; s1 + s2);    }    public static void fun(Fruit fru) {        System.out.println(fru.add(10, 20));    }}</code></pre><h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h3><p>对象引用的特点：不同对象可以操作同一块内容。而方法引用就是指为一个方法设置别名，相当于一个方法定义了不同的名字。<br>1、方法引用在Java8中一共定义了四种形式：</p><blockquote><p>· 引用静态方法： 类名称::static 方法名称;<br>· 引用某个对象的方法：实例化对象::普通方法；<br>· 引用特定类型的方法：特定类::普通方法;<br>· 引用构造方法：类名称::new。</p></blockquote><p>范例：引用静态方法<br>String类中的valueof()：<code>public static String valueof(int x)</code></p><pre class="highlight"><code class="">package com.java.demo;/** * 只有一个方法的接口 * @param &lt;P&gt; 参数的数据类型 * @param &lt;R&gt; 返回值的数据类型 */interface Math&lt;P, R&gt; {    public R exchange(P p);}public class Demo {    public static void main(String[] args) {        // 覆写了exchange(),使其具有valueOf()的功能        Math&lt;Integer, String&gt; math = String::valueOf;        String msg = math.exchange(10000);        // 将所有的0替换成9        System.out.println(msg.replaceAll(&quot;0&quot;, &quot;9&quot;));    }}</code></pre><p>范例：普通方法引用<br>String类中的toUpperCase()：<code>public String toUpperCase()</code></p><pre class="highlight"><code class="">package com.java.demo;interface Math&lt;R&gt; {    public R upper();}public class Demo {    public static void main(String[] args) {        // 覆写了upper,使其具有toUpperCase的功能        // toUpperCase是普通方法,必须由String对象调用        // hello是String对象,代码如下        Math&lt;String&gt; math = &quot;hello&quot;::toUpperCase;        String msg = math.upper();        System.out.println(msg);    }}</code></pre><p>上述例子显示，要实现方法引用，必须要有接口，且该接口只能有一个方法。为了保证该接口只有一个方法，可对其进行注解说明。</p><pre class="highlight"><code class="">@FunctionalInterface // 此为函数式接口，只能定义一个方法interface ITest&lt;R&gt; {    public R upper();}</code></pre><p>2、在进行方法引用的过程中，还有一种形式的引用（这种形式需要特定类的对象支持）。一般使用“类::方法”，引用的是类中的静态方法。但是这种形式也可以引用普通方法。<br>例如：在String类中有一个方法：<code>public int compareTo(String anotherString)</code>，比较的形式是<code>String对象1.compareTo(String对象2)</code>，即要引用该方法，需要有两个参数。<br>范例：引用特定类的方法</p><pre class="highlight"><code class="">interface IMessage&lt;P&gt; {    public int compare(P p1, P p2);}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = String::compareTo;        System.out.println(msg.compare(&quot;A&quot;, &quot;B&quot;));    }}</code></pre><p>与之前相比，方法引用前不需要定义对象，可以理解为将对象定义在参数上。<br>范例：引用构造方法</p><pre class="highlight"><code class="">interface IMessage&lt;C&gt; {    public C create(String t, double p);}class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String toString() {        return &quot;书名:&quot; + this.title + &quot;,价格：&quot; + this.price;    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;Book&gt; msg = Book::new; // 引用构造方法        // 虽然调用的是create()，实际引用了Book类的构造方法        Book book = msg.create(&quot;Java开发&quot;, 66.6);        System.out.println(book);    }}</code></pre><p>对象引用是使用不同的名字，而方法引用需要一个函数接口。</p><h3 id="内建函数式接口"><a class="markdownIt-Anchor" href="#内建函数式接口"></a> 内建函数式接口</h3><p>1、JDK1.8中提供了一个包：<code>java.util.function</code>，提供有以下四个核心接口：</p><blockquote><p>(1)功能性接口（Function）：public interface Function&lt;T,R&gt;{public R apply(T t);}<br>|- 此接口需要接收一个参数，并且返回一个处理结果；<br>(2)消费型接口（Consumer）：public interface Consumer<T>{public void accept(T t);}<br>|- 此接口只负责接收数据（引用数据是不需要返回的），并且不返回结果；<br>(3)供给型接口（Suplier）：public interface Supplier<T>{public T get();}<br>|- 此接口不接收参数，但是可以返回结果<br>(4)断言型接口（Predicate）：public interface Predicate<T>{public boolean Test(T t);}<br>|- 进行判断操作使用；</T></T></T></p></blockquote><p>在JDK1.8中存在以上四个功能型接口，所以很少会由用户去定义新的函数式接口。<br>范例：函数式接口——接收参数并返回处理结果<br>· String类有一个方法：<code>public boolean startsWith(String str)</code></p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Function;public class Demo {    public static void main(String[] args) {        Function&lt;String, Boolean&gt; fun = &quot;##hello&quot;::startsWith;        System.out.println(fun.apply(&quot;##&quot;)); // true    }}</code></pre><p>范例：消费型接口</p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Consumer;class MyDemo {    // 此方法没有返回值，但是有参数    public void print(String str) {        System.out.println(str);    }}public class Demo {    public static void main(String[] args) {        Consumer&lt;String&gt; cons = new MyDemo()::print;        cons.accept(&quot;Hello World&quot;);    }}</code></pre><p>范例：供给型接口<br>· 引用String类的toUpperCase()：<code>public String toUpperCase()</code>;</p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Supplier;public class Demo {    public static void main(String[] args) {        Supplier&lt;String&gt; sup = &quot;hello&quot;::toUpperCase;        System.out.println(sup.get());    }}</code></pre><p>范例：断言型接口<br>· String类中有<code>equalsIgnoreCase()</code></p><pre class="highlight"><code class="">import java.util.function.Predicate;public class Demo {    public static void main(String[] args) {        Predicate&lt;String&gt; pre = &quot;hello&quot;::equalsIgnoreCase;        System.out.println(pre.test(&quot;Hello&quot;));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java8特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java8特性&quot;&gt;&lt;/a&gt; Java8特性&lt;/h2&gt;
&lt;h3 id=&quot;接口定义增强&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#接口定义增强&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(二)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%BA%8C)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(二)/</id>
    <published>2017-12-19T01:46:40.216Z</published>
    <updated>2017-12-20T01:30:35.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2><h3 id="枚举简介"><a class="markdownIt-Anchor" href="#枚举简介"></a> 枚举简介</h3><p>1、多例设计模式：<br>构造方法私有化，而后在类的内部提供有若干个实例化对象，并且通过static方法返回。<br>范例：定义一个表示颜色基色的多例</p><pre class="highlight"><code class="">class Color {    private String title;    private static final Color RED = new Color(&quot;红色&quot;);    private static final Color GREEN = new Color(&quot;绿色&quot;);    private static final Color BLUE = new Color(&quot;蓝色&quot;);    private Color(String title) {        this.title = title;    }    public static Color getInstance(int ch) {        switch (ch) {            case 1:                return RED;            case 2:                return GREEN;            case 3:                return BLUE;            default:                return null;        }    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Color red = Color.getInstance(1);        System.out.println(red);    }}</code></pre><p>2005年之前，Java定义枚举采用上述方式，即多例设计解决了Java无法直接定义枚举的问题。<br>2、从2005年之后，Java增加了枚举的概念，使用<code>enum</code>关键字定义。<br>范例：定义枚举</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED, GREEN, BLUE; // 实例化对象}public class Demo {    public static void main(String[] args) {        Color red = Color.RED;        System.out.println(red);    }}</code></pre><p>枚举可以地替代多例设计模式。<br>3、Java使用enum定义枚举，相当于一个类继承了<code>Enum</code>类。</p><blockquote><p>public abstract class Enum&lt;E extends Enum<E>&gt;<br>extends Object<br>implements Comparable<E>, Serializable</E></E></p></blockquote><p><code>Enum</code>是一个抽象类，里面定义的构造方法如下：<code>protected Enum(String name, int ordinal)</code><br>Enum类的构造方法依然是被封装的，也属于构造方法私有化。多例设计模式的前提：构造方法私有化。<br>4、在Enum类中定义了两个方法：</p><blockquote><p>· 取得枚举的索引：public final int ordinal();<br>· 取得枚举的名字：public final String name();<br>除了以上支持的方法外，使用enum关键字定义的枚举类还有一个<code>values()</code>方法，可以将枚举对象以对象数组的形式的返回。</p></blockquote><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED, GREEN, BLUE;}public class Demo {    public static void main(String[] args) {        for (Color c : Color.values()) {            System.out.println(c.ordinal() + &quot;-&quot; + c.name());        }    }}</code></pre><blockquote><p>请解释enum和Enum的区别？<br>· enum是一个关键字，而Enum是一个抽象类；<br>· 使用enum定义的枚举就相当于一个类继承了Enum类。</p></blockquote><h3 id="定义其它结构"><a class="markdownIt-Anchor" href="#定义其它结构"></a> 定义其它结构</h3><p>1、多例设计模式可以在类中定义属性和方法等；枚举也可以，但有如下要求：</p><blockquote><p>· 枚举之中定义的构造方法不能使用public声明，如果没有无参构造方法，要手工调用构造传递参数；<br>· 枚举对象必须要放在首行，随后才可以定义属性、构造方法、普通方法。</p></blockquote><p>范例：扩充枚举功能</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        for (Color c : Color.values()) {            System.out.println(c); // 调用toString()        }    }}</code></pre><p>此时与之前定义的多例设计模式操作方式完全相同，而且代码更加简单。<br>2. 枚举还可以实现接口<br>范例：枚举实现接口</p><pre class="highlight"><code class="">interface Message {    public String getTitle();}enum Color implements Message { // 定义枚举类    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String getTitle() {        return this.title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Message msg = Color.RED;        System.out.println(msg.getTitle());    }}</code></pre><p>3、枚举还可以在每个对象后面以匿名内部类的形式使用抽象方法。<br>范例：另一种形式的接口</p><pre class="highlight"><code class="">interface Message {    public String getTitle();}enum Color implements Message { // 定义枚举类    RED(&quot;红色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, GREEN(&quot;绿色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, BLUE(&quot;蓝色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }; // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String getTitle() {        return this.title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Message msg = Color.RED;        System.out.println(msg.getTitle());    }}</code></pre><p>4、枚举中还能直接定义抽象方法，此时每一个枚举对象必须分别覆写抽象方法。<br>范例：定义抽象方法并覆写</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED(&quot;红色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, GREEN(&quot;绿色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, BLUE(&quot;蓝色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }; // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String toString() {        return this.title;    }    public abstract String getTitle();}public class Demo {    public static void main(String[] args) {        System.out.println(Color.RED.getTitle());    }}</code></pre><h3 id="枚举应用"><a class="markdownIt-Anchor" href="#枚举应用"></a> 枚举应用</h3><p>1、枚举应用于switch。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Color c =Color.RED;        switch (c){ // 枚举判断            case RED:                System.out.println(&quot;这是红色&quot;);                break;            case GREEN:                System.out.println(&quot;这是绿色&quot;);                break;            case BULE:                System.out.println(&quot;这是蓝色&quot;);                break;        }    }}</code></pre><p>范例：利用枚举编写一个程序：</p><pre class="highlight"><code class="">enum Sex {    MALE(&quot;男&quot;), FEMALE(&quot;女&quot;);    private String title;    private Sex(String title){        this.title = title;    }    public String toString(){        return this.title;    }}class Person{    private String name;    private int age;    private Sex sex;    public Person(String name,int age,Sex sex) {        this.name = name;        this.age = age;        this.sex = sex;    }    public String toString(){        return &quot;姓名:&quot; + this.name +                &quot;,年龄:&quot; + this.age +                &quot;,性别:&quot; + this.sex;    }}public class Demo {    public static void main(String[] args) {        System.out.println(new Person(&quot;张三&quot;, 24, Sex.FEMALE));    }}</code></pre><h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2><blockquote><p>软件开发经历了三个阶段：<br>（1）与配置相关的代码写在程序中；<br>（2）配置与程序代码独立，即程序运行时根据配置文件操作；但会造成配置文件过多时，查错困难；<br>（3）配置信息对用户而言无用，而且错误的修改还会导致程序异常。因此将配置信息写回到程序中，但利用一些明显的标记来区分配置信息与程序。</p></blockquote><h3 id="annotation简介"><a class="markdownIt-Anchor" href="#annotation简介"></a> Annotation简介</h3><p><code>Annotation</code>是JDK1.5最大的特色，利用注解的形式来实现程序的不同功能。在Java SE中支持自定义<code>Annotation</code>的开发，并且提供了三个最为常用的基础Annotation：<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>。</p><h3 id="准确覆写"><a class="markdownIt-Anchor" href="#准确覆写"></a> 准确覆写</h3><p>如果在输出对象时，希望其可以返回需要的内容，就必须覆写<code>toString()</code>。<br>在覆写方法时，可能由于写错方法名等错误，导致未进行覆写，并且这种错误在编译时，并不能被发现。所以为了告诉编译器toString()是覆写的方法，应该加上@Override。</p><h3 id="过期声明"><a class="markdownIt-Anchor" href="#过期声明"></a> 过期声明</h3><p>假设现在有工具包，其中有一个Demo类，类中有一个fun()。在项目最初阶段，fun()非常适用。但随着技术提升，fun()显得功能不足，此时开发者有两个选择：</p><blockquote><p>· 1. 直接在新版本的工具包里删除fun()，同时给出新的fun2()；<br>· 2. 在新版本的开发包里保存fun()，但是通过某种途径告诉开发者，这个方法有问题，同时提供fun2()供开发者使用。</p></blockquote><p>明显，第二种选择比较合适，可以兼顾已使用fun()的项目。这时，就可以使用<code>@Deprecated</code>声明。<br>范例：声明过期操作</p><pre class="highlight"><code class="">class Book{    @Deprecated    public void fun(){}}public class Demo {    public static void main(String[] args) {        Book bk = new Book();        bk.fun();    }}</code></pre><p>利用此操作可以很好地实现方法功能的新旧交替。</p><h3 id="压制警告"><a class="markdownIt-Anchor" href="#压制警告"></a> 压制警告</h3><p>可以压制多个警告（warning）</p><pre class="highlight"><code class="">class Book&lt;T&gt;{    private T title;    public void setTitle(T title){        this.title = title;    }}public class Demo {    @SuppressWarnings(&quot;unchecked&quot;)    public static void main(String[] args) {        Book bk = new Book();        bk.setTitle(&quot;Hello&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;枚举&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#枚举&quot;&gt;&lt;/a&gt; 枚举&lt;/h2&gt;
&lt;h3 id=&quot;枚举简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#枚举简介&quot;&gt;&lt;/a&gt; 枚举简介&lt;/h3&gt;
&lt;p&gt;1
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL避免乱码</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/MySQL%E9%81%BF%E5%85%8D%E4%B9%B1%E7%A0%81/"/>
    <id>http://yov.oschina.io/article/工具/MySQL避免乱码/</id>
    <published>2017-12-13T01:21:07.855Z</published>
    <updated>2017-12-16T06:44:05.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编码简介"><a class="markdownIt-Anchor" href="#编码简介"></a> 编码简介</h3><p>（1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制字符（退格、响铃等）组成；<br>（2）latin1，占1byte，在ASCII基础上，增加128 ～ 255区间的字符；<br>（3）GB2312等CJK字符集，可变长字符集，最多占2bytes，用于存储常见的CJK字符；<br>（4）UTF8，可变长字符集，最多占3bytes，可以囊括ASCII、CJK及其他绝大多数常用语言文字；这中间其实还有个UNICODE字符集，它也是2bytes的，也能囊括ASCII字符，但即便是ASCII字符也需要消耗2bytes，存在一定浪费，而用UTF8存储ASCII字符时，实际只需要1byte，更为节省存储空间；<br>（5）UTF8MB4，可变长字符集，最多占4bytes，可以包含上面其他几种字符集；同样地，以UTF8MB4存储ASCII字符时，实际上也是只占用1bytes，存储一般的汉字占用3bytes，而存储个别汉字则需要4bytes，存储emoji也至少需要4bytes；<br>MySQL采用UTF8MB4字符集时,存储文本实际消耗字节数是由文本内容的字节数决定的,并非总是需要4字节,列举几种情况：</p><blockquote><p>输入字符集任意，且存储ASCII字符时，每个字符需要1byte；<br>输入字符集是GB2312，且存储的字符是汉字时，每个字符需要2bytes；<br>输入字符集是UTF8/UTF8MB4，且存储的字符是低编码汉字时，每个字符需要3bytes；<br>输入字符集是UTF8/UTF8MB4，且存储的字符是高编码汉字时，每个字符需要4bytes；<br>输入字符集是binary，且存储的字符是高编码汉字时，每个字符需要4bytes；</p></blockquote><h3 id="表字符集由utf8直接转换成utf8mb4的方法"><a class="markdownIt-Anchor" href="#表字符集由utf8直接转换成utf8mb4的方法"></a> 表字符集由UTF8直接转换成UTF8MB4的方法</h3><p>1、只修改字符集（使用默认校验集）</p><pre class="highlight"><code class="">mysql&gt; alter table t1 convert to character set utf8mb4</code></pre><p>2、同时修改表字符集和校验集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 convert to  character set utf8mb4 collate utf8mb4_bin;</code></pre><p>3、只修改某列的字符集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)  character set utf8mb4 not null default ‘’</code></pre><p>4、同时修改某列的字符集和校验集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)  character set utf8mb4  collate utf8mb4_unicode_ci  not null default ‘’</code></pre><h3 id="mysql端字符集"><a class="markdownIt-Anchor" href="#mysql端字符集"></a> MySQL端字符集</h3><blockquote><p>character_set_server：server端默认字符集；<br>character_set_database：database默认字符集，若未设定，则和 character_set_server 的设定一样；database中的数据表/stored procedure/stored function 也可以自行设定字符集，若未指定，则和 character_set_database的设置一样；数据表中的字符类型列，也可以单独设定字符集，若未设定，则和该表指定的字符集一样；<br>character_set_client：客户端显示读取结果的字符集；<br>character_set_connection：客户端从server端读取数据时传输字符集；<br>character_set_results：server端将数据发送给客户端时的字符集；</p></blockquote><p>MySQL涉及到字符集的设置实在太多，因此强烈建议各个环节全部采用同一种字符集，避免出现意外状况。</p><h3 id="总结建议"><a class="markdownIt-Anchor" href="#总结建议"></a> 总结建议</h3><p>(1)从前端到后端（浏览器=&gt;WEB Server=&gt;MySQL连接层=&gt;Server层=&gt;DB层&gt;TABLE层）,尽可能使用同一种字符集；<br>(2)尽可能采用大字符集，也就是优先级：UTF8Mb4 &gt; UTF8 &gt; GBK &gt; LATIN1;<br>(3)采用逻辑备份数据时，切记要不定期进行恢复测试.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编码简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编码简介&quot;&gt;&lt;/a&gt; 编码简介&lt;/h3&gt;
&lt;p&gt;（1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(一)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%80)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(一)/</id>
    <published>2017-12-06T06:31:22.456Z</published>
    <updated>2017-12-11T03:06:49.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java5特性"><a class="markdownIt-Anchor" href="#java5特性"></a> Java5特性</h2><h3 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h3><p>要求：定义一个方法，可以接收多个整型数据的相加。<br>范例：用数组解决该问题</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(add(new int[]{1, 2, 3}));        System.out.println(add(new int[]{1, 2}));    }    // 实现任意多个整型数据的相加    // 因为有多个数据，所以用数组接收    // return 累加的结果    public static int add(int[] data) {        int sum = 0;        for (int x = 0; x &lt; data.length; x++) {            sum += data[x];        }        return sum;    }}</code></pre><p>使用数组是因为方法的参数个数是固定的，无法接收随机个参数。但通过数组接收参数不符合预期，理想的调用形式：add(1,2,3),add(10,20);<br>该功能从JDK1.5后实现，它主要是在方法上使用，定义形式：</p><pre class="highlight"><code class="">[public | protected | private] [static] [final] [abstract] 返回值类型 方法名称(数据类型 ... 变量){    [return [返回值] ;]}</code></pre><p>上述代码中，[]中的内容可以忽略。上述形式中的参数不再是一个内容，而是多个内容，尽管参数的定义形式变了，但是参数的访问却没变，即进行参数访问的时候按照数组的形式操作。</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        // 可变参数支持数组        System.out.println(add(new int[] {1,2,3}));// 传递3个整型数据        // 可变参数支持参数        System.out.println(add(1,2,3));// 传递3个整型数据        System.out.println(add(10,20));// 传递2个整型数据        System.out.println(add());// 不传递数据    }    //        实现任意多个整型数据的相加操作    //        由于要接收多个整型数据，所以要用数组完成接收    //        return 多个整型数据的累加结果    public static int add(int ... data){        int sum = 0 ;        for (int x = 0 ; x &lt; data.length ; x ++){            sum += data[x] ;        }        return sum;    }}</code></pre><p>在大部分开发中，应该要求参数的个数是准确的，因此可变参数多用于一些程序相关系统类的设计使用上，而不是开发中。可变参数属于数组的变形应用。</p><h3 id="foreach循环"><a class="markdownIt-Anchor" href="#foreach循环"></a> foreach循环</h3><p>foreach的功能是进行数组或者是集合数据的输出。语法如下：</p><pre class="highlight"><code class="">for(类型 变量 : 数组 | 集合)  { //  每一次循环会自动将数组内容设置给变量}</code></pre><p>范例：for循环输出</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        int data [] = new int[] {1,2,3,4,5,6};        for (int x = 0 ; x &lt; data.length ; x ++){            System.out.println(data[x]) ;        }    }}</code></pre><p>范例：foreach输出</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        int data [] = new int[] {1,2,3,4,5,6};        for (int x : data) { // 循环次数由数组长度决定            // 每一次循环都表示数组的脚标增长，会取得每个数组的内容，并将其设置给了x            System.out.println(x);        }    }}</code></pre><h3 id="静态导入"><a class="markdownIt-Anchor" href="#静态导入"></a> 静态导入</h3><p>假设一个类中定义的方法都是static方法，那么其他类引用此类时必须用“类名称.方法（）”进行调用。<br>范例：</p><pre class="highlight"><code class="">package com.java.util;public class MyMath {    public static int add(int x, int y) {        return x + y;    }    public static int div(int x, int y) {        return x / y;    }}</code></pre><p>此时MyMath中方法都是static方法，随后在其它类中使用这些方法。<br>范例：基本使用形式</p><pre class="highlight"><code class="">package com.java.demo;import com.java.util.MyMath;public class Demo {    public static void main(String [] args) {        System.out.println(&quot;加法操作：&quot; + MyMath.add(10,20));        System.out.println(&quot;加法操作：&quot; + MyMath.div(20,10));    }}</code></pre><p>范例：静态导入</p><pre class="highlight"><code class="">package com.java.demo;// 将MyMath类中的全部static方法导入，这些方法就好比直接定义在了main方法中import static com.java.util.MyMath.* ;public class Demo {    public static void main(String [] args) {        System.out.println(&quot;加法操作：&quot; + add(10,20));        System.out.println(&quot;加法操作：&quot; + div(20,10));    }}</code></pre><h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2><h3 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h3><p>1、要求：定义一个表示坐标的类（Point），该类要保存以下几种坐标：</p><blockquote><p>· 整数：x = 10、y = 20；<br>· 小数：x = 10.2、y = 20.3；<br>· 字符串：x = 东经20度、y = 北纬15度。</p></blockquote><p>Poin类的设计关键在于x和y的类型。必须有一种类型可以保存这三类数据，首先想到的是Object类型：</p><blockquote><p>· int：int自动装箱为Integer，Integer向上转型为Object；<br>· double：double自动装箱为Double，Double向上转型为Object；<br>· String：直接向上转型为Object；</p></blockquote><p>范例：设计如下</p><pre class="highlight"><code class="">class Point{ // 定义坐标类    private Object x;    private Object y;    public Object getX() {        return x;    }    public void setX(Object x) {        this.x = x;    }    public Object getY() {        return y;    }    public void setY(Object y) {        this.y = y;    }}</code></pre><p>范例：测试上述代码</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point();        pA.setX(10);        pA.setY(20);        // 2. 取出数据        int x = (Integer) pA.getX();        int y = (Integer) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>上述代码利用Object数据类型解决了问题，但依然可能有一定问题。<br>范例：错误代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point();        pA.setX(&quot;东经10度&quot;);        pA.setY(10);        // 2. 取出数据        String x = (String) pA.getX();        String y = (String) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>上述问题产生的原因是因为设置时存放的是int(Integer),而取出时是String。两个没有任何关系的类对象之间发生强制转换，会出现<code>java.lang.ClassCastException</code>错误。<br>2、向上转型是为了统一参数，向下转型是为了调用子类定义的特殊功能。向下转型是一种不安全的操作，那么这操作应该在代码运行前排查出来。从JDK1.5增加了泛型，泛型的核心作用在于：类在定义的时候，可以使用一个标记，此标记动态表示类中属性或方法参数的类型，使用时设置具体类型。</p><pre class="highlight"><code class="">// T在Point类定义上只表示一个标记，使用时需要为其设置具体的类型class Point&lt;T&gt; { // 定义坐标,Type = T    private T x; // 该属性类型未知，由Point动态设置    private T y; // 该属性类型未知，由Point动态设置    public T getX() {        return x;    }    public void setX(T x) {        this.x = x;    }    public T getY() {        return y;    }    public void setY(T y) {        this.y = y;    }}</code></pre><p>在使用Point类时，才设置标记的类型，即设置类中属性的类型。<br>范例：设置为String</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point&lt;String&gt; pA = new Point();        pA.setX(&quot;东经10度&quot;);        pA.setY(&quot;北纬20度&quot;);        // 此时Point类的类型为String，不需要向下转型        // 2. 取出数据        String x = pA.getX();        String y = pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>3、使用泛型后，类中属性的类型都是动态设置的，这样避免了向下转型的问题。但是泛型只能用于类，即不能用于基本数据类型，只能是引用类型（例如，不能用<code>&lt;int&gt;</code>，只能用<code>&lt;Integer&gt;</code>）</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point&lt;Integer&gt; pA = new Point();        pA.setX(10);        pA.setY(20);        // 利用包装类的自动装箱和自动拆箱        // 2. 取出数据        int x = pA.getX();        int y = pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>4、对于泛型有两点说明：</p><blockquote><p>· 使用泛型类或接口时，没有设置接口的具体类型会出现编译警告，为了保证程序不出错，将默认使用Object表示。</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point(); // 将使用Object描述泛型        pA.setX(10);        pA.setY(20);        // 2. 取出数据,需要转型        int x = (Integer) pA.getX();        int y = (Integer) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><blockquote><p>· JDK1.7开始，可以简化泛型声明</p></blockquote><pre class="highlight"><code class="">Point&lt;Integer&gt; pA = new Point();</code></pre><p>即实例化时只要在前面声明一个泛型的具体类型。</p><h3 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h3><p>范例：观察下述程序</p><pre class="highlight"><code class="">class Message&lt;T&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;String&gt; m = new Message&lt;String&gt;();        m.setMsg(&quot;Hello&quot;);        fun(m); // 引用传递    }    public static void fun(Message&lt;String&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>上述代码为Message类设置String型的泛型，但是此时设置其他类型时，fun()中的Message<String>就不能使用了，并且fun()不能针对不同的泛型进行重载，因为方法重载只认得参数类型，无法辨别泛型的不同。<br>解决方法一：不设置方法参数的泛型</String></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        Message&lt;String&gt; mB = new Message&lt;String&gt;();        mA.setMsg(100);        mB.setMsg(&quot;Hello&quot;);        fun(mA); // 引用传递        fun(mB);    }    public static void fun(Message temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>此时fun()存在警告，因为不设置具体泛型，就会存在警告。并且存在下述问题：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        mA.setMsg(100);        fun(mA); // 引用传递    }    public static void fun(Message temp) { // 不设置泛型，默认为Object型        temp.setMsg(&quot;Hello&quot;); // 设置Striing型        System.out.println(temp.getMsg());    }}</code></pre><p>1、上述代码说明，需要一种方式可以接收任意的泛型类型，但是不可以修改，只能取出。就可以使用<code>?</code>来描述</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {        Message&lt;Integer&gt; num = new Message&lt;&gt;();        num.setMsg(100);        fun(num);    }    public static void fun (Message&lt;?&gt; tmp) {        //tmp.setMsg(&quot;String&quot;); 报错,无法应用        System.out.println(tmp.getMsg());    }}</code></pre><ol start="3"><li>在<code>?</code>通配符基础上还有两个子通配符：</li></ol><blockquote><p>· ?extends 类：设置泛型上限，可以在声明上和方法参数上使用；<br>|- ?extends Number：意味着可以设置Number或者Number的子类(Integer，Double等)<br>· ?super 类：设置泛型下限，方法参数使用；<br>|-?super String：意味着只能设置String或者它的父类Object.</p></blockquote><p>范例：设置泛型上限</p><pre class="highlight"><code class="">class Message&lt;T extends Number&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        mA.setMsg(100);        fun(mA); // 引用传递    }    public static void fun(Message&lt;? extends Number&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>范例：将Integer改为String</p><pre class="highlight"><code class="">Message&lt;String&gt; mA = new Message&lt;String&gt;();</code></pre><p>此时设置为非Number或其子类，那就会出现语法错误。<br>范例：设置泛型下限</p><pre class="highlight"><code class="">class Message&lt;T&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;String&gt; mA = new Message&lt;String&gt;();        mA.setMsg(&quot;Hello&quot;);        fun(mA); // 引用传递    }    public static void fun(Message&lt;? super String&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><h3 id="泛型接口"><a class="markdownIt-Anchor" href="#泛型接口"></a> 泛型接口</h3><p>1、泛型可以在接口上声明，这样的接口称为泛型接口。<br>范例：定义泛型接口</p><pre class="highlight"><code class="">// 如果是接口在前面加“I”，例如：IMessage;// 如果是抽象类前面加Abstract,例如:AbstractMessage// 如果是普通类直接写，例如：Messageinterface IMessage&lt;T&gt; { // 设置泛型接口    public void print(T t);}</code></pre><p>2、接口必须定义其相应的子类，定义子类有两种形式：<br>形式一：在子类继续设置泛型</p><pre class="highlight"><code class="">// 子类也继续使用泛型，接口使用和子类一样的泛型标记class Message&lt;T&gt; implements IMessage&lt;T&gt; {    public void print(T t) {        System.out.println(t);    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = new Message&lt;String&gt;();        msg.print(&quot;Hello&quot;);    }}</code></pre><p>形式二：在子类不设置泛型，但为接口明确定义一个泛型</p><pre class="highlight"><code class="">class Message implements IMessage&lt;String&gt; {    public void print(String t) {        System.out.println(t);    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = new Message();        msg.print(&quot;Hello&quot;);    }}</code></pre><h3 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h3><p>泛型方法也可以定义在普通类中。<br>范例：泛型方法定义</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = fun(&quot;Hello&quot;);        System.out.println(str.length());    }    // T的类型由传入的参数类型决定    public static &lt;T&gt; T fun(T t) {        return t;    }}</code></pre><blockquote><p>总结：<br>1、泛型解决的是向下转型所带来的安全隐患，其核心是在声明类或接口时不设置参数或属性的类型；<br>2、“?”可以接收任意的泛型类型，只能取出，不能修改泛型</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java5特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java5特性&quot;&gt;&lt;/a&gt; Java5特性&lt;/h2&gt;
&lt;h3 id=&quot;可变参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可变参数&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse使用</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Tool/Eclipse%E4%BD%BF%E7%94%A8/"/>
    <id>http://yov.oschina.io/article/工具/Tool/Eclipse使用/</id>
    <published>2017-12-05T07:01:25.864Z</published>
    <updated>2017-12-05T07:05:25.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="eclipse简介"><a class="markdownIt-Anchor" href="#eclipse简介"></a> Eclipse简介</h3><p>Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包含以下几个部分：JDT、JUNIT、CVS客户端、插件开发、GIT客户端。</p><h3 id="jdt使用"><a class="markdownIt-Anchor" href="#jdt使用"></a> JDT使用</h3><p>JDT是Eclipse中进行Java程序开发的基础工具。<br>Eclipse中项目建立完成后，会在项目的文件目录下生成两个子目录：</p><blockquote><p>· src：保存所有的.java源文件；<br>· bin：保存所有的.class文件；</p></blockquote><p>Eclipse最大特点在于代码生成功能。<br>1、Eclipse中最常用的快捷键：</p><blockquote><p>·Alt + / ：进行代码提示；<br>·Ctrl + 1：为错误的代码给出纠正方案；<br>·Ctrl + Shift + O：组织导入，导入其它包的类；<br>·Ctrl + D：删除当前行代码；<br>·Ctrl + Alt + ↓：删除当前行代码；<br>·Ctrl + /：使用单行注释；<br>·Ctrl + H：强力搜索；<br>·Ctrl + Shift + L：全部快捷键列表；</p></blockquote><p>2、Eclipse中有debug（代码跟踪调试）功能，设置好断点之后，采用调试的方式运行程序。<br>进入到调试视图后，Eclipse将等待用户的操作指令，并且在设置断点处停止执行，调试方式有如下几个：</p><blockquote><p>· 单步进入【F5】：指的是进入到执行的方法之中观察方法的执行效果；<br>· 单步跳过【F6】：在当前代码的表面上执行；<br>· 单步返回【F7】：不再观察了，返回进入处；<br>· 恢复执行【F8】：停止调试，直接正常执行完毕；</p></blockquote><p>在调试过程之中可以清楚地知道方法中所有变量的数值的变化情况。</p><h3 id="junit测试工具"><a class="markdownIt-Anchor" href="#junit测试工具"></a> Junit测试工具</h3><p>junit是一个测试工具。对于软件测试分为两种：<br>·黑盒测试：针对功能测试，看不见代码<br>·白盒测试：针对性能测试，算法的调整<br>除了上述两种测试，还有一类测试----用例测试（UseCase测试工程师），junit是一个use case测试工具，但是其使用不麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;eclipse简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#eclipse简介&quot;&gt;&lt;/a&gt; Eclipse简介&lt;/h3&gt;
&lt;p&gt;Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十七)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%83)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十七)/</id>
    <published>2017-12-04T06:59:17.310Z</published>
    <updated>2017-12-04T07:27:48.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常捕获及处理"><a class="markdownIt-Anchor" href="#异常捕获及处理"></a> 异常捕获及处理</h2><p>合理使用异常处理，可以让程序更加健壮。</p><h3 id="异常的产生"><a class="markdownIt-Anchor" href="#异常的产生"></a> 异常的产生</h3><p>异常是导致程序中断执行的一种指令流。当异常出现时，如果没有合理处理，程序就会中断执行。<br>范例：不产生异常的代码</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 2));        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>范例：产生异常</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        // 2.中将出现异常        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero// at com.java.util.Demo.main(Demo.java:7)</code></pre><p>异常产生后，产生异常的语句以及之后的语句将不再执行。默认情况下系统会输出异常信息，而后自动结束程序的执行。</p><h3 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h3><p>1、Java中进行处理异常，使用<code>try</code>、<code>catch</code>、<code>finally</code>这三个关键字，语法如下：</p><pre class="highlight"><code class="">try {    // 可能出现异常的语句} catch (异常类型 对象1) {    // 异常处理} catch (异常类型 对象2) {    // 异常处理} finally {    // 不论是否出现异常都执行的语句}</code></pre><p>对于上述操作的组合有：<code>try…catch</code>、<code>try…catch…finally</code>、<code>try…finally</code>(这个不建议使用)。<br>范例：应用异常处理格式</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {        }        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// 3.除法计算结束</code></pre><p>2、出现异常就要处理异常，为了能进行异常处理，可以使用异常类中的<code>printStackTrace()</code>输出完整的异常信息：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {            e.printStackTrace();        }        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// java.lang.ArithmeticException: / by zero// at com.java.util.Demo.main(Demo.java:7)// 3.除法计算结束</code></pre><p>范例：使用try…catch…finally</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>3、异常捕获时，一个try语句可以跟多个catch语句。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (ArithmeticException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>上述程序将由用户输入数据，可能存在以下异常：<br>· 用户执行时不输入参数（java Demo）：<code>java.lang.ArrayIndexOutOfBoundsException</code>数组越界错误；<br>· 输入的数据不是数字（java Demo a b）：<code>java.lang.NumberFormatException</code>；<br>· 被除数为0（java Demo 10 0）：<code>java.lang.ArithmeticException</code><br>以上代码只有一个catch，只能处理一个异常，其他异常依然会导致程序中断<br>范例：增加多个catch</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (ArithmeticException e) {            e.printStackTrace();        } catch (NumberFormatException e) {            e.printStackTrace();        } catch (ArrayIndexOutOfBoundsException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3><p>1、观察两个异常类的继承结构：</p><pre class="highlight"><code class="">NumberFormatException：java.lang.Object  |- java.lang.Throwable      |- Exception          |- RuntimeException              |- IllegalArgumentException                  |- NumberFormatExceptionArithmeticException：java.lang.Object  |-java.lang.Throwable      |- Exception          |- RuntimeException              |- ArithmeticException</code></pre><p>由上表可得，所有异常类都是<code>Throwable</code>的子类。Throwable下有两个子类<code>Error</code>和<code>Exception</code>。</p><blockquote><p>请解释Error和Exception的区别：<br>· Error：指的是JVM错误，即：此时程序还没有执行，用户不能处理；<br>· Exception：指的是程序运行中产生的异常，用户可以处理。</p></blockquote><p>所谓的异常处理指的是Exception以及它的子类异常。<br>2、异常处理流程图<br><img src="/article/Java/Java Base/Java基础知识(十七)/24-1.png" alt="无法加载" title="异常处理流程图"><br>流程描述：<br>1）当程序运行时出现异常，由JVM自动根据异常类型实例化一个与之类型匹配的异常类对象；<br>2）产生异常对象后，会判断当前语句是否存在异常处理。如果没有异常处理，就交给JVM进行默认的异常处理（输出异常信息，结束程序调用）；<br>3）如果有异常捕获操作，会由try语句捕获产生的异常类实例化对象，之后与catch语句进行比较，如果有符合的捕获类型，则使用catch语句进行异常处理；如果不匹配，则继续向下匹配其它catch语句；<br>4）不论异常处理是否能够匹配，都要继续执行，如果程序中存在finally语句，就先执行finally语句中的代码，执行完毕后根据之前catch匹配结果来决定如何执行，如果之前成功捕获异常，那就继续执行finally之后的语句；如果没有成功捕获，就交给JVM进行默认处理。<br>整个过程和catch中的异常类型进行匹配，但是所有Java对象都可以自动向上转型。即如果真的要匹配类型，简单的做法就是匹配Exception。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (Exception e) {            e.printStackTrace();        }  finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>上述将所有的异常都交由Exception类处理，因此程序无法知道具体产生的是什么异常。</p><blockquote><p>说明：<br>· 使用多个catch时，范围大的异常一定要放在范围小的异常后面，否则会出现语法错误。<br>· 直接捕获Exception比较方便，但不合理，因为所有异常都按照同种方式处理。项目中应根据具体异常类型处理。</p></blockquote><h3 id="throws关键字"><a class="markdownIt-Anchor" href="#throws关键字"></a> throws关键字</h3><p>1、throws关键字主要用于方法声明，将异常交由被调用处（如main方法）处理。<br>范例：使用throws关键字</p><pre class="highlight"><code class="">class MyMath {    public static int div(int x, int y) throws Exception {        // 使用了throws,所以该方法产生的异常交由调用处处理        return x / y;    }}</code></pre><p>范例：调用上述方法</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 必须进行异常处理，否则代码报错        try {            System.out.println(MyMath.div(10, 2));        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>调用了具有throws声明的方法，不论操作是否异常，都需要使用<code>try..catch</code>进行异常处理。<br>2.在主方法使用throws关键字后，异常将交给JVM处理，即采用默认处理方式。由于开发的程序多数希望正常结束调用，因此主方法不应该使用throws关键字。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {        System.out.println(MyMath.div(10, 0));    }}</code></pre><h3 id="throw关键字"><a class="markdownIt-Anchor" href="#throw关键字"></a> throw关键字</h3><p>1、程序中可以使用throw手工抛出一个异常类的对象。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        try {            throw new Exception(&quot;自定义异常&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><blockquote><p>throws与throw的区别：<br>·throw：在方法中手工抛出一个异常类对象（该对象可以是自定义的，或者已经存在的）；<br>·throws：用于方法声明上，使得调用该方法时必须处理异常。</p></blockquote><h3 id="异常处理标准格式"><a class="markdownIt-Anchor" href="#异常处理标准格式"></a> 异常处理标准格式</h3><p>要求：定义div()，在执行除法前打印提示信息，在计算结束后打印提示信息；如果计算中产生了异常，交给调用处处理。<br>范例：</p><pre class="highlight"><code class="">class MyMath {    public static void div(int x, int y) {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        System.out.println(x / y);        System.out.println(&quot;==== 除法计算结束 ====&quot;);    }}public class Demo {    public static void main(String[] args) {        MyMath.div(10,2);    }}</code></pre><p>上述代码可能出现异常，因此要进行异常处理。根据要求，异常交由调用处处理，因此使用throws关键字。</p><pre class="highlight"><code class="">class MyMath {    // 如果div()出现异常，异常交给调用处处理    public static void div(int x, int y) throws Exception {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        System.out.println(x / y);        System.out.println(&quot;==== 除法计算结束 ====&quot;);    }}public class Demo {    public static void main(String[] args) {        try {            MyMath.div(10, 2);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>上述代码产生错误后，程序运行到<code>System.out.println(&quot;==== 除法计算结束 ====&quot;);</code>就不执行了。<br>范例：正确做法如下：</p><pre class="highlight"><code class="">class MyMath {    // 如果div()出现异常，异常交给调用处处理    public static void div(int x, int y) throws Exception {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        try {            System.out.println(x / y);        } catch (Exception e) {            throw e; // 抛出异常        } finally {            System.out.println(&quot;==== 除法计算结束 ====&quot;);        }    }}public class Demo {    public static void main(String[] args) {        try {            MyMath.div(10, 0);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h3 id="runtimeexception类"><a class="markdownIt-Anchor" href="#runtimeexception类"></a> RuntimeException类</h3><p>范例：观察下述程序</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int temp = Integer.parseInt(&quot;100&quot;);    }}</code></pre><p>parseInt()： <code>public static int parseInt(String s) throws NumberFormatException;</code><br>parseInt()抛出了NumberFormatException，按照之前知识点，此处应强制进行异常捕获，但实际并没有该要求：<br>观察一下NumberFormatException的继承结构:</p><pre class="highlight"><code class="">java.lang.Object  |- java.lang.Throwable      |- java.lang.Exception          |- java.lang.RuntimeException → 运行时异常              |- java.lang.IllegalArgumentException                  |- java.lang.NumberFormatException</code></pre><p>Java为方便代码编写，提供了RuntimeException类，该类的特征是：程序在编译时，不会强制性要求用户处理异常，用户可以根据自己的需求选择性处理，但是没有处理又发生异常，就会交给JVM默认处理。</p><blockquote><p>请解释Exception与RuntimeException的区别，请列举常见的几种RuntimeException<br>· Exception是RuntimeExceptio的父类；<br>· 使用Exception定义的异常必须要被处理，而RuntimeException的异常可以选择性处理。<br>·常见的RuntimeException：ArithmeticException、NullPointerException、ClassCastException。</p></blockquote><h3 id="异常的捕获及处理断言"><a class="markdownIt-Anchor" href="#异常的捕获及处理断言"></a> 异常的捕获及处理（断言）</h3><p>assert关键字在JDK1.4引入，其功能是进行断言。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int num = 10;        assert num == 20 : &quot;num 不等于20&quot;;        System.out.println(&quot;num = &quot; + num);    }}</code></pre><p>默认情况下，断言是不应该影响程序的运行，即Java在解释程序时，断言是默认不起作用的。<br>启用断言：<code>java -ea Demo</code></p><pre class="highlight"><code class="">Exception in thread &quot;main&quot; java.lang.AssertionError: num的内容不是20        at Demo.main(Demo.java:6)</code></pre><h3 id="异常的捕获及处理自定义异常"><a class="markdownIt-Anchor" href="#异常的捕获及处理自定义异常"></a> 异常的捕获及处理（自定义异常）</h3><ol><li>Java自身提供了大量的异常类，但对于实际开发是不够。例如：进行添加数据操作时，可能出现错误数据，错误数据出现就应该抛出异常，例如AddException，而该异常Java没有，需要自己开发。<br>如果要自己开发一个异常类可以选择继承Exception或RuntimeException。<br>范例：定义AddException</li></ol><pre class="highlight"><code class="">class AddException extends Exception {    public AddException(String msg) {        super(msg);    }}public class Demo {    public static void main(String[] args) {        int num = 11;        try {            if (num &gt; 10) {                throw new AddException(&quot;数值传递过大&quot;);            }        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>上述代码，只是介绍自定义异常的形式，不能说明自定义异常的作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常捕获及处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异常捕获及处理&quot;&gt;&lt;/a&gt; 异常捕获及处理&lt;/h2&gt;
&lt;p&gt;合理使用异常处理，可以让程序更加健壮。&lt;/p&gt;
&lt;h3 id=&quot;异常的产生&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十六)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E5%85%AD)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十六)/</id>
    <published>2017-11-22T02:16:01.974Z</published>
    <updated>2017-11-22T07:04:37.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2><h3 id="访问控制权限-2"><a class="markdownIt-Anchor" href="#访问控制权限-2"></a> 访问控制权限</h3><p>Java有四种访问控制权限：<code>public,protected,default,private</code>。</p><table><thead><tr><th>No.</th><th>范围</th><th style="text-align:center">public</th><th style="text-align:center">protected</th><th style="text-align:center">default</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td>1</td><td>在同一个类中</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>2</td><td>在同一包的不同类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td>3</td><td>在不同包的子类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>4</td><td>在不同包的非子类</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p><code>protected</code>权限与包的定义有关。<br>范例：定义com.java.demoA.A类</p><pre class="highlight"><code class="">package com.java.demoa;public class A {    protected String info = &quot;Hello&quot;;}</code></pre><p>范例：定义com.java.demoB.B类</p><pre class="highlight"><code class="">package com.java.demoB;import com.java.demoa.A;public class B extends A { // 与A处于不同包中    public void print() {        System.out.println(&quot;A中的info：&quot; + super.info);    }}</code></pre><p>范例：测试</p><pre class="highlight"><code class="">package com.java.test;import com.java.demoB.B;public class Test {    public static void main(String[] args) {        new B().print(); // A中的info：Hello    }}</code></pre><p>范例：由Test类直接输出A类中的属性</p><pre class="highlight"><code class="">package com.java.test;import com.java.demoa.A;public class Test {    public static void main(String[] args) {        System.out.println(new A().info); // 报错，无法访问info    }}</code></pre><p>由于Test与A不在同一个包，并且没有继承关系，所以是无法访问protected权限。</p><blockquote><p>总结：<br>1.Java的封装性是以private、protected、default三种权限为主；<br>2.对于权限的选择，建议如下：<br>·声明属性就用private；<br>·声明方法就用public；<br>3.关于命名要求：<br>· 类名称每个单词的首字母大写，其余字母小写，例如：StudentInfo；<br>· 属性名称第一个单词字母小写，而后每个单词首字母大写，例如：studentName；<br>· 方法名称第一个单词字母小写，而后每个单词首字母大写，例如：toString()；<br>· 常量名全部大写，例如：MSG；<br>· 包名全部小写，例如：com.java.demo</p></blockquote><h3 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式"></a> 单例设计模式</h3><p>（1）正常情况下，类只有产生实例化对象后才能操作这个类。<br>范例：观察程序</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = new Singleton(); // 生成实例化对象        singleton.print();    }}</code></pre><p>Singleton类中存在构造方法，没有自定义构造方法时系统会自动生成一个无参无返回值操作的构造方法，即：一个类至少存在一个构造方法。<br>范例：修改Singleton类定义</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = new Singleton(); // 报错,无法访问Singleton()        singleton.print();    }}</code></pre><p>构造方法私有化后，无法调用构造方法实例化对象。<br>范例：调用私有化方法<br>分析步骤：<br>1.构造方法上使用了private声明，导致构造方法只能内部使用，因此直接在内部实例化对象：</p><pre class="highlight"><code class="">class Singleton{    Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}</code></pre><p>2.<code>instance</code>是普通属性，普通属性只有实例化对象才可以调用，因此需要使用static声明instance属性，使其不受实例化对象控制。</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    static Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = Singleton.instance;         singleton.print();    }}</code></pre><p>3.类中属性需要进行封装<code>private static Singleton instance = new Singleton();</code><br>4.获取封装的属性要使用<code>getter()</code>，因此要定义一个同样不受实例化对象控制的getter()，使用static定义。</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    private static Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }    public static Singleton getInstance() {        return instance;    }}public class Demo {    public static void main(String[] args) {        Singleton singletonA = Singleton.getInstance();        Singleton singletonB = Singleton.getInstance();        System.out.println(singletonA == singletonB); // true    }}</code></pre><p>上述代码的意义：要限制一个类实例化底下的个数，首先要锁定的是构造方法，因为实例化对象必须调用构造方法 ，那么构造方法私有化，就无法产生新的对象。此时要实例化一个对象，就需要在类中使用static定义一个公共对象 ，并使用static方法返回该对象，这样不论外部调用多少次，最终该类中只产生了一个对象，这就是<code>单例设计模式（Singleton）</code>。<br>（2）单例设计模式有两种形式：饿汉式、懒汉式<br>上述单例设计模式就属于饿汉式，即在定义Singleton类时就实例化一个对象，不论该对象最后是否被使用。<br>而懒汉式则是在第一次使用时才进行实例化对象，如果不使用， 就不进行实例化操作。<br>范例：实现懒汉式</p><pre class="highlight"><code class="">class Singleton{    private static Singleton instance;    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>单例设计模式的目的是让该类在整个系统中只有一个实例化对象。</p><h3 id="多例设计模式"><a class="markdownIt-Anchor" href="#多例设计模式"></a> 多例设计模式</h3><p>多例设计模式，可以让一个类产生指定数量的实例化对象。<br>范例：定义一个表示性别的类</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(int ch) {        switch (ch) {            case 0:                return FEMALe;            case 1:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Sex sex = Sex.getInstance(0);        System.out.println(sex);    }}</code></pre><p>JDK1.7之前，switch只能判断int或char，由于数字或字符表示不太直观，在1.7增加了String判断。</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(String sex) {        switch (sex) {            case &quot;woman&quot;:                return FEMALe;            case &quot;man&quot;:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}</code></pre><p>如果不想在switch语句中使用String，则可以引入一个标记接口（该方式不好）</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(int ch) {        switch (ch) {            case 0:                return FEMALe;            case 1:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}interface Choose {    int WOMAN = 0;    int MAN = 1;}public class Demo {    public static void main(String[] args) {        Sex sex = Sex.getInstance(Choose.MAN);        System.out.println(sex);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;访问控制权限&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#访问控制权限&quot;&gt;&lt;/a&gt; 访问控制权限&lt;/h2&gt;
&lt;h3 id=&quot;访问控制权限-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#访问控制权限-2&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十五)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%BA%94)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十五)/</id>
    <published>2017-11-11T11:13:36.150Z</published>
    <updated>2017-11-22T02:26:44.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展概念"><a class="markdownIt-Anchor" href="#扩展概念"></a> 扩展概念</h2><h3 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h3><pre class="highlight"><code class="">interface Message {    public void print();}class Messagelmpl implements Message {    public void print() {        System.out.println(&quot;Hello&quot;);    }}public class Demo {    public static void main(String[] args) {        fun(new Messagelmpl());    }    public static void fun(Message msg) {        msg.print();    }}</code></pre><p>假如<code>Messagelmpl</code>只使用一次，那么就可以利用匿名内部类。<br><strong>范例</strong>：使用匿名内部类</p><pre class="highlight"><code class="">interface Message {    public void print();}public class Demo {    public static void main(String[] args) {        fun(new Message() {            // 匿名内部类            public void print() {                System.out.println(&quot;Hello&quot;);            }        });    }    public static void fun(Message msg) {        msg.print();    }}</code></pre><p>使用匿名内部类的前提：<strong>必须基于接口或抽象类的应用。</strong><br>匿名内部类定义在方法中，方法的参数或是变量要被匿名内部类访问，必须加上<code>final</code>关键字。<strong>匿名内部类的优点在于减少了类的定义。</strong></p><h3 id="基本数据类型的包装类"><a class="markdownIt-Anchor" href="#基本数据类型的包装类"></a> 基本数据类型的包装类</h3><p>1、Java设计的基本原则：一切皆对象，一切操作都以对象的形式进行描述。此时我们发现，有一个矛盾点，基本数据类型不是对象。对于这个矛盾点，我们可以进行处理：</p><pre class="highlight"><code class="">class MyInt { // 定义类    private int num; // 类封装基本数据类型    // 定义构造方法，将基本数据类型传递给对象    public MyInt(int num) {        this.num = num;    }    public int intValue() { // 返回被封装的数据        return this.num;    }}public class Demo {    public static void main(String[] args) {        MyInt mi = new MyInt(10); // 装箱        int temp = mi.intValue(); // 拆箱        // 被封装的数据只有拆箱后才能进行计算        System.out.println(temp * 2);    }}</code></pre><p>Java为了方便用户使用，专门提供了一组包装类，来包装所有的基本类型：<code>byte(Byte)</code>、<code>short(Short)</code>、<code>int(Integer)</code>、<code>long(Long)</code>、<code>float(Float)</code>、<code>double(Double)</code>、<code>boolean(Boolean)</code>、<code>char（Character）</code>。（）中为基本类型对应的包装类。</p><blockquote><p>以上包装类严格讲分为两种子类型：<br>· 对象型包装类（Object直接子类）：Character，Boolean；<br>· 数值型包装类（Number直接子类）：Byte、Short、Integer、Float、Long、Double</p></blockquote><p><code>Numbe</code>是一个抽象类，一共定义了六个操作方法：<code>byteValue()</code>、<code>shortValue()</code>、<code>integerValue()</code>、<code>floatValue()</code>、<code>longValue()</code>、<code>doubleValue()</code>。</p><h3 id="装箱与拆箱"><a class="markdownIt-Anchor" href="#装箱与拆箱"></a> 装箱与拆箱</h3><p>1、基本数据类型与包装类间的转换通过以下方式：</p><blockquote><p>· 装箱操作： 将基本数据类型变为包装类的形式：<br>|- 每个包装类的构造方法都可以接收各自数据类型的变量；<br>· 拆箱操作： 将包装类取出被包装基本数据类型数据：<br>|- 利用Number类中提供的一些列xxValue()方法<br><strong>范例</strong>：使用int和Integer</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Integer obj = new Integer(10); // 装箱        int temp = obj.intValue(); // 拆箱        System.out.println(temp * 2);    }}</code></pre><p><strong>范例</strong>：使用double和Double</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Double obj = new Double(10.2); // 装箱        double temp = obj.doubleValue(); // 拆箱        System.out.println(temp * 2);    }}</code></pre><p><strong>范例</strong>：使用boolean和Boolean</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Boolean obj = new Boolean(true); // 装箱        boolean temp = obj.booleanValue(); // 拆箱        System.out.println(!temp);    }}</code></pre><p>2、所有包装类都利用同种格式的方法进行操作。但在JDK1.5之后，增加了自动装箱和自动拆箱的机制，并且可以直接使用包装类的对象进行数字计算，为开发提供了便利。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Integer obj = 10; // 自动装箱        int temp = obj; // 自动拆箱        obj++; // 包装类直接进行数学计算        System.out.println(temp * obj);    }}</code></pre><p>3、注意点：Integer对象可以直接赋值，也可以使用构造方法赋值，二者有何区别？<br>两者的区别可以参考String类直接赋值和构造方法赋值的区别。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Integer objA = 10; // 自动装箱        Integer objB = 10; // 自动装箱        Integer objC = new Integer(10);        System.out.println(objA == objB); // true        System.out.println(objA == objC); // false        System.out.println(objA.equals(objC)); // true    }}</code></pre><p>使用包装类时，几乎都是直接赋值，很少使用构造方法，判断内容是否相等时依然使用<code>equals()</code>方法。<br>4、Object类可以接收一切引用数据类型，由于自动装箱机制的存在，Object也可以接收基本数据类型。</p><blockquote><p>流程：基本数据类型 → 自动装箱（成为对象） → 向上转型为Object。</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Object obj = 10;        // Object不能直接向下转型向int        // Object只能自动转型为Integer        int temp = (Integer) obj;        System.out.println(temp * 2);    }}</code></pre><h3 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换"></a> 数据类型转换</h3><p>1、包装类多用于数据类型转换：在包装类中提供了将String数据变为基本数据类型的方法。<br>如下：</p><blockquote><p>· Integer类：public static int parseInt（String s）；<br>· Double类：public static double parseDouble（String s）；<br>· Boolean类：public static boolean parseBoolean（String s）；</p></blockquote><p><strong>注意</strong>：<code>Character</code>类不存在将字符串变为字符的方法，但<code>String</code>类的<code>charAt()</code>可以根据索引取出字符。<br><strong>范例</strong>：将String变为int型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;123&quot;;        int temp = Integer.parseInt(str);        System.out.println(temp * 2);    }}</code></pre><p>将字符串变为int型的前提是：<strong>该字符串全部为数字</strong>.<br><strong>范例</strong>：将String变为double型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;12.3&quot;;        double temp = Double.parseDouble(str);        System.out.println(temp * 2);    }}</code></pre><p><strong>范例</strong>：将String变为boolean</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = &quot;true&quot;;        boolean temp = Boolean.parseBoolean(str);        System.out.println(!temp);    }}</code></pre><p>Boolean转换时，如果字符串的值不是true或false，默认转为false。<br>2、字符串可以变为基本数据类型，基本数据类型也可变为字符串。方法有两种：<br>（1）任何基本数据类型与字符串使用<code>+</code>连接后，都会变为String类型数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int num = 100;        String str = num + &quot;&quot;; // 变为String类        System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199    }}</code></pre><p>上述方式虽然完成了转换，但产生了垃圾<code>&quot;&quot;</code><br>（2）利用<code>public static String valueOf(数据类型 变量)</code></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int num = 100;        String str = String.valueOf(num);        System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199    }}</code></pre><p>上述方式不会产生垃圾，因此开发中常用上述方法。</p><h2 id="包的定义及使用"><a class="markdownIt-Anchor" href="#包的定义及使用"></a> 包的定义及使用</h2><h3 id="包的定义"><a class="markdownIt-Anchor" href="#包的定义"></a> 包的定义</h3><p>1、包指的是程序的目录。早期开发一个程序是将所有类写在一个java文件中，编译后程序将直接保存在根目录下。利用包可以实现程序拆分，将不同的类根据要求保存在不同目录中。<br>包的定义通过关键字<code>package</code>完成。<br>范例：定义包</p><pre class="highlight"><code class="">package com.java.demo;public class Demo {    public static void main(String[] args) {    }}</code></pre><p>2、定义包时用<code>.</code>表示子目录。如果类中有包的定义，就必须使其保存在对应的目录下，而这些目录不需要手动创建，可以使用命令自动生成：<br>（1）打包编译：<code>java -d . Demo.java</code><br>|- <code>-d</code>: 根据<code>package</code>定义生成目录；<br>|-<code>.</code>：设置保存路径。<code>.</code>表示在当前路径下生成。<br>（2）解释程序时不要进入包中解释程序，而是在包外输入类的完整名称<code>包.类</code>：<br>|- <code>java com.java.demo.Demo</code></p><h3 id="包的导入"><a class="markdownIt-Anchor" href="#包的导入"></a> 包的导入</h3><p>1、使用包可以将一个完整的程序拆分为不同文件，从而分别保存。这存在问题：不同包间可能要进行互相访问，就需要进行导包操作，使用<code>import</code>语句完成。<br>范例：定义com.java.util.Message</p><pre class="highlight"><code class="">package com.java.util;class Message{    public static void print(){        System.out.println(&quot;Hello World !&quot;);    }}</code></pre><p>定义com.java.test.TestMessage</p><pre class="highlight"><code class="">package com.java.test;import com.java..util.Message;public class TestMessage {    public static void print() {        Message msg = new Message();        msg.print();    }}</code></pre><p>编译时，应先编译Message，再编译TestMessage：<br>|- <code>javac -d . Message.java</code><br>|- <code>javac -d . TestMessage.java</code><br>此时报错：<strong>Message在com.java.util中不是公共的; 无法从外部程序包中对其进行访问</strong><br>出现上述问题是因为public class定义的类可以被不同的包访问；而class定义的类只能被本包所访问。因此我们要修改Message.java:</p><pre class="highlight"><code class="">package com.java.util;public class Message{    public static void print(){        System.out.println(&quot;Hello World !&quot;);    }}</code></pre><p>Java编译器考虑到大型程序开发,因此可以使用通配符<code>*</code>：<code>java -d . *.java</code>编译当前目录下所有java文件。<br>2、当要导入一个包中多个类时，可以使用<code>import 包.*</code></p><pre class="highlight"><code class="">package com.java.test;import com.java..util.*;public class TestMessage {    public static void print() {        Message msg = new Message();        msg.print();    }}</code></pre><p><code>import 包.*</code>并不是导入包中所有的类，而是只导入程序所需的类，因此不用担心性能问题。<br>3、一个Java文件可能导入多个包，而不同包中可能存在同名的类。现假设：<br>·com.java.util.Message;<br>·com.java.demo.Message.</p><pre class="highlight"><code class="">package com.java.demo;public class Message {    public static void print() {        System.out.println(&quot;世界你好！&quot;);    }}</code></pre><p>由于需要，要同时导入上述两个类：</p><pre class="highlight"><code class="">package com.java.test;import com.java.demo.Message;import com.java.util.Message;public class TestMessage {    public static void main(String[] args) {        Message msg = new Message();        msg.print();    }}</code></pre><p>系统报错：<code>Error:(4, 1) java: com.java.demo.Message的 single-type-import 已定义具有相同简名的类型。</code>为了避免该错误，在使用类时，应加上包名：</p><pre class="highlight"><code class="">package com.java.test;import com.java.demo.Message;import com.java.util.Message;public class TestMessage {    public static void main(String[] args) {        com.java.demo.Message msg = new com.java.demo.Message();        Message.print();    }}</code></pre><h3 id="系统常用包"><a class="markdownIt-Anchor" href="#系统常用包"></a> 系统常用包</h3><p>Java提供了许多程序开发包，此外还有许多第三方包。Java自带的常见系统包如下：</p><blockquote><p>（1）java.lang：包含了String、Object、Integer等类，此包系统自动导入；<br>（2）java.lang.reflect：反射开发包；<br>（3）java.util：Java的工具包，提供了大量的工具类，像链表；<br>（4）java.util.regex：正则工具包；<br>（5）java.text：国际化处理程序包；<br>（6）<a href="http://java.io">java.io</a>：进行输入、输出处理以及文件操作；<br>（7）<a href="http://java.net">java.net</a>：网络编程开发包；<br>（8）java.sql：数据库程序开发包；<br>（9）java.applet：Applet程序开发包（已经不用了）；<br>|-Applet指的是在网页上嵌套的程序，可以使用Applet做一些动态效果，是采用绘图的方式完成的显示。随着时间的发展，Applet程序已经不再使用了（如果要再实现同样的功能，都是用Canvas绘图）。<br>（10）java.awt、javax.swing：图形界面的开发包，主要功能是开发单机程序界面。<br>|-JDK1.0时推出了awt开发包，但是这个开发包使用了大量的windows图形函数，使Java丧失了可移植性；<br>|-JDK1.2时推出了javax.swing开发包，是一个轻量级（Java自己开发的，不再使用windows），所以Java更名为Java2；</p></blockquote><h3 id="jar命令"><a class="markdownIt-Anchor" href="#jar命令"></a> jar命令</h3><p>使用jar命令压缩class文件，压缩的单位为包。<br><img src="/article/Java/Java Base/Java基础知识(十五)/22-1.png" alt="无法加载" title="jar命令"><br>范例：定义Message.java文件</p><pre class="highlight"><code class="">package com.java.util;class Message{    public static void print(){        System.out.println(&quot;Hello World !&quot;);    }}</code></pre><p>编译后会生成class文件，此时要交付给用户使用，将改包的代码压缩：<code>jar -cvf my.jar com</code>。生成的jar文件不能直接使用，必须配置CLASSPATH才能使用：<code>SET CLASSPATH = .;jar包所在路径</code>。开发中需要使用大量的第三方jar文件，都需要配置CLASSPATH，最简单的配置就是在环境变量中配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扩展概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#扩展概念&quot;&gt;&lt;/a&gt; 扩展概念&lt;/h2&gt;
&lt;h3 id=&quot;匿名内部类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#匿名内部类&quot;&gt;&lt;/a&gt; 匿名内部类&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十四)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E5%9B%9B)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十四)/</id>
    <published>2017-11-11T10:24:38.982Z</published>
    <updated>2017-11-11T11:12:55.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="object类"><a class="markdownIt-Anchor" href="#object类"></a> Object类</h2><p>Object类用于统一对象、数组和接口。</p><h3 id="object类基本描述"><a class="markdownIt-Anchor" href="#object类基本描述"></a> Object类基本描述</h3><p>1、<code>Object</code>类是所有类的父类，即任何一个类在没有定义继承某个类时，Object类就是其父类。</p><pre class="highlight"><code class="">class Book{}class Book extends Object{}</code></pre><p>上述两个类声明是等价的，Object类是唯一没有父类的类。Object类是所有类的父类，因此可以利用Object类通过向上转型，接收所有类型的对象。</p><pre class="highlight"><code class="">class Book extends Object {}public class Demo {    public static void main(String[] args) {        Object objA = new Book(); // 向上转型        Object objB = &quot;Hello&quot;; // 向上转型        Book b = (Book) objA; // 向下转型        String s = (String) objB; // 向下转型    }}</code></pre><p>因此在不确定参数类型时，使用Object类型是最好的选择。<br>2、Object类中定义了一个无参构造方法，因为其是所有类的父类，所以实例化子类对象时必然会调用父类的无参构造方法。</p><blockquote><p>一般而言，定义简单Java类时应覆写Object类中的如下方法：<br>· 取得对象信息：public String toString();<br>· 对象比较：public boolean equals(Object obj);<br>· 取得对象HASH码：public int hashCode();</p></blockquote><h3 id="tostring"><a class="markdownIt-Anchor" href="#tostring"></a> toString()</h3><pre class="highlight"><code class="">class Book extends Object {}public class Demo {    public static void main(String[] args) {        Book b = new Book();        String s = &quot;Hello&quot;;        System.out.println(b); // Book@1540e19d        System.out.println(b.toString()); // Book@1540e19d        System.out.println(s); // Hello    }}</code></pre><p>上述代码中直接输出实例对象和使用toString()输出的结果是一样。因为输出对象时，会自动调用toString()将对象变为字符串后输出。Object类中的<code>toString()</code>为了适应对象的输出，仅输出对象的编码。<br>但是这和我们的想法不符，我们想输出的应该是实例化对象的属性信息，因此要覆写toString()。<br><strong>范例</strong>：覆写toString()</p><pre class="highlight"><code class="">class Book extends Object {    private String title;    private double price;    // getter,setter,无参构造方法暂时略    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String toString() {        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price;    }}public class Demo {    public static void main(String[] args) {        Book b = new Book(&quot;Java开发&quot;, 20.3);        System.out.println(b); // 书名：Java开发,价格：20.3    }}</code></pre><p>此时直接输出对象，调用的就是覆写后的方法。</p><h3 id="equals"><a class="markdownIt-Anchor" href="#equals"></a> equals()</h3><p><strong>范例</strong>：对象比较</p><pre class="highlight"><code class="">class Book extends Object {    private String title;    private double price;    // getter,setter,无参构造方法暂时略    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String toString() {        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price;    }    public boolean equals(Object obj) {        if (this == obj) { // 地址相同            return true;        }        if (obj == null) {            return false;        }        if (!(obj instanceof Book)) { // 不是Book类对象            return false;        }        Book book = (Book) obj;        if (this.title.equals(book.title)                &amp;&amp; this.price == book.price) {            return true;        }        return false;    }}public class Demo {    public static void main(String[] args) {        Book bA = new Book(&quot;Java开发&quot;, 20.3);        Book bB = new Book(&quot;Java开发&quot;, 20.3);        System.out.println(bA.equals(bB)); // true        System.out.println(bA.equals(&quot;Hello&quot;)); // false    }}</code></pre><p>覆写后的equals()用于进行对象比较。</p><h3 id="object接收引用类型"><a class="markdownIt-Anchor" href="#object接收引用类型"></a> Object接收引用类型</h3><p>1、Object类是所有类的父类，因此Object类对象可以接收所有类型的对象，包括数组和接口对象。<br><strong>范例</strong>：接收数组数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Object obj = new int[]{1, 2, 3};        System.out.println(obj); // [I@1540e19d表示数组        if (obj instanceof int[]) { // 如果是数组，则输出            int data[] = (int[]) obj; // 向下转型            for (int x = 0; x &lt; data.length; x++) {                System.out.println(data[x]);            }        }    }}</code></pre><p><strong>范例</strong>：接收接口对象</p><pre class="highlight"><code class="">interface A {    public void fun();}class B implements A {    public void fun() {        System.out.println(&quot;Hello&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B();        Object obj = a;        A t = (A) obj;        t.fun(); // Hello    }}</code></pre><p>上述代码把参数类型统一为<code>Object</code>，有利于开发。</p><h3 id="object修改链表"><a class="markdownIt-Anchor" href="#object修改链表"></a> Object修改链表</h3><p>此时我们可以利用Object类的特点解决之前开发的链表存在的问题：<strong>由于参数类型不统一，每次使用都要进行重新开发</strong>。<br><strong>范例</strong>：修改链表</p><pre class="highlight"><code class="">class Link { // 链表类，外部可见    private class Node { // 节点类        private Object data; // 保存数据        private Node next; // 引用关系        public Node(Object data) { // 有数据才有Node            this.data = data;        }        // 设置关系        public void addNode(Node newNode) {            if (this.next == null) {                this.next = newNode;            } else {                this.next.addNode(newNode);            }        }        // 数据查询        public boolean containsNode(Object data) {            if (data.equals(this.data)) { // 当前数据等于要目标数据                return true; // 结束查询            } else { // 当前数据不等于目标数据                if (this.next != null) { // 有后续节点                    return this.next.containsNode(data);                } else { // 没有后续节点                    return false;                }            }        }        public Object getNode(int index) {            // 当前foot内容与要查询的索引比较            // foot自增，目的是下次查询方便            if (Link.this.foot++ == index) {                return this.data;            } else {                return this.next.getNode(index);            }        }        // 修改节点信息        public void setNode(int index, Object data) {            if (Link.this.foot++ == index) {                this.data = data;            } else {                this.next.setNode(index, data);            }        }        // 删除非根节点        public void removeNode(Node previous, Object data) {            // 参数中传递上一个节点和要删除的数据            if (data.equals(this.data)) {                previous.next = this.next;            } else {                this.next.removeNode(this, data);            }        }        public void toArrayNode() {            Link.this.retArray[Link.this.foot++] = this.data;            if (this.next != null) {                this.next.toArrayNode();            }        }    }    // ====================以上为内部类=====================    private Node root; // 根节点    private int count = 0; // 节点的个数    private int foot = 0; // 索引    private Object[] retArray; // 返回的数组    public void add(Object data) {        if (data == null) { // 输入数据为空            return;        }        Node newNode = new Node(data); // 要保存的数据        if (this.root == null) { // 根节点不存在            this.root = newNode; // 设为根节点        } else { //  根节点存在，交由Node处理            this.root.addNode(newNode);        }        this.count++; // 每次增加节点，count+1    }    // 获取链表长度    public int size() {        return this.count;    }    // 判断是否为空链表    public boolean isEmpty() {        return this.count == 0;    }    // 判断数据是否存在    public boolean contains(Object data) {        if (data == null || root == null) {            return false;        }        return this.root.containsNode(data);    }    // 根据索引获取信息    public Object get(int index) {        if (index &gt; this.count) { // 超出查询范围            return null;        }        this.foot = 0;        return this.root.getNode(index); // 查询交给Node类    }    // 设置信息    public void set(int index, Object data) {        if (index &gt; this.count) {            return;        }        this.foot = 0; // 重置foot,作为索引        this.root.setNode(index, data); // Node进行修改数据    }    // 判断删除节点是否为root    public void remove(Object data) {        if (this.contains(data)) { // 判断数据是否存在            if (data.equals(this.root.data)) { // 判断数据是否是root数据                this.root = this.root.next;            } else {                // root是Node对象，此处直接访问内部类私有操作                this.root.next.removeNode(this.root, data);            }            this.count--; // 删除后数据个数减少        }    }    public Object[] toArray() {        if (this.root == null) {            return null;        }        this.foot = 0; // 需要脚标控制        this.retArray = new Object[this.count]; // 根据保存内容开辟数组        this.root.toArrayNode();        return this.retArray;    }}</code></pre><p><strong>范例</strong>: 测试程序</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link all = new Link();        all.add(&quot;A&quot;);        all.add(&quot;B&quot;);        all.add(&quot;C&quot;);        System.out.println(all.size());        all.remove(&quot;B&quot;);        Object[] data = all.toArray();        for (int x = 0; x &lt; data.length; x++) {            String str = (String) data[x];            System.out.println(str);        }    }}</code></pre><h3 id="综合实战-宠物商店"><a class="markdownIt-Anchor" href="#综合实战-宠物商店"></a> 综合实战: 宠物商店</h3><p><strong>要求</strong>: 以程序结构为主,实现一个宠物商店的模型,具有保存多个宠物的信息(名字,年龄),宠物上架、下架、模糊查询功能。<br><strong>思路图</strong>：<br><img src="/article/Java/Java Base/Java基础知识(十四)/20-1.png" alt="无法加载" title="思路图"><br>宠物商店的商品（宠物）要符合宠物这一标准（接口），宠物商店借助链表实现上架、下架和模糊查询功能。<br><strong>范例</strong>：定义宠物的标准</p><pre class="highlight"><code class="">interface Pet { // 定义宠物的标准    public String getName();    public int getAge();}</code></pre><p>宠物商店与具体的宠物无关，只和宠物这一接口有联系。<br><strong>范例</strong>：定义宠物商店</p><pre class="highlight"><code class="">class PetShop {    private Link pets = new Link(); // 要保存的宠物信息    public void add(Pet pet) { // 上架        this.pets.add(pet);    }    public void delete(Pet pet) { // 下架        this.pets.remove(pet);    }    public Link search(String keyWord) { // 模糊查询，返回的内容个数不明        Link result = new Link();        // 将集合以数组的形式返回，        // 真正要查询的数据是Pet接口对象的getName()的返回值        Object obj[] = this.pets.toArray();        for (int x = 0; x &lt; obj.length; x++) {            Pet p = (Pet) obj[x];            if (p.getName().contains(keyWord)) {                result.add(p);            }        }        return result;    }}</code></pre><p><strong>范例</strong>： 定义猫类</p><pre class="highlight"><code class="">class Cat implements Pet {    private String name;    private int age;    public Cat(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public boolean equals(Object obj) {        if (this == obj) {            return true;        }        if (obj == null) {            return false;        }        if (!(obj instanceof Cat)) {            return false;        }        Cat cat = (Cat) obj;        if (this.name.equals(cat.name)                &amp;&amp; this.age == cat.age) {            return true;        }        return false;    }    public String toString() {        return &quot;猫名：&quot; + this.name + &quot;, 年龄&quot; + this.age;    }}</code></pre><p>可参照上述结构，定义一个狗类。<br><strong>范例</strong>：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        PetShop shop = new PetShop();        shop.add(new Cat(&quot;阿猫&quot;, 9));        shop.add(new Cat(&quot;猫咪&quot;, 19));        shop.add(new Dog(&quot;阿狗&quot;, 10));        shop.add(new Dog(&quot;狗子&quot;, 8));        // 模糊查询        Link all = shop.search(&quot;阿&quot;);        Object obj[] = all.toArray();        for (int x = 0; x &lt; obj.length; x++) {            System.out.println(obj[x]);        }        shop.delete(new Dog(&quot;狗子&quot;, 8));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;object类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#object类&quot;&gt;&lt;/a&gt; Object类&lt;/h2&gt;
&lt;p&gt;Object类用于统一对象、数组和接口。&lt;/p&gt;
&lt;h3 id=&quot;object类基本描述&quot;&gt;&lt;a class=&quot;m
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十三)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%89)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十三)/</id>
    <published>2017-10-28T12:06:18.603Z</published>
    <updated>2017-10-28T12:25:13.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><h3 id="接口的基本定义"><a class="markdownIt-Anchor" href="#接口的基本定义"></a> 接口的基本定义</h3><p>1、<code>接口</code>是只由抽象方法和全局变量组成的类,使用<code>interface</code>关键字定义。</p><pre class="highlight"><code class="">interface A { // 定义接口    public static final String MSG = &quot;Hello&quot;; // 全局常量    public abstract void print(); // 抽象方法}</code></pre><p>由于接口中存在抽象方法，因此接口对象不能直接实例化，其使用原则如下：</p><blockquote><p>（1）接口必须要有子类，子类可以使用implements关键字实现多接口；<br>（2）接口的子类（非抽象类时），必须对接口的抽象方法进行覆写；<br>（3）接口的对象可以利用子类对象通过向上转型实现实例化。</p></blockquote><pre class="highlight"><code class="">interface A { // 定义接口    public static final String MSG = &quot;Hello&quot;; // 全局常量    public abstract void print(); // 抽象方法}interface B {    public abstract void get();}class X implements A, B { // X 实现A和B两个接口    public void print() {        System.out.println(&quot;A.抽象方法&quot;);    }    public void get() {        System.out.println(&quot;B.抽象方法&quot;);    }}public class Demo {    public static void main(String[] args) {        X x = new X(); // 实例化子类对象        A a = x; // 向上转型        B b = x; // 向上转型        a.print();        b.get();    }}</code></pre><p>X是A和B的子类，因此X的对象可以变为A或者B接口的对象。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        A a = new X();        B b = (B) a;        b.get(); // B.抽象方法        System.out.println(a instanceof A); // true        System.out.println(b instanceof B); // true    }}</code></pre><p>从结构上来说，A和B接口没有直接关系，但是两个接口拥有共同的子类X，最终实例化的是X，这个子类向上转型为B类对象，因此代码可以执行。<br>2、子类同时继承类和接口时，语法:<code>class X extends A implements B {}</code><br>接口的组成只有抽象方法和全局变量，因此可以不写<code>abstract</code>和<code>public static final</code>,并且方法是否使用<code>public</code>定义都是一样的，因为接口只能使用<code>public</code>权限。</p><pre class="highlight"><code class="">|interface A{     public static final String MSG = &quot;Hello&quot;; //全局常量public abstract void print(); //抽象方法}|interface A{    String MSG = &quot;Hello&quot;; //全局常量void print(); //抽象方法}</code></pre><p>上述代码是等价的。在接口中，<strong>默认访问权限为<code>public</code></strong>，而不是<code>default</code>。但开发时，定义接口中的方法时要写上public。<br>3、一个抽象类只能继承一个抽象类，但一个接口可以使用<code>extends</code>关键字同时继承多个接口，接口不能继承抽象类。</p><pre class="highlight"><code class="">interface A {    public void funA();}interface B {    public void funB();}interface C extends A, B {    public void funC();}class X implements C {    public void funA() {    }    public void funB() {    }    public void funC() {    }}</code></pre><p>从继承上来说，抽象类的限制比接口多：</p><blockquote><p>（1）一个抽象类只能继承一个抽象父类，而接口没有该限制；<br>（2）一个子类只能继承一个抽象类，但可以实现多接口。</p></blockquote><p>因此Java中接口的功能是<strong>解决单继承限制</strong>。<br>4、从概念而言，接口只能由<code>抽象方法和全局变量</code>组成。但接口中可以定义<code>普通内部类、抽象内部类、内部接口</code>。这些内部接口不受接口的概念限制。</p><pre class="highlight"><code class="">interface A {    public void funA();    abstract class B { // 定义抽象内部类        public abstract void funB();    }}class X implements A { // X实现A接口    public void funA() {    }    class Y extends B { // 抽象内部类的子类        public void funB() {        }    }}</code></pre><p>上述代码形式，几乎不会用到。<br>5、在接口中使用<code>static</code>定义一个内部接口，相当于外部接口。</p><pre class="highlight"><code class="">interface A {    public void funA();    static interface B { // 相当于外部接口        public void funB();    }}class X implements A.B { // X实现B接口    public void funB() {    }}</code></pre><blockquote><p>总结：<br>接口在实际开发中的三大作用：<br>（1）定义不同层之间的操作标准；<br>（2）表示一种操作的能力；<br>（3）表示将服务器端的远程方法视图暴露给客户端。</p></blockquote><h3 id="定义标准"><a class="markdownIt-Anchor" href="#定义标准"></a> 定义标准</h3><p><img src="/article/Java/Java Base/Java基础知识(十三)/19-1.png" alt="无法加载" title="定义标准"><br>根据上图编写代码：电脑利用USB接口标准和其他设备关联。<br><strong>范例</strong>：定义USB标准</p><pre class="highlight"><code class="">// 标准可以连接不同层的操作类interface USB { // 接口就是标准    public void start();    public void stop();}</code></pre><p><strong>范例</strong>：定义电脑</p><pre class="highlight"><code class="">class Computer{    public void plugin(USB usb){ // 插入USB设备        usb.start();        usb.stop();    }}</code></pre><p>不论是什么设备，只要实现了USB标准，就可以在电脑上使用。<br><strong>范例</strong>：定义U盘</p><pre class="highlight"><code class="">class Flash implements USB {    public void start() {        System.out.println(&quot;U盘开始使用&quot;);    }    public void stop() {        System.out.println(&quot;U盘停止使用&quot;);    }}</code></pre><p><strong>范例</strong>：定义打印机</p><pre class="highlight"><code class="">class Print implements USB {    public void start() {        System.out.println(&quot;打印机开始使用&quot;);    }    public void stop() {        System.out.println(&quot;打印机停止使用&quot;);    }}</code></pre><p><strong>范例</strong>：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Computer com = new Computer();        com.plugin(new Flash());        com.plugin(new Print());    }}</code></pre><p>Java中，<strong>标准就是被定义为接口</strong>。</p><h3 id="工厂设计模式"><a class="markdownIt-Anchor" href="#工厂设计模式"></a> 工厂设计模式</h3><pre class="highlight"><code class="">interface Fruit {    public void eat();}class Apple implements Fruit {    public void eat() {        System.out.println(&quot;吃苹果&quot;);    }}</code></pre><p>上述代码通过主方法可以取得Fruit对象，但存在如下问题：</p><blockquote><p>附：要确定代码是否合理，标准如下：<br>（1）客户端调用简单，不用关注具体实现；<br>（2）客户端之外的代码修改，不影响用户的使用，即用户不用关注代码的变更。</p></blockquote><p>由上述标准可知该程序的问题是一个接口不一定只有子类，现在添加一个Fruit子类：</p><pre class="highlight"><code class="">class Orange implements Fruit {    public void eat() {        System.out.println(&quot;吃橘子&quot;);    }}</code></pre><p>客户端要使用这个新子类，需要修改代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Fruit f = new Orange ();        f.eat(); // 吃橘子    }}</code></pre><p>在上述代码，我们最关注的是如何获得Fruit对象,之后进行方法调用。至于该对象是怎么实例的,不是客户端的工作。<br>1、上述程序中，客户端每次更换对象，就需要修改主方法的代码，这不符合标准。该问题的关键在于<code>new</code>的使用，这种问题是因为<code>耦合度太高（两者联系程度太高）</code>。<strong>耦合度太高，代码不便于维护</strong>。</p><blockquote><p>解决思路：参考Java虚拟机的设定-程序→JVM→适应不同的操作系统。</p></blockquote><p><strong>范例</strong>：增加一个过渡</p><pre class="highlight"><code class="">class Factory { // 工厂设计模式    public static Fruit getInstance(String className) {        if (&quot;apple&quot;.equals(className)) {            return new Apple();        } else if (&quot;orange&quot;.equals(className)) {            return new Orange();        } else {            return null;        }    }}public class Demo {    public static void main(String[] args) {        Fruit f = Factory.getInstance(&quot;apple&quot;);        f.eat(); // 吃苹果    }}</code></pre><p>此时，所有子类对于客户端是不可见的，因为Fruit对象的实例化是通过Factory对象获取的，日后扩充Fruit子类时，只需修改Factory即可，不用修改客户端代码。<br><img src="/article/Java/Java Base/Java基础知识(十三)/19-2.png" alt="无法加载" title="工厂设计模式"><br>上图描述的是工厂设计模式，客户端可见的只有接口和Factory。</p><h3 id="代理设计模式"><a class="markdownIt-Anchor" href="#代理设计模式"></a> 代理设计模式</h3><p><img src="/article/Java/Java Base/Java基础知识(十三)/19-3.png" alt="无法加载" title="代理设计模式"><br>代理设计模式的核心在于有一个主题操作接口（可能有很多接口），核心操作类只完成核心功能，而代理主题负责完成所有与核心操作有关的辅助性操作。<br>1、以<code>去餐馆吃饭为例</code>,外人只看到吃饭,看不到厨师和顾客。皇帝完成核心业务,厨师完成辅助业务。<br><img src="/article/Java/Java Base/Java基础知识(十三)/19-4.png" alt="无法加载" title="去餐馆吃饭"></p><pre class="highlight"><code class="">package com.java.demo;interface Subject {  // 核心业务    public void eat();}class RealSubject implements Subject {   // 实际进行核心业务的对象    public void eat() {        System.out.println(&quot;顾客在吃饭&quot;);    }}class ProxySubject implements Subject {  // 执行代理操作的对象    private Subject subject;  // 接收进行核心业务的对象    public ProxySubject(Subject subject) {        this.subject = subject;    }    public void prepared() {        System.out.println(&quot;为吃做准备&quot;);    }    public void eat() {        this.prepared();        this.subject.eat();        this.destory();    }    public void destory() {        System.out.println(&quot;为吃收尾&quot;);    }}public class Demo {    public static void main(String[] args) {        Subject sub = new ProxySubject(new RealSubject());        sub.eat();  // 调用代理操作    }}</code></pre><h3 id="接口与抽象类的区别"><a class="markdownIt-Anchor" href="#接口与抽象类的区别"></a> 接口与抽象类的区别</h3><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">区别</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">关键字</td><td>abstract class</td><td>interface</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">组成</td><td>构造方法、普通方法、抽象方法、static方法、变量、常量</td><td>抽象方法，全局常量</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">子类使用</td><td>class 子类 extends 抽象类</td><td>class 子类implements 接口,接口…</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">关系</td><td>抽象类可以实现多接口</td><td>接口不能继承抽象类，却可以继承多个接口</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">权限</td><td>可以使用任意权限</td><td>只能使用public权限</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">限制</td><td>单继承局限</td><td>没有单继承局限</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">子类</td><td>抽象类和接口都必须有子类，子类必须要覆写全部抽象方法</td><td>抽象类和接口都必须有子类，子类必须要覆写全部抽象方法</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">实例化对象</td><td>依靠子类对象的向上转型进行对象的实例化</td><td>依靠子类对象的向上转型进行对象的实例化</td></tr></tbody></table><p>经过比较发现，抽象类存在单继承限制，因此当抽象类和接口都可以使用时，优先考虑接口。</p><blockquote><p>（1）当进行公共操作时，要定义接口；<br>（2）有了接口就需要使用子类完善方法<br>（3）自定义的接口，不能直接实例化接口子类，应使用工厂设计模式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#接口&quot;&gt;&lt;/a&gt; 接口&lt;/h2&gt;
&lt;h3 id=&quot;接口的基本定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#接口的基本定义&quot;&gt;&lt;/a&gt; 接口的基本定义&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十二)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%BA%8C)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十二)/</id>
    <published>2017-10-23T12:21:57.952Z</published>
    <updated>2017-10-24T07:25:08.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辅助概念"><a class="markdownIt-Anchor" href="#辅助概念"></a> 辅助概念</h2><h3 id="关键字final"><a class="markdownIt-Anchor" href="#关键字final"></a> 关键字final</h3><p>Java中，<code>final</code>被称为终结器，可以用于定义类、方法、属性，具有如下特点：<br>1、final定义的类不能有子类</p><pre class="highlight"><code class="">final class A{}class B extends A{} //报错，无法继承A类</code></pre><p>开发系统类或者进行一些架构代码开发时使用到<code>final</code>定义类。<br>2、final定义的方法不能被方法覆写<br>父类中某些方法具备某种隐藏的特性，或子类必须使用该方法时，使用final定义，意思是子类不要破坏父类中该方法的结构。</p><pre class="highlight"><code class="">class A{    public final void fun(){}}class B extends A{    public void fun(){} // 报错，无法覆写方法}</code></pre><p>3、final定义的变量就成了常量。常量必须在定义时设置好值，且不能修改。</p><pre class="highlight"><code class="">class A {    final double GOOD = 100.0;    public void fun() {        GOOD = 200; // 无法修改常量GOOD的值    }}</code></pre><p>用final定义变量，就可以使用变量名来描述一些数据。开发中常量名均为大写，变量名首个单词小写，之后的单词首字母大写。<br>4、全局常量：public static final 声明的变量就是全局常量:</p><pre class="highlight"><code class="">public static final String MSG = &quot;MLDN&quot;;</code></pre><p>static数据存在公共数据区，因此MSG是一个公共常量。</p><blockquote><p>总结：<br>（1）final定义的类和方法不能继承，不能覆写；<br>（2）public static final 定义的是全局常量，常量名全部大写。</p></blockquote><h3 id="对象多态性"><a class="markdownIt-Anchor" href="#对象多态性"></a> 对象多态性</h3><p>多态性依赖于方法覆写。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print(); // 覆写的方法    }}</code></pre><p>1、多态性分为两种：</p><pre class="highlight"><code class="">（1）方法的多态性|- 方法重载：同一个方法名，根据传入的参数类型或个数的不同，执行不同方法体；|- 方法覆写：同一个方法，根据对象所属的子类不同，执行不同方法体。（2）对象的多态性：指发生在具有继承关系的类中，父类与子类的转换。|- 向上转型（自动完成）：父类 父类对象 = 子类实例化;|- 向下转型（强制完成）：子类 子类对象 = （父类）父类实例化;</code></pre><p><strong>范例</strong>：向上转型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        A a = new B();        a.print(); // 覆写的方法    }}</code></pre><p><strong>范例</strong>：向下转型</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        B b = (B) new A(); // 向下转型        b.print(); // 覆写的方法    }}</code></pre><p>2、向上转型：由于子类对象都可以自动向上转型，所以可应用于参数的统一。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B覆写的方法&quot;);    }}class C extends A {    public void print() {        System.out.println(&quot;C覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a1 = new B(); // 向上转型        A a2 = new C(); // 向上转型        a1.print(); // B覆写的方法        a2.print(); // C覆写的方法    }}</code></pre><p>a1,a2参数统一后，还可以调用子类覆写的方法，即同一个方法针对不同子类可以有不同实现。<br>3、向下转型：父类发生向上转型后，不能调用子类中自定义的方法。因此当父类要调用子类自定义方法时，需要进行向下转型，将父类对象变为子类对象。</p><pre class="highlight"><code class="">class A {}class B extends A {    public void fun() {        System.out.println(&quot;自定义方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        a.fun(); // 报错，无法调用B自定义方法    }}</code></pre><p>向下转型后，可以调用子类自定义的方法：</p><pre class="highlight"><code class="">class A {}class B extends A {    public void fun() {        System.out.println(&quot;自定义方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        B b = (B) a; // 向下转型        b.fun();    }}</code></pre><blockquote><p>问题：上述代码中不适用向下转型,直接实例化子类对象就可以直接调用fun(),为什么还要转型？<br>答：数据的操作分为两步：设置数据（最需要进行参数统一）和取出数据。</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        fun(new B()); // 向上转型    }    public static void fun(A a){ // 统一参数        B b = (B) a; // 向下转型        b.fun(); // 调用子类自定义方法    }}</code></pre><p>5、个性化操作在开发中尽量少出现，因为对象的强制转型容易带来安全隐患。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A.print()&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B.print()&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new A();        B b = (B) a;        b.print();    }}</code></pre><p>上述代码会报错,<code>Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at ExDemo.main(ExDemo.java:15)</code>，表示类转换异常，指的是两个没有关系的类对象强制进行向下转型时发生的异常，因此向下转型存在风险。<br>为保证转型的安全性，Java提供关键字<code>instanceof</code>,其返回结果为boolean:<code>对象 instanceof 类</code><br>如果某个对象是某个类的实例，则会返回true，反之返回false。</p><pre class="highlight"><code class="">class A {    public void print() {        System.out.println(&quot;A.print()&quot;);    }}class B extends A {    public void print() {        System.out.println(&quot;B.print()&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B();        System.out.println(a instanceof A); // true        System.out.println(a instanceof B); // true        if (a instanceof B) {            B b = (B) a;            b.print(); // B.print()        }    }}</code></pre><p>向下转型前应先进行对象的向上转型，建立关系后才能进行向下转型。</p><blockquote><p>总结：<br>（1）大多数情况只使用向上转型，使得参数统一，便于程序设计；子类尽量覆写方法，而不是自定义方法；<br>（2）极少情况使用向下转型调用子类的自定义方法，或者不转型。</p></blockquote><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>1、抽象类是含有抽象方法的类。抽象方法没有方法体，必须用<code>abstract</code>定义。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public void fun(){方法体;} // 普通方法    public abstract void print(); // 抽象方法}public class Demo {    public static void main(String[] args) {        A a = new A(); // 报错，A是抽象类，无法实例化    }}</code></pre><p>结果显示，<strong>无法直接实例化抽象类对象</strong>.普通类的对象实例化后,该对象可以调用类中的属性和方法.而抽象类中存在抽象方法,抽象方法没有方法体无法调用，因此无法产生实例化对象.<br>2、抽象类使用原则：</p><blockquote><p>（1）抽象类必须有子类；<br>（2）抽象类的子类（非抽象类时）必须覆写抽象类中所有的抽象方法（强制子类进行方法覆写）<br>（3）抽象类对象的实例化依靠子类完成，采用向上转型方式。</p></blockquote><p><strong>范例</strong>：使用抽象类</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public void fun() { // 普通方法        System.out.println(&quot;普通方法&quot;);    }    public abstract void print(); // 抽象方法}class B extends A {    // 强制要求对抽象方法进行覆写，否则会报错    public void print() {        System.out.println(&quot;覆写后的抽象方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A a = new B(); // 向上转型        a.fun();        a.print();    }}</code></pre><p>由上述代码，可知：</p><blockquote><p>（1）抽象类的子类明确要求方法覆写，而普通类没有；<br>（2）抽象类只比普通类多了抽象方法，其他部分相同；<br>（3）抽象类对象必须经过向上转型才能实例化；<br>（4）虽然子类可以继承任何类，但开发中，普通类最好继承抽象类。</p></blockquote><h3 id="使用限制"><a class="markdownIt-Anchor" href="#使用限制"></a> 使用限制</h3><p>1、抽象类由于存在属性，因此会有构造方法来初始化属性。子类对象实例化时依然先执行父类构造方法，再调用子类构造方法。<br>2、抽象类不能使用final定义，因为抽象类必须有子类。<br>3、抽象外部类不允许使用<code>static</code>定义，而抽象内部类可以使用<code>static</code>声明。使用<code>static</code>定义的抽象内部类相当于抽象外部类，继承时使用<code>外部类.内部类</code>的形式表示类名。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    static abstract class B {        public abstract void print();    }}class X extends A.B {    public void print() {        System.out.println(&quot;*****&quot;);    }}public class Demo {    public static void main(String[] args) {        A.B ab = new X(); // 向上转型        ab.print();    }}</code></pre><p>4、<code>static</code>定义的方法可以没有实例化对象的情况下直接调用，即使是抽象类中的static方法。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public static void print() {        System.out.println(&quot;static方法&quot;);    }}public class Demo {    public static void main(String[] args) {        A.print(); // static方法        A a = new A() ; // 报错    }}</code></pre><p>5、有时抽象类只需要一个特定的子类操作，因此可以将该子类定义为该抽象类的内部类。</p><pre class="highlight"><code class="">abstract class A { // 抽象类    public abstract void print();    private static class B extends A { // 内部抽象类子类        public void print() {            System.out.println(&quot;Hello&quot;);        }    }    public static A getInstance() { // 获取B的实例化对象        return new B();    }}public class Demo {    public static void main(String[] args) {        // 客户端得到抽象类对象时，B对其不可见        A a = A.getInstance();        a.print();    }}</code></pre><p>上述设计在系统类库中较为常见，目的是：为用户隐藏不需要知道的子类。<br>6、观察下述代码：</p><pre class="highlight"><code class="">abstract class A { // 抽象类    // 1. 先调用父类构造    public A() {        this.print();    }    public abstract void print();}class B extends A {    private int num = 100;    // 3.调用子类构造，并初始化num = 30.运行结束，未输出初始化后的num    public B(int num) {        this.num = num;    }    // 2. 父类构造调用子类的print，此时num = 0,打印输出。    public void print() {        System.out.println(&quot;num = &quot; + num);    }}public class Demo {    public static void main(String[] args) {        new B(30); // 4. 结果为0    }}</code></pre><p>在构造方法执行完之前，属性的内容均为其对应的数据类型的默认值。子类在执行构造方法前必先执行父类的构造方法，因为此时子类构造方法还没执行，就调用<code>print()</code>输出了num的值，所以num为<code>0</code>.</p><h3 id="模板设计模式"><a class="markdownIt-Anchor" href="#模板设计模式"></a> 模板设计模式</h3><blockquote><p>要求：设计三个类，通过类描述如下行为：<br>（1）机器人：充电、工作；<br>（2）人：吃饭、工作、睡觉；<br>（3）猪：吃饭、睡觉<br><strong>思路</strong>：定义一个抽象类，具有吃饭、睡觉、工作的抽象方法。根据子类的不同，具体实现抽象方法。<br><img src="/article/Java/Java Base/Java基础知识(十二)/18-2.png" alt="无法加载" title="思路图"></p></blockquote><pre class="highlight"><code class="">abstract class Action {    public static final int EAT = 1;    public static final int SLEEP = 5;    public static final int WORK = 7;    public void command(int flag) {        switch (flag) {            case EAT:                this.eat();                break;            case SLEEP:                this.sleep();                break;            case WORK:                this.work();                break;            case EAT + WORK:                this.eat();                this.work();                break;        }    }    // 不确定方法中的具体行为，定义为抽象类    public abstract void eat();    public abstract void sleep();    public abstract void work();}</code></pre><p><strong>定义子类</strong>：</p><pre class="highlight"><code class="">class Robot extends Action {    public void eat() {        System.out.println(&quot;机器人正在补充能量&quot;);    }    public void sleep() {    }    public void work() {        System.out.println(&quot;机器人正在工作&quot;);    }}class Human extends Action {    public void eat() {        System.out.println(&quot;人正在吃饭&quot;);    }    public void sleep() {        System.out.println(&quot;人正在睡觉&quot;);    }    public void work() {        System.out.println(&quot;人正在工作&quot;);    }}class Pig extends Action {    public void eat() {        System.out.println(&quot;猪正在吃饭&quot;);    }    public void sleep() {        System.out.println(&quot;猪正在睡觉&quot;);    }    public void work() {    }}</code></pre><p><strong>范例</strong>：测试程序</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        fun(new Robot());        fun(new Human());        fun(new Pig());    }    public static void fun(Action act) {        act.command(Action.EAT);        act.command(Action.SLEEP);        act.command(Action.WORK);    }}</code></pre><p>结果显示：子类要实现操作，必须按照Action类的标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辅助概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#辅助概念&quot;&gt;&lt;/a&gt; 辅助概念&lt;/h2&gt;
&lt;h3 id=&quot;关键字final&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键字final&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用IDEA将SpringBoot打包成war</title>
    <link href="http://yov.oschina.io/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/%E4%BD%BF%E7%94%A8IDEA%E5%B0%86SpringBoot%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/"/>
    <id>http://yov.oschina.io/article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/</id>
    <published>2017-10-22T12:33:06.711Z</published>
    <updated>2017-10-22T12:48:32.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改pomxml"><a class="markdownIt-Anchor" href="#修改pomxml"></a> 修改pom.xml</h2><h3 id="将package格式改为war"><a class="markdownIt-Anchor" href="#将package格式改为war"></a> 将package格式改为war</h3><pre class="highlight"><code class="">&lt;groupId&gt;com&lt;/groupId&gt;&lt;artifactId&gt;demo&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;</code></pre><h3 id="排除内置tomcat"><a class="markdownIt-Anchor" href="#排除内置tomcat"></a> 排除内置tomcat</h3><pre class="highlight"><code class="">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="打包过程跳过测试"><a class="markdownIt-Anchor" href="#打包过程跳过测试"></a> 打包过程跳过测试</h3><pre class="highlight"><code class="">&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;skip&gt;true&lt;/skip&gt;&lt;/configuration&gt;&lt;/plugin&gt;</code></pre><h2 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h2><p>打开IDE右侧边栏的<code>Maven Projects</code></p><pre class="highlight"><code class="">demo |- Lifecycle |- clean |- validate |- compile |- test |- package |- verify |- install |- site |- deploy |- Plugins |- Dependencies</code></pre><p>双击<code>package</code>即可开始打包，打包后,会在项目文件<code>target</code>中。</p><h2 id="发布war包"><a class="markdownIt-Anchor" href="#发布war包"></a> 发布war包</h2><p>删除tomcat下webapps中的文件,将文件war包文件复制放入。点击tomcat中bin文件夹下的startup.bat，此时便可进行访问localhost查看SpringBoot。</p><pre class="highlight"><code class="">  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v1.5.8.RELEASE)20:45:57 CST 2017]; root of context hierarchy2017-10-22 20:46:01.008  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello],methods=[GET]}&quot; onto public java.lang.String com.demo.DemoApplication.hello()2017-10-22 20:46:01.016  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-10-22 20:46:01.030  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView 2017-10-22 20:46:01.635  INFO 5972 --- [ost-startStop-1] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2017-10-22 20:46:01.687  INFO 5972 --- [ost-startStop-1] com.demo.DemoApplication                 : Started DemoApplication in 5.963 seconds (JVM running for 11.781)2017-10-22 20:46:02.385  WARN 5972 --- [ost-startStop-1] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [682] milliseconds.application archive E:\apache-tomcat-8.0.45\webapps\ROOT.war has finished in 10,051 ms22-Oct-2017 20:46:02.430 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8888&quot;]22-Oct-2017 20:46:02.454 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]22-Oct-2017 20:46:02.468 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 10192 ms</code></pre><p>在上述信息中，告诉了我们可以访问的端口为8888.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改pomxml&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#修改pomxml&quot;&gt;&lt;/a&gt; 修改pom.xml&lt;/h2&gt;
&lt;h3 id=&quot;将package格式改为war&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="框架" scheme="http://yov.oschina.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
      <category term="框架" scheme="http://yov.oschina.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十一)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%80)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十一)/</id>
    <published>2017-10-22T07:53:56.490Z</published>
    <updated>2017-10-22T08:29:57.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承性"><a class="markdownIt-Anchor" href="#继承性"></a> 继承性</h2><blockquote><p>继承性的作用是解决代码重用问题。</p></blockquote><h3 id="继承问题的引出"><a class="markdownIt-Anchor" href="#继承问题的引出"></a> 继承问题的引出</h3><p>范例:定义两个类Person和Student</p><pre class="highlight"><code class="">class Person{private String name;private int age;public void setName(String name){this.name = name;}public void setAge(int age){this.age = age;}public String getName(){return this.name; }public int getAge(){return this.age;}}class Student{    private String name;private int age;private String school;public void setName(String name){this.name = name;}public void setAge(int age){this.age = age;}public void setSchool(String school){this.school = school;}public String getName(){return this.name; }public int getAge(){return this.age;}public String getSchool(){return this.school; }}</code></pre><p>由代码可见Studen和Person存在代码重复。在自然关系上，Student是Person的一种，只是Student描述的更细致，范围更小。</p><h3 id="实现继承"><a class="markdownIt-Anchor" href="#实现继承"></a> 实现继承</h3><p>继承使用关键字<code>extends</code>实现，语法如下：<code>class 子类 extends 父类{}</code><br>子类也被称为<code>派生类</code>，父类也被称为<code>基类、超类或super类</code>。<br><strong>范例</strong>：实现继承</p><pre class="highlight"><code class="">class Person { // 父类    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}class Student extends Person { // 继承Person类}public class Demo {    public static void main(String[] args) {        Student stu = new Student();        stu.setName(&quot;张三&quot;);        stu.setAge(18);        System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;,年龄：&quot; + stu.getAge());    }}</code></pre><p>Student继承了Person，可以使用Person类中的方法。<br><strong>范例</strong>：在Student中添加属性和方法</p><pre class="highlight"><code class="">class Student extends Person { // 继承Person类    private String school;    public String getSchool() {        return school;    }    public void setSchool(String school) {        this.school = school;    }}</code></pre><p>由上述代码，可知继承性的优点：</p><blockquote><p>（1）子类可以直接使用父类的属性和方法，进行代码重用；<br>（2）子类可以扩充属于自己的操作。</p></blockquote><h3 id="继承的限制"><a class="markdownIt-Anchor" href="#继承的限制"></a> 继承的限制</h3><p><strong>Java中继承存在如下限制：</strong><br>1、Java不允许多重继承，但允许多层继承。<br>C++允许多继承，即一个子类可以同时继承多个父类。但该操作在Java中是不允许的。多继承是为了使子类可以同时拥有多个父类的操作。Java中使用多层继承替代，语法如下：</p><pre class="highlight"><code class="">class A{}class B extends A{}class C extends B{}</code></pre><p>相当于C是B的子类，是A的孙子类。多层继承没有层数限制，但最好不超过三层。<br>2、子类继承父类时，会继承父类全部操作。对于私有操作属于隐式继承，对于非私有操作属于显式继承。</p><pre class="highlight"><code class="">class A {    private String msg;    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }}class B extends A {}public class Demo {    public static void main(String[] args) {        B b = new B();        b.setMsg(&quot;Hello&quot;);        System.out.println(b.getMsg()); // Hello    }}</code></pre><p>上述代码显示B类中也存在属性msg,因为如果msg不存在，setMsg()设置的内容就不能保存，即getMsg()无法输出内容。</p><pre class="highlight"><code class="">class B extends A {    public void fun() {        System.out.println(msg); // 报错，无法访问    }}</code></pre><p>但是在B类中无法直接访问msg，因为msg是A类的私有属性，只能间接访问。<br>3、在实例化子类对象之前，会先调用父类构造方法（默认是无参构造方法），以保证父类对象先实例化，而后在实例化子类对象。</p><pre class="highlight"><code class="">class A {    public A() {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B() {        System.out.println(&quot;B 构造方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        // A 构造方法        // B 构造方法    }}</code></pre><p>由结果可知，在实例化子类对象前，会先实例化父类对象。对于子类构造方法来说相当于隐藏一个”super()”.</p><pre class="highlight"><code class="">class B extends A {    public B() {        super(); // 父类有无参构造方法时，加不加都一样        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><blockquote><p>何时要在子类构造方法中添加super()：如果父类中没有无参构造方法，就必须使用super调用父类的有参构造方法。</p></blockquote><pre class="highlight"><code class="">class A {    public A(String title) {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B() {        // 子类默认调用无参构造，但A中没有无参构造        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p>上述代码执行后，不会调用A中的有参构造，因此需要在B类中的构造方法添加super():</p><pre class="highlight"><code class="">class A {    public A(String title) {        System.out.println(&quot;A 构造方法&quot;);    }}class B extends A {    public B(String title) {        super(title);        System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p><code>super()</code>必须放在子类构造方法的第一行。而<code>this()</code>也应该放在构造方法的首行。</p><blockquote><p><strong>问题：子类构造方法未添加super()，系统默认使用super()调用父类的无参构造方法。如果在子类构造方法中添加this()，那么子类是不是无法调用父类构造方法？</strong></p></blockquote><pre class="highlight"><code class="">class B extends A {    public B() { // 报错，构造递归调用        this();         System.out.println(&quot;B 构造方法&quot;);    }}</code></pre><p>由结果可知，super()和this()不能同时存在。不论子类怎么修改，子类构造方法执行前都必须先执行父类的构造方法。</p><h3 id="方法覆写"><a class="markdownIt-Anchor" href="#方法覆写"></a> 方法覆写</h3><p>继承性的特点是子类可以对父类已有的功能进行扩展。子类在定义属性或方法时有可能与父类重名，该操作就称为覆写。<br>1、<strong>方法覆写</strong>：子类定义一个与父类方法的方法名、参数类型及个数、返回值都相同的方法。</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // A中的方法    }}</code></pre><p>此时B中没有fun()，所以调用的是从A继承的fun().<br><strong>范例</strong>：方法覆写</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void fun(){ // 方法覆写        System.out.println(&quot;覆写的方法&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // 覆写的方法    }}</code></pre><p>当方法覆写后，此时会调用子类中覆写的方法。<br>2、覆写结果的分析要素：</p><blockquote><p>（1）实例化的是那个类；<br>（2）该对象调用的方法是否被覆写，如果未覆写将调用父类中的方法。</p></blockquote><pre class="highlight"><code class="">class B extends A {    public String fun(){         System.out.println(&quot;覆写的方法&quot;);        // 报错，B中fun()无法覆盖A中fun()，返回类型不兼容        return &quot;Hello&quot;;    }}</code></pre><p><strong>进行方法覆写时，不能改变方法中的返回值和参数个数。</strong><br>3、方法覆写的使用原则：父类方法不能满足子类需求，但又必须使用该方法名时，要进行方法覆写。<br>方法覆写时还要考虑到权限问题，被子类覆写的方法不能拥有比父类更高的访问控制权限。</p><blockquote><p>访问控制权限：public&gt;default&gt;private，private的访问权限最严格。即如果父类方法使用public方法，子类覆写此方法时，只能使用public。父类使用的是default，子类覆写时，只能用default或public.</p></blockquote><p><strong>范例</strong>：正确覆写</p><pre class="highlight"><code class="">class A {    void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    public void fun(){        System.out.println(&quot;覆写的方法&quot;);    }}</code></pre><p><strong>错误覆写</strong>：</p><pre class="highlight"><code class="">class A {    public void fun() {        System.out.println(&quot;A中的方法&quot;);    }}class B extends A {    void fun(){        System.out.println(&quot;覆写的方法&quot;);        // 报错，正在尝试分配更低权限。    }}</code></pre><p>上述代码中子类使用default，比public权限更严格，不符合方法覆写原则。</p><blockquote><p>问题：父类方法使用private声明，子类使用public声明该方法，是覆写吗？<br>答：从概念上，private声明权限高于public，因此从权限上而言符合覆写的要求。观察下述代码：</p></blockquote><pre class="highlight"><code class="">class A {    public void fun() {        print();    }    private void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // Hello    }}</code></pre><p>从上述代码来看，子类并没有覆写print()，因为使用private定义的方法对于子类而言是不可见，因此子类定义的print()虽然符合覆写的要求，但是实际只是相当于定义了一个全新的方法，而不是方法覆写。而正确的覆写结果应该如下：</p><pre class="highlight"><code class="">class A {    public void fun() {        print();    }    public void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.fun(); // World    }}</code></pre><p>5、默认情况下，子类对象调用是一定是覆写后的方法。</p><pre class="highlight"><code class="">class A {    public void print(){        System.out.println(&quot;Hello&quot;);    }}class B extends A {    public void print(){        print();  // 等同于this.print()        System.out.println(&quot;World&quot;);    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print(); // 报错，方法递归调用，死循环    }}</code></pre><p>上述代码中，B类会优先调用B中print()，因此发生了递归调用。如果B中没有print()，则会调用父类中的。<br><strong>范例</strong>：调用父类中方法<code>super.方法名()</code></p><pre class="highlight"><code class="">class B extends A {    public void print(){        super.print();        System.out.println(&quot;World&quot;);    }}</code></pre><blockquote><p><strong>super.方法名()与this.方法名()的区别：</strong><br>（1）this.方法名()会优先查找本类中是否有目标方法，如果有则直接调用，没有就继续在父类中查找。<br>（2）super.方法名()会直接在父类中查找目标方法，不会在子类中查找。</p></blockquote><blockquote><p><strong>问题：请说明重载（overloading）和覆写（override）的区别</strong></p></blockquote><table><thead><tr><th>No.</th><th>区别</th><th>重载</th><th>覆写</th></tr></thead><tbody><tr><td>1</td><td>英文单词</td><td>Overloading</td><td>Overrid</td></tr><tr><td>2</td><td>发生范围</td><td>发生在一个类中</td><td>发生在继承关系中</td></tr><tr><td>3</td><td>定义</td><td>方法名相同，参数类型及个数不相同</td><td>方法名称、参数类型及个数，方法返回值都相同</td></tr><tr><td>4</td><td>权限</td><td>没有权限限制</td><td>被覆写的方法不能拥有比父类更严格的权限</td></tr></tbody></table><p>在方法重载时，返回值可以不同，但为了程序设计的统一性，应尽量保证返回值类型一致。</p><h3 id="属性覆写"><a class="markdownIt-Anchor" href="#属性覆写"></a> 属性覆写</h3><p>1、子类定义了与父类完全相同的属性名时，称为属性覆写。</p><pre class="highlight"><code class="">class A {    String info = &quot;Hello&quot;;}class B extends A {    String info = &quot;World&quot;;    public void print(){        System.out.println(super.info); // 调用父类属性        System.out.println(this.info);  // 调用本类属性    }}public class Demo {    public static void main(String[] args) {        B b = new B();        b.print();    }}</code></pre><p>由于在开发中，类的属性必须封装，而封装后，属性覆写就没有意义。因为父类定义的私有属性，子类不可见，因此不会互相影响。</p><blockquote><p><strong>问题：super和this的区别</strong></p></blockquote><table><thead><tr><th>No.</th><th>区别</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>功能</td><td>调用本类中的操作</td><td>子类调用父类中的操作</td></tr><tr><td>2</td><td>形式</td><td>先从本类查找目标操作,再从父类中查找</td><td>只查找父类</td></tr><tr><td>3</td><td>特殊</td><td>表示本类的当前对象</td><td>super不能单独使用</td></tr></tbody></table><p>在开发中，对于本类或父类的操作，最好加上this.或super.，这样便于代码调试。</p><h3 id="继承综合实战数组操作"><a class="markdownIt-Anchor" href="#继承综合实战数组操作"></a> 继承综合实战：数组操作</h3><blockquote><p>要求：定义Array类，在类中可以进行整型数组的操作：由外部传入数组的数据，可以进行数据的保存和输出，并且在这个类上派生出两个子类：<br>（1）排序类：通过此类取得的数据可以进行排序；<br>（2）反转类：通过此类取得的数据采用倒序的方式输出。<br>开发时，先不考虑子类，先开发父类。</p></blockquote><h4 id="根据要求定义父类array实现其操作"><a class="markdownIt-Anchor" href="#根据要求定义父类array实现其操作"></a> 根据要求定义父类Array，实现其操作。</h4><blockquote><p>思路：开辟好数组后，根据索引，一一存放数据。</p></blockquote><pre class="highlight"><code class="">class Array {    private int data[]; // 数组    private int foot; // 脚标    // 开辟数组空间    public Array(int len) {        if (len &gt; 0) {             this.data = new int[len];        } else { // 数组默认长度为1            this.data = new int[1];        }    }    // 为数组添加数据    public boolean add(int num) {        if (this.foot &lt; this.a[this.foot++] = num; // 保存数据            return true;        }        return false;    }    // 取得数组内容    public int[] getData() {        return this.data;    }}public class Demo {    public static void main(String[] args) {        Array array = new Array(3);        System.out.println(array.add(10)); // true        System.out.println(array.add(20)); // true        System.out.println(array.add(30)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><p>####定义子类。</p><blockquote><p>思路：将Array类getData()返回的结果进行排序输出即可，因此要覆写父类的方法。</p></blockquote><pre class="highlight"><code class="">// 定义一个排序数组的子类class SortArray extends Array {    // Array中没有无参构造方法，    // 需要明确调用父类的有参构造方法    public SortArray(int len) {        super(len);    }    // Array的getData()无法排序，进行方法覆写    public int[] getData() {        // 调用类库中的方法排序        java.util.Arrays.sort(super.getData());        return super.getData();    }}public class Demo {    public static void main(String[] args) {        SortArray array = new SortArray(3);        System.out.println(array.add(20)); // true        System.out.println(array.add(30)); // true        System.out.println(array.add(10)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><p>####定义反转子类，也要保持客户端操作不变，因此要覆写父类的方法。</p><pre class="highlight"><code class="">// 定义一个反转子类class ReverseArray extends Array {    public ReverseArray(int len) {        super(len);    }    public int[] getData() {        int center = super.getData().length / 2;        int head = 0;        int tail = super.getData().length - 1;        for (int x = 0; x &lt; center; x++) {            int temp = super.getData()[head];            super.getData()[head] = super.getData()[tail];            super.getData()[tail] = temp;            head++;            tail--;        }        return super.getData();    }}public class Demo {    public static void main(String[] args) {        ReverseArray array = new ReverseArray(3);        System.out.println(array.add(20)); // true        System.out.println(array.add(10)); // true        System.out.println(array.add(30)); // true        // 超出数组长度，false        System.out.println(array.add(40));        int[] temp = array.getData();        for (int x = 0; x &lt; temp.length; x++) {            System.out.println(temp[x]); // 10 20 30        }    }}</code></pre><blockquote><p><strong>总结</strong>：<br>子类扩充方法时，尽量根据需求覆写父类方法，而不是直接定义新方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承性&quot;&gt;&lt;/a&gt; 继承性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;继承性的作用是解决代码重用问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承问题的引出&quot;&gt;&lt;a c
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot小例子进阶</title>
    <link href="http://yov.oschina.io/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/SpringBoot%E5%B0%8F%E4%BE%8B%E5%AD%90%E8%BF%9B%E9%98%B6/"/>
    <id>http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子进阶/</id>
    <published>2017-10-21T05:42:31.770Z</published>
    <updated>2017-10-21T13:10:31.828Z</updated>
    
    <content type="html"><![CDATA[<p>本部分代码是基于<code>SpringBoot基础应用</code>博文的。</p><blockquote><p>代码结构如下：</p></blockquote><pre class="highlight"><code class="">demo   // 项目名|- .idea|- .mvn|- src  // 代码存放区   |- main       |- java         |- com.example.demo          // java包         |- aspect                 // 拦截器            |- HttpAspect.java              |- controller             // 控制器            |- PersonController            |- domain                 // 实体类            |- Person               |- Result              // 定义异常的响应信息的格式         |- enums            |- ResultEnum          // 定义异常的code和信息         |- exception              // 自定义异常            |- PersonException              |- handle                 // 捕获异常            |- ExceptionHandle          |- repository             // jpa操作            |- PersonRepository         |- service                // 处理业务逻辑            |- PersonService              |- DemoApplication.java   // 项目启动类      |- resources         |- static     // 用于存放css,js等样式文件         |- templates  // 用于存放html文件         application.properties  // 项目配置文件   |- test //测试代码存放区|- target.gitignoremvnwmvnw.cmddemo.imlpom.xml // 项目对象模型,添加项目依赖等配置</code></pre><h2 id="实现表单验证"><a class="markdownIt-Anchor" href="#实现表单验证"></a> 实现表单验证</h2><blockquote><p>要求： age小于18的数据无法入库</p></blockquote><h3 id="修改person类"><a class="markdownIt-Anchor" href="#修改person类"></a> 修改Person类</h3><pre class="highlight"><code class="">package com.example.demo.domain;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.validation.constraints.Min;@Entitypublic class Person {    @Id    @GeneratedValue    private Integer id;    private String name;    // @Min 使得该属性必须大于18,当数值小于18时,有提示信息    @Min(value = 18, message = &quot;年龄小于18无法添加&quot;)    private Integer age;    public Person() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><h3 id="修改personcontroller类addperson"><a class="markdownIt-Anchor" href="#修改personcontroller类addperson"></a> 修改PersonController类addPerson()</h3><pre class="highlight"><code class="">     /**     * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据     * @param person 要添加的person对象     * @param bindingResult 获取绑定结果信息     * @return 返回Person类信息     */    @PostMapping(value = &quot;/person&quot;)    public Person addPerson(@Valid Person person, BindingResult bindingResult) {    // 当输入数据不符合要求时,后台输出错误信息        if (bindingResult.hasErrors()) {            System.out.println(bindingResult.getFieldError().getDefaultMessage());            return null;        }        return  personRepository.save(person);    }</code></pre><p><code>@Valid</code>用于对传入的数据进行校验。</p><h2 id="使用aop处理请求"><a class="markdownIt-Anchor" href="#使用aop处理请求"></a> 使用AOP处理请求</h2><blockquote><p>什么是AOP<br>(1)AOP(面向切面, Aspect Oriented Programming)是一种编程范式,是一种程序设计思想。思想是将通用逻辑从业务逻辑中分离出来<br><img src="/article/框架/Spring Boot/SpringBoot小例子进阶/AOP%E6%80%9D%E6%83%B3.png" alt="无法加载" title="AOP"><br>将纵向的分析变为横向分析,从而将通用逻辑从业务逻辑中分离出来。<br>(2)除了AOP还有OOP(面向对象,Object Oriented Programming),POP(面向过程,Proceduer Oriented Programming)</p></blockquote><h3 id="aop统一处理请求日志"><a class="markdownIt-Anchor" href="#aop统一处理请求日志"></a> AOP统一处理请求日志</h3><blockquote><p>要求：记录每一个http请求</p></blockquote><h4 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h4><pre class="highlight"><code class="">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="创建httpaspect类"><a class="markdownIt-Anchor" href="#创建httpaspect类"></a> 创建HttpAspect类</h4><p><code>@Aspect</code>实现切面注入;<code>@Component</code>将该类注册到SpringBoot容器中</p><pre class="highlight"><code class="">package com.example.demo.aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;// 切面注入@Aspect@Componentpublic class HttpAspect {// 日志对象    private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect            .class);// 指明哪些方法需要执行AOP    @Pointcut(&quot;execution(public * com.example.demo.controller.PersonController&quot; +            &quot;.*(..))&quot;)    public void log() {}    /**     * 该方法功能是将请求中的信息输出至日志中     * @Before 在使用PersonController中方法前先执行该注解下的方法     * @param joinpoint 目标类连接点对象     */    @Before(&quot;log()&quot;)    public void doBefore(JoinPoint joinpoint) {        ServletRequestAttributes attributes = (ServletRequestAttributes)                RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 获取url        LOGGER.info(&quot;url = {}&quot;, request.getRequestURL());        // 获取请求方式        LOGGER.info(&quot;method = {}&quot;, request.getMethod());        // 获取请求方的ip        LOGGER.info(&quot;ip = {}&quot;, request.getRemoteAddr());        // 获取被调用的方法名        LOGGER.info(&quot;class_method = {}&quot;,                joinpoint.getSignature().getDeclaringTypeName() +                        &quot;.&quot; + joinpoint.getSignature().getName() + &quot;()&quot;);        // 获取请求参数        LOGGER.info(&quot;args = {}&quot;, joinpoint.getArgs());    }    /** 该方法功能是将响应中的信息输出至日志中     * @AfterReturning 使得该类可以接收HttpResponse中对象信息     * @param object 返回的对象信息     */    @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;)    public void doAfterReturning(Object object) {        LOGGER.info(&quot;response = {}&quot;, object.toString());    }}</code></pre><h2 id="统一异常处理"><a class="markdownIt-Anchor" href="#统一异常处理"></a> 统一异常处理</h2><blockquote><p>要求:获取Person对象的age并判断<br>age &lt; 12 : 返回&quot;正在上小学&quot;<br>age &gt; 12 &amp;&amp; age &lt; 15: 返回&quot;正在上初中&quot;</p></blockquote><h3 id="定义异常响应信息格式"><a class="markdownIt-Anchor" href="#定义异常响应信息格式"></a> 定义异常响应信息格式</h3><pre class="highlight"><code class="">package com.example.demo.domain;public class Result&lt;T&gt; {    private Integer code; // 错误码    private String msg;   // 提示信息    private T data;       // 具体内容    public Integer getCode() {        return code;    }    public void setCode(Integer code) {        this.code = code;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    public T getData() {        return data;    }    public void setData(T data) {        this.data = data;    }}</code></pre><h3 id="自定义异常类"><a class="markdownIt-Anchor" href="#自定义异常类"></a> 自定义异常类</h3><pre class="highlight"><code class="">package com.example.demo.exception;import com.example.demo.enums.ResultEnum;public class PersonException extends RuntimeException {    private Integer code;    public PersonException(ResultEnum resultEnum) {        super(resultEnum.getMsg());        this.code = resultEnum.getCode();    }    public Integer getCode() {        return code;    }    public void setCode(Integer code) {        this.code = code;    }}</code></pre><h3 id="规范响应code和msg"><a class="markdownIt-Anchor" href="#规范响应code和msg"></a> 规范响应code和msg</h3><pre class="highlight"><code class="">package com.example.demo.enums;public enum ResultEnum {    UNKNOW_ERROR(-1, &quot;未知错误&quot;),    SUCCESS(200, &quot;添加成功&quot;),    PRIMARY_SCHOOL(403, &quot;在上小学&quot;),    MIDDLE_SCHOOL(404, &quot;在上初中&quot;),    ;    private Integer code;    private String msg;    ResultEnum(Integer code, String msg) {        this.code = code;        this.msg = msg;    }    public Integer getCode() {        return code;    }    public String getMsg() {        return msg;    }}</code></pre><h3 id="进行异常捕获"><a class="markdownIt-Anchor" href="#进行异常捕获"></a> 进行异常捕获</h3><pre class="highlight"><code class="">package com.example.demo.handle;import com.example.demo.domain.Result;import com.example.demo.exception.PersonException;import com.example.demo.util.ResultUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger            (ExceptionHandle.class);    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e){        if (e instanceof PersonException) {            PersonException personException = (PersonException) e;            return ResultUtil.error(personException.getCode(),                    personException.getMessage());        } else {            LOGGER.error(&quot;[系统异常] {}&quot;, e);            return ResultUtil.error(-1, &quot;未知错误&quot;);        }    }}</code></pre><h3 id="进行逻辑判断从而判断异常"><a class="markdownIt-Anchor" href="#进行逻辑判断从而判断异常"></a> 进行逻辑判断,从而判断异常</h3><pre class="highlight"><code class="">package com.example.demo.service;import com.example.demo.domain.Person;import com.example.demo.enums.ResultEnum;import com.example.demo.exception.PersonException;import com.example.demo.repository.PersonRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PersonService {    @Autowired    private PersonRepository personRepository;    public void getAge(Integer id) throws Exception{        Person person = personRepository.findOne(id);        Integer age = person.getAge();        if (age &lt; 10) {            throw new PersonException(ResultEnum.PRIMARY_SCHOOL);        } else if (age &gt; 10 &amp;&amp; age &lt; 16) {            throw new PersonException(ResultEnum.MIDDLE_SCHOOL);        }    }}</code></pre><h2 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h2><p>对Service进行测试</p><pre class="highlight"><code class="">package com.example.demo;import com.example.demo.domain.Person;import com.example.demo.service.PersonService;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class PersonServiceTest {    @Autowired    private PersonService personService;    @Test    public void findOneTest() {        Person person = personService.findOne(9);        // 断言        Assert.assertEquals(new Integer(19), person.getAge());    }}</code></pre><p>对API进行测试</p><pre class="highlight"><code class="">package com.example.demo.controller;import com.example.demo.domain.Person;import com.example.demo.repository.PersonRepository;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet        .AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class PersonControllerTest {    @Autowired    private MockMvc mockMvc;    @Test    public void personList() throws Exception {        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person&quot;)).                // 对状态码进行断言                andExpect(MockMvcResultMatchers.status().isOk()).                // 对响应文本进行断言                andExpect(MockMvcResultMatchers.content().string(&quot;&quot;));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本部分代码是基于&lt;code&gt;SpringBoot基础应用&lt;/code&gt;博文的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码结构如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;&quot;&gt;demo   // 项目名
      
    
    </summary>
    
      <category term="框架" scheme="http://yov.oschina.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
      <category term="框架" scheme="http://yov.oschina.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十)/</id>
    <published>2017-10-18T02:24:29.526Z</published>
    <updated>2017-10-21T05:59:07.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><blockquote><p>链表是引用的加强应用.<br>知识点前提：依赖于引用传递；this表示当前对象。</p></blockquote><h3 id="链表基本概念"><a class="markdownIt-Anchor" href="#链表基本概念"></a> 链表基本概念</h3><p>1.链表是一种简单的数据结构，功能是<strong>依靠引用关系实现多个数据的保存。</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-1.png" alt="无法加载" title="数据保存"><br>根据上图编写代码：</p><blockquote><p>要求：定义一个Node类，保存String类型数据，同时拥有下一个节点的引用。</p></blockquote><pre class="highlight"><code class="">// 每个链表由多个节点组成class Node { // 定义节点类    private String data; // 要保存的数据    private Node next;   // 要保存的下一个节点    // 每个Node对象都必须保存相应的数据    public Node(String data) { // 有数据才有Node        this.data = data;    }    public void setNext(Node next) {        this.next = next;    }    public Node getNext() {        return this.next;    }    public String getData() {        return this.data;    }}</code></pre><p><code>Node</code>类专门负责保存节点关系，需要其他类负责Node之间的关系匹配。<br><strong>范例</strong>：使用循环取出数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Node root = new Node(&quot;火车头&quot;);        Node n1 = new Node(&quot;车厢A&quot;);        Node n2 = new Node(&quot;车厢B&quot;);        root.setNext(n1);        n1.setNext(n2);        // 2. 取出数据        Node currentNode = root; //从根节点开始读取数据        while (currentNode != null) { // 当前节点存在数据            System.out.println(currentNode.getData());            // 将下一节点设置为当前节点            currentNode = currentNode.getNext();        }    }}</code></pre><p>利用循环取出数据不够便捷，应使用递归。<br><strong>范例</strong>：使用递归取出数据</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Node root = new Node(&quot;火车头&quot;);        Node n1 = new Node(&quot;车厢A&quot;);        Node n2 = new Node(&quot;车厢B&quot;);        root.setNext(n1);        n1.setNext(n2);        print(root);    }    public static void print(Node current){        if (current == null){ // 节点不存在            return ; // 结束方法调用        }        System.out.println(current.getData());        print(current.getNext()); // 递归调用    }}</code></pre><p><strong>因为循环次数未知，所以使用while循环。节点操作中，递归比while循环更直观。</strong></p><blockquote><p><strong>问题：为什么要设置Node类</strong><br>答：数据本身不具有先后关系，因此需要使用Node类封装份数据，同时利用Node类指向下一节点。</p></blockquote><h3 id="链表基本实现"><a class="markdownIt-Anchor" href="#链表基本实现"></a> 链表基本实现</h3><p>通过分析发现：</p><blockquote><p>(1)用户操作过程中，Node类应该是不可见的，即用户无需关注Node类的结构<br>(2)Node之间的关系不应该由用户定义，而应该由一个专门的类处理。</p></blockquote><p><strong>范例</strong>：定义Link类，隐藏Node类<br>程序要描述的步骤如下：<br><strong>第一步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-2.png" alt="无法加载" title="数据保存"><br><strong>第二步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-3.png" alt="无法加载" title="数据保存"><br><strong>第三步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-4.png" alt="无法加载" title="数据保存"><br><strong>第四步：</strong><br><img src="/article/Java/Java Base/Java基础知识(十)/15-5.png" alt="无法加载" title="数据保存"></p><pre class="highlight"><code class="">// 处理Node对象间关系class Link {    private Node root; // 根节点    // 设置数据    public void add(String data) {        // 为了设置数据的先后关系，将data包装在Node对象中        Node newNode = new Node(data);        if (this.root == null) { // 保存数据时，根节点不存在            // 该判断执行一次，因为链表只有一个根节点            this.root = newNode; // 将新节点设置为根节点        } else { // 根节点存在            // 新节点应交给Node决定            // 从root之后设置合适的位置            this.root.addNode(newNode);        }    }    // 输出数据    public void print() {        if (this.root != null) {            this.root.printNode();        }    }}</code></pre><p><strong>范例</strong>:根据Link类，修改Node类</p><pre class="highlight"><code class="">class Node {     private String data;     private Node next;      public Node(String data) {         this.data = data;    }    public void setNext(Node next) {        this.next = next;    }    public Node getNext() {        return this.next;    }    public String getData() {        return this.data;    }    // 添加节点    // 第一次Link调用: this = link.root    // 第二次Node调用：this = link.root.next    // 第三次Node调用：this = link.root.next.next    public void addNode(Node newNode) {        if (this.next == null) { // 当前节点的next为空            this.next = newNode; // 保存为新节点        } else {             // 当前节点的next的next继续保存            this.next.addNode(newNode);        }    }    // 第一次Link调用: this = link.root    // 第二次Node调用：this = link.root.next    // 第三次Node调用：this = link.root.next.next    public void printNode() {        System.out.println(this.data); // 输出当前节点数据        if (this.next != null) { // 当前节点有next            this.next.printNode(); // 输出next节点信息        }    }}</code></pre><p><strong>范例</strong>：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link(); // 负责数据操作        // 增加数据        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);        // 输出数据        link.print();    }}</code></pre><p>由上述代码可知链表操作的基本特点：</p><blockquote><p>（1）对于客户端而言Node是不可见的，只能利用Link中的方法<br>（2）Link类的功能是控制Node对象的产生和根节点的使用；<br>（3）Node类的功能是保存数据以及配置引用关系。</p></blockquote><h3 id="可用链表基本结构"><a class="markdownIt-Anchor" href="#可用链表基本结构"></a> 可用链表基本结构</h3><p>1.可用链表指的是能实现数据的增删改查的链表。<br>2.可用链表开发要求：Node类负责节点数据的保存以及节点关系的匹配，因此Node类不能被单独使用，即外部不能绕过Link去使用Node<br><strong>范例</strong>：修改Node结构，使得Node类只能被Link类使用</p><blockquote><p>思路：将Node类变为private定义的内部类。</p></blockquote><pre class="highlight"><code class="">class Link { // 链表类，外部可见    // Node定义在内部让其只为Link服务    private class Node {         private String data; // 保存数据        private Node next; // 引用关系        public Node(String data) {             this.data = data;        }    }    // ====================以上为内部类=====================    private Node root; // 根节点}</code></pre><p>上述代码即为可用链表的基本结构，后续为其增加功能代码。</p><h3 id="增加数据功能"><a class="markdownIt-Anchor" href="#增加数据功能"></a> 增加数据功能</h3><blockquote><p>思路：数据的增加应由Link负责节点对象的产生，以及根节点的维护。节点间的关系匹配，由Node类处理。</p></blockquote><p><strong>范例</strong>：Node类中添加<code>addNode()</code>，Link类中添加<code>add()</code></p><pre class="highlight"><code class="">// 设置关系public void addNode(Node newNode) {    if (this.next == null) {        this.next = newNode;    } else {        this.next.addNode(newNode);    }}public void add(String data) {    if (data == null) { // 输入数据为空        return;    }    Node newNode = new Node(data); // 要保存的数据    if (this.root == null) { // 根节点不存在        this.root = newNode; // 设为根节点    } else { //  根节点存在，交由Node处理        this.root.addNode(newNode);    }}</code></pre><p>范例：测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link();        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);    }}</code></pre><h3 id="获取链表长度"><a class="markdownIt-Anchor" href="#获取链表长度"></a> 获取链表长度</h3><blockquote><p>思路：每个链表对象都只有一个root，可以在Link类中设置count属性，随后每次添加数据后，count自增。</p></blockquote><p>范例：修改Link类<br>（1）增加count属性:<code>private int count = 0; // 节点的个数</code><br>（2）在add()添加统计节点个数的操作</p><pre class="highlight"><code class="">public void add(String data) {   if (data == null) {        return;   }   Node newNode = new Node(data);    if (this.root == null) {        this.root = newNode;    } else { //        this.root.addNode(newNode);   }   this.count++; // 每次增加节点，count+1}</code></pre><p>（3）添加获取链表长度的方法size()</p><pre class="highlight"><code class="">public int size() {    return this.count;}</code></pre><p>（4）判断链表是否为空，有两种方式，一是判断root是否为null，二是判断count是否为0，在此采用第二种方式，在Link类中添加isEmpty()</p><pre class="highlight"><code class="">public boolean isEmpty() {    return this.count == 0;}</code></pre><h3 id="内容查询"><a class="markdownIt-Anchor" href="#内容查询"></a> 内容查询</h3><blockquote><p>思路：判断链表中是否存在某数据，以String为例，仅需遍历链表中的数据，与要查询的数据记性匹配（使用equals(String str)），如果匹配成功返回true，反之返回false。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-6.png" alt="无法加载" title="内容查询"><br>根据上图编写代码：<br>（1）Link中添加contains()</p></blockquote><pre class="highlight"><code class="">public boolean contains(String data) {    if (data == null || root == null) {        return false;    }    return this.root.containsNode(data);}</code></pre><p>Link从root节点开始查询数据是否存在，数据不存在，Node开始查询非根节点。<br>（2）Node中添加containsNode()</p><pre class="highlight"><code class="">public boolean containsNode(String data) {    if (data.equals(this.data)) { // 当前数据等于要目标数据        return true; // 结束查询    } else { // 当前数据不等于目标数据        if (this.next != null) { // 有后续节点            return this.next.containsNode(data);        } else {             return false;        }    }}</code></pre><p>（3）测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link link = new Link();        link.add(&quot;火车头&quot;);        link.add(&quot;车厢A&quot;);        link.add(&quot;车厢B&quot;);        System.out.println(link.contains(&quot;火车头&quot;));    }}</code></pre><blockquote><p>案例中使用的是String类型数据，所以判断数据使用equals(String str)。如果判断的是自定义类型数据，就需要定义一个对象比较的方法，方法名暂定为compare()。</p></blockquote><h3 id="根据索引取得数据"><a class="markdownIt-Anchor" href="#根据索引取得数据"></a> 根据索引取得数据</h3><blockquote><p>链表中保存有多个对象。数组也可以保存多个对象。链表和数组相比优势在于没有长度限制。因此链表相当于一个动态对象数组，具备像数组那样根据索引取得元素的功能。<br>由于是动态对象数组，所以元素的索引也是动态生成的。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-7.png" alt="无法加载" title="内容查询"><br>根据上图，编写代码：<br>（1）Link中增加foot属性，表示Node的索引:<code>private int foot = 0; // 索引</code><br>每次查询前，应该重置为0.链表查询数据前应先判断要查询的索引小于索引总数。</p></blockquote><pre class="highlight"><code class="">public String get(int index) {    if (index &gt; this.count) { // 超出查询范围        return null;    }    this.foot = 0;    return this.root.getNode(index); // 查询交给Node类}</code></pre><p>（2）Node定义getNode()，内部类和外部类间可以方便地进行私有属性的访问。</p><pre class="highlight"><code class="">public String getNode(int index) {    // 当前foot内容与要查询的索引比较    // foot自增，目的是下次查询方便    if (Link.this.foot++ == index) {        return this.data;    } else {        return this.next.getNode(index);    }}</code></pre><h3 id="修改链表数据"><a class="markdownIt-Anchor" href="#修改链表数据"></a> 修改链表数据</h3><blockquote><p>修改和查询思路差不多，不同的是查询是当满足索引值时，返回数据；修改是满足索引时，对数据重新赋值。</p></blockquote><p>（1）Link添加<code>set(int index, String data)</code></p><pre class="highlight"><code class="">public void set(int index, String data) {    if (index &gt; this.count) {        return;    }    this.foot = 0; // 重置foot,作为索引    this.root.setNode(index, data); // Node进行修改数据}</code></pre><p>（2）Node添加<code>setNode(int index, String data)</code></p><pre class="highlight"><code class="">public void setNode(int index, String data) {    if (Link.this.foot++ == index) {        this.data = data;    } else {        this.next.setNode(index, data);    }}</code></pre><h3 id="删除链表数据"><a class="markdownIt-Anchor" href="#删除链表数据"></a> 删除链表数据</h3><blockquote><p>删除链表数据应分为两种情况：<br>（1）要删除的是根节点，root.next()变为root，在Link中处理，因为由Link来维护root；<br>（2）要删除的是非根节点，当前节点的上一节点.next()=当前节点.next()，即空出了当前节点。非根节点应交由Node处理。</p></blockquote><p>1.Node添加removeNode(Node previous, String data)</p><pre class="highlight"><code class="">public void removeNode(Node previous, String data) {    // 参数中传递上一个节点和要删除的数据    if (data.equals(this.data)) {        previous.next = this.next;    } else {        this.next.removeNode(this, data);    }}</code></pre><ol start="2"><li>Link添加remove(String data)</li></ol><pre class="highlight"><code class="">public void remove(String data) {    if (this.contains(data)) { // 判断数据是否存在        if (data.equals(this.root.data)) { // 判断数据是否是root数据            this.root = this.root.next;        } else {            // root是Node对象，此处直接访问内部类私有操作            this.root.next.removeNode(this.root, data);        }this.count -- ; // 删除后数据个数减少    }}</code></pre><h3 id="对象数组转换"><a class="markdownIt-Anchor" href="#对象数组转换"></a> 对象数组转换</h3><blockquote><p>开发中，类中不应该有输出语句。想输出数据应将数据返回到调用处。链表属于动态数组，因此可以将链表以对象数组的形式返回。<br><img src="/article/Java/Java Base/Java基础知识(十)/15-8.png" alt="无法加载" title="对象数组转换"><br>由上图可知，Link的<code>toArray()</code>要返回一个对象数组，且该数组也要由Node操作。因此该数组应定义为Link的属性。<br>（1）Link添加一个数组属性，便于Node和Link访问。添加toArray()</p></blockquote><pre class="highlight"><code class="">private String[] retArray; // 返回的数组public String[] toArray() {    if (this.root == null) {        return null;    }    this.foot = 0; // 需要脚标控制    this.retArray = new String[this.count]; // 根据保存内容开辟数组    this.root.toArrayNode();    return this.retArray;}</code></pre><p>（2）Node添加toArrayNode()进行数组数据保存</p><pre class="highlight"><code class="">public void toArrayNode() {    Link.this.retArray[Link.this.foot++] = this.data;    if (this.next != null) {        this.next.toArrayNode();    }}</code></pre><p><strong>链表数据变为对象数组取出是重要功能！</strong></p><h3 id="链表使用"><a class="markdownIt-Anchor" href="#链表使用"></a> 链表使用</h3><blockquote><p>上述链表只能操作String数据。下面要使用链表操作自定义类，由于链表具有contains()，因此类中需定义对象比较的方法。</p></blockquote><p>（1）定义Book类（setter/getter暂时省略）</p><pre class="highlight"><code class="">class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String getInfo() {        return &quot;书名：&quot; + this.title + &quot;,价格&quot; + this.price;    }    public boolean compare(Book book) {        if (book == null) {            return false;        }        if (this == book) {            return true;        }        if (this.title.equals(book.title)                &amp;&amp; this.price == book.price) {            return true;        } else {            return false;        }    }}</code></pre><p>（2）修改链表</p><pre class="highlight"><code class="">class Link {     private class Node { // 节点类        private Book data; // 保存数据        private Node next; // 引用关系        public Node(Book data) {             this.data = data;        }        // 设置关系        public void addNode(Node newNode) {            if (this.next == null) {                this.next = newNode;            } else {                this.next.addNode(newNode);            }        }        // 数据查询        public boolean containsNode(Book data) {            if (data.equals(this.data)) { // 当前数据等于要目标数据                return true; // 结束查询            } else { // 当前数据不等于目标数据                if (this.next != null) { // 有后续节点                    return this.next.containsNode(data);                } else { // 没有后续节点                    return false;                }            }        }        public Book getNode(int index) {            // 当前foot内容与要查询的索引比较            // foot自增，目的是下次查询方便            if (Link.this.foot++ == index) {                return this.data;            } else {                return this.next.getNode(index);            }        }        // 修改节点信息        public void setNode(int index, Book data) {            if (Link.this.foot++ == index) {                this.data = data;            } else {                this.next.setNode(index, data);            }        }        // 删除非根节点        public void removeNode(Node previous, Book data) {            // 参数中传递上一个节点和要删除的数据            if (data.equals(this.data)) {                previous.next = this.next;            } else {                this.next.removeNode(this, data);            }        }        public void toArrayNode() {            Link.this.retArray[Link.this.foot++] = this.data;            if (this.next != null) {                this.next.toArrayNode();            }        }    }    // ====================以上为内部类=====================    private Node root; // 根节点    private int count = 0; // 节点的个数    private int foot = 0; // 索引    private Book[] retArray; // 返回的数组    public void add(Book data) {        if (data == null) { // 输入数据为空            return;        }        Node newNode = new Node(data); // 要保存的数据        if (this.root == null) { // 根节点不存在            this.root = newNode; // 设为根节点        } else { //  根节点存在，交由Node处理            this.root.addNode(newNode);        }        this.count++; // 每次增加节点，count+1    }    // 获取链表长度    public int size() {        return this.count;    }    // 判断是否为空链表    public boolean isEmpty() {        return this.count == 0;    }    // 判断数据是否存在    public boolean contains(Book data) {        if (data == null || root == null) {            return false;        }        return this.root.containsNode(data);    }    // 根据索引获取信息    public Book get(int index) {        if (index &gt; this.count) { // 超出查询范围            return null;        }        this.foot = 0;        return this.root.getNode(index); // 查询交给Node类    }    // 设置信息    public void set(int index, Book data) {        if (index &gt; this.count) {            return;        }        this.foot = 0; // 重置foot,作为索引        this.root.setNode(index, data); // Node进行修改数据    }    // 判断删除节点是否为root    public void remove(Book data) {        if (this.contains(data)) { // 判断数据是否存在            if (data.equals(this.root.data)) { // 判断数据是否是root数据                this.root = this.root.next;            } else {                // root是Node对象，此处直接访问内部类私有操作                this.root.next.removeNode(this.root, data);            }            this.count--; // 删除后数据个数减少        }    }    public Book[] toArray() {        if (this.root == null) {            return null;        }        this.foot = 0; // 需要脚标控制        this.retArray = new Book[this.count]; // 根据保存内容开辟数组        this.root.toArrayNode();        return this.retArray;    }}</code></pre><p>（3）测试</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Link all = new Link();        all.add(new Book(&quot;Java开发&quot;, 69.8));        all.add(new Book(&quot;JSP&quot;, 78.8));        all.add(new Book(&quot;C++开发&quot;, 19.8));        System.out.println(&quot;保存书的个数：&quot; + all.size());        System.out.println(all.contains(new Book(&quot;Java开发&quot;, 69.8)));        all.remove(new Book(&quot;C++开发&quot;, 19.8));        Book[] books = all.toArray();        for (int x = 0; x &lt; books.length; x++) {            System.out.println(books[x].getInfo());        }    }}</code></pre><p>链表的最佳应用就是横向替换对象数组。</p><h3 id="在映射中使用链表"><a class="markdownIt-Anchor" href="#在映射中使用链表"></a> 在映射中使用链表</h3><blockquote><p>链表属于动态对象数组。之前进行数据表映射时，都会出现对象数组的概念，现在就用链表来进行对象保存。本节以一对多为例，即用前文中的省份-城市表为例：</p></blockquote><p>（1）对于使用链表的类，要添加对象比较的方法</p><pre class="highlight"><code class="">class Province {    private int pid;    private String pname;    private Link cities = new Link();    public Link getCities() {        return this.cities;    }    //getter/setter,无参构造方法略    public Province(int pid, String pname) {        this.pid = pid;        this.pname = pname;    }    public boolean compare(Province province) {        if (province == null) {            return false;        }        if (this == province) {            return true;        }        if (this.pid == province.pid &amp;&amp; this.pname.equals(province.pname)) {            return true;        } else {            return false;        }    }    public String getInfo() {        return &quot;省份ID：&quot; + this.pid + &quot;,省份名称：&quot; + this.pname;    }}class City {    private int cid;    private String cname;    private Province province;    public void setProvince(Province province) {        this.province = province;    }    public Province getProvince() {        return this.province;    }    //getter/setter,无参构造方法略    public City(int cid, String cname) {        this.cid = cid;        this.cname = cname;    }    public String getInfo() {        return &quot;城市ID：&quot; + this.cid + &quot;,城市名称：&quot; + this.cname;    }    public boolean compare(City city) {        if (city == null) {            return false;        }        if (this == city) {            return true;        }        if (this.cid == city.cid &amp;&amp; this.cname.equals(city.cname)                &amp;&amp; this.province.compare(city.province)) {            return true;        } else {            return false;        }    }}</code></pre><p>此时只需将链表中的Book改为City即可。<br>在此时发现问题：每定义一个新的类，链表就需要重新进行修改。方法解决了代码重复问题。但是该问题不属于代码重复，属于数据类型不同意，该问题需要依靠面向对象的特性的来结局。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><blockquote><p>（1）本章所讲的只是最基础的单向链表；<br>（2）链表中应有如下方法：</p></blockquote><table><thead><tr><th>No.</th><th style="text-align:left">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">public void add(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">向链表中添加数据</td></tr><tr><td>2</td><td style="text-align:left">public int size()</td><td style="text-align:center">普通</td><td style="text-align:left">取得链表中数据个数</td></tr><tr><td>3</td><td style="text-align:left">public boolean isEmpty()</td><td style="text-align:center">普通</td><td style="text-align:left">判断是否为空链表</td></tr><tr><td>4</td><td style="text-align:left">public boolean contains(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">判断数据是否存在</td></tr><tr><td>5</td><td style="text-align:left">public 数据类型 get(int index)</td><td style="text-align:center">普通</td><td style="text-align:left">根据索引取得数据</td></tr><tr><td>6</td><td style="text-align:left">public void set(int index,数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">修改数据</td></tr><tr><td>7</td><td style="text-align:left">public void remove(数据类型 变量)</td><td style="text-align:center">普通</td><td style="text-align:left">删除指定数据</td></tr><tr><td>8</td><td style="text-align:left">public 数据类型 [] toArray()</td><td style="text-align:center">普通</td><td style="text-align:left">将链表以对象数组的形式转换</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt; 链表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;链表是引用的加强应用.&lt;br&gt;
知识点前提：依赖于引用传递；this表示当前对象。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(九)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B9%9D)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(九)/</id>
    <published>2017-10-15T01:28:21.490Z</published>
    <updated>2017-10-21T05:58:17.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h2><blockquote><p>代码块是<code>{}</code>定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：<strong>普通代码块，构造块，静态块和同步代码块</strong>。</p></blockquote><h3 id="普通代码块"><a class="markdownIt-Anchor" href="#普通代码块"></a> 普通代码块</h3><p>1.写在方法中的代码块，称为<strong>普通代码块</strong>。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        { // 普通代码块            int num = 10; // 局部变量            System.out.println(&quot;num = &quot; + num); // 10        }        int num = 100; // 全局变量        System.out.println(&quot;num = &quot; + num); // 100    }}</code></pre><p><strong>普通代码块的功能</strong>是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。</p><h3 id="构造块"><a class="markdownIt-Anchor" href="#构造块"></a> 构造块</h3><p>1.写在类中的代码块，称为<strong>构造块</strong>。</p><pre class="highlight"><code class="">class Book {    public Book(){ // 构造方法        System.out.println(&quot;A. Book类的构造方法&quot;);    }    { // 构造块        System.out.println(&quot;B. Book类的构造块&quot;);    }}public class Demo {    public static void main(String[] args) {        new Book();        // B. Book类的构造块        // A. Book类的构造方法    }}</code></pre><p>输出结果显示：<strong>构造块的调用优先于构造方法。</strong></p><h3 id="静态块"><a class="markdownIt-Anchor" href="#静态块"></a> 静态块</h3><p>static定义的代码块，称为<strong>静态块</strong>。静态块的使用，分为两种情况：<br>1.在非主类中使用</p><pre class="highlight"><code class="">class Book {    public Book(){ // 构造方法        System.out.println(&quot;A. Book类的构造方法&quot;);    }    { // 构造块        System.out.println(&quot;B. Book类的构造块&quot;);    }    static {        System.out.println(&quot;C. Book类的静态块&quot;);    }}public class Demo {    public static void main(String[] args) {        new Book(); // C B A        new Book(); // B A    }}</code></pre><p>结果显示：**静态块优先于构造块。**且不论实例化多少个对象，<strong>静态块只执行一次</strong>。static主要功能是为类中的static属性初始化。</p><pre class="highlight"><code class="">class Book {    public static String msg;    static {        msg = &quot;Hello&quot;.substring(0,2);        System.out.println(&quot;C. Book类的静态块&quot;);    }}public class Demo {    public static void main(String[] args) {        System.out.println(Book.msg);    }}</code></pre><p>2.在主类中定义</p><pre class="highlight"><code class="">public class Demo {    static {        System.out.println(&quot;**************&quot;);    }    public static void main(String[] args) {        System.out.println(&quot;Hello World !&quot;);        // **************        // Hello World !    }}</code></pre><p>结果显示：静态块优先于<code>main()</code>方法执行。在编写测试时，可以使用静态块。</p><h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2><blockquote><p>从开发角度来说，尽量不要使用内部类</p></blockquote><h3 id="内部类基本概念"><a class="markdownIt-Anchor" href="#内部类基本概念"></a> 内部类基本概念</h3><p>1.<strong>内部类</strong>是指在一个类的内部定义其他的类。<br><strong>范例</strong>：内部类</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        public void print() {            System.out.println(msg);        }    }    public void fun() {        // 实例化内部类对象，调用print()方法        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        // 实例化外部类对象        Outer out = new Outer();        out.fun(); // 调用外部类方法，Hello World    }}</code></pre><p>上述代码牺牲了程序的结构，实现了一个重要功能。<br>2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。<br><strong>范例</strong>：取出内部类</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public void fun() {        new Inner().print();    }}class Inner {     public void print() {        System.out.println(msg);    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun(); // 报错，msg属于Outer，Inner无法调用    }}</code></pre><p>（1）要想使得<code>Inner</code>调用<code>msg</code>，就需在<code>Outer</code>中写一个<code>getMsg()</code></p><pre class="highlight"><code class="">public String getMsg(){    return this.msg;}</code></pre><p>（2）<code>Inner</code>要调用<code>Outer</code>的<code>getMsg()</code>方法，必须实例化一个<code>Outer</code>对象</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public String getMsg(){        return this.msg;    }    public void fun() {        new Inner().print();    }}class Inner {    public void print() {        System.out.println(new Outer().getMsg());    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。</p><pre class="highlight"><code class="">class Outer {     private String msg = &quot;Hello World&quot;;    public String getMsg() {        return this.msg;    }    public void fun() {        new Inner(this).print();    }}class Inner {    private Outer out;    public Inner(Outer out) {        this.out = out;    }    public void print() {        System.out.println(this.out.getMsg());    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>由此可得内部类的特点：</p><blockquote><p>内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。</p></blockquote><p><strong>范例</strong>：访问内部类私有属性</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        private  String info = &quot;世界你好&quot;;        public void print() {            System.out.println(msg);        }    }    public void fun() {        // 实例化内部类对象        Inner in = new Inner();        // 使用内部类对象访问内部类私有属性        System.out.println(in.info);    }}public class Demo {    public static void main(String[] args) {        Outer out = new Outer();        out.fun();    }}</code></pre><p>3.观察代码</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        private  String info = &quot;世界你好&quot;;        public void print() {            System.out.println(this.msg); // 报错，找不到msg        }    }    public void fun() {        new Inner().print();    }}</code></pre><p><strong>报错原因</strong>：<code>this.msg</code>指向的是<code>Inner</code>类，而<code>Inner</code>类中没有<code>msg</code>属性。因此要访问<code>Outer</code>的<code>msg</code>属性，需要使用<code>Outer.this.msg</code>.</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    class Inner { // 内部类        public void print() {            // 外部类.this = 外部类的当前对象            System.out.println(Outer.this.msg);         }    }    public void fun() {        new Inner().print();    }}</code></pre><p>4.内部类的class文件名: <code>Outer$Inner.class</code><br>直接实例化内部类对象语法：<code>外部类.内部类 对象名 = new 外部类().new 内部类();</code><br><strong>范例</strong>：实例化内部类对象</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Outer.Inner in = new Outer().new Inner();        in.print();    }}</code></pre><p>上述代码说明：</p><blockquote><p>要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。</p></blockquote><p>5.内部类只想被外部类使用，不能被外部调用，应使用<code>private</code>定义</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    private class Inner { // 内部类        public void print() {            // 外部类.this = 外部类的当前对象            System.out.println(Outer.this.msg);       }    }}</code></pre><h3 id="static定义内部类"><a class="markdownIt-Anchor" href="#static定义内部类"></a> static定义内部类</h3><p>使用static定义的属性或方法不受实例化对象控制，因此使用<strong>static定义的内部类也不受外部类实例化对象控制。</strong><br>1.static定义的内部类只能访问外部类中static定义的属性或方法</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    static class Inner { // 内部类        public void print() {            System.out.println(msg); // 报错，无法引用非静态变量msg        }    }}</code></pre><p>2.static定义的内部类，相当于外部类<br>取得static定义的内部类对象语法：<code>外部类.内部类 对象 = new 外部类.内部类();</code>由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于<strong>内部类成了一个外部类。</strong></p><pre class="highlight"><code class="">class Outer { // 外部类    private static String msg = &quot;Hello World&quot;;    static class Inner { // 内部类        public void print() {            System.out.println(msg);        }    }}public class Demo {    public static void main(String[] args) {        Outer.Inner in = new Outer.Inner();        in.print();    }}</code></pre><h3 id="方法中定义内部类"><a class="markdownIt-Anchor" href="#方法中定义内部类"></a> 方法中定义内部类</h3><p>1.内部类可定义在外部类中的任意位置。<strong>在方法中定义内部类</strong>是最常见的形式。</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun() {        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(msg);            }        }        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        new Outer().fun();    }}</code></pre><p>2.方法可以接收参数，也可以定义变量<br><strong>范例</strong>：访问方法中定义的参数或变量</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun(int num) { // 方法参数        double score = 99.9; // 方法变量        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(&quot;属性：&quot; + msg);                System.out.println(&quot;方法参数：&quot; + num);                System.out.println(&quot;方法变量：&quot; + score);            }        }        new Inner().print();    }}public class Demo {    public static void main(String[] args) {        new Outer().fun(100);    }}</code></pre><p><strong>方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后</strong>！在JDK1.8之前的版本严格要求：方法中的内部类只能访问<code>final</code>标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式：</p><pre class="highlight"><code class="">class Outer { // 外部类    private String msg = &quot;Hello World&quot;;    public void fun(final int num) { // 方法参数       final double score = 99.9; // 方法变量        class Inner { // 定义在方法中的内部类            public void print() {                System.out.println(&quot;属性：&quot; + msg);                System.out.println(&quot;方法参数：&quot; + num);                System.out.println(&quot;方法变量：&quot; + score);            }        }        new Inner().print();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码块&quot;&gt;&lt;/a&gt; 代码块&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块是&lt;code&gt;{}&lt;/code&gt;定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：&lt;stron
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
