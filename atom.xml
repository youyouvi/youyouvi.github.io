<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember</title>
  
  <subtitle>一切有为法,如梦幻泡影。如露亦如电,应作如是观。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yov.oschina.io/"/>
  <updated>2018-01-17T13:59:11.869Z</updated>
  <id>http://yov.oschina.io/</id>
  
  <author>
    <name>子语</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/%E5%B9%B6%E5%8F%91/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/并发/</id>
    <published>2018-01-17T12:27:17.965Z</published>
    <updated>2018-01-17T13:59:11.869Z</updated>
    
    <content type="html"><![CDATA[<p>通常程序都是顺序执行且代码只是为了完成独立的一个任务，因为这样的代码易写易维护。但某些情况下，并行执行多个任务更有好处，比如Web服务需要在各自的套接字（socket）上同时接收多少数据请求。每个套接字请求都是独立的，可以独立其他套接字进行处理，此时并行执行多个请求可以显著提高服务。Go语言的语法和运行时内置了对并发的支持。</p><p>Go中的并发指的是能让某个函数独立于其他函数运行。当一个函数创建为<code>goroutime</code>时，Go会将其视为一个独立的工作单元，这个单元会被调度到可用的逻辑处理器上运行。Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有<code>goroutime</code>并为其分配执行时间。这个调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行<code>goroutime</code>。调度器在任何给定的时间，都会全面控制某个<code>goroutime</code>要在某个逻辑处理器上运行。</p><p>Go语言的并发同步模型来自一个叫做通信顺序进程<code>Communicating Sequential Processes, CSP</code>的范型<code>paradigm</code>。CSP是一种消息传递模型，通过在<code>goroutime</code>间传递数据来传递消息，而不是对数据进行加锁从而实现同步。用于在<code>goroutime</code>之间同步和传递数据的关键数据类型叫作通道<code>channel</code>。</p><h2 id="并发与并行"><a class="markdownIt-Anchor" href="#并发与并行"></a> 并发与并行</h2><p>什么是操作系统的线程（thread）和进程（process）。当运行一个应用程序时，操作系统会为其启动一个进程。可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。</p><p>进程中的资源包括但不限于内存地址空间、文件和设备的句柄以及线程。一个线程是一个执行空间，这个空间会被操作系统调度用来运行函数中所写的代码。每个进程至少包含一个线程，每个进程的初始线程被称为<code>主线程</code>。因为执行这个线程的空间是应用程本身的空间，所以当主线程终止时，应用程序也会终止。操作系统会将线程调度到某个处理器上运行，但这个处理器不一定是进程所在的处理器。</p><p>操作系统会在物理处理器上调度线程来运行，而Go的运行时会在逻辑处理器上调度<code>goroutime</code>来运行。Go1.5之前，默认给整个应用程序只分配一个逻辑处理器；1.5之后运行时会默认为每个可用的物理处理器分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的<code>goroutime</code>，即便只有一个逻辑处理器，Go依然可以并发调度无数个<code>goroutime</code>。</p><p>如果创建一个<code>goroutime</code>并准备运行，这个<code>goroutime</code>就会被放到调度器的全局队列中，之后调度器就会将队列中的<code>goroutime</code>分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中，本地运行队列中的<code>goroutime</code>会一直等待直到自己被分配逻辑处理器执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常程序都是顺序执行且代码只是为了完成独立的一个任务，因为这样的代码易写易维护。但某些情况下，并行执行多个任务更有好处，比如Web服务需要在各自的套接字（socket）上同时接收多少数据请求。每个套接字请求都是独立的，可以独立其他套接字进行处理，此时并行执行多个请求可以显著
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组、切片和映射</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/数组、切片和映射/</id>
    <published>2018-01-17T01:49:34.873Z</published>
    <updated>2018-01-11T14:08:10.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组-切片和映射"><a class="markdownIt-Anchor" href="#数组-切片和映射"></a> 数组、切片和映射</h2><h3 id="数组的内部实现和基本功能"><a class="markdownIt-Anchor" href="#数组的内部实现和基本功能"></a> 数组的内部实现和基本功能</h3><p>数组是切片和映射的基础数据结构。</p><h4 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现</h4><p>在Go中，数组是一个长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。存储的数据类型可以是内置的，如整型，也可以是某种结构类型。数组的每个元素都紧邻着下一个元素，可以通过索引来访问。</p><p>数据占用的内存是连续分配的，因此CPU能把正在使用的数据缓存更久的时间，同时内存连续很容易计算索引，可以快速迭代数组里的所有元素。数组的元素类型相同，且连续分配，就可以以固定速度索引数组中的任意数据，速度非常快。</p><h4 id="声明和初始化"><a class="markdownIt-Anchor" href="#声明和初始化"></a> 声明和初始化</h4><p>声明数组时需要指定内部存储的数据类型以及长度。一旦声明，数据里存储的数据类型和长度就不能改变。如果要存储更多元素，就需要创建一个更长的数组，将源数组的值复制过去。数组初始化时，会将每个元素初始化为对应类型的零值。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="comment">// 声明一个长度为5的数组</span><span class="keyword">var</span> array1 [<span class="number">5</span>]<span class="keyword">int</span><span class="comment">// 声明一个长度为5的数组并用具体值初始化每个元素</span>array2 := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>,<span class="number">40</span>, <span class="number">50</span>}<span class="comment">// 让Go自动那个计算声明的数组长度</span>array3 := [...]<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}<span class="comment">// 指定特定元素的值，index:value，指定索引为index的元素值为value</span>array4 := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>}    <span class="comment">// for循环输出语句</span><span class="keyword">for</span> index, value := <span class="keyword">range</span> array4{fmt.Printf(<span class="string">"arr[%d] = %d \n"</span>, index, value)}fmt.Println(<span class="built_in">len</span>(array1)) <span class="comment">// 5</span>fmt.Println(<span class="built_in">len</span>(array2)) <span class="comment">// 5</span>fmt.Println(<span class="built_in">len</span>(array3)) <span class="comment">// 5</span>}</code></pre><h4 id="使用数组"><a class="markdownIt-Anchor" href="#使用数组"></a> 使用数组</h4><p>要访问数组时，可以利用<code>[]</code>运算符，通过索引访问元素。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="comment">/* 使用索引访问数组元素 */</span>array := [<span class="number">5</span>]<span class="keyword">int</span> {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}<span class="comment">// 修改索引为2的元素的值</span>array[<span class="number">2</span>] = <span class="number">35</span><span class="comment">/* 声明一个元素都是指针的数组，使用*运算符就能访问元素指针所指向的值 */</span>array1 := [<span class="number">5</span>]*<span class="keyword">int</span>{<span class="number">0</span>: <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="number">1</span>: <span class="built_in">new</span>(<span class="keyword">int</span>)}*array1[<span class="number">0</span>] = <span class="number">10</span>*array1[<span class="number">1</span>] = <span class="number">20</span><span class="comment">/* 将同类型的数组赋值给另一个数组,类型相同指的是数据类型和长度都相等 */</span>colorArray := [<span class="number">5</span>]<span class="keyword">string</span>{<span class="string">"Blue"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}<span class="keyword">var</span> colorArray1 [<span class="number">5</span>]<span class="keyword">string</span>colorArray1 = colorArray<span class="keyword">for</span> _, value := <span class="keyword">range</span> colorArray1{fmt.Println(value)}<span class="comment">/* 编译器会阻止不同类型的数组互相赋值 */</span><span class="keyword">var</span> stringarray [<span class="number">5</span>]<span class="keyword">string</span><span class="keyword">var</span> shortarray [<span class="number">4</span>]<span class="keyword">int</span><span class="keyword">var</span> longarray [<span class="number">6</span>]<span class="keyword">int</span>intarray := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}<span class="comment">// 类型不同的数组不能互相赋值</span>stringarray = intarray<span class="comment">// 不能将长数组赋值给短数组</span>shortarray = intarray<span class="comment">// 不能将短数组赋值给长数组</span>longarray = intarray<span class="comment">/* 把一个指针数组赋值给另一个 */</span><span class="keyword">var</span> array3 [<span class="number">3</span>]*<span class="keyword">string</span>array4 := [<span class="number">3</span>]*<span class="keyword">string</span>{<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)}*array4[<span class="number">0</span>] = <span class="string">"Red"</span>*array4[<span class="number">1</span>] = <span class="string">"Blue"</span>*array4[<span class="number">2</span>] = <span class="string">"Green"</span>array3 = array4<span class="keyword">for</span> _, value := <span class="keyword">range</span> array3{fmt.Println(value)}}</code></pre><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="comment">/* 声明一个二维数组 */</span><span class="keyword">var</span> a1 [<span class="number">4</span>][<span class="number">2</span>] <span class="keyword">int</span>a2 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ {<span class="number">10</span>, <span class="number">11</span>}, {<span class="number">12</span>, <span class="number">13</span>}, {<span class="number">14</span>, <span class="number">15</span>}, {<span class="number">16</span>, <span class="number">17</span>} }<span class="comment">/* 声明数组并初始化外层索引为1和3的元素 */</span>a3 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ <span class="number">1</span>: {<span class="number">20</span>, <span class="number">21</span>}, <span class="number">3</span>: {<span class="number">40</span>, <span class="number">41</span>}}<span class="comment">/* 声明数组并初始化外层数组和内层数组的单个元素 */</span>a4 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ <span class="number">1</span>: {<span class="number">0</span>: <span class="number">20</span>}, <span class="number">3</span>: {<span class="number">1</span>: <span class="number">41</span>}}<span class="comment">/* 访问数组中的元素 */</span>a1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span><span class="comment">/* 同类型数组可以互相赋值，此处的同类型指的是长度，数据类型相同 */</span>a1 = a2<span class="comment">/* 使用索引为多维数组赋值*/</span><span class="comment">// 将数组a1中索引为1的值复制到一个同类型数组中</span><span class="keyword">var</span> a5 [<span class="number">2</span>]<span class="keyword">int</span> = a1[<span class="number">1</span>]<span class="comment">// 将数组a1中外层索引为1，内层索引为0的元素赋予变量</span><span class="keyword">var</span> value <span class="keyword">int</span> = a1[<span class="number">1</span>][<span class="number">0</span>]}</code></pre><h4 id="在函数间传递数组"><a class="markdownIt-Anchor" href="#在函数间传递数组"></a> 在函数间传递数组</h4><p>从内存和性能来看，在函数间传递数组是一个开销很大的操作，因为不论数组多长，都会被完整的复制并传递给函数。假设现在有一个int型数组长度为100万，在64位架构上需要8MB的内存。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span>foo(array)}<span class="comment">// 函数foo接收一个长度为100万的数组</span><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array [1e6]<span class="keyword">int</span>)</span></span> {}</code></pre><p>每次<code>foo</code>被调用时，必须在栈上分配8MB的内存。之后，整数组的值被复制到刚分配的内存中。这开销十分的大。我们可以通过<code>只传入指向数组的指针</code>的方式解决这个问题。这样只需要复制8字节的数据而不需要复制8MB的数据到栈上，。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span><span class="comment">// 将array的地址传给foo</span>foo(&amp;array)}<span class="comment">// 函数foo接收一个指向长度为100万的数组的指针</span><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array *[1e6]<span class="keyword">int</span>)</span></span> {}</code></pre><p>这样操作会更有效地利用内存，性能也更好。但由于传递的是指针，所以如果改变指针指向的值，会改变共享的内存。切片能更好地处理这类共享问题。</p><h3 id="切片的内部实现和基础功能"><a class="markdownIt-Anchor" href="#切片的内部实现和基础功能"></a> 切片的内部实现和基础功能</h3><blockquote><p><code>切片</code>是一种数据结构，便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以自动增长和缩小。切片的动态增长是通过函数<code>append</code>实现的。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能取得索引，迭代以及为垃圾回收优化的好处。</p></blockquote><h4 id="内部实现-2"><a class="markdownIt-Anchor" href="#内部实现-2"></a> 内部实现</h4><p>切片是很小的对象，对底层数组进行抽象，并提供相关的操作方法。切片有3个字段的数据结构，这三个字段分别是指向底层数组的指针，切片访问的元素的个数（即长度）和切片允许增长的到的元素个数（即容量）。</p><h4 id="创建和初始化"><a class="markdownIt-Anchor" href="#创建和初始化"></a> 创建和初始化</h4><p>是否能提前知道切片需要的容量通常会决定要如何创建切片。</p><h5 id="make和切片字面量"><a class="markdownIt-Anchor" href="#make和切片字面量"></a> make和切片字面量</h5><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {<span class="comment">/* 创建一个字符串切片，长度和容量都是5 */</span>slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)<span class="comment">/* 创建一个长度为3，容量为5的字符串切片 */</span>s1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">/* 创建长度和容量都是5的切片 */</span>    s2 := []<span class="keyword">string</span> {<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}      <span class="comment">/* 创建chang*/</span>}</code></pre><p>上述切片可以访问3个元素，而底层数组拥有5个元素，剩下2个元素可以后期操作合并到切片，并通过切片访问这些元素。如果基于这个切片创建新的切片，新切片会和原有切片共享底层数组，也能通过后期操作访问多余容量的元素。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">/* 切片的容量不能小于长度 */</span>   slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">3</span>)      <span class="comment">// Error:len larger than cap in make([]string)</span>   fmt.Println(slice)}</code></pre><p>如果在<code>[]</code>元素符中指定了值，那么创建的就是数组而不是切片。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">/* 声明长度和容量皆为100的切片 */</span>   slice := []<span class="keyword">string</span>{<span class="number">99</span>:<span class="string">"Red"</span>}   <span class="comment">/* 声明长度为100的数组 */</span>   s1 := [<span class="number">100</span>]<span class="keyword">string</span>{<span class="number">99</span>:<span class="string">"Red"</span>}   fmt.Println(s1)   fmt.Println(slice)}</code></pre><h5 id="nil和空切片"><a class="markdownIt-Anchor" href="#nil和空切片"></a> nil和空切片</h5><p>nil切片常用于描述一个不存在的切片，例如当函数要求返回一个切片但返回异常时。而空切片在底层数组包含0个元素，也没有分配任何存储空间，可用于当数据库查询返回0个结果时。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">/* nil切片，指针为nil */</span>   <span class="keyword">var</span> slice []<span class="keyword">int</span>      <span class="comment">/* 空切片，指针为空 */</span>   s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)   s2 := []<span class="keyword">int</span>{}}</code></pre><h4 id="使用切片"><a class="markdownIt-Anchor" href="#使用切片"></a> 使用切片</h4><ul><li>赋值和切片</li></ul><p>对于切片中某个索引指向的元素赋值和数据操作一致。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">// 创建长度和容量都是5的切片</span>   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}      <span class="comment">// 修改索引为0的元素</span>   slice[<span class="number">0</span>] = <span class="number">0</span>}</code></pre><p>切片之所以被称为切片，是因为创建一个新切片就是把底层数组切出一部分。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {fmt.Println(slice[i]) <span class="comment">// 10, 20, 30, 40, 50</span>}<span class="comment">// 创建一个新切片，长度为2，容量为4</span>newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(newSlice) ; i++ {fmt.Println(newSlice[i]) <span class="comment">// 20 30</span>}}</code></pre><p><img src="/article/Go/Go Base/数组、切片和映射/slice.png" alt="无法加载" title="共享同一底层数组的两个切片"></p><p>上述结果显示，两个切片共享同一段底层数组，但是不同的切片看到的是数组的不同部分。对于底层数组容量为k的<code>lices[i:j]</code>，新切片的长度为<code>j-i</code>,容量为<code>k-i</code>。</p><p>此时两个数组共享同一个底层数组，如果一个切片修改了底层数组的共享部分，另一个切片也能感受到。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment">// 修改新切片索引为1的元素</span>   newSlice[<span class="number">1</span>] = <span class="number">35</span>   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {      fmt.Println(slice[i]) <span class="comment">// 10, 20, 35, 40, 50</span>   }}</code></pre><p>修改newSlice索引为1的元素其实也是修改了slice索引为2的元素。</p><p>切片只能访问其长度内的元素。与切片容量相关联的元素只能用于增长元素，在使用这部分元素前，必须将其合并到切片的长度里。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]      <span class="comment">// newSlice长度为2，所以索引为3的元素对其而言不存在</span>   newSlice[<span class="number">3</span>] = <span class="number">35</span>   <span class="comment">// Error：runtime error: index out of range</span>   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {      fmt.Println(slice[i]) <span class="comment">// 10, 20, 35, 40, 50</span>   }}</code></pre><p>切片有额外的容量很好，但如果没有把这些容量合并到切片的长度中，这些容量就是没用的。</p><ul><li><p>切片增长</p><p>切片可以按需增长容量，Go中的<code>append</code>函数会处理增长长度的所有操作细节。要使用<code>append</code>需要一个被操作的切片和一个要追加的值。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment">// 使用原有的容量来分配一个新元素</span>   newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {      fmt.Println(slice[i]) <span class="comment">// 10 20 30 40 50 </span>   }}</code></pre></li></ul><p><code>newSlice</code>在底层数组还有可用容量，因此<code>append</code>会将可用元素合并到切片的长度中，并对其赋值。但由于和slice共享同一个数组，所以slice中索引为3的元素也会被改变。</p><p>如果切片的底层数组没有可用容量，append会创建一个新的数组，将被引用的现有的值复制到新数组中，再追加新的值。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>}   newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {      fmt.Println(slice[i]) <span class="comment">// 10 20 30 40</span>   }   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(newSlice); i++ {      fmt.Println(newSlice[i]) <span class="comment">// 10 20 30 40 50</span>   }   }</code></pre><p><code>append</code>会智能处理底层数组的容量增长，当切片容量小于1000时，会成倍增长容量。但超过1000时，会将增长因子设为1.25.</p><ul><li>创建切片时的3个索引</li></ul><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}    <span class="comment">// 定义一个长度为1，容量为2的切片</span>    <span class="comment">// 2为新切片开始的索引</span>    <span class="comment">// 3为新切片的长度+2</span>    <span class="comment">// 4为新切片的容量+2</span>slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {fmt.Println(slice[i]) <span class="comment">// 30</span>}<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(source); i++ {fmt.Println(source[i]) <span class="comment">// 10 20 30 40 50</span>}}</code></pre><p>此时切片的长度，对于<code>slice[i:j:k]</code>，其长度为<code>j-i</code>，容量为<code>k-i</code>.如果设置的容量比可用容量大，就会运行出错。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">6</span>]   <span class="comment">// panic: runtime error: slice bounds out of range</span>  }</code></pre><p>append会先使用可用容量，如果没有可用容量就会创建新的底层数组。这导致很容易忘记切片间正在共享一个数组，一旦发生这种情况，会导致问题，对切片内容的修改会影响多个切片。</p><p>因此设置长度和容量一样的好处就是，会强制让新的切片的第一个<code>append</code>操作创建一个新的底层数组，与原有的数组分离。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   slice := []<span class="keyword">int</span>{<span class="number">60</span>, <span class="number">70</span>}   <span class="comment">// 将两个切片追加。source追加slice元素</span>   fmt.Printf(<span class="string">"%v\n"</span>, <span class="built_in">append</span>(source, slice...)) <span class="comment">// [10 20 30 40 50 60 70]</span>   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(source); i++ {      fmt.Println(source[i]) <span class="comment">// 10 20 30 40 50</span>   }}</code></pre><ul><li>迭代切片</li></ul><p>切片是一个集合，可以迭代其中的元素。Go可以使用关键字<code>range</code>配合关键字<code>for</code>迭代切片里的元素。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   <span class="keyword">for</span> index, value := <span class="keyword">range</span> source {      fmt.Printf(<span class="string">"index = %d, value = %d \n"</span>, index, value)   }}</code></pre><p>迭代切片时，关键字<code>range</code>会返回两个值，一个是当前元素的索引，一个是当前元素值的一个副本。此处要注意的是，切片返回的是元素值的副本，不是对该元素的直接引用。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}      <span class="keyword">for</span> index, value := <span class="keyword">range</span> source {      fmt.Printf(<span class="string">"Value: %d Value-Addr: %X ElemAddr: %X \n"</span>, value, &amp;value,         &amp;source[index])   }      <span class="comment">/** Output   Value: 10 Value-Addr: C04204A088 ElemAddr: C042066030    Value: 20 Value-Addr: C04204A088 ElemAddr: C042066038    Value: 30 Value-Addr: C04204A088 ElemAddr: C042066040    Value: 40 Value-Addr: C04204A088 ElemAddr: C042066048    Value: 50 Value-Addr: C04204A088 ElemAddr: C042066050     */</span>}</code></pre><p>此时我们可以看到副本的地址一直是不变的是因为迭代返回的变量是在迭代过程中根据切片依次赋予的新值，但其本身不变。要想获取元素真正的地址，需要使用切片变量和索引值。</p><p><code>range</code>的迭代是从切片索引0开始的，要像从其他索引开始迭代，可以使用<code>for</code>循环。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   <span class="comment">// 从索引2开始迭代切片</span>   <span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(source); index ++ {      fmt.Printf(<span class="string">"value = %d, index = %d \n"</span>, source[index], index)   }}</code></pre><p>Go中有两个内置函数<code>len()</code>和<code>cap()</code>，可以用于处理数组、切片和通道。对于切片，<code>len()</code>返回切片的长度，<code>cap()</code>返回切片的容量。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}   slice := <span class="built_in">append</span>(source, <span class="number">60</span>)    <span class="comment">// 当append超出原切片容量时，会创建新数组，且当元素为1000时，容量会翻倍</span>   fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 10</span>}</code></pre><h4 id="多维切片"><a class="markdownIt-Anchor" href="#多维切片"></a> 多维切片</h4><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">// 创建多维切片，该切片中包含两个切片{10},{10, 20}</span>   slice := [][]<span class="keyword">int</span>{ {<span class="number">10</span>}, {<span class="number">10</span>, <span class="number">20</span>}}    fmt.Println(slice) <span class="comment">// [[10] [10 20]]</span>   <span class="comment">// 为切片中的第一个切片追加值为20的元素</span>   slice[<span class="number">0</span>] = <span class="built_in">append</span>(slice[<span class="number">0</span>], <span class="number">20</span>)   fmt.Println(slice) <span class="comment">// [[10 20] [10 20]]</span>}</code></pre><p>多维切片<code>append</code>的过程是先增长<code>{10}</code>，然后将增长后的<code>{10, 20}</code>赋值给<code>slice[0]</code>。多维切片，操作时会涉及众多布局和值，但是切片本身结构简单，可以以很小的成本在函数间传递。</p><h4 id="切片在函数间传递"><a class="markdownIt-Anchor" href="#切片在函数间传递"></a> 切片在函数间传递</h4><p>切片的尺寸小，在函数间赋值和传递切片的成本也低。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1e6</span>)   foo(slice)}<span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> {   <span class="keyword">return</span> slice}</code></pre><p>在64位架构的机器上，一个切片需要24字节的内存：指针字段需要8字节，长度和容量字段分别需要8字节。由于切片关联的数据包含在底层数组中，不属于切片本身，所以将切片复制到任何函数时，对底层数组大小都不会有影响。复制的只是切片本身，不会涉及底层数组 。</p><h3 id="映射的内部实现和基本功能"><a class="markdownIt-Anchor" href="#映射的内部实现和基本功能"></a> 映射的内部实现和基本功能</h3><p>映射是一种数据结构，用于存储一系列的键值对。映射里基于键来存储值。映射的优势是，能够基于键快速检索数据，键就像是索引一样，指向与该键关联的值。</p><h4 id="内部实现-3"><a class="markdownIt-Anchor" href="#内部实现-3"></a> 内部实现</h4><p>映射是一个集合，可以使用类似切片的方式迭代映射中的元素。但映射是无序集合，这使得无法预测键值对被返回的顺序，即使用同样的顺序保存键值对，但每次迭代映射的时候，顺序也会不一样。这是因为映射的实现使用了散列表。散列表的具体细节暂时不描述。</p><h4 id="创建和初始化-2"><a class="markdownIt-Anchor" href="#创建和初始化-2"></a> 创建和初始化</h4><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// 创建一个键值类型都是string的映射</span>   dict1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)      fmt.Println(dict1)   <span class="comment">// 创建一个映射，key为int,value为string</span>   dict := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{<span class="number">1</span>:<span class="string">"One"</span>,<span class="number">2</span>:<span class="string">"Two"</span>,<span class="number">3</span>:<span class="string">"Three"</span>}   <span class="comment">// 迭代循环，由结果可得，其是无序集合，每次输出的顺序可能都不一样</span>   <span class="keyword">for</span> key, value := <span class="keyword">range</span> dict {      fmt.Printf(<span class="string">"%d = %s \n"</span>, key, value)   }}</code></pre><p>映射的长度会根据初始化时指定的键值对数量来确定。映射的键可以是任何只，可以是基本数据类型，也可以是结构类型，只要这个值可以用<code>==</code>运算符做比较。切片、函数以及包含切片的结构类型由于使用了引用，都不能作为映射的键。但可以作为映射的值。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// 将切片作为映射的键</span>   dict1 := <span class="keyword">map</span>[[]<span class="keyword">string</span>] <span class="keyword">int</span>{}   <span class="comment">// Exception: invalid map key type []string</span>   fmt.Println(dict1)   <span class="comment">// 将切片作为映射的值</span>   dict2 := <span class="keyword">map</span>[<span class="keyword">int</span>] []<span class="keyword">string</span>{}   fmt.Println(dict2)}</code></pre><h4 id="使用映射"><a class="markdownIt-Anchor" href="#使用映射"></a> 使用映射</h4><p>键值对赋值给映射，是通过指定适当类型的键并给这个键赋值来完成的。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">//  声明一个空映射</span>   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{}   <span class="comment">// 将"1"对应的英文"One"加入到映射中</span>   nums[<span class="string">"1"</span>] = <span class="string">"One"</span>   <span class="comment">// 空映射可以用于存储键值对，但nil映射不能</span>   <span class="keyword">var</span> colors <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>   colors[<span class="string">"Red"</span>] = <span class="string">"#da1337"</span>   <span class="comment">// panic: assignment to entry in nil map</span>}</code></pre><p>检测映射中是否存在某个键是映射的常用操作。这个操作允许用户写一些逻辑来确定是否完成了某个操作或是否在映射中缓存了特定数据，也可以用于比较两个映射，来确定哪些键值对互相匹配。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">//  声明一个空映射</span>   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{}   <span class="comment">// 将"1"对应的英文"One"加入到映射中</span>   nums[<span class="string">"1"</span>] = <span class="string">"One"</span>   <span class="comment">// 同时获取映射中key对应的值，以及这个键是否存在</span>   value, exists := nums[<span class="string">"1"</span>]   <span class="keyword">if</span> exists {      fmt.Println(value)   }       <span class="comment">// 只返回键对应的值，从而判断这个值是不是零值，以此来判断key是否存在</span>   v := nums[<span class="string">"1"</span>]   <span class="keyword">if</span> v != <span class="string">""</span> {      fmt.Println(value)   }}</code></pre><p>Go中即使键不存在，也会返回一个值。这个值是值对应的数据类型的零值。</p><p>可以使用<code>delete()</code>函数删除映射中的键值对</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">//  声明一个空映射</span>   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{      <span class="string">"1"</span>: <span class="string">"One"</span>,      <span class="string">"2"</span>: <span class="string">"Two"</span>,      <span class="string">"3"</span>: <span class="string">"Three"</span>,   }   <span class="built_in">delete</span>(nums, <span class="string">"2"</span>)   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value)   }}</code></pre><h4 id="在函数间传递映射"><a class="markdownIt-Anchor" href="#在函数间传递映射"></a> 在函数间传递映射</h4><p>在函数间传递映射时，并不会造出该映射的副本，即将映射传递给函数后，所有对这个映射的映射都会收到函数的操作带来的影响。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">//  声明一个空映射</span>   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{      <span class="string">"1"</span>: <span class="string">"One"</span>,      <span class="string">"2"</span>: <span class="string">"Two"</span>,      <span class="string">"3"</span>: <span class="string">"Three"</span>,   }   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value)      <span class="comment">// Output:</span>      <span class="comment">// 1 = One </span>      <span class="comment">// 2 = Two</span>      <span class="comment">// 3 = Three </span>   }   remove(nums, <span class="string">"2"</span>)   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value)       <span class="comment">// Output:</span>      <span class="comment">// 1 = One </span>      <span class="comment">// 3 = Three </span>   }}<span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, key <span class="keyword">string</span>)</span></span>  {   <span class="built_in">delete</span>(dict, key)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组-切片和映射&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组-切片和映射&quot;&gt;&lt;/a&gt; 数组、切片和映射&lt;/h2&gt;
&lt;h3 id=&quot;数组的内部实现和基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go中的类型</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/Go%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/Go中的类型/</id>
    <published>2018-01-17T01:39:45.690Z</published>
    <updated>2018-01-17T01:49:54.996Z</updated>
    
    <content type="html"><![CDATA[<p>Go是一种静态类型的语言。这意味着编译器需要在编译时知道程序中每个值的类型。这有助于减少潜在的内存异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。</p><h3 id="自定义类型"><a class="markdownIt-Anchor" href="#自定义类型"></a> 自定义类型</h3><p>Go允许用户自定义类型，当用户声明一个新类型时，该声明就给编译器提供一个框架，告知必要的内存大小和表示信息Go中有两种声明类型的方式，，一种是使用关键字<code>struct</code>，用于创建一个结构类型。结构类型通过组合一系列固定且唯一的字段来声明。结构中的字段可以用Go内置的类型声明，也可以用自定义的类型声明。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义一个user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {name <span class="keyword">string</span>age <span class="keyword">int</span>sex <span class="keyword">bool</span>}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="comment">// 声明user型变量</span><span class="keyword">var</span> u user<span class="comment">// 不赋值时，每个字段为其对应数据类型的默认值</span>fmt.Println(u) <span class="comment">// &amp;#123"" 0 false&amp;#125</span><span class="comment">// 给结构中的字段赋值</span>u.name = <span class="string">"Tom"</span>u.age = <span class="number">18</span>u.sex = <span class="literal">true</span><span class="comment">// 给结构中的字段赋值，可以不按照结构中字段的顺序进行赋值</span>lisa := user{name: <span class="string">"Lisa"</span>,age:<span class="number">21</span>,sex: <span class="literal">false</span>,}<span class="comment">// 给结构中的字段赋值，必须按照结构中字段的顺序进行赋值</span>bill := user{<span class="string">"Bill"</span>, <span class="number">8</span>, <span class="literal">true</span>}fmt.Println(u)fmt.Println(lisa)fmt.Println(bill)}</code></pre><p>使用自定义类型声明类型中的字段</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义一个user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name <span class="keyword">string</span>   age <span class="keyword">int</span>   sex <span class="keyword">bool</span>}<span class="comment">// 使用自定义类型声明结构中的字段</span><span class="keyword">type</span> admin <span class="keyword">struct</span> {   person user   level <span class="keyword">string</span>}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   u := admin{      person:user {         name:<span class="string">"admin"</span>,         age:<span class="number">18</span>,         sex:<span class="literal">true</span>,      },      level:<span class="string">"1"</span>,   }   fmt.Println(u) </code></pre><p>此外还可以基于已有的类型，声明新类型的类型。当需要一个可以用已有类型表示新的类型时，这个方式很好用。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="keyword">type</span> Duration <span class="keyword">int64</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="keyword">var</span> dur Duration   dur = <span class="keyword">int64</span>(<span class="number">1000</span>)   <span class="comment">// cannot use int64(1000) (type int64) as type Duration in assignment</span>   fmt.Println(dur) }</code></pre><p>尽管<code>int64</code>是<code>Duration</code>的基础类型，但是Go不会认为它们是同一种类型。因此当将<code>int64</code>的值赋予<code>dur</code>时会报错。两种类型即使互相兼容，但不能互相赋值，编译器不会对不同类型的值做隐式转换。</p><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><p>方法能给用户定义的类型添加新的行为。方法实际也是函数，只是在声明时，在关键字<code>func</code>和方法名之间增加了一个参数。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义一个user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="keyword">type</span> people <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="comment">// 定义一个方法,(u user)表示只有类型为user的变量才可以接收该方法</span><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span>{   fmt.Printf(<span class="string">"Sending User Email To %s&lt;%s&gt; \n"</span>, u.name, u.email)}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   bill := user{   <span class="string">"bill"</span>,    <span class="string">"bill@email.com"</span>   }   <span class="comment">// 只有类型为user的变量才能调用notify()</span>   bill.notify()   lisa := people{   <span class="string">"lisa"</span>,    <span class="string">"lisa@email.com"</span>   }   <span class="comment">// 报错，type people has no field or method notify</span>   lisa.notify()}</code></pre><p>该参数用于定义方法的接收者，即定义调用方法的变量。Go中的接收者有两种类型：值接收者和指针接收者。值接受者声明的方法，在调用时，会用这个值的副本来执行。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义一个user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="comment">// 定义一个指针接收者方法</span><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">changeEmail</span><span class="params">(email <span class="keyword">string</span>)</span></span>  {   u.email = email}<span class="comment">// 定义一个值接收者方法</span><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">changeName</span><span class="params">(name <span class="keyword">string</span>)</span></span>  {   u.name = name}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// user类型的值可以调用值接收者方法，也可以调用指针接收者方法</span>   bill := user{   <span class="string">"bill"</span>,    <span class="string">"bill@email.com"</span>   }   bill.changeName(<span class="string">"lisa"</span>)   bill.changeEmail(<span class="string">"lisa@email.com"</span>)   fmt.Print(bill) <span class="comment">// {bill lisa@email.com}</span>   <span class="comment">// user类型的值的指针可以调用指针接收者方法，也可以调用值接收者方法</span>   lisa := &amp;user{<span class="string">"lisa"</span>, <span class="string">"lisa@email.com"</span>}   lisa.changeName(<span class="string">"Lisa"</span>)   lisa.changeEmail(<span class="string">"Lisa@mail.com"</span>)   fmt.Println(lisa) <span class="comment">// {lisa Lisa@mail.com}</span>}</code></pre><p>由结果我们可以看出，值接收者声明的方法，执行后不会改变调用该方法的变量本身的值。但指针接收者声明的方法，不论是普通变量还是指针变量调用后，都会改变自身的值。这是因为值接收者声明的方法，被调用后，接收到的是<code>bill</code>的副本，而指针接收者声明的方法被调用后接收到的是变量自身的实际值。指针变量能够调用值接收者方法，是因为Go调整了指针的值，指针被解引用为值，即等价于<code>(*lisa).changeName(&quot;Lisa&quot;)</code>。普通变量能够调用指针接收者方法，是因为Go先引用<code>bill</code>得到了一个指针，即等价于<code>(&amp;bill).changeEmail(&quot;lisa@email.com&quot;)</code></p><h3 id="类型的本质"><a class="markdownIt-Anchor" href="#类型的本质"></a> 类型的本质</h3><p>声明一个类型之后，声明一个该类型的方法之前，需要考虑以下几点：</p><ul><li>该类型的本质是什么</li><li>给该类型增加或删除某个值，是要创建新值还是改变当前值。如果是创建新值，则使用值接收者声明方法；如果是修改当前值，则使用指针接收者声明方法。</li></ul><h4 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h4><p>基本类型是由语言自身提供的一组类型，如数值类型、字符串类型、布尔类型。这些类型是本质是原始的类型，因此对这些值进行操作时，会创建新值。基于这个 理论，当这些类型的值传递给方法或函数时，应该传递一个对应值的副本。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> (   <span class="string">"fmt"</span>   <span class="string">"strings"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"Hello, World"</span>   <span class="comment">// Trim删除s中的H、e、l、o、d字母</span>   fmt.Println(strings.Trim(s, <span class="string">"Helod"</span>)) <span class="comment">// 生成了新的字符串 ", Wor"</span>   fmt.Println(s)  <span class="comment">// s本身不变</span>}</code></pre><p>字符串本质上是基本类型，所以在函数或方法内外传递时，传递的是字符串的副本。</p><h4 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h4><p>Go中的引用类型有：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称为<code>header</code>值。从技术细节来讲，字符串也是引用类型。每个引用类型的创建的<code>header</code>值，包含一个指向底层数据结构的指针，还包含一组独特的字段，用于管理底层数据结构。因为<code>header</code>值是为复制而设计的，所以永远不需要共享一个引用类型的值。<code>header</code>值里包含一个指针，因此通过复制来传递引用类型的值的副本，本质上就是共享底层数据结构。即引用类型的函数或方法内外传递时，依然使用的是数据副本。</p><h4 id="结构类型"><a class="markdownIt-Anchor" href="#结构类型"></a> 结构类型</h4><p>结构类型可以用于描述一组数据，这组数据的本质可以是原始的，也可以是非原始的，如果要决定在某些数据需要删除或添加结构类型的值时，该结构类型的值不应该被更改，那么需要遵守之前提到的基本类型和引用类型的规范。使用值接收者还是指针接收者，不应该由这个方法是否修改了值的本身决定，而是应该基于该类型的本质。其本质为原始，则使用值接收，非原始则使用指针接收。</p><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</p><h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4><p>接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。</p><h4 id="方法集"><a class="markdownIt-Anchor" href="#方法集"></a> 方法集</h4><p>方法集定义了接口的接收规则。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义notifier接口，具有notify()行为</span><span class="keyword">type</span> notifier <span class="keyword">interface</span> {   notify()}<span class="comment">// 定义user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="comment">// 使用指针接收者实现notify()</span><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {   fmt.Printf(<span class="string">"Sending user email to  %s&lt;%s&gt;\n"</span>, u.name, u.email)}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>   u := user{   <span class="string">"Bill"</span>,    <span class="string">"bill@email.com"</span>   }   SendNotification(u)   <span class="comment">// cannot use u (type user) as type notifier in argument to SendNotification:</span>   <span class="comment">// user does not implement notifier (notify method has pointer receiver)</span>}<span class="comment">// 接收一个实现了notifier接口的值</span><span class="function"><span class="keyword">func</span> <span class="title">SendNotification</span><span class="params">(n notifier)</span></span>  {   n.notify()}</code></pre><p>由报错的原因，我们可以看出notify()是指针接收者声明的。要想了解指针接收者来实现接口时为什么user类型的值无法实现该接口，就需要先了解方法集。方法集定义了一组关联到给定类型的值或指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针。</p><p>从接收者类型角度来看方法集，值接收者定义的方法可以接收值或指针，而指针接收者定义的方法只能接收指针。所以将代码改为下述形式后，就不会报错了：</p><pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>   u := user{   <span class="string">"Bill"</span>,    <span class="string">"bill@email.com"</span>   }   SendNotification(&amp;u)}</code></pre><h4 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h4><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义notifier接口，具有notify()行为</span><span class="keyword">type</span> notifier <span class="keyword">interface</span> {   notify()}<span class="comment">// 定义user类型</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="comment">// user实现的notify()</span><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {   fmt.Printf(<span class="string">"Sending user email to  %s&lt;%s&gt;\n"</span>, u.name, u.email)}<span class="comment">// 定义admin类型</span><span class="keyword">type</span> admin <span class="keyword">struct</span> {   name <span class="keyword">string</span>   age  <span class="keyword">int</span>}<span class="comment">// admin实现的notify()</span><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> {   fmt.Printf(<span class="string">"%s is %d years old."</span>, a.name, a.age)}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>   u := user{   <span class="string">"Bill"</span>,    <span class="string">"bill@email.com"</span>   }   SendNotification(&amp;u)   <span class="comment">// 创建一个admin类型的变量，并调用notify()</span>   a := admin{   <span class="string">"Lisa"</span>,    <span class="number">18</span>}   SendNotification(&amp;a)}<span class="comment">// 接收一个实现了notifier接口的值</span><span class="function"><span class="keyword">func</span> <span class="title">SendNotification</span><span class="params">(n notifier)</span></span>  {   n.notify()}</code></pre><p>任意一个实体类型都能实现接口<code>notifier</code>，因此<code>SendNotification</code>可以针对实现接口的类型，实现具体的行为。这就是多态。</p><h3 id="嵌入类型"><a class="markdownIt-Anchor" href="#嵌入类型"></a> 嵌入类型</h3><p>Go语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候很重要。这个功能是通过<code>嵌入类型（type embedding）</code>完成的。嵌入类型是将已有的类型直接声明在新结构类型中。被嵌入的类型被称为新的外部类型的内部类型。</p><p>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。外部类也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符或者方法。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {   fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)}<span class="keyword">type</span> admin <span class="keyword">struct</span> {   user <span class="comment">// 嵌入类型</span>   level <span class="keyword">string</span>}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   ad := admin{      user: user{         name:  <span class="string">"john smith"</span>,         email: <span class="string">"john@yohoo.com"</span>,      },      level: <span class="string">"super"</span>,   }   <span class="comment">// 可通过内部类型调用内部类型的方法</span>   ad.user.notify()   <span class="comment">// 也可以直接使用外部类型直接调用方法</span>   ad.notify()}</code></pre><p>上述代码中将<code>user</code>嵌入<code>admin</code>类型中只需要在外部类型中声明要嵌入的类型名即可。对于外部类型而言，内部类型是存在的，所以即使外部类型可以使用内部类型的属性名来访问内部类型的值。也可以直接访问内部类型<code>user</code>来调用外部类型方法，也可以直接用外部类型的变量调用<code>notify()</code>。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="comment">// 定义个接口，接口有notify()</span><span class="keyword">type</span> notifier <span class="keyword">interface</span> {   notify()}<span class="keyword">type</span> user <span class="keyword">struct</span> {   name  <span class="keyword">string</span>   email <span class="keyword">string</span>}<span class="comment">// 通过user类型的值的指针调用notify()</span><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {   fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)}<span class="keyword">type</span> admin <span class="keyword">struct</span> {   user <span class="comment">// 嵌入类型</span>   level <span class="keyword">string</span>}<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   ad := admin{      user: user{         name:  <span class="string">"john smith"</span>,         email: <span class="string">"john@yohoo.com"</span>,      },      level: <span class="string">"super"</span>,   }   <span class="comment">// admin类型的值的指针也可以传入</span>   sendNotification(&amp;ad)}<span class="comment">// 接收一个实现notifier接口的值</span><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> {   n.notify()}                     </code></pre><p>由上述代码可知，如果嵌入类型实现了某接口，外部类型也相当于实现了该接口。如果外部类型并不需要使用内部类型对接口的实现方式，想定义属于自己的实现方式，应按照下述代码：</p><pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> {fmt.Printf(<span class="string">"Sending admin email to %s&lt;%s&gt;\n"</span>, a.name, a.email)}</code></pre><p>在上述代码添加由admin类型的值的指针调用的方法，此时再运行上述代码，调用的就不再是user类型的值的指针调用的方法。</p><pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   ad := admin{      user: user{         name:  <span class="string">"john smith"</span>,         email: <span class="string">"john@yohoo.com"</span>,      },      level: <span class="string">"super"</span>,   }   <span class="comment">// admin类型的值的指针也可以传入</span>   sendNotification(&amp;ad)  <span class="comment">// Sending admin email to john smith&lt;john@yohoo.com&gt;</span>   sendNotification(&amp;ad.user) <span class="comment">// Sending user email to john smith&lt;john@yohoo.com&gt;</span>}</code></pre><h3 id="公开或未公开的标识符"><a class="markdownIt-Anchor" href="#公开或未公开的标识符"></a> 公开或未公开的标识符</h3><p>定义一个<code>counters/counters.go</code></p><pre class="highlight"><code class="go"><span class="keyword">package</span> counters<span class="comment">// 未公开类型</span><span class="keyword">type</span> alertCounter <span class="keyword">int</span></code></pre><p>此时在主程序中调用该类型</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> (   <span class="string">"demo/counters"</span>   <span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   counter := counters.alertCounter(<span class="number">10</span>)   fmt.Println(counter)   <span class="comment">/*   .\main.go:9:13: cannot refer to unexported name counters.alertCounter   .\main.go:9:13: undefined: counters.alertCounter    */</span>}</code></pre><p>在Go中，当一个标识符以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。当一个标识符以大写字母开头，其就是公开的，即包外可见。修改上述程序：</p><pre class="highlight"><code class="go"><span class="keyword">package</span> counters<span class="comment">// 公开类型</span><span class="keyword">type</span> AlertCounter <span class="keyword">int</span>=======================================<span class="keyword">package</span> main<span class="keyword">import</span> (   <span class="string">"demo/counters"</span>   <span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {   counter := counters.AlertCounter(<span class="number">10</span>)   fmt.Println(counter) <span class="comment">// 10</span>}</code></pre><p>或者在不修改<code>counter.go</code>中<code>alertCounter</code>的情况下，也可以使用以下方式调用未公开的类型：</p><pre class="highlight"><code class="go"><span class="keyword">package</span> counters<span class="comment">// 未公开类型</span><span class="keyword">type</span> alertCounter <span class="keyword">int</span><span class="comment">// 创建并返回一个alertCounter类型的值</span><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">alertCounter</span></span>  {   <span class="keyword">return</span> alertCounter(value)}===========================================<span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"demo/counters"</span><span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {counter := counters.New(<span class="number">10</span>)fmt.Println(counter) <span class="comment">// 10</span>}</code></pre><p>我们可以实现工厂函数，来返回一个未公开类型的值。Go语言习惯将工厂函数命名为<code>New</code>，它创建了一个未公开类型的值，并将其返回给调用者。该程序能通过编译，需要两个条件：第一、公开或未公开的标识符不是一个值；第二、短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> entities<span class="keyword">type</span> User <span class="keyword">struct</span> {   Name <span class="keyword">string</span>   <span class="comment">// 未公开字段</span>   email <span class="keyword">string</span>}==================<span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"demo/entities"</span><span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {u := entities.User{Name:  <span class="string">"Bill"</span>,email: <span class="string">"bill@email.com"</span>,<span class="comment">// unknown field 'email' in struct literal of type entities.User</span>}fmt.Println(u)}</code></pre><p>上述代码出错，是由于<code>email</code>字段首字母为小写，是不公开字段。下面看展示公开和未公开的内嵌类型是如何工作的。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> entities<span class="keyword">type</span> user <span class="keyword">struct</span> {   Name <span class="keyword">string</span>   Email <span class="keyword">string</span>}<span class="keyword">type</span> Admin <span class="keyword">struct</span> {   user <span class="comment">// 嵌入的类型未公开</span>   Rights <span class="keyword">int</span>}=====================<span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"demo/entities"</span><span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {a := entities.Admin{Rights: <span class="number">10</span>,}a.Name = <span class="string">"Bill"</span>a.Email = <span class="string">"bill@email.com"</span>fmt.Println(a)}</code></pre><p>上述代码无法直接通过结构字面量的方式初始化该内部类型。但即便内部类型是未公开，内部类型里声明的字段依旧是公开的，。既然内部类型的标识符提升到了外部类型，这些公开字段也可以通过外部类型的字段的值来访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go是一种静态类型的语言。这意味着编译器需要在编译时知道程序中每个值的类型。这有助于减少潜在的内存异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。&lt;/p&gt;
&lt;h3 id=&quot;自定义类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>实践篇03--Spring Cloud Eureka</title>
    <link href="http://yov.oschina.io/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%AE%9E%E8%B7%B5%E7%AF%8703--Spring%20Cloud%20Eureka/"/>
    <id>http://yov.oschina.io/article/微服务/Micro Service/实践篇03--Spring Cloud Eureka/</id>
    <published>2018-01-15T14:06:20.326Z</published>
    <updated>2018-01-18T07:42:52.699Z</updated>
    
    <content type="html"><![CDATA[<p><code>Spring Cloud Eureka</code>是<code>Spring Cloud Netflix</code>微服务套件中的一部分，它基于<code>Netflix Eureka</code>的二次封装，主要是负责完成微服务架构的服务治理能力。我们只需通过简单引入依赖和注解配置就能使<code>Spring Boot</code>构建的微服务应用轻松地与Eureka服务治理体系进行整合。下面将构建用于服务治理的基础设施：</p><ul><li>构建服务注册中心</li><li>服务注册与服务发现</li><li>Eureka的基础架构</li><li>Eureka的服务治理机制</li><li>Eureka的配置</li></ul><h2 id="服务治理"><a class="markdownIt-Anchor" href="#服务治理"></a> 服务治理</h2><p>服务治理是微服务架构中最为核心和基础的模块，主要用于实现各个微服务实例的自动化注册与发现。随着业务的发展、功能的复杂、微服务应用的增加，静态配置维护难度会递增，且面对不断发展的业务，集群规模、服务位置和命名都有可能改变，手工维护的方式容易导致错误和冲突。</p><p>因此为了解决微服务架构中实例维护问题，出现了许多服务治理框架和产品，他们的实现主要都围绕着服务注册与服务发现机制来实现对微服务应用实例的自动化管理。</p><ul><li>服务注册：在服务治理框架中，会构建一个注册中心，每个服务向注册中心登记自己提供的服务，将主机、端口号、通信协议等信息告知。注册中心会在服务启动和注册后，维护一个服务清单，并以心跳的方式检测清单中的服务是否可用，若不可用则剔除，以达到排除故障的效果。</li><li>服务发现：由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来发现，而是通过向服务名发起请求调用实现。所以，服务调用放在调用服务提供方接口时，并不知道具体的服务实例位置。因此调用发需要向服务注册中心咨询服务，并获取所有的服务的实例清单，以实现对具体服务实例的访问。</li></ul><h2 id="netflix-eureka"><a class="markdownIt-Anchor" href="#netflix-eureka"></a> Netflix Eureka</h2><p><code>Spring Cloud Eureka</code>,使用<code>Netflix Eureka</code>实现服务注册与发现，既包含服务端组件，也包含客户端组件，提供了完备的RESTful API，支持将非Java语言构建的微服务纳入其服务治理体系中。</p><p>Eureka服务端，也称为服务注册中心，支持高可用配置，依托于强一致性提供良好的服务实例可用性，可以应对多重不同的故障场景。当Eureka以集群模式部署，集群中有分片出现故障时，Eureka会转入自动保护模式。它允许分片故障期间继续提供服务的发现和注册，当故障分片回复运行时，集群中其它分片会它们的状态再次同步回来。</p><p>Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入到客户端应用程序的代码中，当应用程序运行时，客户端向注册中心注册自身的提供的服务，并周期性地发送心跳来更新它的服务租约。同时它也能从服务端查询当前注册的服务信息并将它们缓存到本地并周期地刷新服务状态。</p><h3 id="搭建服务注册中心"><a class="markdownIt-Anchor" href="#搭建服务注册中心"></a> 搭建服务注册中心</h3><p>创建一个Spring Boot工程<code>enreka-server</code>，在<code>pom.xml</code>中引入相关依赖：</p><pre class="highlight"><code class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>   <span class="tag">&lt;<span class="name">properties</span>&gt;</span>      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>   <span class="comment">&lt;!-- eureka服务依赖 --&gt;</span>   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring-cloud.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>   <span class="tag">&lt;<span class="name">build</span>&gt;</span>      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>   <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>在项目启动器中添加<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其他应用进行对话。</p><pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaserver;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<span class="meta">@EnableEurekaServer</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>{   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{      SpringApplication.run(EurekaServerApplication.class, args);   }}</code></pre><p>默认情况下，该服务注册中心也会将自己作为客户端进行注册。可在配置文件<code>application.yml</code>中禁用该项:</p><pre class="highlight"><code class="yaml"><span class="attr">spring:</span><span class="attr">  application:</span><span class="attr">    name:</span> <span class="string">Eureka-Server</span><span class="attr">server:</span><span class="attr">  port:</span> <span class="number">10000</span><span class="attr">eureka:</span><span class="attr">  instance:</span><span class="attr">    hostname:</span> <span class="string">localhost</span><span class="attr">  client:</span><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span><span class="attr">    fetch-registry:</span> <span class="literal">false</span>  <span class="comment"># 注册中心的职责是维护服务实例，不需要检索服务</span></code></pre><p>启动应用，并访问<code>http://localhost:10000</code>，界面如下：</p><p><img src="/article/微服务/Micro Service/实践篇03--Spring Cloud Eureka/eureka-server.png" alt="无法加载" title="服务注册中心"></p><p>此时可见<code>Instances currently registered with Eureka</code>为空，这是因为还没有服务向注册中心注册。</p><h3 id="构建服务"><a class="markdownIt-Anchor" href="#构建服务"></a> 构建服务</h3><p>接下来构建一个微服务向服务中心注册自己。新建Spring Boot项目<code>eureka-client</code>，在<code>pom.xml</code>添加依赖：</p><pre class="highlight"><code class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>   <span class="tag">&lt;<span class="name">properties</span>&gt;</span>      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>      <span class="comment">&lt;!-- 添加Eureka依赖 --&gt;</span>      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring-cloud.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>   <span class="tag">&lt;<span class="name">build</span>&gt;</span>      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>   <span class="tag">&lt;/<span class="name">build</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>添加<code>/hello</code>接口，通过注入<code>DiscoveryClient</code>对象，在日志中输出服务的相关信息。</p><pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaclient;<span class="keyword">import</span> org.apache.log4j.Logger;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="comment">/** * <span class="doctag">@author</span> Yov * <span class="doctag">@date</span> 2018/1/14 20:10 */</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>{    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(getClass());    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DiscoveryClient discoveryClient; <span class="comment">// 用于获取服务</span>    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>{        discoveryClient.getServices().forEach(id -&gt; {            discoveryClient.getInstances(id).forEach(instance -&gt; {                <span class="comment">// 在日志中输出服务的相关信息</span>                logger.info(<span class="string">"Hello, host:"</span> + instance.getHost() +                        <span class="string">", server_id: "</span> + instance.getServiceId());            });        });        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;    }}</code></pre><p>在程序入口添加<code>@EnableDiscoveryClient</code>注解，激活Eureka中的<code>DiscoveryClient</code>(自动化配置，创建<code>DiscoveryClient</code>接口针对Eureka的<code>EnrekaDiscoveryClient</code>实例)，这样才能实现Controller中对服务信息的输出。</p><pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaclient;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<span class="meta">@EnableDiscoveryClient</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>{   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{      SpringApplication.run(EurekaClientApplication.class, args);   }}</code></pre><p>修改配置文件<code>application.yml</code></p><pre class="highlight"><code class="yaml"><span class="attr">spring:</span><span class="attr">  application:</span><span class="attr">    name:</span> <span class="string">hello-service</span>  <span class="comment"># 为服务命名</span><span class="attr">eureka:</span><span class="attr">  client:</span><span class="attr">    service-url:</span><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka</span> <span class="comment"># 为服务指定注册中心</span><span class="attr">server:</span><span class="attr">  port:</span> <span class="number">10001</span></code></pre><p>启动服务后，可以在<code>eureka-client</code>控制台看到如下信息：</p><pre class="highlight"><code class="verilog">Registering application hello-service <span class="keyword">with</span> eureka <span class="keyword">with</span> status UPSaw <span class="keyword">local</span> status change <span class="keyword">event</span> StatusChangeEvent [timestamp=<span class="number">1516155585227</span>, current=UP, previous=STARTING]DiscoveryClient_HELLO-SERVICE/youw:hello-service:<span class="number">10001</span>: registering service...DiscoveryClient_HELLO-SERVICE/youw:hello-service:<span class="number">10001</span> - registration status: <span class="number">204</span>Tomcat started on port(s): <span class="number">10001</span> (http)Updating port to <span class="number">10001</span></code></pre><p>当访问该服务时，会出现控制台输出如下信息：<code>Hello, host:youw, server_id: HELLO-SERVICE</code>。</p><p>在<code>eureka-server</code>控制台可看到如下信息：<code>Registered instance HELLO-SERVICE/youw:hello-service:10001 with status UP (replication=false)</code>。访问<code>http://localhost:10000</code>，此时可见<code>Instances currently registered with Eureka</code>为增加了一个服务：<code>HELLO-SERVICE</code>。</p><h3 id="高可用注册中心"><a class="markdownIt-Anchor" href="#高可用注册中心"></a> 高可用注册中心</h3><p>在微服务这样分布式的环境中，需要充分考虑发生故障的情况，所以在生产环节需要对各个组件进行高可用部署。Eureka Server充分考虑了这一点，每一个节点既可以是服务提供者，也可以是服务消费者。服务注册中心也可以向其他服务注册自身。</p><p>新建一个项目<code>eureka-center</code>，作为另一个服务注册中心，参照<code>enreka-server</code>，但要修改<code>application.qml</code>文件:</p><pre class="highlight"><code class="yaml"><span class="attr">server:</span><span class="attr">  port:</span> <span class="number">20000</span><span class="attr">spring:</span><span class="attr">  application:</span><span class="attr">    name:</span> <span class="string">eureka-server</span><span class="attr">eureka:</span><span class="attr">  instance:</span><span class="attr">    hostname:</span> <span class="string">center</span><span class="attr">  client:</span><span class="attr">    service-url:</span><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka/</span> <span class="comment"># 指向注册中心</span></code></pre><p>修改<code>eureka-server</code>的<code>application.yml</code>启动:</p><pre class="highlight"><code class="yaml"><span class="attr">spring:</span><span class="attr">  application:</span><span class="attr">    name:</span> <span class="string">eureka-Server</span><span class="attr">server:</span><span class="attr">  port:</span> <span class="number">10000</span><span class="attr">eureka:</span><span class="attr">  instance:</span><span class="attr">    hostname:</span> <span class="string">localhost</span><span class="attr">  client:</span><span class="attr">    service-url:</span><span class="attr">      defaultZone:</span> <span class="attr">http://center:20000/eureka/</span> <span class="comment"># 指向注册中心</span></code></pre><p>修改<code>eureka-client</code>的<code>application.yml</code></p><pre class="highlight"><code class="yaml"><span class="attr">spring:</span><span class="attr">  application:</span><span class="attr">    name:</span> <span class="string">hello-service</span>  <span class="comment"># 为服务命名</span><span class="attr">eureka:</span><span class="attr">  client:</span><span class="attr">    service-url:</span>      <span class="comment"># 同时向两个注册中心注册自己</span><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka/,http://center:20000/eureka/</span><span class="attr">server:</span><span class="attr">  port:</span> <span class="number">10001</span></code></pre><p>其实启动三个应用程序，访问两个注册中心，均能看到：</p><p><img src="/article/微服务/Micro Service/实践篇03--Spring Cloud Eureka/%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="无法加载" title="高可用服务注册中心"></p><p>此时两个注册中心即使有一个中断了，在另一个注册中心的服务依然可以访问<code>hello-server</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Spring Cloud Eureka&lt;/code&gt;是&lt;code&gt;Spring Cloud Netflix&lt;/code&gt;微服务套件中的一部分，它基于&lt;code&gt;Netflix Eureka&lt;/code&gt;的二次封装，主要是负责完成微服务架构的服务治理能力。我们只需
      
    
    </summary>
    
      <category term="微服务" scheme="http://yov.oschina.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://yov.oschina.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>打包和工具链</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/打包和工具链/</id>
    <published>2018-01-05T14:08:26.602Z</published>
    <updated>2018-01-07T06:32:36.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打包和工具链"><a class="markdownIt-Anchor" href="#打包和工具链"></a> 打包和工具链</h2><h3 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h3><p>Go程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，以标准库中的http包为例：</p><pre class="highlight"><code class="xml">net/http/     cgi/     cookiejar/        testdata/     fcgi/     httptest/     httputil/     pprof/     testdata/</code></pre><p>这些目录将实现HTTP服务器、客户端、测试工具和性能调试工具的相关代码拆分成功能清晰、小的代码单元。以<code>cookiejar</code>包为例，这个包里包含了存储与获取网页会话上的cookie相关代码。每个包都可以单独导入和使用。</p><p>所有的go文件，除了空行和注释都应该在第一行声明自己所属的包，每个包都在单独的目录里，不能将多个包放在同一个目录下，也不能把同一包的文件拆分到不同目录中。</p><h4 id="包的命名原则"><a class="markdownIt-Anchor" href="#包的命名原则"></a> 包的命名原则</h4><p>包名应使用简洁、清晰且全小写的名字。</p><h4 id="main包"><a class="markdownIt-Anchor" href="#main包"></a> main包</h4><p><code>main</code>包具有特殊含义，Go的编译器会将其编译为二进制可执行文件。所有Go编译的可执行文件都必须有一个<code>main</code>包。当编译器发现main包后，会寻找<code>main()</code>，然后创建可执行文件。main()是程序的入口，程序编译时会使用声明<code>main包</code>的代码所在的目录的目录名作为二进制可执行文件的文件名。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// fmt包提供格式化输出功能</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {fmt.Println(<span class="string">"Hello World!"</span>)}</code></pre><p>此时可在<code>$GOPATH/src/hello</code>目录执行<code>go build</code>，会生成一个二进制文件，该文件会根据系统改变文件形式，比如在windows上会变为<code>hello.exe</code>。此时执行该程序，会在控制台显示<code>Hello World!</code>。如果将包名改为其他，编译器会认为其只是一个包，而不是命令。</p><h3 id="导入"><a class="markdownIt-Anchor" href="#导入"></a> 导入</h3><p><code>import</code>告诉编译器要导入包的路径。如果要导入多个包，可按照如下格式：</p><pre class="highlight"><code class="go"><span class="keyword">import</span> (  <span class="string">"fmt"</span>  <span class="string">"strings"</span>  <span class="comment">// strings包提供关于字符串的操作，如查找、替换和变换</span>)</code></pre><p>编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。开发者创建的包会在<code>GOPATH</code>环境变量指定的目录里查找。<code>GOPATH</code>指订的目录就是开发者的个人工作空间。如果Go安装在<code>/user/local/go</code>，并把<code>GOPATH</code>设置为<code>/home/myproject:/home/mylibraries</code>，编译器会按照以下顺序查找<code>net/http</code>包：</p><pre class="highlight"><code class="">/usr/local/go/src/pkg/net/http/home/myproject/src/net/http/home/mylibraries/src/net/http</code></pre><p>如果编译器找到满足的包，就会停止查找。编译器会优先查找Go的安装目录，然后才是GOPATH中的目录。</p><h4 id="远程导入"><a class="markdownIt-Anchor" href="#远程导入"></a> 远程导入</h4><p>目前趋势是，使用分布式版本控制系统（Distributed Version Control Systems, <code>DVCS</code>）分享代码。Go的工具链支持远程导入。如：</p><pre class="highlight"><code class="go"><span class="keyword">import</span> <span class="string">"github.com/spf13/viper"</span></code></pre><p>编译程序时，编译器会通过<code>go get</code>根据指定的URL获取包。</p><h4 id="命名导入"><a class="markdownIt-Anchor" href="#命名导入"></a> 命名导入</h4><p>当要导入的多个包具有相同名字时，可以为其定义别名，格式如下：</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> (  <span class="string">"fmt"</span>  myfmt <span class="string">"mylib.fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {  fmt.Println(<span class="string">"Hello"</span>)  myfmt.Println(<span class="string">"Hello"</span>)}</code></pre><p>当导入一个包，但不使用它，Go编译器会编译失败，并输出一个错误。这样会避免代码变得臃肿。有时可能需要导入一个包，但不需要引用该包的标识符，此时可以使用空白标识符<code>_</code>来重命名这个导入。</p><blockquote><p>空白标识符  下划线<code>_</code>在Go中被称为空白标识符，用来i抛弃不想继续使用的值，比如忽略函数返回的不需要的值。</p></blockquote><h3 id="函数-init"><a class="markdownIt-Anchor" href="#函数-init"></a> 函数 init</h3><p>每个包都可以包含任意多个<code>init</code>函数，这些函数会在程序开始执行的时间被调用。<code>init</code>函数会在<code>main</code>函数之前执行。<code>init</code>函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。</p><p>例子：以数据库驱动为例，<code>database</code>下的驱动在启动时执行<code>init</code>函数会被自身注册到sql包中，因为sql包在编译时并不知道这些驱动的存在，等启动后sql才会调用这些驱动，其代码实现如下：</p><pre class="highlight"><code class="go"><span class="keyword">package</span> postgres<span class="keyword">import</span> <span class="string">"database/sql"</span><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  {<span class="comment">// 创建一个postgres驱动的实例，此处不进行细节定义</span>sql.Register(<span class="string">"postgres"</span>, <span class="built_in">new</span>(PostgresDriver)) }</code></pre><p>这段示例代码包含在PostgreSQL数据库的驱动中，如果程序导入了这个包，就会调用<code>init</code>函数，促使驱动注册到GO的<code>sql</code>包中成为一个可用驱动。</p><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"database/sql"</span>_ <span class="string">"./postgres"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {sql.Open(<span class="string">"postgres"</span>, <span class="string">"mydb"</span>)}</code></pre><p>在使用这个新的数据库驱动写程序时，使用空白标识符导入包，以便新的驱动会包含到<code>sql</code>包中，这样就可以让<code>init</code>函数被调用运行，且不会由于没有使用这个包中方法而产生错误。</p><h3 id="使用go的工具"><a class="markdownIt-Anchor" href="#使用go的工具"></a> 使用Go的工具</h3><pre class="highlight"><code class="shell">λ goGo is a tool for managing Go source code.Usage:        go command [arguments]The commands are:        build       compile packages and dependencies        clean       remove object files        doc         show documentation for package or symbol        env         print Go environment information        bug         start a bug report        fix         run go tool fix on packages        fmt         run gofmt on package sources        generate    generate Go files by processing source        get         download and install packages and dependencies        install     compile and install packages and dependencies        list        list packages        run         compile and run Go program        test        test packages        tool        run specified go tool        version     print Go version        vet         run go tool vet on packagesUse "go help [command]" for more information about a command.Additional help topics:        c           calling between Go and C        buildmode   description of build modes        filetype    file types        gopath      GOPATH environment variable        environment environment variables        importpath  import path syntax        packages    description of package lists        testflag    description of testing flags        testfunc    description of testing functionsUse "go help [topic]" for more information about that topic.</code></pre><ul><li>编译源代码使用<code>go build xx.go</code></li><li>删除编译生成的可执行文件<code>go clean xx.go</code></li></ul><p>范例：编写代码获取text文本中的内容长度。</p><pre class="highlight"><code class="go">---------------------- count.<span class="keyword">go</span> ------------------------------<span class="keyword">package</span> words<span class="keyword">import</span> <span class="string">"strings"</span><span class="function"><span class="keyword">func</span> <span class="title">CountWords</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="params">(count <span class="keyword">int</span>)</span></span> {    <span class="comment">// 计算文本长度</span>count = <span class="built_in">len</span>(strings.Fields(text))<span class="keyword">return</span>}---------------------- main.<span class="keyword">go</span> -------------------------------<span class="keyword">package</span> main<span class="keyword">import</span> (<span class="string">"os"</span><span class="string">"io/ioutil"</span><span class="string">"../words"</span>   <span class="comment">// 导入上述的包</span><span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {filename := os.Args[<span class="number">1</span>]contents, err := ioutil.ReadFile(filename)<span class="keyword">if</span> err != <span class="literal">nil</span> {fmt.Println(<span class="string">"There was an error opening the file:"</span>, err)<span class="keyword">return</span>}text := <span class="keyword">string</span>(contents)count := words.CountWords(text)fmt.Printf(<span class="string">"There are %d words in your text. \n"</span>, count)}</code></pre><p>直接使用<code>go build</code>，go编译器会默认使用<code>当前目录</code>编译。</p><p>可以指定包编译<code>go build xxx/xxx</code>，</p><p>也可以使用通配符<code>...</code>,会编译目录下所有包<code>go build xx/xx/...</code></p><p>要执行程序，需要先编译，虽然执行生成的可执行文件。此处可以使用<code>go run</code>完成一次性完成这两步，该命令会先构建<code>main.go</code>里包含的程序，然后执行创建后的程序。</p><h3 id="go开发工具"><a class="markdownIt-Anchor" href="#go开发工具"></a> Go开发工具</h3><h4 id="go-vet"><a class="markdownIt-Anchor" href="#go-vet"></a> go vet</h4><p><code>go vet</code>会帮助开发人员检测代码常见的错误，可以捕获以下类型错误：</p><ul><li><code>Printf</code>类函数调用时，类型匹配错误的参数；</li><li>定义常用方法时，方法签名的错误</li><li>错误的结构标签</li><li>没有指定字段名的结构字面量</li></ul><pre class="highlight"><code class="go"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {fmt.Printf(<span class="string">"There is dogs"</span>, <span class="number">3</span>)}</code></pre><p>上述程序要输出一个整数3，但是格式化字符串中没有对应的格式化参数，执行<code>go vet</code>会得到如下信息：</p><pre class="highlight"><code class="shell">λ go vet main.gomain.go:6: no formatting directive in Printf call</code></pre><h4 id="go-fmt"><a class="markdownIt-Anchor" href="#go-fmt"></a> go fmt</h4><p><code>go fmt</code>会自动格式化源代码文件并保存。</p><h4 id="go语言开发文档"><a class="markdownIt-Anchor" href="#go语言开发文档"></a> Go语言开发文档</h4><ul><li>从命令行获取文档</li></ul><p>比如要了解<code>fmt</code>包相关信息，就可以使用命令 <code>go doc fmt</code>。就能获取<code>fmt</code>包的详细信息，比如函数，格式化参数等。</p><ul><li>浏览器查看文档</li></ul><p>使用<code>godoc -http=:port</code>，此时就可以打开浏览器输入<code>ip:port</code>查看Go的文档</p><ul><li>给代码编写文档</li></ul><p>GO文档工具也支持开发人员自己写的代码。如果开发人员按照规则来编写代码，这些代码也会自动包含在<code>godoc</code>生成的文档中。</p><p>用户可以在标识符前，将文档内容作为注释添加到代码中。注释可以以<code>//</code>开头，也可以以<code>/**/</code>。此外还可以在包中添加<code>doc.go</code>，其包名与包一致，将包的介绍使用注释加载包名声明之前。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打包和工具链&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#打包和工具链&quot;&gt;&lt;/a&gt; 打包和工具链&lt;/h2&gt;
&lt;h3 id=&quot;包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#包&quot;&gt;&lt;/a&gt; 包&lt;/h3&gt;
&lt;
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基础篇02--微服务架构综述</title>
    <link href="http://yov.oschina.io/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%9F%BA%E7%A1%80%E7%AF%8702--%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yov.oschina.io/article/微服务/Micro Service/基础篇02--微服务架构综述/</id>
    <published>2018-01-05T11:48:36.354Z</published>
    <updated>2018-01-08T12:41:41.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务架构综述"><a class="markdownIt-Anchor" href="#微服务架构综述"></a> 微服务架构综述</h2><h3 id="什么是微服务架构"><a class="markdownIt-Anchor" href="#什么是微服务架构"></a> 什么是微服务架构</h3><blockquote><p>微服务架构是一种架构模式，它提倡将单一的应用程序划分为一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。                                                                      ---------Martin Fowler</p></blockquote><h4 id="微服务要多微"><a class="markdownIt-Anchor" href="#微服务要多微"></a> 微服务要多“微”？</h4><p>微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低且高度自治的一组服务，每个服务都是很小的应用，那么“微”的程度到底是怎样的？</p><p>由于不同语言有不同特点，不同功能的替换或重写很大程度取决于成员的能力，因此代码行数的多少以及重写时间的长短都不能用于衡量“微”。</p><p>微服务的“微”并不是一个真正可衡量、看得见、摸得着的微，其所表达是一种设计思想和指导方针。这需要团队觉得合适，在此之前应遵循以下两个基本前提：</p><ul><li>业务独立性</li></ul><p>应保证微服务具有业务独立性的单元，并不是只是为了微而微。</p><ul><li>团队自主性</li></ul><p>团队应该由不同技能、不同角色的成员组成且团队规模要小。</p><h4 id="单一职责"><a class="markdownIt-Anchor" href="#单一职责"></a> 单一职责</h4><p>编写代码的原则是“高内聚，低耦合”。高内聚指的是一个模块中各个元素彼此结合紧密；低耦合指的是一个完整的系统中，模块与模块之间应尽可能独立存在。符合该原则的系统具有良好的重用性、可维护性和扩展性，能够持续支持业务的发展。</p><p>面向对象的设计中有“SOLID”原则，S指的是SRP（<code>Single Responsibility Principle</code>，单一职责原则）：即一个对象应该只有一个发生变化的原因，如果该对象可以被多个原因改变，则其承担了多个职责。</p><p>Linux中的每个命令都独立负责一个功能，但命令与命令可以通过管道连接起来可以实现更强大的功能。类似的，对于每个服务而言，我们希望它处理的业务逻辑能够单一，在服务架构层面遵循单一职责原则。即微服务架构中的每个服务都是具有业务逻辑 ，符合高内聚、低耦合原则以及单一职责原则的单元，不同服务通过“管道”方式灵活组合，从而构建庞大的系统。</p><h4 id="轻量级通信"><a class="markdownIt-Anchor" href="#轻量级通信"></a> 轻量级通信</h4><p>服务之间应该通过轻量级的通信机制，实现彼此的互通互联，互相协作。所谓轻量级通信机制，通常指语言无关、平台无关的交互方式。</p><p>对于轻量级通信的格式而言，XML或JSON的解析与使用基本与语言无关、平台无关。对于轻量级通信的协议而言，通常基于HTTP，能让服务间的通信变得标准化且无状态化。REST(<code>Representational State Transfer</code>）是实现服务之间互相协作的轻量级通信机制之一。</p><p>对于微服务而言，通过使用语言无关、平台无关的轻量级通信机制，使服务与服务之间的协作变得更加标准化，这就意味着团队可以选择更合适的语言、工具或者平台来开发服务本身。</p><h4 id="独立性"><a class="markdownIt-Anchor" href="#独立性"></a> 独立性</h4><p>独立性指在应用交付的过程中，开发、测试以及部署的独立。</p><p>传统单块架构应用，所有功能都存在于同一块代码块中，当修改某部分时，容易出现功能之间互相影响，即功能的开发不具有独立性。此外，但代码实现后，需要集成、回归测试，才能保证功能互相配合、正常工作且互不影响，因此测试过程不具有独立性。当测试完毕，单块应用被部署后，由于某个特性存在缺陷将导致部署失败或回滚。</p><p>因此单块架构中，功能的开发、测试、构建以及部署耦合度较高。</p><p>微服务架构中，每个服务都是独立的业务单元，服务与服务之间是独立的：</p><ul><li>每个服务都有独立的代码库，从代码库的层面，服务与服务是隔离的；</li><li>每个服务都有独立的测试机制，从测试的角度而言，服务与服务之间是松耦合的；</li><li>构建包是独立的，部署流程是也是独立的，服务能运行在不同进程中。从部署角度考虑，服务与服务之间也是高度解耦的</li></ul><h4 id="进程隔离"><a class="markdownIt-Anchor" href="#进程隔离"></a> 进程隔离</h4><p>单块架构应用，所有功能都运行在同一进程中，当要部署时，需要停掉当前的应用，无法独立部署。为了提高代码的重用以及可维护性，在应用开发中，开发人员会将重复的代码提取出来，封装成组件（此处指的是可以独立审升级、替换掉的部分）。在传统的单块架构中，组件的通常形态叫共享库，例如JAR包或DLL。应用程序在运行时，所有的组件最终也会被加载到同一进程中运行。</p><p>微服务架构中，应用程序由多个服务组成，每个服务都具一个高度自制的独立业务实体。每个服务都能运行在一个独立的操作系统进程中，这意味着不同服务能被部署到不同主机上。理论上，能将多个服务部署到同一节点上，但这样增加了部署和扩展的复杂度。</p><p>综上所诉，微服务架构其实是将单一的应用程序划分为一组小的服务，每个服务都具有业务属性的独立单元，同时能够被独立开发、独立运行、独立测试以及独立部署。</p><h3 id="微服务架构与soa"><a class="markdownIt-Anchor" href="#微服务架构与soa"></a> 微服务架构与SOA</h3><p>面向服务架构<code>SOA</code>，对于复杂的企业IT系统，应按照不同的，可重用的粒度划分，将功能相关的一组功能提供者组织在一起为消费者服务。其目的是为了解决企业内部不同IT系统资源之间无法互联而导致的信息孤岛问题。</p><h4 id="微服务与soa"><a class="markdownIt-Anchor" href="#微服务与soa"></a> 微服务与SOA</h4><table><thead><tr><th>SOA实现</th><th>微服务架构实现</th></tr></thead><tbody><tr><td>企业级，自上向下开展实施</td><td>团队级，自下向上开展实施</td></tr><tr><td>服务由多个子系统组成，力粒度大</td><td>一个系统被拆分成多个服务，粒度细</td></tr><tr><td>企业服务总线，集中式的服务架构</td><td>无集中式总线，松散的服务架构</td></tr><tr><td>集成方式复杂（ESB/WS/SOAP）</td><td>集成方式简单（HTTP/REST/JSON）</td></tr><tr><td>单块架构系统，相互依赖，部署复杂</td><td>服务能独立部署</td></tr></tbody></table><h3 id="微服务的本质"><a class="markdownIt-Anchor" href="#微服务的本质"></a> 微服务的本质</h3><ul><li>服务作为组件</li><li>围绕业务组织团队</li><li>关注产品而非项目</li><li>技术多样性</li><li>业务数据独立</li><li>基础设施自动化</li><li>演进式架构</li></ul><h4 id="服务作为组件"><a class="markdownIt-Anchor" href="#服务作为组件"></a> 服务作为组件</h4><p>软件领域一直提倡使用组件<code>Component</code>的方式将应用模块化并为其构建相对独立的单元。传统实现组件的方式是给独立的部分或者抽取公用部分构建库<code>Library</code>，从而达到解耦和复用的效果。这样的共享库一般是语言相关、平台相关，且与应用程序运行在同一个进程中。即库的变化可能导致整个应用都要更新，重新部署。</p><p>将微服务作为组件，与传统使用组件方式最大的区别是，组件可以被独立部署。即，每个服务的变更仅需重新部署自身，不影响其他服务。</p><p>因此，微服务架构的一个优势就是能以松散的服务形式，构建可独立化部署的模块化应用。把服务当成组件的另一个优点是，组件和组件之间定义了清晰的、语言无关的、平台无关的接口。许多开发虽然有良好的公共调用接口，但依赖于特定平台和语言，导致组件间耦合度高。</p><p>微服务通过语言无关、平台无关的轻量级通信机制协作，灵活性高。不足的是分布式调用比进程内调用更消耗时间，且严重依赖于网络的可靠性与稳定性。</p><h4 id="围绕业务组织团队"><a class="markdownIt-Anchor" href="#围绕业务组织团队"></a> 围绕业务组织团队</h4><p>微服务架构团队组织方式提倡以业务为核心，按照业务能力来组织团队，团队中的成员具有多样性的技能。单块应用架构根据技能划分团队。</p><h4 id="关注产品而非项目"><a class="markdownIt-Anchor" href="#关注产品而非项目"></a> 关注产品而非项目</h4><blockquote><p>项目模式：当项目启动后，企业或组织根据不通过的技能资源池中抽取相关的资源，组成团队并完成项目，</p></blockquote><p>单块架构应用大部分是基于项目模式构建，其弊端如下：</p><ul><li>团队成员缺乏主人翁精神；</li><li>难以制定有效的奖惩机制；</li><li>团队成员缺乏产品成就感。</li></ul><p>微服务架构提倡的是采用产品模式构建，即让团队负责整个服务的生命周期，从服务的分析、开发、测试、部署、运维，所有成员的个人目标和团队目标一致，都是为了更有效、高效、以可持续性发展的方式为消费者提供服务。最终目标是通过多个服务的协调、组合实现产品的功能，以及传递价值。</p><h4 id="技术多样性"><a class="markdownIt-Anchor" href="#技术多样性"></a> 技术多样性</h4><p>传统的单块应用架构，倾向于采用统一的技术皮平台或方案解决问题。</p><p>微服务架构中，提倡针对不同的业务特征选择合适的技术方案，有针对性地解决具体的业务问题。</p><h4 id="业务数据独立"><a class="markdownIt-Anchor" href="#业务数据独立"></a> 业务数据独立</h4><p>传统的单块应用架构，多采用统一的数据存储平台来存储所有数据。随着业务快速发展，需求不断变化，数据变得复杂难以管理，同时随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的继承作用。</p><p>传统的数据库大多是关系型数据库，存储的信息以结构化信息为主，但随着互联网的快速发展，其维护成本会越来越高。</p><p>微服务架构提倡服务自主管理其相关的业务数据，这样的优势在于：</p><ul><li>能随着业务发展，提供业务数据接口集成，而不是以数据库的方式同其他服务集成；</li><li>能随着业务发展，选择更合适的工具管理或者迁移业务理数据。</li></ul><h4 id="基础服务自动化"><a class="markdownIt-Anchor" href="#基础服务自动化"></a> 基础服务自动化</h4><p>传统单块架构应用只需要部署一次就能上线。而微服务架构将应用分为多个小的服务，需要对每个服务分别部署，此外每个服务都需要部署带来的健康监控、错误回滚等，这会导致部署和运维的成本随着服务的增多呈指数级增长。</p><p>因此微服务需要更稳定的基础设置自动化机制，能够创建运行环境、安装依赖、部署应用。</p><h4 id="演进式架构"><a class="markdownIt-Anchor" href="#演进式架构"></a> 演进式架构</h4><h3 id="微服务不是银弹"><a class="markdownIt-Anchor" href="#微服务不是银弹"></a> 微服务不是银弹</h3><p>微服务的优势性在于独立性、单一职责、技术多样性。此外微服务的实施也会推动基础设施自动化以及DevOps文化在团队中的发展，有利于构建全功能的团队。</p><p>微服务在实施的过程中需要考虑如下因素：</p><ul><li>分布式系统的复杂度</li><li>运维成本</li><li>部署自动化</li><li>DevOps与组织架构</li><li>服务间依赖测试</li><li>服务间依赖管理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微服务架构综述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微服务架构综述&quot;&gt;&lt;/a&gt; 微服务架构综述&lt;/h2&gt;
&lt;h3 id=&quot;什么是微服务架构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是微服务
      
    
    </summary>
    
      <category term="微服务" scheme="http://yov.oschina.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://yov.oschina.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Spring Boot实现热部署</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Tool/IDEA%E4%B8%ADSpringBoot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yov.oschina.io/article/工具/Tool/IDEA中SpringBoot实现热部署/</id>
    <published>2018-01-04T11:47:37.732Z</published>
    <updated>2018-01-04T12:50:17.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IntelliJ IDEA 作为当下较为热门的Java IDE,当使用Spring Boot进行开发时，由于静态页面经常修改，每次重启十分麻烦。因此实现Spring Boot热部署尤为重要。</p></blockquote><h3 id="devtools"><a class="markdownIt-Anchor" href="#devtools"></a> Devtools</h3><p>Spring为开发者提供了spring-boot-devtools模块进行Spring Boot热部署,提高了开发效率，无需手动重启应用。使用需要在<code>pom.xml</code>添加如下配置：</p><pre class="highlight"><code class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span>    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span>  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></code></pre><p>在application.yml中添加配置</p><pre class="highlight"><code class="yaml"><span class="attr">  thymeleaf:</span><span class="attr">    cache:</span> <span class="literal">false</span>   <span class="comment"># 关闭cache，刷新即可显示新页面</span><span class="attr">  devtools:</span><span class="attr">    restart:</span><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 启用热部署</span><span class="attr">      additional-paths:</span> <span class="string">src/main/resources</span> <span class="comment"># 设置重启目录</span></code></pre><h3 id="idea设置"><a class="markdownIt-Anchor" href="#idea设置"></a> IDEA设置</h3><p>（1）File-&gt;Settings-&gt;Compiler-&gt;Build project automatically，将其打勾。</p><p>（2）ctrl + shift + A，在检索框输入Registry，随后找到<code>Compiler autoMake allow when app running</code>，勾选。</p><p>重启应用，此时不论是修改java文件还是修改html文件都会自动重新加载，不会重启应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;IntelliJ IDEA 作为当下较为热门的Java IDE,当使用Spring Boot进行开发时，由于静态页面经常修改，每次重启十分麻烦。因此实现Spring Boot热部署尤为重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;de
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="http://yov.oschina.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>一个Go程序</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/一个Go程序/</id>
    <published>2018-01-03T12:12:27.888Z</published>
    <updated>2018-01-07T06:32:36.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个go程序"><a class="markdownIt-Anchor" href="#一个go程序"></a> 一个Go程序</h2><h3 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h3><p><img src="/article/Go/Go Base/一个Go程序/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="无法加载" title="程序架构流程图"></p><h3 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h3><pre class="highlight"><code class="go">- sample    - data        data.json   -- 数据源    - matchers        rss.<span class="keyword">go</span>      -- 搜索rss源的匹配器      - search        <span class="keyword">default</span>.<span class="keyword">go</span>  -- 搜索数据用的默认匹配器        feed.<span class="keyword">go</span>     -- 用于读取json数据文件        match.<span class="keyword">go</span>    -- 用于支持不同匹配器的接口        search.<span class="keyword">go</span>   -- 执行搜索的主控制逻辑    - main        main.<span class="keyword">go</span>     -- 程序的入口</code></pre><h3 id="main包maingo"><a class="markdownIt-Anchor" href="#main包maingo"></a> main包(main.go)</h3><pre class="highlight"><code class="go"><span class="comment">/* 程序入口 */</span><span class="keyword">package</span> main<span class="comment">/* 导入外部包，让用户可以访问其中的标识符 */</span><span class="keyword">import</span> (<span class="string">"log"</span><span class="string">"os"</span><span class="comment">/* _ "package_name" 该方式是为了调用包中的初始化函数，而不是使用其中的标识符 */</span>_ <span class="string">"sample/matchers"</span><span class="string">"sample/search"</span>)<span class="comment">// init在main之前调用</span><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  {<span class="comment">// 将日志输出到标准输出</span>log.SetOutput(os.Stdout)}<span class="comment">// main函数是程序的入口</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {<span class="comment">// 使用特定项进行搜索</span>search.Run(<span class="string">"president"</span>)}</code></pre><h3 id="search包"><a class="markdownIt-Anchor" href="#search包"></a> search包</h3><p>程序所使用的框架和业务逻辑都在search包中，其由4个go文件组成，分别对应一个独立的职责。</p><h4 id="searchgo"><a class="markdownIt-Anchor" href="#searchgo"></a> search.go</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个go程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一个go程序&quot;&gt;&lt;/a&gt; 一个Go程序&lt;/h2&gt;
&lt;h3 id=&quot;程序结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#程序结构&quot;&gt;&lt;/a&gt; 程序
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基础篇01--单块架构及其面临的挑战</title>
    <link href="http://yov.oschina.io/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%9F%BA%E7%A1%80%E7%AF%8701--%E5%8D%95%E5%9D%97%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://yov.oschina.io/article/微服务/Micro Service/基础篇01--单块架构及其面临的挑战/</id>
    <published>2018-01-02T12:47:03.123Z</published>
    <updated>2018-01-05T13:56:24.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-基础篇"><a class="markdownIt-Anchor" href="#第一部分-基础篇"></a> 第一部分 基础篇</h2><blockquote><p>系统的架构设计是每个系统构建过程及其关键的一部分，决定了系统是否能够被正确、有效地构建。</p><p><code>系统架构设计</code>描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多重因素，将应用系统划分成不同的部分，并使这些部分相互分工，相互协作，从而为用户提供某种特定价值的方式。</p><p>随着面向对象分析、设计模式、企业架构模式等方法论的深入人心，从功能实现、代码组织的角度考虑，系统中不同职责的部分逐渐被划分到了如下三个部分：</p><ul><li>表示层：聚焦数据显示和用户交互</li><li>业务逻辑层：聚焦业务逻辑处理</li><li>数据访问层：聚焦数据的存储与访问</li></ul><p>每层负责的部分更趋向于具体化、细致化，这就是最初的软件三层架构，该架构解决了系统间调用复杂、职责不清的问题，更有效地降低了层与层之间的依赖关系。这是将系统在逻辑上进行划分，而不是物理上划分，即不同层的代码在进行编译、打包、部署后依然运行在同一个进程中。</p><p>对于这种功能集中、代码中心化、一个发布包、部署后运行在同一进程的应用程序，通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或项目。</p><p>随着业务的扩大，需求的增加，单块架构很难满足业务快速变化的需求：一方面代码的可维护性、扩展性、灵活性在降低；另一方面系统的修改成本、构建以及维护成本在显著增加。</p></blockquote><h3 id="单块架构及其面临的挑战"><a class="markdownIt-Anchor" href="#单块架构及其面临的挑战"></a> 单块架构及其面临的挑战</h3><h4 id="三层应用架构"><a class="markdownIt-Anchor" href="#三层应用架构"></a> 三层应用架构</h4><h5 id="三层应用架构的发展"><a class="markdownIt-Anchor" href="#三层应用架构的发展"></a> 三层应用架构的发展</h5><p><code>层</code>能帮助我们划分出构成某整体事务的、上下互相支撑的不同部分。层的概念：</p><ul><li>层能被单独构造；</li><li>每层具有区别于其它层的显著特点；</li><li>层与层之间能够互相连接，互相支撑，互相作用，相互协作，从而构成一个整体；</li><li>层的内部可以被替换成其他可工作的部分，但对整体的影响不大。</li></ul><p>Web程序开发早期收到面向过程思维以及设计方式的影响，所有的逻辑代码调用相互交错，错综复杂，如早期的PHP、JSP以及ASP便是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，即一层架构。</p><p>随着Java、.NET的发展，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，即二层架构。</p><p>随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从而为用户提供以及有效组织软件结构的考虑，Web根据职责的不同逐渐被定义在不同的层次，每一层负责的部分更趋向于具体化、细致化，即三层架构。</p><h5 id="什么是三层架构"><a class="markdownIt-Anchor" href="#什么是三层架构"></a> 什么是三层架构</h5><p>三层架构通常包括表示层、业务逻辑层以及数据访问层、</p><ul><li>表示层</li></ul><p>表示层指的是用户使用应用程序时与其交互操作的部分，通过该部分进行交互并获取期望的结果。目前用户接口大部分为Web形式，也可以是桌面软件形式。</p><ul><li>业务逻辑层</li></ul><p>业务逻辑层是根据用户输入的信息，进行逻辑计算或业务处理的部分。业务逻辑层主要聚焦应用程序对业务问题的逻辑处理，以及业务流程的操作，它是大部分软件系统区别于其他系统的核心。</p><ul><li>数据访问层</li></ul><p>在用户同应用程序交互的过程中就会产生数据，这类数据需要通过某种机制被有效地存储，以便将来使用。这种机制或方法就是数据访问层最关注的部分。它关注的是对原始数据的操作，而不是对数据存储介质，即数据库的操作。</p><h5 id="三层架构的优势"><a class="markdownIt-Anchor" href="#三层架构的优势"></a> 三层架构的优势</h5><p>三层架构一方面解决了应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接口与实现分离，可以很容易地利用不同的实现来替换原有层次的实现，从而降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。</p><p>另一方面，三层架构的出现从某种程度上解决了企业内部如何有效根据技能调配人员，提高生产效率的问题。</p><h4 id="单块架构"><a class="markdownIt-Anchor" href="#单块架构"></a> 单块架构</h4><h5 id="什么是单块架构"><a class="markdownIt-Anchor" href="#什么是单块架构"></a> 什么是单块架构</h5><p>三层架构将应用从逻辑上分为三层，但最终经历编译、打包、部署后，不考虑负载均衡以及水平扩展的情况，最终还是运行在同一台机器的同一个进程中。对于这种功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序，我们称之为单块架构应用。</p><h5 id="单块架构的优势"><a class="markdownIt-Anchor" href="#单块架构的优势"></a> 单块架构的优势</h5><ul><li><p>易于开发</p></li><li><p>易于测试</p><p>由于所有功能都运行在一个进程中，启动开发环境或将发布包部署到某一环境，一旦启动该进程，就能立即开始策测试。</p></li><li><p>易于部署</p></li></ul><p>所有功能最终都会被打成一个包，因此只需复制该软件包到服务器相应的位置即可。最简单的方式是使用<code>scp</code>远程复制到指定目录下。</p><ul><li>易于水平伸缩</li></ul><h5 id="单块架构面临的挑战"><a class="markdownIt-Anchor" href="#单块架构面临的挑战"></a> 单块架构面临的挑战</h5><ul><li>维护成本增加</li></ul><p>随着应用程序功能越来越多，团队越来越大，相应的成本必然增加。此外当出现缺陷时，由于引起缺陷的原因组合会比较多，这将导致修复缺陷的成本增加，周期增长。</p><p>另外随着代码量增加，在开发人员对全局功能缺乏深度理解下，修复一个缺陷，可能引入其他缺陷。</p><ul><li>持续交付周期长</li></ul><p>随着应用程序的功能越来越多，代码越来越复杂，构建和部署的时间也会响应增加。</p><ul><li>新人培养周期长</li></ul><p>随着应用程序的功能越来越多，对于新加入的团队成员而言，了解行业背景、熟悉应用程序业务、配置本地开发环境这些任务将消耗其大量的时间。</p><ul><li>技术选型成本高</li></ul><p>传统的单块架构系统倾向于采用统一的技术平台或方案解决所有问题。因此对于单块架构的应用而言，初始的技术选型严重限制了将来采用不同语言或框架的能力。</p><ul><li>可扩展性差</li></ul><p>（1）垂直扩展：所有代码都运行在同一台服务器上，将会导致应用程序扩展非常困难。相对而言垂直扩展是最容易的，但成本会越来越高；</p><p>（2）水平扩展：水平扩展的通常方法是建立一个集群，通过在集群中不断添加新节点，然后借助前端的负载均衡器，将用户请求根据某种算法合理地分配到不同的节点上。</p><p>对于单块架构而言，所有程序代码都运行在服务器同一个进程中，则会导致应用程序的水平扩展成本高。比如某部分功能是内存密集型，另一个部分是CPU密集型，当扩展时就需要新节点必须有足够的内存和强劲的CPU。</p><ul><li>构建全功能团队难</li></ul><p>单块架构的开发模式在分工时以进呢个为单位，这样的分工会导致任何功能的改变都需要跨团队沟通和协调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一部分-基础篇&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一部分-基础篇&quot;&gt;&lt;/a&gt; 第一部分 基础篇&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;系统的架构设计是每个系统构建过程及其关键的一部分，决定了系统是否能够被正确、有效地
      
    
    </summary>
    
      <category term="微服务" scheme="http://yov.oschina.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://yov.oschina.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go语言简介</title>
    <link href="http://yov.oschina.io/article/Go/Go%20Base/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/"/>
    <id>http://yov.oschina.io/article/Go/Go Base/Go语言简介/</id>
    <published>2018-01-02T11:33:54.288Z</published>
    <updated>2018-01-02T12:39:34.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用go解决现有编程难题"><a class="markdownIt-Anchor" href="#用go解决现有编程难题"></a> 用Go解决现有编程难题</h2><h3 id="开发速度"><a class="markdownIt-Anchor" href="#开发速度"></a> 开发速度</h3><p>编译一个大型的C或C++项目需要花费较长的时间。而Go使用了更为智能的编译器，简化了解决依赖的算法，最终提高了编译速度。编译Go程序时，编译器只会关注那些被直接引用的库，而不像Java或C那样遍历依赖链中所有依赖的库。</p><p>因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出，代价是动态语言不提供静态语言提供的类型安全特性，因此经常需要使用大量的测试套件来避免运行时出现<code>类型错误</code>这类bug。</p><h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3><p>Go语言对并发的支持是这门语言最重要的特性之一。<code>goroutine</code>很像线程，但它占据的内存远少于线程，且使用它需要的代码更少。<code>channel(通道)</code>是一种内置的数据结构，可以让不同用户在不同的<code>goroutine</code>之间同步发送具有类型的消息，这让编程模型更倾向于在<code>goroutine</code>间发送消息，而不是让多个<code>goroutine</code>争夺同一个数据的试用权。</p><h4 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> <code>goroutine</code></h4><p><code>goroutine</code>是可以与其它<code>goroutine</code>并行执行的函数，同时也会与主程序并行执行。在其他编程代码中，需要使用线程来完成同样的事，而在Go中会使用同一个线程来执行多个<code>goroutine</code>。例如：用户在写一个Web服务器，希望同时处理不同的Web请求，Java需要写大量额外的代码来使用线程。而在Go中，<code>net/http</code>库直接使用了内置的<code>goroutine</code>，每个请求都自动在自己的<code>goroutine</code>里处理。Go运行时会自动在配置的一组逻辑处理器上调度运行<code>goroutine</code>，每个逻辑处理器绑定到一个操作系统线程上，这让应用程序执行效率更高，而开发工作量减少。</p><p>如果想在执行一段代码时，并行去做另外的事，<code>goroutine</code>是很好的选择，下面是一个简单的例子：</p><pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(msg <span class="keyword">string</span>)</span></span> {  <span class="comment">// 此处是处理日志的代码</span>}<span class="comment">// 代码中有些地方检测到错误</span><span class="keyword">go</span> log(<span class="string">"发生错误"</span>)</code></pre><p>关键字<code>go</code>是唯一需要去编写的代码，调用<code>log()</code>作为独立的<code>goroutine</code>去运行，以便与其他<code>goroutine</code>并行执行，这意味着应用程序的其他部分会与记录日志并行执行。</p><h4 id="通道"><a class="markdownIt-Anchor" href="#通道"></a> 通道</h4><p>通道是一种数据结构，可以让<code>goroutine</code>之间安全的通信，可以避免其他语言中常见的共享内存访问的问题。</p><p>并发最难的部分就是要确保其他并发运行的进程、线程或<code>goroutine</code>不会意外修改用户的数据。当不同线程在没有同步保护的情况下修改同一个数据时，将会导致错误。在其他语言中如果使用全局变量或共享内存，需要使用复杂的锁规则来防止对同一个变量的不同步修改。</p><p>通道提供了新模式，这一模式保证同一时刻只会有一个<code>goroutine</code>修改数据。通道用于在几个<code>goroutine</code>之间发哦那个数据。例子：一个应用程序，有多个进程需要顺序读取或修改某个数据，使用<code>goroutine</code>和通道可以为这个过程建立安全的模型。运行过程如下图所示：</p><p><img src="/article/Go/Go Base/Go语言简介/channel.png" alt="无法加载" title="使用通道在goroutine之间安全地发送数据"></p><p>上图有三个<code>goroutine</code>，还有2个不带缓存的通道。第一个<code>goroutine</code>通过通道将数据传给已经在等待的第二个<code>goroutine</code>。两个<code>goroutine</code>间传输数据是同步的，一旦传输完成，两者都会知道数据完成传输。第二个<code>goroutine</code>lion个数据完成任务后，会将数据传给第三个<code>goroutine</code>，传输依然是同步的。这种在<code>goroutine</code>之间安全传输数据的方法不需要任何锁或者同步机制。</p><p>需要注意的是，通道不提供跨<code>goroutine</code>的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个<code>goroutine</code>都会持有一份副本，各自对自己的副本做修改是安全的。当传输指向数据的指针时，如果读和写是由不同的<code>goroutine</code>完成，每个<code>goroutine</code>依旧需要额外的同步动作。</p><h3 id="go的数据类型"><a class="markdownIt-Anchor" href="#go的数据类型"></a> Go的数据类型</h3><p>Go提供灵活的、无继承的类型系统，无需降低运行性能就能最大程度复用代码，这个类型依然支持面向对象开发。Go使用组合<code>composition</code>设计模式，只需要简单地将一个类型嵌入另一个类型，就能复用所有的功能。</p><p>此外Go还有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行建模。在Go中不需要声明某个类型实现某个接口，编译器会判断类型的实例是否符合正在使用的接口。</p><h4 id="类型简单"><a class="markdownIt-Anchor" href="#类型简单"></a> 类型简单</h4><p>Go不仅有<code>int</code>和<code>string</code>这样的内置类型，还支持自定义类型。Go中自定义的类型通常包含一组带类型的子弹，用于存储数据，类似于C语言的结构，但Go的类型可以声明操作该类型数据的方法。传统语言使用继承来扩展结构，而Go构建更小的开发类型，然后将这些小类型组合为更大的类型。</p><h4 id="go接口对一组行为建模"><a class="markdownIt-Anchor" href="#go接口对一组行为建模"></a> Go接口对一组行为建模</h4><p>接口用于描述类型的行为，如果一个类型的实例实现了一个接口，意味着这个实例可以执行一组特地的行为。你甚至不要去声明这个实例实现了某个接口，只需要实现这组行为就好了，这种特性被称为<code>鸭子特性</code>。Go中如果一个类型实现了一个接口所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。</p><p>Go的接口一般只会描述一个单一的动作，在Go中最常用的接口之一就是<code>io.Reader</code>，该接口提供了一个简单的方法，用来声明一个类型有数据可以读取，其定义如下：</p><pre class="highlight"><code class="go"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {  Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)}</code></pre><p>为了实现该接口，你只需要实现一个Read方法，这个方法接受一个byte切片，返回一个整数和可能出现的错误。</p><p>这个与传统接口有本质区别，更有利于使用组合来复用代码，用户几乎可以给所有包含数据的类型实现<code>io.Reader</code>,然后把这个类型的实例传给任何一个知道如何读取<code>io.Reader</code>的Go函数。</p><h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3><p>不当的内存管理会导致程序崩溃或者内存泄漏，甚至系统崩溃。Go具有现代化的垃圾回收机制。其他语言使用内存前要先分配这段内存，然后使用完毕后释放。哪怕出现一点失误，就会导致程序崩溃或内存泄漏。这存在一个问题，追踪内存是否还在被使用是件艰难的事，而要想支持多线程和高并发，更是让这件事愈发困难。虽然Go的垃圾回收会造成额外开销，但降低了开发难度。</p><h2 id="hello-go"><a class="markdownIt-Anchor" href="#hello-go"></a> Hello ，Go</h2><pre class="highlight"><code class="go"><span class="keyword">package</span> main     <span class="comment">// Go程序都组织成包</span><span class="keyword">import</span> <span class="string">"fmt"</span>     <span class="comment">// 导入外部代码，fmt包用于格式化并输出数据</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">// main函数是程序的入口</span>fmt.Println(<span class="string">"Hello World!"</span>)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用go解决现有编程难题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#用go解决现有编程难题&quot;&gt;&lt;/a&gt; 用Go解决现有编程难题&lt;/h2&gt;
&lt;h3 id=&quot;开发速度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
      <category term="Go" scheme="http://yov.oschina.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="http://yov.oschina.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Node.js安装及环境配置</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Tool/Node.js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <id>http://yov.oschina.io/article/工具/Tool/Node.js安装说明/</id>
    <published>2017-12-31T05:33:25.278Z</published>
    <updated>2017-12-31T07:05:59.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常好。</p></blockquote><h2 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h2><p>1.系统：Window10 Pro（64位）</p><p>2.Node.js：v6.11.3LTS（64位）</p><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><h3 id="下载nodejs"><a class="markdownIt-Anchor" href="#下载nodejs"></a> 下载Node.js</h3><p>打开<a href="https://nodejs.org/en/download/">Node.js官网</a>下载安装包<img src="/article/工具/Tool/Node.js安装说明/install.png" alt="无法加载" title="安装页面"></p><h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装Node.js</h3><p><img src="/article/工具/Tool/Node.js安装说明/install1.png" alt="无法加载" title="安装页面"></p><p><img src="/article/工具/Tool/Node.js安装说明/install2.png" alt="无法加载" title="安装页面"></p><p>安装目录可修改,默认为C盘:</p><p><img src="/article/工具/Tool/Node.js安装说明/install3.png" alt="无法加载" title="安装页面"></p><p><img src="/article/工具/Tool/Node.js安装说明/install4.png" alt="无法加载" title="安装页面"></p><p>安装成功:</p><p><img src="/article/工具/Tool/Node.js安装说明/success.png" alt="无法加载" title="安装成功"></p><p>安装成功则可以查看node.js版本以及npm版本:</p><p><img src="/article/工具/Tool/Node.js安装说明/version.png" alt="无法加载" title="安装成功"></p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><blockquote><p>此处配置的是npm安装的全局模块锁在路径，以及缓存cache的路径。进行该项配置是当执行<code>npm install xxxx -g</code>时，会默认安装到<code>C:\User\用户名\npm</code>路径下，占据C盘空间。</p></blockquote><h3 id="修改全局模块安装路径和缓存路径"><a class="markdownIt-Anchor" href="#修改全局模块安装路径和缓存路径"></a> 修改全局模块安装路径和缓存路径</h3><p>在node.js的安装文件中新建<code>node_cache</code>和<code>node_global</code>，在<code>node_global</code>下新建<code>node_modules</code>文件夹。随后使用cmd命令进行配置：</p><pre class="highlight"><code class="shell">npm config set prefix "D:\Program Files\nodejs\node_global"npm config set cace "D:\Program Files\nodejs\node_cache"</code></pre><h3 id="设置环境变量"><a class="markdownIt-Anchor" href="#设置环境变量"></a> 设置环境变量</h3><p>“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”</p><p>在系统变量(S)中新建<code>NODE_PATH</code>，变量值为<code>D:\Program Files\nodejs\node_global\node_modules</code>;</p><p>修改用户变量(U)中的<code>PATH</code>将<code>C:\User\用户名\npm</code>改为<code>D:\Program Files\nodejs\node_global</code></p><p>测试环境变量修改成功，使用cmd命令进行安装</p><pre class="highlight"><code class="shell">npm install express -g # -g 全局安装D:\Program Files\nodejs\node_global`-- express@4.16.2  +-- accepts@1.3.4  | +-- mime-types@2.1.17  | | `-- mime-db@1.30.0  | `-- negotiator@0.6.1  +-- array-flatten@1.1.1  +-- body-parser@1.18.2  | +-- bytes@3.0.0  | +-- http-errors@1.6.2  | | +-- inherits@2.0.3  | | `-- setprototypeof@1.0.3  | +-- iconv-lite@0.4.19  | `-- raw-body@2.3.2  +-- content-disposition@0.5.2  +-- content-type@1.0.4  +-- cookie@0.3.1  +-- cookie-signature@1.0.6  +-- debug@2.6.9  | `-- ms@2.0.0  +-- depd@1.1.1  +-- encodeurl@1.0.1  +-- escape-html@1.0.3  +-- etag@1.8.1  +-- finalhandler@1.1.0  | `-- unpipe@1.0.0  +-- fresh@0.5.2  +-- merge-descriptors@1.0.1  +-- methods@1.1.2  +-- on-finished@2.3.0  | `-- ee-first@1.1.1  +-- parseurl@1.3.2  +-- path-to-regexp@0.1.7  +-- proxy-addr@2.0.2  | +-- forwarded@0.1.2  | `-- ipaddr.js@1.5.2  +-- qs@6.5.1  +-- range-parser@1.2.0  +-- safe-buffer@5.1.1  +-- send@0.16.1  | +-- destroy@1.0.4  | `-- mime@1.4.1  +-- serve-static@1.13.1  +-- setprototypeof@1.1.0  +-- statuses@1.3.1  +-- type-is@1.6.15  | `-- media-typer@0.3.0  +-- utils-merge@1.0.1  `-- vary@1.1.2</code></pre><p>安装时不加<code>-g</code>参数则会默认安装在路径下。</p><h3 id="配置nodejs源"><a class="markdownIt-Anchor" href="#配置nodejs源"></a> 配置Node.js源</h3><p>node.js安装速度缓慢,因此需要更换npm的源,打开cmd使用如下命令:</p><pre class="highlight"><code class="shell">npm config set registry http://registry.npm.taobao.org/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Ja
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Node.js" scheme="http://yov.oschina.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Java中的小问题（不断更新中）</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98(%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java中的小问题(不断更新中)/</id>
    <published>2017-12-23T10:47:05.360Z</published>
    <updated>2017-12-24T08:49:08.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1、使用private声明main()会怎样?<br>A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。</p></blockquote><blockquote><p>2、Java中传引用和传值的区别是什么？<br>A：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。</p></blockquote><blockquote><p>3、如果要重写一个对象的equals()，还要考虑什么？<br>A：hashCode。</p></blockquote><blockquote><p>*4、Java的”一次编写，处处运行”是如何实现的？<br>A：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。</p></blockquote><blockquote><p>*5、public static void main(String args[])这段声明里每个关键字的作用<br>A：<code>public</code>: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见,所以可见性设置为pulic.<br><code>static</code>: Java平台调用这个方法时不会创建这个类的实例对象，因此这个方法必须声明为static。<br><code>void</code>: main方法没有返回值。<br><code>String</code>是命令行传进参数的类型，<code>args</code>是指命令行传进的字符串数组。</p></blockquote><blockquote><p>*6、<code>==</code>与equals()的区别<br>A：<code>==</code>比较两个对象在内存里是不是同一个对象，即内存地址是否一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .<code>==</code>比较的是引用<br>而equals()比较的是内容。<code>public boolean equals(Object obj)</code>这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,此时和==是等价的。String, BitSet, Date, 和File都对equals()进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。</p></blockquote><pre class="highlight"><code class="">public class EqualsTest {   public static void main(String[] args) {      Strings1 = &quot;abc&quot;;      Strings2 = s1;      Strings5 = &quot;abc&quot;;      Strings3 = newString(&quot;abc&quot;);      Strings4 = newString(&quot;abc&quot;);      System.out.println(&quot; == comparison:&quot; + (s1 == s5));      System.out.println(&quot; == comparison:&quot; + (s1 == s2));      System.out.println(&quot;Using equals method:&quot; + s1.equals(s2));      System.out.println(&quot; == comparison:&quot; + s3 == s4);      System.out.println(&quot;Using equals method : &quot; + s3.equals(s4));   }}</code></pre><p>结果：</p><pre class="highlight"><code class="">==comparison:true==comparison:trueUsingequals method:truefalseUsingequals method:true</code></pre><blockquote><p>7 main()去掉static修饰符会怎样？<br>A：报错，main 方法不是类 com.java.demo.Demo 中的static</p></blockquote><blockquote><p>8、为什么oracle type4驱动被称作瘦驱动？<br>A：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的,可以在运行时由浏览器下载,不依赖任何客户端的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。</p></blockquote><blockquote><p>9、final,finally,finalize()<br>A：<code>final</code>: 常量声明。 <code>finally</code>: 处理异常。 <code>finalize()</code>: 帮助进行垃圾回收。<br>接口里声明的变量默认是final的。final类无法继承,也就是没有子类。这么做是出于基本类型的安全考虑，比如String和Integer,这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。<br>finalize()在对象被销毁和回收前会被调用。<br>finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如,关闭连接通常放到finally块中完成。</p></blockquote><blockquote><p>10、什么是Java API？<br>A：Java API是大量软件组件的集合,它们提供了大量有用的功能,比如GUI组件。</p></blockquote><blockquote><p>11、GregorianCalendar类是什么东西？<br>A：GregorianCalendar提供了西方传统日历的支持。</p></blockquote><blockquote><p>12、ResourceBundle类是什么?<br>A：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。</p></blockquote><blockquote><p>13、为什么Java里没有全局变量?<br>A：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。</p></blockquote><blockquote><p>14、如何将String类型转化成Number类型？<br>A：Integer类的valueOf方法可以将String转成Number。下面是代码示例：</p></blockquote><pre class="highlight"><code class="">String numString = &quot;1000&quot;;int id = Integer.valueOf(numString).intValue();</code></pre><blockquote><p>15、SimpleTimeZone类是什么?<br>A：SimpleTimeZone提供公历日期支持。</p></blockquote><blockquote><p>16、while循环和do循环有什么不同？<br>A：while结构在循环的开始判断下一个迭代是否应该继续。<br>do/while结构在循环的结尾来判断是否将继续下一轮迭代,do结构至少会执行一次循环体。</p></blockquote><blockquote><p>17、Locale类是什么？<br>A：Locale类用来根据语言环境来动态调整程序的输出。</p></blockquote><blockquote><p>*18、面向对象编程的原则是什么?<br>A：多态,继承和封装。</p></blockquote><blockquote><p>19、简述继承性<br>A：继承使得一个类可以获取另一个类的属性和方法。使用继承可以让已经测试完备的功能得以复用,并且可以一次修改,所有继承的地方都同时生效。</p></blockquote><blockquote><p>20、什么是隐式的类型转化?<br>A：隐式的类型转化就是直接将一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。<br>代码示例：</p></blockquote><pre class="highlight"><code class="">int i = 1000;long j = i;//Implicit casting</code></pre><blockquote><p>21、sizeof是Java的关键字吗?<br>A：不是。</p></blockquote><blockquote><p>22、native方法是什么?<br>A：native方法是非Java代码实现的方法。</p></blockquote><blockquote><p>23、在System.out.println()里面,System, out, println分别是什么?<br>A：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。</p></blockquote><blockquote><p>24、多态是什么？<br>A：简单来说,多态是指一个名字多种实现,多态使得一个实体通过一个通用的方式来实现不同的操作,具体的操作是由实际的实现来决定的。<br>多态在Java里有三种表现方式：方法重载通过继承实现方法重写通过Java接口进行方法重写。</p></blockquote><blockquote><p>25、显式的类型转化是什么?<br>A：显式的类型转化是明确告诉了编译器来进行对象的转化。<br>代码示例：</p></blockquote><pre class="highlight"><code class="">long i = 700.20;int j = (int)i;</code></pre><blockquote><p>26、什么是Java虚拟机?<br>A：Java虚拟机是能移植到不同硬件平台上的软件系统。</p></blockquote><blockquote><p>27、类型向下转换是什么?<br>A：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。</p></blockquote><blockquote><p>28、Java的访问修饰符是什么?<br>A：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：<br>public: 所有类都可以访问<br>protected: 同一个包内以及所有子类都可以访问<br>private: 只有归属的类才能访问默认: 归属类及相同包下的子类可以访问</p></blockquote><blockquote><p>29、所有类的父类是什么？<br>A：Object.</p></blockquote><blockquote><p>30、Java的基本类型有哪些?<br>A：byte,char, short, int, long, float, double, boolean。</p></blockquote><blockquote><p>31、静态类型有什么特点?<br>A：static定义的变量与类绑定,即每个实例对象都共享同一个静态变量。不论有多少个实例对象,静态变量只有一个。static定义的变量通常使用类名访问,当程序运行时,这个变量就会被创建直到程序结束才会被销毁。静态变量的作用域与普通变量一致,初始值也是一致的。变量没被初始化时根据其数据类型会有一个默认值。<br>static定义的方法属于类,而不是类对象,其调用不作用于类对象,也不需要创建类实例.静态方法本身就带有final,因为重写只会发生在类实例上，即只要原方法没声明为final,非静态方法就不能重写静态方法。父类的静态方法会被子类的静态方法屏蔽，但你不能在子类把父类的静态方法改为实例方法。</p></blockquote><blockquote><p>32、&amp;操作符和&amp;&amp;操作符有什么区别?<br>A：当一个<code>&amp;</code>表达式在求值的时候，两个操作数都会被求值。<br>当一个<code>&amp;&amp;</code>表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。</p></blockquote><blockquote><p>33、Java是如何处理整型的溢出和下溢的?<br>A：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。</p></blockquote><blockquote><p>34、public static void写成static public void会怎样？<br>A：程序正常编译及运行.</p></blockquote><blockquote><p>35、声明变量和定义变量有什么不同？<br>答案：声明变量只提供变量的类型和名字,并没有进行初始化。<br>定义包括声明和初始化两个阶段：<code>String s;</code>只是变量声明,<code>String s = new String(&quot;bob&quot;);</code>或者<code>String s = &quot;bob&quot;;</code>是变量定义。</p></blockquote><blockquote><p>36、Java支持哪种参数传递类型?<br>A：Java参数都是进行传值.对于对象而言,传递的值是对象的引用,也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。</p></blockquote><blockquote><p>37、对象封装的原则是什么?<br>A：封装是将数据及操作数据的代码绑定到一个独立的单元,这样保障了数据的安全,防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。</p></blockquote><blockquote><p>38、你怎么理解变量？<br>A：变量是一块命名的内存区域,以便程序进行访问。变量用来存储数据,随着程序的执行,存储的数据也可能跟着改变。</p></blockquote><blockquote><p>39、数值提升是什么?<br>A：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中,byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。</p></blockquote><blockquote><p>40、Java的类型转化是什么?<br>A：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的类型转换，一个是隐式的。</p></blockquote><blockquote><p>41、main()方法的参数里面,字符串数组的第一个参数是什么?<br>A：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。</p></blockquote><blockquote><p>42、怎么判断数组是null还是为空?<br>A：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。</p></blockquote><blockquote><p>43、程序中可以允许多个类同时拥有都有main方法吗?<br>A：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。</p></blockquote><blockquote><p>44、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？<br>A：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。</p></blockquote><blockquote><p>45、一个类能拥有多个main方法吗？<br>A：可以，但只能有一个main方法拥有以下签名：<br>public static void main(String[] args) {}<br>否则程序将无法通过编译。编译器会警告你main方法已经存在。</p></blockquote><blockquote><p>46、简述JVM是如何工作的?<br>A：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。</p></blockquote><blockquote><p>47、如何原地交换两个变量的值？<br>A：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：</p></blockquote><pre class="highlight"><code class="">int a = 5, b = 10; a = a + b; b = a - b; a = a - b;</code></pre><p>使用异或操作也可以交换。第一个方法还可能会引起溢出。异或的方法如下：</p><pre class="highlight"><code class="">int a = 5;int b = 10;a=a^b;b=a^b;a=a^b;</code></pre><blockquote><p>48、什么是数据的封装?<br>A：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。</p></blockquote><blockquote><p>49、什么是反射API？它是如何实现的？<br>A：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。</p></blockquote><blockquote><p>50、JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？<br>A：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。</p></blockquote><blockquote><p>51、虚拟内存是什么?<br>A：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。</p></blockquote><blockquote><p>52、方法可以同时即是static又是synchronized的吗?<br>A：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于：</p></blockquote><pre class="highlight"><code class="">synchronized(XYZ.class){}</code></pre><blockquote><p>53、String和StringTokenizer的区别是什么？<br>A：StringTokenizer是一个用来分割字符串的工具类。</p></blockquote><pre class="highlight"><code class="">String Tokenizerst = new StringTokenizer(&quot;Hello World&quot;);while(st.hasMoreTokens()){   System.out.println(st.nextToken());}输出：HelloWorld</code></pre><blockquote><p>54、transient变量有什么特点?<br>A：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p></blockquote><blockquote><p>55、哪些容器使用Border布局作为它们的默认布局?<br>A：Window, Frame, Dialog。</p></blockquote><blockquote><p>56、什么是同步?<br>A：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。<br>对方法进行同步：</p></blockquote><pre class="highlight"><code class="">public synchronized void Method1(){    // Appropriate method-related code.}</code></pre><p>在方法内部对代码块进行同步：</p><pre class="highlight"><code class="">public myFunction() {   synchronized(this){     // Synchronized code here.   }}</code></pre><blockquote><p>57、问题：给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？<br>A：</p></blockquote><pre class="highlight"><code class="">public class Test{  public static void main(String[] args) {     //给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？     int a = 8;     //打印二进制     System.out.println(Integer.toBinaryString(a));   //输出  1000     System.out.println(Integer.toBinaryString(a|4)); //输出 1100  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;1、使用private声明main()会怎样?&lt;br&gt;
A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(四)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E5%9B%9B)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(四)/</id>
    <published>2017-12-23T08:17:41.083Z</published>
    <updated>2017-12-31T11:51:00.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java多线程实现"><a class="markdownIt-Anchor" href="#java多线程实现"></a> Java多线程实现</h2><p>Java可通过以下两种方式实现多线程：</p><blockquote><p>· 继承Thread类；<br>· 实现Runnable接口（此外扩充了Callable接口）</p></blockquote><h3 id="线程与进程"><a class="markdownIt-Anchor" href="#线程与进程"></a> 线程与进程</h3><p>Java支持多线程。<br>1、进程指的是一次程序的完整运行，在运行过程中内存、处理器、IO等资源都是为该进程服务。<br>DOS系统时代，有一种现象：假如病毒运行，那电脑就无法运行，因为所有资源都被病毒占用。但在windows时代，即使病毒在运行，电脑也可以运行。<br>这是因为windows系统是多进程操作系统。其资源分配方法是：在同一时间段，多进程轮流抢占资源，但在某时间点，只会有一个进程在运行<br>2、线程是在进程基础上进一步地划分的结果：即一个进程可以同时创建多个线程。线程是比进程更快的处理单元，而且所占的资源更小。多线程的应用也是性能最高的应用。</p><h3 id="thread类实现多线程"><a class="markdownIt-Anchor" href="#thread类实现多线程"></a> Thread类实现多线程</h3><p>1、<code>Thread类</code>是一个支持多线程的功能类，只要是其子类，就可以实现多线程。<br><code>class MyThread extends Thread { // 多线程操作类}</code><br>程序的起点是<code>main()</code>。而每个线程也有它的起点<code>run()</code>。多线程类必须覆写Thread类的<code>run()</code>：<code>public void run(){}</code>，该方法没有返回值，表示线程一旦开始，就需要一直运行，不能返回内容。</p><pre class="highlight"><code class="">// 线程操作主类class MyThread extends Thread {     private String name;    public MyThread(String name) {        this.name = name;    }    @Override    public void run() { // 覆写run(),作为线程的主体操作方法        for (int x = 0; x &lt; 200; x++) {            System.out.println(this.name + &quot;--&gt;&quot; + x);        }    }}public class Demo {    public static void main(String[] args) {        MyThread mA = new MyThread(&quot;线程A&quot;);        MyThread mB = new MyThread(&quot;线程B&quot;);        MyThread mC = new MyThread(&quot;线程C&quot;);        mA.run();        mB.run();        mC.run();    }}</code></pre><p>运行上述代码，输出结果是线程A、B、C依次进行循环输出。<br>2、线程与进程是一样的，都必须轮流去抢占资源，多线程的执行应该是多个线程彼此交替执行。但直接调用run()并不能启用多线程，多线程启用依靠的是Thread类的start()：<code>public void start()</code>（调用此方法，执行的方法体是run()定义的）。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread(&quot;线程A&quot;);        MyThread mtB = new MyThread(&quot;线程B&quot;);        MyThread mtC = new MyThread(&quot;线程C&quot;);        mtA.start();        mtB.start();        mtC.start();    }}</code></pre><p>上述代码结果中每个线程对象交替执行。</p><blockquote><p>问题：为什么多线程启用不是调用run()而是调用start()？<br>打开Java的源代码，观察start()的定义</p></blockquote><pre class="highlight"><code class="">public synchronized void start() {    if (threadStatus != 0)        throw new IllegalThreadStateException();    group.add(this);    boolean started = false;    try {        start0();        started = true;    } finally {        try {            if (!started) {                group.threadStartFailed(this);            }        } catch (Throwable ignore) {        }    }}private native void start0();</code></pre><p>start()利用throw抛出<code>IllegalThreadStateException</code>，本应使用<code>try…catch</code>处理，或者start()上使用<code>throws</code>声明，但此处没有这样处理，这是因为该异常是<code>RuntimeException</code>的子类，属于选择性处理。如果某一个线程重复启动，就会抛出异常。<br><code>start()</code>要调用<code>start0()</code>，而且该方法结构与抽象方法类似，唯一不同的是使用<code>native</code>声明。Java中有一个<code>JNI</code>技术（Java Native Interface），其特点是：使用Java调用本机操作系统提供的函数。其缺点：不能离开特定的操作系统。<br>如果线程要执行，需要操作系统进行资源分配，所以此操作是由JVM根据不同的操作系统实现的。即：使用Thread类的start()不仅仅要启动多线程的执行代码，还要根据不同的操作系统进行资源的分配。</p><h3 id="runnable接口实现多线程"><a class="markdownIt-Anchor" href="#runnable接口实现多线程"></a> Runnable接口实现多线程</h3><p>1、虽然Thread类可以实现多线程。但存在问题：Java存在单继承限制。任何情况下，对于类的单继承都是应该尽量回避的，多线程也一样。为了解决单继承的限制，在Java中专门提供了Runnable接口，此接口定义如下：</p><pre class="highlight"><code class="">@FunctionalInterfacepublic interface Runnable{    public void run();}</code></pre><p>接口中都是public权限，不存在default权限。那么只需要让一个类实现Runnable接扣，并覆写run()方法即可。</p><pre class="highlight"><code class="">class MyThread implements Runnable {    private String name;    public MyThread(String name) {        this.name = name;    }    @Override    public void run() {        for (int x = 0; x &lt; 10; x++) {            System.out.println(this.name + &quot;--&gt;&quot; + x);        }    }}</code></pre><p>与继承Thread类相比，此时MyThread类在结构上并没有区别，但存在一个不同：继承Thread类，可以直接继承start()，但是实现Runnable接口，并没有start()。<br>2、要想启用多线程，一定依靠Thread类完成，在Thread类定义有如下构造方法：<br><code>public Thread（Runnable target）</code>，接收的是Runable接口对象；<br>范例：启动多线程</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread(&quot;线程A&quot;);        MyThread mtB = new MyThread(&quot;线程B&quot;);        MyThread mtC = new MyThread(&quot;线程C&quot;);        new Thread(mtA).start();        new Thread(mtB).start();        new Thread(mtC).start();    }}</code></pre><p>此时就避免了单继承局限，所以实际开发中使用接口是最合适的。</p><h3 id="两种实现方式的区别"><a class="markdownIt-Anchor" href="#两种实现方式的区别"></a> 两种实现方式的区别</h3><p>Runnable接口与Thread类相比，解决了单继承的局限，所以如果要使用，一定使用Runnable接口。<br>1、观察Thread类的定义<br><code>public class Thread extends Object implements Runnable</code><br>Thread类实现了Runnable接口。<br><img src="/article/Java/Java/Java知识(四)/31-1.png" alt="无法加载" title="结构分析"><br>2、除了以上的联系外，还有一点：使用Runnable接口可以比Thread类更好地描述出数据共享这一概念。此时的数据共享指的是多个线程访问同一资源的操作。<br>范例：观察代码（每一个线程对象都必须通过start()启动）</p><pre class="highlight"><code class="">class MyThread extends Thread {    private int ticket = 10;    @Override    public void run() {        for (int x = 0; x &lt; 100; x++) {            if (this.ticket &gt; 0) {                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);            }        }    }}public class Demo {    public static void main(String[] args) { // 主类        MyThread mtA = new MyThread();        MyThread mtB = new MyThread();        MyThread mtC = new MyThread();        mtA.start();        mtB.start();        mtC.start();    }}</code></pre><p>上述代码声明了三个MyThread对象，并且分别调用start()方法，启动线程，发现每个线程都在卖各自的十张票，此时的内存关系如下：<br><img src="/article/Java/Java/Java知识(四)/31-2.png" alt="无法加载" title="内存分析"><br>此时并不存在数据共享。<br>范例：利用Runnable实现</p><pre class="highlight"><code class="">class MyThread implements Runnable {    private int ticket = 10;    @Override    public void run() {        for (int x = 0; x &lt; 100; x++) {            if (this.ticket &gt; 0) {                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);            }        }    }}public class Demo {    public static void main(String[] args) { // 主类        MyThread mt = new MyThread();        new Thread(mt).start();        new Thread(mt).start();        new Thread(mt).start();    }}</code></pre><p>上述代码的内存分析如下：<br><img src="/article/Java/Java/Java知识(四)/31-3.png" alt="无法加载" title="内存年分析"><br>此时也属于三个线程对象，唯一的区别是，这三个线程对象都直接占用了同一个MyThread类对象引用，即这三个线程对象都直接访问同一个数据资源。</p><blockquote><p>请解释Thread与Runnable实现多线程的区别？（请解释多线程两种实现方式的区别？）<br>1、Thread类是Runnable接口的子类，使用Runnable接口多线程可以避免单继承局限；<br>2、Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚地描述数据共享的概念；</p></blockquote><h3 id="callable接口实现多继承"><a class="markdownIt-Anchor" href="#callable接口实现多继承"></a> Callable接口实现多继承</h3><p>1、使用Runnable实现多线程可以避免单继承局限，但是Runnable中的run()不能返回操作结果。为了解该问题，Java提供了一个新的接口<code>java.util.concurrent.Callable</code>。</p><pre class="highlight"><code class="java"><span class="meta">@FunctionalInterface</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>{    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;}</code></pre><p>call()执行完线程的主体功能之后可以返回一个结果，而返回类型由Callable的泛型决定。<br>范例：定义一个线程主体类</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) {            <span class="keyword">if</span> (<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) {                System.out.println(<span class="string">"卖票，ticket = "</span> + <span class="keyword">this</span>.ticket--);            }        }        <span class="keyword">return</span> <span class="string">"票已经卖光"</span>;    }}</code></pre><p>此时发现Thread类中没有接收Callable对象的应用。但从JDK1.5开始增加<code>java.util.concurrent.FutureTask&lt;V&gt;</code>类，这个类主要负责Callable接口对象的操作。这个类的结构：<br><code>public class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt;</code><br>而上述的<code>RunnableFuture</code>结构如下：<br><code>public interface RunnableFuture&lt;V&gt; extends Runnable,Future&lt;V&gt;</code><br>在FutureTask类中定义有构造方法：<code>public FutureTask(Callable&lt;V&gt; callable)</code>，接收的是call()的返回值。<br>范例：启动多线程</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {             MyThread mtA = new MyThread();        MyThread mtB = new MyThread();        FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mtA);        FutureTask&lt;String&gt; taskB = new FutureTask&lt;String&gt;(mtB);        // 目的是取得call()的返回值        // FutureTask是Runnable接口的子类，所以可以使用Thread的构造接收        new Thread(taskA).start(); // 启动多线程        new Thread(taskB).start();        // 多线程执行完毕后，可以通过FutureTask的父接口Future中的get()方法取得返回内容        System.out.println(&quot;A线程的返回结果:&quot; + taskA.get());        System.out.println(&quot;B线程的返回结果:&quot; + taskB.get());    }}</code></pre><p>上述代码最麻烦的地方在于需要接收返回值，并且又要与原始的多线程实现靠拢（向Thread类靠拢）。</p><h2 id="多线程常用操作方法"><a class="markdownIt-Anchor" href="#多线程常用操作方法"></a> 多线程常用操作方法</h2><p>多线程有许多方法，但大部分方法都定义在Thread类中，本章只介绍几种开发常用方法。</p><h3 id="线程命名和获取线程"><a class="markdownIt-Anchor" href="#线程命名和获取线程"></a> 线程命名和获取线程</h3><p>1、线程的每次运行结果都不同，因为其会根据实际情况进行资源抢占。因此要区分每个线程，必须依靠线程名。线程名一般是在其启动前定义。不建议更改已经启动的线程名或为不同线程设置相同的名字。</p><p>2.、对线程进行命名，可以利用Thread类的如下方法：</p><blockquote><ol><li>构造方法：<code>public Thread(Runnable target, String name);</code></li></ol><p>2）设置名字：<code>public final void setName(String name);</code></p><p>3）取得名字：<code>public final String getName();</code></p></blockquote><p><code>Runable</code>子类没有继承<code>Thread</code>类，要想获取线程名即获取当前执行方法的线程名需要利用Thread类中提供的取得当前线程对象的方法:<code>public static Thread currentThread()</code>；</p><p>**范例：**不设置线程名</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        System.out.println(Thread.currentThread().getName());    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-1</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-2</span>    }}</code></pre><p>实例化<code>Thread</code>类对象时，如果没有为其设置名字，会自动进行编号命名<code>Thread-x</code>，来保证线程名字不重复。</p><p>**范例：**设置线程名</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        System.out.println(Thread.currentThread().getName());    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>        <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>).start(); <span class="comment">// 线程B</span>    }}</code></pre><p>3、观察下述代码</p><pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>        mt.run(); <span class="comment">// 直接调用run()方法，结果为main</span>    }}</code></pre><p>上述代码说明主方法就是一个线程<code>main线程</code>，所有在主方法上创建的线程实际上都可以将其视为子线程。上述代码也说明线程一直都存在（主方法就是主线程），每当使用<code>java</code>命令去解释一个程序类时，对于操作系统而言，都相当于启动了一个进程，而main只是这进程上的一个子线程而已。</p><blockquote><p>**问题：**一个JVM进程启动时至少启动几个线程？</p><p>**答：**至少启用了2个线程</p><p>1.main线程：程序的主要执行，以及启动子线程；</p><p>2.gc线程：负责垃圾收集</p></blockquote><hr><h3 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h3><p>1、线程休眠指的是让线程的执行暂时停顿，其方法：<code>public static void sleep(longmillis) throws InterruptedException</code></p><p>**范例：**观察休眠特点</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10000</span>; x++) {            <span class="keyword">try</span> {                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让其休眠1秒</span>            } <span class="keyword">catch</span> (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);        }}}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start();    }}</code></pre><p>由于每次执行<code>run()</code>都要休眠1秒，所以执行的速度变慢。一般情况下，休眠时设置多个线程对象将导致所有线程对象一起进入<code>run()</code>（所谓一起进入实际上是因为先后进入的顺序时间间隔短，肉眼忽略，但实际上不是同时进入）。</p><h3 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h3><p>1、 线程优先级越高，越有可能先被执行。在Thread类中提供有以下两个方法设置和获取优先级：</p><blockquote><p>​       · 设置优先级：<code>public final void setPriority(int new Priority)</code>；</p><p>​       · 取得优先级：<code>public final int getPriority()</code>；</p></blockquote><p>设置和取得优先级都是使用int型数据类型，对于此内容有三种取值：</p><blockquote><p>​       · 最高优先级：<code>public static final int MAX_PRIORITY；// 值为10</code></p><p>​       · 默认优先级：<code>public static final int NORM_PRIORITY；// 值为5</code></p><p>​       · 最低优先级：<code>public static final int MIN_PRIORITY。 // 值为1</code></p></blockquote><p>**范例：**优先级</p><pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) {            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);        }    }}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{        MyThread mt = <span class="keyword">new</span> MyThread();        Thread tA = <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>);        Thread tB = <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>);        Thread tC = <span class="keyword">new</span> Thread(mt, <span class="string">"线程C"</span>);        tA.setPriority(Thread.MAX_PRIORITY);        tA.start();        tB.start();        tC.start();    }}</code></pre><p>**范例：**主线程优先级</p><pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{      <span class="comment">// 获取主线程的优先级</span>      System.out.println(Thread.currentThread().getPriority());     <span class="comment">// 5</span>    }}</code></pre><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><blockquote><p><code>Thread.currentThread()</code>可以取得当前线程类对象；</p><p><code>Thread.sleep()</code>用于线程休眠，看起来是一起休眠，实际存在时间间隔</p><p>优先级越高的线程越有可能先执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java多线程实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java多线程实现&quot;&gt;&lt;/a&gt; Java多线程实现&lt;/h2&gt;
&lt;p&gt;Java可通过以下两种方式实现多线程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;· 继承Thread类
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(三)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%89)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(三)/</id>
    <published>2017-12-20T01:31:23.603Z</published>
    <updated>2017-12-20T01:35:50.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java8特性"><a class="markdownIt-Anchor" href="#java8特性"></a> Java8特性</h2><h3 id="接口定义增强"><a class="markdownIt-Anchor" href="#接口定义增强"></a> 接口定义增强</h3><p>JDK1.8之前，接口的组成只有<code>全局变量</code>和<code>抽象方法</code>。从JDK1.8开始，接口的组成增加了。<br>假设：现有一个接口，其子类有2W个。现在发现该接口功能不足，要增加一个方法，该方法对于所有子类而言的功能是一样的（即方法体是一样的）。此时要修改每个子类的方法，要修改2W次。<br>上述问题在JDK1.8中不存在，因为其允许接口中定义普通方法，但普通方法必须使用default定义。</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法    default public void fun() { // 普通方法        System.out.println(&quot;JDK1.8&quot;);    }}class Apple implements Fruit {    @Override    public void print() {        System.out.println(&quot;苹果&quot;);    }}public class Demo {    public static void main(String[] args) {        Fruit f = new Apple();        f.fun();        f.print();    }}</code></pre><p>除了使用<code>default</code>定义方法，还可以使用<code>stati</code>c定义方法<br>范例：定义static方法</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法    default public void fun() { // 普通方法        System.out.println(&quot;JDK1.8&quot;);    }    static void get() {        System.out.println(&quot;直接由接口调用&quot;);    }}class Apple implements Fruit {    @Override    public void print() {        System.out.println(&quot;苹果&quot;);    }}public class Demo {    public static void main(String[] args) {        Fruit f = new Apple();        f.fun();        f.print();        Fruit.get();    }}</code></pre><p>JDK1.8有个新功能：内部类访问方法参数时可以不加上final关键字。<br>这些新特性，完全打破了Java已有的代码组成形式。</p><h3 id="lamda表达式"><a class="markdownIt-Anchor" href="#lamda表达式"></a> Lamda表达式</h3><p>Lamda属于函数式编程的概念，下面通过匿名内部类，来分析函数式编程的产生目的。<br>范例：匿名内部类</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        fun(new Fruit() {            @Override            public void print() {                System.out.println(&quot;水果&quot;);            }        });    }    public static void fun(Fruit fru) {        fru.print();    }}</code></pre><p>上述代码中fun()最终需要的只是输出，但是由于Java的开发结构的完整性要求，不得不在这个核心语句上嵌套更多的内容。但是该做法过于严谨复杂，在JDK1.8引入函数式编程，简化过程。<br>范例：使用Lamda表达式</p><pre class="highlight"><code class="">interface Fruit {    public void print(); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        fun(()-&gt; System.out.println(&quot;水果&quot;));    }    public static void fun(Fruit fru) {        fru.print();    }}</code></pre><p>Lamda语法有三种形式：</p><blockquote><p>·(参数)-&gt;单行语句；<br>·(参数)-&gt;｛单行语句｝；<br>·(参数)-&gt;表达式；</p></blockquote><p>范例：观察有参单行</p><pre class="highlight"><code class="">interface Fruit {    public void print(String str); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s) -&gt; System.out.println(s));    }    public static void fun(Fruit fru) {        fru.print(&quot;苹果&quot;); // 设置参数的内容    }}</code></pre><p>范例：编写多行语句</p><pre class="highlight"><code class="">interface Fruit {    public void print(String str); // 接口原本定义的方法}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s) -&gt; {            s = s.toUpperCase();            System.out.println(s);        });    }    public static void fun(Fruit fru) {        fru.print(&quot;Hello&quot;); // 设置参数的内容    }}</code></pre><p>范例：编写表达式</p><pre class="highlight"><code class="">interface Fruit {    public int add(int x, int y);}public class Demo {    public static void main(String[] args) {        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出        fun((s1, s2) -&gt; s1 + s2);    }    public static void fun(Fruit fru) {        System.out.println(fru.add(10, 20));    }}</code></pre><h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h3><p>对象引用的特点：不同对象可以操作同一块内容。而方法引用就是指为一个方法设置别名，相当于一个方法定义了不同的名字。<br>1、方法引用在Java8中一共定义了四种形式：</p><blockquote><p>· 引用静态方法： 类名称::static 方法名称;<br>· 引用某个对象的方法：实例化对象::普通方法；<br>· 引用特定类型的方法：特定类::普通方法;<br>· 引用构造方法：类名称::new。</p></blockquote><p>范例：引用静态方法<br>String类中的valueof()：<code>public static String valueof(int x)</code></p><pre class="highlight"><code class="">package com.java.demo;/** * 只有一个方法的接口 * @param &lt;P&gt; 参数的数据类型 * @param &lt;R&gt; 返回值的数据类型 */interface Math&lt;P, R&gt; {    public R exchange(P p);}public class Demo {    public static void main(String[] args) {        // 覆写了exchange(),使其具有valueOf()的功能        Math&lt;Integer, String&gt; math = String::valueOf;        String msg = math.exchange(10000);        // 将所有的0替换成9        System.out.println(msg.replaceAll(&quot;0&quot;, &quot;9&quot;));    }}</code></pre><p>范例：普通方法引用<br>String类中的toUpperCase()：<code>public String toUpperCase()</code></p><pre class="highlight"><code class="">package com.java.demo;interface Math&lt;R&gt; {    public R upper();}public class Demo {    public static void main(String[] args) {        // 覆写了upper,使其具有toUpperCase的功能        // toUpperCase是普通方法,必须由String对象调用        // hello是String对象,代码如下        Math&lt;String&gt; math = &quot;hello&quot;::toUpperCase;        String msg = math.upper();        System.out.println(msg);    }}</code></pre><p>上述例子显示，要实现方法引用，必须要有接口，且该接口只能有一个方法。为了保证该接口只有一个方法，可对其进行注解说明。</p><pre class="highlight"><code class="">@FunctionalInterface // 此为函数式接口，只能定义一个方法interface ITest&lt;R&gt; {    public R upper();}</code></pre><p>2、在进行方法引用的过程中，还有一种形式的引用（这种形式需要特定类的对象支持）。一般使用“类::方法”，引用的是类中的静态方法。但是这种形式也可以引用普通方法。<br>例如：在String类中有一个方法：<code>public int compareTo(String anotherString)</code>，比较的形式是<code>String对象1.compareTo(String对象2)</code>，即要引用该方法，需要有两个参数。<br>范例：引用特定类的方法</p><pre class="highlight"><code class="">interface IMessage&lt;P&gt; {    public int compare(P p1, P p2);}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = String::compareTo;        System.out.println(msg.compare(&quot;A&quot;, &quot;B&quot;));    }}</code></pre><p>与之前相比，方法引用前不需要定义对象，可以理解为将对象定义在参数上。<br>范例：引用构造方法</p><pre class="highlight"><code class="">interface IMessage&lt;C&gt; {    public C create(String t, double p);}class Book {    private String title;    private double price;    public Book(String title, double price) {        this.title = title;        this.price = price;    }    public String toString() {        return &quot;书名:&quot; + this.title + &quot;,价格：&quot; + this.price;    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;Book&gt; msg = Book::new; // 引用构造方法        // 虽然调用的是create()，实际引用了Book类的构造方法        Book book = msg.create(&quot;Java开发&quot;, 66.6);        System.out.println(book);    }}</code></pre><p>对象引用是使用不同的名字，而方法引用需要一个函数接口。</p><h3 id="内建函数式接口"><a class="markdownIt-Anchor" href="#内建函数式接口"></a> 内建函数式接口</h3><p>1、JDK1.8中提供了一个包：<code>java.util.function</code>，提供有以下四个核心接口：</p><blockquote><p>(1)功能性接口（Function）：public interface Function&lt;T,R&gt;{public R apply(T t);}<br>|- 此接口需要接收一个参数，并且返回一个处理结果；<br>(2)消费型接口（Consumer）：public interface Consumer<T>{public void accept(T t);}<br>|- 此接口只负责接收数据（引用数据是不需要返回的），并且不返回结果；<br>(3)供给型接口（Suplier）：public interface Supplier<T>{public T get();}<br>|- 此接口不接收参数，但是可以返回结果<br>(4)断言型接口（Predicate）：public interface Predicate<T>{public boolean Test(T t);}<br>|- 进行判断操作使用；</T></T></T></p></blockquote><p>在JDK1.8中存在以上四个功能型接口，所以很少会由用户去定义新的函数式接口。<br>范例：函数式接口——接收参数并返回处理结果<br>· String类有一个方法：<code>public boolean startsWith(String str)</code></p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Function;public class Demo {    public static void main(String[] args) {        Function&lt;String, Boolean&gt; fun = &quot;##hello&quot;::startsWith;        System.out.println(fun.apply(&quot;##&quot;)); // true    }}</code></pre><p>范例：消费型接口</p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Consumer;class MyDemo {    // 此方法没有返回值，但是有参数    public void print(String str) {        System.out.println(str);    }}public class Demo {    public static void main(String[] args) {        Consumer&lt;String&gt; cons = new MyDemo()::print;        cons.accept(&quot;Hello World&quot;);    }}</code></pre><p>范例：供给型接口<br>· 引用String类的toUpperCase()：<code>public String toUpperCase()</code>;</p><pre class="highlight"><code class="">package com.java.demo;import java.util.function.Supplier;public class Demo {    public static void main(String[] args) {        Supplier&lt;String&gt; sup = &quot;hello&quot;::toUpperCase;        System.out.println(sup.get());    }}</code></pre><p>范例：断言型接口<br>· String类中有<code>equalsIgnoreCase()</code></p><pre class="highlight"><code class="">import java.util.function.Predicate;public class Demo {    public static void main(String[] args) {        Predicate&lt;String&gt; pre = &quot;hello&quot;::equalsIgnoreCase;        System.out.println(pre.test(&quot;Hello&quot;));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java8特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java8特性&quot;&gt;&lt;/a&gt; Java8特性&lt;/h2&gt;
&lt;h3 id=&quot;接口定义增强&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#接口定义增强&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(二)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%BA%8C)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(二)/</id>
    <published>2017-12-19T01:46:40.216Z</published>
    <updated>2017-12-20T01:30:35.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2><h3 id="枚举简介"><a class="markdownIt-Anchor" href="#枚举简介"></a> 枚举简介</h3><p>1、多例设计模式：<br>构造方法私有化，而后在类的内部提供有若干个实例化对象，并且通过static方法返回。<br>范例：定义一个表示颜色基色的多例</p><pre class="highlight"><code class="">class Color {    private String title;    private static final Color RED = new Color(&quot;红色&quot;);    private static final Color GREEN = new Color(&quot;绿色&quot;);    private static final Color BLUE = new Color(&quot;蓝色&quot;);    private Color(String title) {        this.title = title;    }    public static Color getInstance(int ch) {        switch (ch) {            case 1:                return RED;            case 2:                return GREEN;            case 3:                return BLUE;            default:                return null;        }    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Color red = Color.getInstance(1);        System.out.println(red);    }}</code></pre><p>2005年之前，Java定义枚举采用上述方式，即多例设计解决了Java无法直接定义枚举的问题。<br>2、从2005年之后，Java增加了枚举的概念，使用<code>enum</code>关键字定义。<br>范例：定义枚举</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED, GREEN, BLUE; // 实例化对象}public class Demo {    public static void main(String[] args) {        Color red = Color.RED;        System.out.println(red);    }}</code></pre><p>枚举可以地替代多例设计模式。<br>3、Java使用enum定义枚举，相当于一个类继承了<code>Enum</code>类。</p><blockquote><p>public abstract class Enum&lt;E extends Enum<E>&gt;<br>extends Object<br>implements Comparable<E>, Serializable</E></E></p></blockquote><p><code>Enum</code>是一个抽象类，里面定义的构造方法如下：<code>protected Enum(String name, int ordinal)</code><br>Enum类的构造方法依然是被封装的，也属于构造方法私有化。多例设计模式的前提：构造方法私有化。<br>4、在Enum类中定义了两个方法：</p><blockquote><p>· 取得枚举的索引：public final int ordinal();<br>· 取得枚举的名字：public final String name();<br>除了以上支持的方法外，使用enum关键字定义的枚举类还有一个<code>values()</code>方法，可以将枚举对象以对象数组的形式的返回。</p></blockquote><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED, GREEN, BLUE;}public class Demo {    public static void main(String[] args) {        for (Color c : Color.values()) {            System.out.println(c.ordinal() + &quot;-&quot; + c.name());        }    }}</code></pre><blockquote><p>请解释enum和Enum的区别？<br>· enum是一个关键字，而Enum是一个抽象类；<br>· 使用enum定义的枚举就相当于一个类继承了Enum类。</p></blockquote><h3 id="定义其它结构"><a class="markdownIt-Anchor" href="#定义其它结构"></a> 定义其它结构</h3><p>1、多例设计模式可以在类中定义属性和方法等；枚举也可以，但有如下要求：</p><blockquote><p>· 枚举之中定义的构造方法不能使用public声明，如果没有无参构造方法，要手工调用构造传递参数；<br>· 枚举对象必须要放在首行，随后才可以定义属性、构造方法、普通方法。</p></blockquote><p>范例：扩充枚举功能</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        for (Color c : Color.values()) {            System.out.println(c); // 调用toString()        }    }}</code></pre><p>此时与之前定义的多例设计模式操作方式完全相同，而且代码更加简单。<br>2. 枚举还可以实现接口<br>范例：枚举实现接口</p><pre class="highlight"><code class="">interface Message {    public String getTitle();}enum Color implements Message { // 定义枚举类    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String getTitle() {        return this.title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Message msg = Color.RED;        System.out.println(msg.getTitle());    }}</code></pre><p>3、枚举还可以在每个对象后面以匿名内部类的形式使用抽象方法。<br>范例：另一种形式的接口</p><pre class="highlight"><code class="">interface Message {    public String getTitle();}enum Color implements Message { // 定义枚举类    RED(&quot;红色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, GREEN(&quot;绿色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, BLUE(&quot;蓝色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }; // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String getTitle() {        return this.title;    }    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Message msg = Color.RED;        System.out.println(msg.getTitle());    }}</code></pre><p>4、枚举中还能直接定义抽象方法，此时每一个枚举对象必须分别覆写抽象方法。<br>范例：定义抽象方法并覆写</p><pre class="highlight"><code class="">enum Color { // 定义枚举类    RED(&quot;红色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, GREEN(&quot;绿色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }, BLUE(&quot;蓝色&quot;) {        public String getTitle() {            return &quot;自己的&quot; + this;        }    }; // 对象必须要放在首行    private String title; //属性    private Color(String title) {        this.title = title;    }    public String toString() {        return this.title;    }    public abstract String getTitle();}public class Demo {    public static void main(String[] args) {        System.out.println(Color.RED.getTitle());    }}</code></pre><h3 id="枚举应用"><a class="markdownIt-Anchor" href="#枚举应用"></a> 枚举应用</h3><p>1、枚举应用于switch。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Color c =Color.RED;        switch (c){ // 枚举判断            case RED:                System.out.println(&quot;这是红色&quot;);                break;            case GREEN:                System.out.println(&quot;这是绿色&quot;);                break;            case BULE:                System.out.println(&quot;这是蓝色&quot;);                break;        }    }}</code></pre><p>范例：利用枚举编写一个程序：</p><pre class="highlight"><code class="">enum Sex {    MALE(&quot;男&quot;), FEMALE(&quot;女&quot;);    private String title;    private Sex(String title){        this.title = title;    }    public String toString(){        return this.title;    }}class Person{    private String name;    private int age;    private Sex sex;    public Person(String name,int age,Sex sex) {        this.name = name;        this.age = age;        this.sex = sex;    }    public String toString(){        return &quot;姓名:&quot; + this.name +                &quot;,年龄:&quot; + this.age +                &quot;,性别:&quot; + this.sex;    }}public class Demo {    public static void main(String[] args) {        System.out.println(new Person(&quot;张三&quot;, 24, Sex.FEMALE));    }}</code></pre><h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2><blockquote><p>软件开发经历了三个阶段：<br>（1）与配置相关的代码写在程序中；<br>（2）配置与程序代码独立，即程序运行时根据配置文件操作；但会造成配置文件过多时，查错困难；<br>（3）配置信息对用户而言无用，而且错误的修改还会导致程序异常。因此将配置信息写回到程序中，但利用一些明显的标记来区分配置信息与程序。</p></blockquote><h3 id="annotation简介"><a class="markdownIt-Anchor" href="#annotation简介"></a> Annotation简介</h3><p><code>Annotation</code>是JDK1.5最大的特色，利用注解的形式来实现程序的不同功能。在Java SE中支持自定义<code>Annotation</code>的开发，并且提供了三个最为常用的基础Annotation：<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>。</p><h3 id="准确覆写"><a class="markdownIt-Anchor" href="#准确覆写"></a> 准确覆写</h3><p>如果在输出对象时，希望其可以返回需要的内容，就必须覆写<code>toString()</code>。<br>在覆写方法时，可能由于写错方法名等错误，导致未进行覆写，并且这种错误在编译时，并不能被发现。所以为了告诉编译器toString()是覆写的方法，应该加上@Override。</p><h3 id="过期声明"><a class="markdownIt-Anchor" href="#过期声明"></a> 过期声明</h3><p>假设现在有工具包，其中有一个Demo类，类中有一个fun()。在项目最初阶段，fun()非常适用。但随着技术提升，fun()显得功能不足，此时开发者有两个选择：</p><blockquote><p>· 1. 直接在新版本的工具包里删除fun()，同时给出新的fun2()；<br>· 2. 在新版本的开发包里保存fun()，但是通过某种途径告诉开发者，这个方法有问题，同时提供fun2()供开发者使用。</p></blockquote><p>明显，第二种选择比较合适，可以兼顾已使用fun()的项目。这时，就可以使用<code>@Deprecated</code>声明。<br>范例：声明过期操作</p><pre class="highlight"><code class="">class Book{    @Deprecated    public void fun(){}}public class Demo {    public static void main(String[] args) {        Book bk = new Book();        bk.fun();    }}</code></pre><p>利用此操作可以很好地实现方法功能的新旧交替。</p><h3 id="压制警告"><a class="markdownIt-Anchor" href="#压制警告"></a> 压制警告</h3><p>可以压制多个警告（warning）</p><pre class="highlight"><code class="">class Book&lt;T&gt;{    private T title;    public void setTitle(T title){        this.title = title;    }}public class Demo {    @SuppressWarnings(&quot;unchecked&quot;)    public static void main(String[] args) {        Book bk = new Book();        bk.setTitle(&quot;Hello&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;枚举&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#枚举&quot;&gt;&lt;/a&gt; 枚举&lt;/h2&gt;
&lt;h3 id=&quot;枚举简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#枚举简介&quot;&gt;&lt;/a&gt; 枚举简介&lt;/h3&gt;
&lt;p&gt;1
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL避免乱码</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/MySQL%E9%81%BF%E5%85%8D%E4%B9%B1%E7%A0%81/"/>
    <id>http://yov.oschina.io/article/工具/MySQL避免乱码/</id>
    <published>2017-12-13T01:21:07.855Z</published>
    <updated>2017-12-16T06:44:05.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编码简介"><a class="markdownIt-Anchor" href="#编码简介"></a> 编码简介</h3><p>（1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制字符（退格、响铃等）组成；<br>（2）latin1，占1byte，在ASCII基础上，增加128 ～ 255区间的字符；<br>（3）GB2312等CJK字符集，可变长字符集，最多占2bytes，用于存储常见的CJK字符；<br>（4）UTF8，可变长字符集，最多占3bytes，可以囊括ASCII、CJK及其他绝大多数常用语言文字；这中间其实还有个UNICODE字符集，它也是2bytes的，也能囊括ASCII字符，但即便是ASCII字符也需要消耗2bytes，存在一定浪费，而用UTF8存储ASCII字符时，实际只需要1byte，更为节省存储空间；<br>（5）UTF8MB4，可变长字符集，最多占4bytes，可以包含上面其他几种字符集；同样地，以UTF8MB4存储ASCII字符时，实际上也是只占用1bytes，存储一般的汉字占用3bytes，而存储个别汉字则需要4bytes，存储emoji也至少需要4bytes；<br>MySQL采用UTF8MB4字符集时,存储文本实际消耗字节数是由文本内容的字节数决定的,并非总是需要4字节,列举几种情况：</p><blockquote><p>输入字符集任意，且存储ASCII字符时，每个字符需要1byte；<br>输入字符集是GB2312，且存储的字符是汉字时，每个字符需要2bytes；<br>输入字符集是UTF8/UTF8MB4，且存储的字符是低编码汉字时，每个字符需要3bytes；<br>输入字符集是UTF8/UTF8MB4，且存储的字符是高编码汉字时，每个字符需要4bytes；<br>输入字符集是binary，且存储的字符是高编码汉字时，每个字符需要4bytes；</p></blockquote><h3 id="表字符集由utf8直接转换成utf8mb4的方法"><a class="markdownIt-Anchor" href="#表字符集由utf8直接转换成utf8mb4的方法"></a> 表字符集由UTF8直接转换成UTF8MB4的方法</h3><p>1、只修改字符集（使用默认校验集）</p><pre class="highlight"><code class="">mysql&gt; alter table t1 convert to character set utf8mb4</code></pre><p>2、同时修改表字符集和校验集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 convert to  character set utf8mb4 collate utf8mb4_bin;</code></pre><p>3、只修改某列的字符集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)  character set utf8mb4 not null default ‘’</code></pre><p>4、同时修改某列的字符集和校验集</p><pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)  character set utf8mb4  collate utf8mb4_unicode_ci  not null default ‘’</code></pre><h3 id="mysql端字符集"><a class="markdownIt-Anchor" href="#mysql端字符集"></a> MySQL端字符集</h3><blockquote><p>character_set_server：server端默认字符集；<br>character_set_database：database默认字符集，若未设定，则和 character_set_server 的设定一样；database中的数据表/stored procedure/stored function 也可以自行设定字符集，若未指定，则和 character_set_database的设置一样；数据表中的字符类型列，也可以单独设定字符集，若未设定，则和该表指定的字符集一样；<br>character_set_client：客户端显示读取结果的字符集；<br>character_set_connection：客户端从server端读取数据时传输字符集；<br>character_set_results：server端将数据发送给客户端时的字符集；</p></blockquote><p>MySQL涉及到字符集的设置实在太多，因此强烈建议各个环节全部采用同一种字符集，避免出现意外状况。</p><h3 id="总结建议"><a class="markdownIt-Anchor" href="#总结建议"></a> 总结建议</h3><p>(1)从前端到后端（浏览器=&gt;WEB Server=&gt;MySQL连接层=&gt;Server层=&gt;DB层&gt;TABLE层）,尽可能使用同一种字符集；<br>(2)尽可能采用大字符集，也就是优先级：UTF8Mb4 &gt; UTF8 &gt; GBK &gt; LATIN1;<br>(3)采用逻辑备份数据时，切记要不定期进行恢复测试.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编码简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编码简介&quot;&gt;&lt;/a&gt; 编码简介&lt;/h3&gt;
&lt;p&gt;（1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java知识(一)</title>
    <link href="http://yov.oschina.io/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%80)/"/>
    <id>http://yov.oschina.io/article/Java/Java/Java知识(一)/</id>
    <published>2017-12-06T06:31:22.456Z</published>
    <updated>2017-12-11T03:06:49.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java5特性"><a class="markdownIt-Anchor" href="#java5特性"></a> Java5特性</h2><h3 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h3><p>要求：定义一个方法，可以接收多个整型数据的相加。<br>范例：用数组解决该问题</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(add(new int[]{1, 2, 3}));        System.out.println(add(new int[]{1, 2}));    }    // 实现任意多个整型数据的相加    // 因为有多个数据，所以用数组接收    // return 累加的结果    public static int add(int[] data) {        int sum = 0;        for (int x = 0; x &lt; data.length; x++) {            sum += data[x];        }        return sum;    }}</code></pre><p>使用数组是因为方法的参数个数是固定的，无法接收随机个参数。但通过数组接收参数不符合预期，理想的调用形式：add(1,2,3),add(10,20);<br>该功能从JDK1.5后实现，它主要是在方法上使用，定义形式：</p><pre class="highlight"><code class="">[public | protected | private] [static] [final] [abstract] 返回值类型 方法名称(数据类型 ... 变量){    [return [返回值] ;]}</code></pre><p>上述代码中，[]中的内容可以忽略。上述形式中的参数不再是一个内容，而是多个内容，尽管参数的定义形式变了，但是参数的访问却没变，即进行参数访问的时候按照数组的形式操作。</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        // 可变参数支持数组        System.out.println(add(new int[] {1,2,3}));// 传递3个整型数据        // 可变参数支持参数        System.out.println(add(1,2,3));// 传递3个整型数据        System.out.println(add(10,20));// 传递2个整型数据        System.out.println(add());// 不传递数据    }    //        实现任意多个整型数据的相加操作    //        由于要接收多个整型数据，所以要用数组完成接收    //        return 多个整型数据的累加结果    public static int add(int ... data){        int sum = 0 ;        for (int x = 0 ; x &lt; data.length ; x ++){            sum += data[x] ;        }        return sum;    }}</code></pre><p>在大部分开发中，应该要求参数的个数是准确的，因此可变参数多用于一些程序相关系统类的设计使用上，而不是开发中。可变参数属于数组的变形应用。</p><h3 id="foreach循环"><a class="markdownIt-Anchor" href="#foreach循环"></a> foreach循环</h3><p>foreach的功能是进行数组或者是集合数据的输出。语法如下：</p><pre class="highlight"><code class="">for(类型 变量 : 数组 | 集合)  { //  每一次循环会自动将数组内容设置给变量}</code></pre><p>范例：for循环输出</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        int data [] = new int[] {1,2,3,4,5,6};        for (int x = 0 ; x &lt; data.length ; x ++){            System.out.println(data[x]) ;        }    }}</code></pre><p>范例：foreach输出</p><pre class="highlight"><code class="">public class Demo {    public static void main (String [] args){        int data [] = new int[] {1,2,3,4,5,6};        for (int x : data) { // 循环次数由数组长度决定            // 每一次循环都表示数组的脚标增长，会取得每个数组的内容，并将其设置给了x            System.out.println(x);        }    }}</code></pre><h3 id="静态导入"><a class="markdownIt-Anchor" href="#静态导入"></a> 静态导入</h3><p>假设一个类中定义的方法都是static方法，那么其他类引用此类时必须用“类名称.方法（）”进行调用。<br>范例：</p><pre class="highlight"><code class="">package com.java.util;public class MyMath {    public static int add(int x, int y) {        return x + y;    }    public static int div(int x, int y) {        return x / y;    }}</code></pre><p>此时MyMath中方法都是static方法，随后在其它类中使用这些方法。<br>范例：基本使用形式</p><pre class="highlight"><code class="">package com.java.demo;import com.java.util.MyMath;public class Demo {    public static void main(String [] args) {        System.out.println(&quot;加法操作：&quot; + MyMath.add(10,20));        System.out.println(&quot;加法操作：&quot; + MyMath.div(20,10));    }}</code></pre><p>范例：静态导入</p><pre class="highlight"><code class="">package com.java.demo;// 将MyMath类中的全部static方法导入，这些方法就好比直接定义在了main方法中import static com.java.util.MyMath.* ;public class Demo {    public static void main(String [] args) {        System.out.println(&quot;加法操作：&quot; + add(10,20));        System.out.println(&quot;加法操作：&quot; + div(20,10));    }}</code></pre><h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2><h3 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h3><p>1、要求：定义一个表示坐标的类（Point），该类要保存以下几种坐标：</p><blockquote><p>· 整数：x = 10、y = 20；<br>· 小数：x = 10.2、y = 20.3；<br>· 字符串：x = 东经20度、y = 北纬15度。</p></blockquote><p>Poin类的设计关键在于x和y的类型。必须有一种类型可以保存这三类数据，首先想到的是Object类型：</p><blockquote><p>· int：int自动装箱为Integer，Integer向上转型为Object；<br>· double：double自动装箱为Double，Double向上转型为Object；<br>· String：直接向上转型为Object；</p></blockquote><p>范例：设计如下</p><pre class="highlight"><code class="">class Point{ // 定义坐标类    private Object x;    private Object y;    public Object getX() {        return x;    }    public void setX(Object x) {        this.x = x;    }    public Object getY() {        return y;    }    public void setY(Object y) {        this.y = y;    }}</code></pre><p>范例：测试上述代码</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point();        pA.setX(10);        pA.setY(20);        // 2. 取出数据        int x = (Integer) pA.getX();        int y = (Integer) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>上述代码利用Object数据类型解决了问题，但依然可能有一定问题。<br>范例：错误代码：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point();        pA.setX(&quot;东经10度&quot;);        pA.setY(10);        // 2. 取出数据        String x = (String) pA.getX();        String y = (String) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>上述问题产生的原因是因为设置时存放的是int(Integer),而取出时是String。两个没有任何关系的类对象之间发生强制转换，会出现<code>java.lang.ClassCastException</code>错误。<br>2、向上转型是为了统一参数，向下转型是为了调用子类定义的特殊功能。向下转型是一种不安全的操作，那么这操作应该在代码运行前排查出来。从JDK1.5增加了泛型，泛型的核心作用在于：类在定义的时候，可以使用一个标记，此标记动态表示类中属性或方法参数的类型，使用时设置具体类型。</p><pre class="highlight"><code class="">// T在Point类定义上只表示一个标记，使用时需要为其设置具体的类型class Point&lt;T&gt; { // 定义坐标,Type = T    private T x; // 该属性类型未知，由Point动态设置    private T y; // 该属性类型未知，由Point动态设置    public T getX() {        return x;    }    public void setX(T x) {        this.x = x;    }    public T getY() {        return y;    }    public void setY(T y) {        this.y = y;    }}</code></pre><p>在使用Point类时，才设置标记的类型，即设置类中属性的类型。<br>范例：设置为String</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point&lt;String&gt; pA = new Point();        pA.setX(&quot;东经10度&quot;);        pA.setY(&quot;北纬20度&quot;);        // 此时Point类的类型为String，不需要向下转型        // 2. 取出数据        String x = pA.getX();        String y = pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>3、使用泛型后，类中属性的类型都是动态设置的，这样避免了向下转型的问题。但是泛型只能用于类，即不能用于基本数据类型，只能是引用类型（例如，不能用<code>&lt;int&gt;</code>，只能用<code>&lt;Integer&gt;</code>）</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point&lt;Integer&gt; pA = new Point();        pA.setX(10);        pA.setY(20);        // 利用包装类的自动装箱和自动拆箱        // 2. 取出数据        int x = pA.getX();        int y = pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><p>4、对于泛型有两点说明：</p><blockquote><p>· 使用泛型类或接口时，没有设置接口的具体类型会出现编译警告，为了保证程序不出错，将默认使用Object表示。</p></blockquote><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 1. 设置数据        Point pA = new Point(); // 将使用Object描述泛型        pA.setX(10);        pA.setY(20);        // 2. 取出数据,需要转型        int x = (Integer) pA.getX();        int y = (Integer) pA.getY();        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);    }}</code></pre><blockquote><p>· JDK1.7开始，可以简化泛型声明</p></blockquote><pre class="highlight"><code class="">Point&lt;Integer&gt; pA = new Point();</code></pre><p>即实例化时只要在前面声明一个泛型的具体类型。</p><h3 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h3><p>范例：观察下述程序</p><pre class="highlight"><code class="">class Message&lt;T&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;String&gt; m = new Message&lt;String&gt;();        m.setMsg(&quot;Hello&quot;);        fun(m); // 引用传递    }    public static void fun(Message&lt;String&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>上述代码为Message类设置String型的泛型，但是此时设置其他类型时，fun()中的Message<String>就不能使用了，并且fun()不能针对不同的泛型进行重载，因为方法重载只认得参数类型，无法辨别泛型的不同。<br>解决方法一：不设置方法参数的泛型</String></p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        Message&lt;String&gt; mB = new Message&lt;String&gt;();        mA.setMsg(100);        mB.setMsg(&quot;Hello&quot;);        fun(mA); // 引用传递        fun(mB);    }    public static void fun(Message temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>此时fun()存在警告，因为不设置具体泛型，就会存在警告。并且存在下述问题：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        mA.setMsg(100);        fun(mA); // 引用传递    }    public static void fun(Message temp) { // 不设置泛型，默认为Object型        temp.setMsg(&quot;Hello&quot;); // 设置Striing型        System.out.println(temp.getMsg());    }}</code></pre><p>1、上述代码说明，需要一种方式可以接收任意的泛型类型，但是不可以修改，只能取出。就可以使用<code>?</code>来描述</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {        Message&lt;Integer&gt; num = new Message&lt;&gt;();        num.setMsg(100);        fun(num);    }    public static void fun (Message&lt;?&gt; tmp) {        //tmp.setMsg(&quot;String&quot;); 报错,无法应用        System.out.println(tmp.getMsg());    }}</code></pre><ol start="3"><li>在<code>?</code>通配符基础上还有两个子通配符：</li></ol><blockquote><p>· ?extends 类：设置泛型上限，可以在声明上和方法参数上使用；<br>|- ?extends Number：意味着可以设置Number或者Number的子类(Integer，Double等)<br>· ?super 类：设置泛型下限，方法参数使用；<br>|-?super String：意味着只能设置String或者它的父类Object.</p></blockquote><p>范例：设置泛型上限</p><pre class="highlight"><code class="">class Message&lt;T extends Number&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();        mA.setMsg(100);        fun(mA); // 引用传递    }    public static void fun(Message&lt;? extends Number&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><p>范例：将Integer改为String</p><pre class="highlight"><code class="">Message&lt;String&gt; mA = new Message&lt;String&gt;();</code></pre><p>此时设置为非Number或其子类，那就会出现语法错误。<br>范例：设置泛型下限</p><pre class="highlight"><code class="">class Message&lt;T&gt; {    private T msg;    public void setMsg(T msg) {        this.msg = msg;    }    public T getMsg() {        return msg;    }}public class Demo {    public static void main(String[] args) {        Message&lt;String&gt; mA = new Message&lt;String&gt;();        mA.setMsg(&quot;Hello&quot;);        fun(mA); // 引用传递    }    public static void fun(Message&lt;? super String&gt; temp) {        System.out.println(temp.getMsg());    }}</code></pre><h3 id="泛型接口"><a class="markdownIt-Anchor" href="#泛型接口"></a> 泛型接口</h3><p>1、泛型可以在接口上声明，这样的接口称为泛型接口。<br>范例：定义泛型接口</p><pre class="highlight"><code class="">// 如果是接口在前面加“I”，例如：IMessage;// 如果是抽象类前面加Abstract,例如:AbstractMessage// 如果是普通类直接写，例如：Messageinterface IMessage&lt;T&gt; { // 设置泛型接口    public void print(T t);}</code></pre><p>2、接口必须定义其相应的子类，定义子类有两种形式：<br>形式一：在子类继续设置泛型</p><pre class="highlight"><code class="">// 子类也继续使用泛型，接口使用和子类一样的泛型标记class Message&lt;T&gt; implements IMessage&lt;T&gt; {    public void print(T t) {        System.out.println(t);    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = new Message&lt;String&gt;();        msg.print(&quot;Hello&quot;);    }}</code></pre><p>形式二：在子类不设置泛型，但为接口明确定义一个泛型</p><pre class="highlight"><code class="">class Message implements IMessage&lt;String&gt; {    public void print(String t) {        System.out.println(t);    }}public class Demo {    public static void main(String[] args) {        IMessage&lt;String&gt; msg = new Message();        msg.print(&quot;Hello&quot;);    }}</code></pre><h3 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h3><p>泛型方法也可以定义在普通类中。<br>范例：泛型方法定义</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        String str = fun(&quot;Hello&quot;);        System.out.println(str.length());    }    // T的类型由传入的参数类型决定    public static &lt;T&gt; T fun(T t) {        return t;    }}</code></pre><blockquote><p>总结：<br>1、泛型解决的是向下转型所带来的安全隐患，其核心是在声明类或接口时不设置参数或属性的类型；<br>2、“?”可以接收任意的泛型类型，只能取出，不能修改泛型</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java5特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java5特性&quot;&gt;&lt;/a&gt; Java5特性&lt;/h2&gt;
&lt;h3 id=&quot;可变参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可变参数&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yov.oschina.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse使用</title>
    <link href="http://yov.oschina.io/article/%E5%B7%A5%E5%85%B7/Tool/Eclipse%E4%BD%BF%E7%94%A8/"/>
    <id>http://yov.oschina.io/article/工具/Tool/Eclipse使用/</id>
    <published>2017-12-05T07:01:25.864Z</published>
    <updated>2017-12-05T07:05:25.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="eclipse简介"><a class="markdownIt-Anchor" href="#eclipse简介"></a> Eclipse简介</h3><p>Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包含以下几个部分：JDT、JUNIT、CVS客户端、插件开发、GIT客户端。</p><h3 id="jdt使用"><a class="markdownIt-Anchor" href="#jdt使用"></a> JDT使用</h3><p>JDT是Eclipse中进行Java程序开发的基础工具。<br>Eclipse中项目建立完成后，会在项目的文件目录下生成两个子目录：</p><blockquote><p>· src：保存所有的.java源文件；<br>· bin：保存所有的.class文件；</p></blockquote><p>Eclipse最大特点在于代码生成功能。<br>1、Eclipse中最常用的快捷键：</p><blockquote><p>·Alt + / ：进行代码提示；<br>·Ctrl + 1：为错误的代码给出纠正方案；<br>·Ctrl + Shift + O：组织导入，导入其它包的类；<br>·Ctrl + D：删除当前行代码；<br>·Ctrl + Alt + ↓：删除当前行代码；<br>·Ctrl + /：使用单行注释；<br>·Ctrl + H：强力搜索；<br>·Ctrl + Shift + L：全部快捷键列表；</p></blockquote><p>2、Eclipse中有debug（代码跟踪调试）功能，设置好断点之后，采用调试的方式运行程序。<br>进入到调试视图后，Eclipse将等待用户的操作指令，并且在设置断点处停止执行，调试方式有如下几个：</p><blockquote><p>· 单步进入【F5】：指的是进入到执行的方法之中观察方法的执行效果；<br>· 单步跳过【F6】：在当前代码的表面上执行；<br>· 单步返回【F7】：不再观察了，返回进入处；<br>· 恢复执行【F8】：停止调试，直接正常执行完毕；</p></blockquote><p>在调试过程之中可以清楚地知道方法中所有变量的数值的变化情况。</p><h3 id="junit测试工具"><a class="markdownIt-Anchor" href="#junit测试工具"></a> Junit测试工具</h3><p>junit是一个测试工具。对于软件测试分为两种：<br>·黑盒测试：针对功能测试，看不见代码<br>·白盒测试：针对性能测试，算法的调整<br>除了上述两种测试，还有一类测试----用例测试（UseCase测试工程师），junit是一个use case测试工具，但是其使用不麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;eclipse简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#eclipse简介&quot;&gt;&lt;/a&gt; Eclipse简介&lt;/h3&gt;
&lt;p&gt;Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包
      
    
    </summary>
    
      <category term="工具" scheme="http://yov.oschina.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十七)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%83)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十七)/</id>
    <published>2017-12-04T06:59:17.310Z</published>
    <updated>2017-12-04T07:27:48.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常捕获及处理"><a class="markdownIt-Anchor" href="#异常捕获及处理"></a> 异常捕获及处理</h2><p>合理使用异常处理，可以让程序更加健壮。</p><h3 id="异常的产生"><a class="markdownIt-Anchor" href="#异常的产生"></a> 异常的产生</h3><p>异常是导致程序中断执行的一种指令流。当异常出现时，如果没有合理处理，程序就会中断执行。<br>范例：不产生异常的代码</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 2));        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>范例：产生异常</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        // 2.中将出现异常        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero// at com.java.util.Demo.main(Demo.java:7)</code></pre><p>异常产生后，产生异常的语句以及之后的语句将不再执行。默认情况下系统会输出异常信息，而后自动结束程序的执行。</p><h3 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h3><p>1、Java中进行处理异常，使用<code>try</code>、<code>catch</code>、<code>finally</code>这三个关键字，语法如下：</p><pre class="highlight"><code class="">try {    // 可能出现异常的语句} catch (异常类型 对象1) {    // 异常处理} catch (异常类型 对象2) {    // 异常处理} finally {    // 不论是否出现异常都执行的语句}</code></pre><p>对于上述操作的组合有：<code>try…catch</code>、<code>try…catch…finally</code>、<code>try…finally</code>(这个不建议使用)。<br>范例：应用异常处理格式</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {        }        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// 3.除法计算结束</code></pre><p>2、出现异常就要处理异常，为了能进行异常处理，可以使用异常类中的<code>printStackTrace()</code>输出完整的异常信息：</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {            e.printStackTrace();        }        System.out.println(&quot;3.除法计算结束&quot;);    }}// 结果为：// 1.除法计算开始// java.lang.ArithmeticException: / by zero// at com.java.util.Demo.main(Demo.java:7)// 3.除法计算结束</code></pre><p>范例：使用try…catch…finally</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));        } catch (ArithmeticException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>3、异常捕获时，一个try语句可以跟多个catch语句。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (ArithmeticException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>上述程序将由用户输入数据，可能存在以下异常：<br>· 用户执行时不输入参数（java Demo）：<code>java.lang.ArrayIndexOutOfBoundsException</code>数组越界错误；<br>· 输入的数据不是数字（java Demo a b）：<code>java.lang.NumberFormatException</code>；<br>· 被除数为0（java Demo 10 0）：<code>java.lang.ArithmeticException</code><br>以上代码只有一个catch，只能处理一个异常，其他异常依然会导致程序中断<br>范例：增加多个catch</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (ArithmeticException e) {            e.printStackTrace();        } catch (NumberFormatException e) {            e.printStackTrace();        } catch (ArrayIndexOutOfBoundsException e) {            e.printStackTrace();        } finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3><p>1、观察两个异常类的继承结构：</p><pre class="highlight"><code class="">NumberFormatException：java.lang.Object  |- java.lang.Throwable      |- Exception          |- RuntimeException              |- IllegalArgumentException                  |- NumberFormatExceptionArithmeticException：java.lang.Object  |-java.lang.Throwable      |- Exception          |- RuntimeException              |- ArithmeticException</code></pre><p>由上表可得，所有异常类都是<code>Throwable</code>的子类。Throwable下有两个子类<code>Error</code>和<code>Exception</code>。</p><blockquote><p>请解释Error和Exception的区别：<br>· Error：指的是JVM错误，即：此时程序还没有执行，用户不能处理；<br>· Exception：指的是程序运行中产生的异常，用户可以处理。</p></blockquote><p>所谓的异常处理指的是Exception以及它的子类异常。<br>2、异常处理流程图<br><img src="/article/Java/Java Base/Java基础知识(十七)/24-1.png" alt="无法加载" title="异常处理流程图"><br>流程描述：<br>1）当程序运行时出现异常，由JVM自动根据异常类型实例化一个与之类型匹配的异常类对象；<br>2）产生异常对象后，会判断当前语句是否存在异常处理。如果没有异常处理，就交给JVM进行默认的异常处理（输出异常信息，结束程序调用）；<br>3）如果有异常捕获操作，会由try语句捕获产生的异常类实例化对象，之后与catch语句进行比较，如果有符合的捕获类型，则使用catch语句进行异常处理；如果不匹配，则继续向下匹配其它catch语句；<br>4）不论异常处理是否能够匹配，都要继续执行，如果程序中存在finally语句，就先执行finally语句中的代码，执行完毕后根据之前catch匹配结果来决定如何执行，如果之前成功捕获异常，那就继续执行finally之后的语句；如果没有成功捕获，就交给JVM进行默认处理。<br>整个过程和catch中的异常类型进行匹配，但是所有Java对象都可以自动向上转型。即如果真的要匹配类型，简单的做法就是匹配Exception。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        System.out.println(&quot;1.除法计算开始&quot;);        try {            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;2.出发计算：&quot; + (x / y));        } catch (Exception e) {            e.printStackTrace();        }  finally {            System.out.println(&quot;不论是否异常，都执行&quot;);        }        System.out.println(&quot;3.除法计算结束&quot;);    }}</code></pre><p>上述将所有的异常都交由Exception类处理，因此程序无法知道具体产生的是什么异常。</p><blockquote><p>说明：<br>· 使用多个catch时，范围大的异常一定要放在范围小的异常后面，否则会出现语法错误。<br>· 直接捕获Exception比较方便，但不合理，因为所有异常都按照同种方式处理。项目中应根据具体异常类型处理。</p></blockquote><h3 id="throws关键字"><a class="markdownIt-Anchor" href="#throws关键字"></a> throws关键字</h3><p>1、throws关键字主要用于方法声明，将异常交由被调用处（如main方法）处理。<br>范例：使用throws关键字</p><pre class="highlight"><code class="">class MyMath {    public static int div(int x, int y) throws Exception {        // 使用了throws,所以该方法产生的异常交由调用处处理        return x / y;    }}</code></pre><p>范例：调用上述方法</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        // 必须进行异常处理，否则代码报错        try {            System.out.println(MyMath.div(10, 2));        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>调用了具有throws声明的方法，不论操作是否异常，都需要使用<code>try..catch</code>进行异常处理。<br>2.在主方法使用throws关键字后，异常将交给JVM处理，即采用默认处理方式。由于开发的程序多数希望正常结束调用，因此主方法不应该使用throws关键字。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) throws Exception {        System.out.println(MyMath.div(10, 0));    }}</code></pre><h3 id="throw关键字"><a class="markdownIt-Anchor" href="#throw关键字"></a> throw关键字</h3><p>1、程序中可以使用throw手工抛出一个异常类的对象。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        try {            throw new Exception(&quot;自定义异常&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><blockquote><p>throws与throw的区别：<br>·throw：在方法中手工抛出一个异常类对象（该对象可以是自定义的，或者已经存在的）；<br>·throws：用于方法声明上，使得调用该方法时必须处理异常。</p></blockquote><h3 id="异常处理标准格式"><a class="markdownIt-Anchor" href="#异常处理标准格式"></a> 异常处理标准格式</h3><p>要求：定义div()，在执行除法前打印提示信息，在计算结束后打印提示信息；如果计算中产生了异常，交给调用处处理。<br>范例：</p><pre class="highlight"><code class="">class MyMath {    public static void div(int x, int y) {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        System.out.println(x / y);        System.out.println(&quot;==== 除法计算结束 ====&quot;);    }}public class Demo {    public static void main(String[] args) {        MyMath.div(10,2);    }}</code></pre><p>上述代码可能出现异常，因此要进行异常处理。根据要求，异常交由调用处处理，因此使用throws关键字。</p><pre class="highlight"><code class="">class MyMath {    // 如果div()出现异常，异常交给调用处处理    public static void div(int x, int y) throws Exception {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        System.out.println(x / y);        System.out.println(&quot;==== 除法计算结束 ====&quot;);    }}public class Demo {    public static void main(String[] args) {        try {            MyMath.div(10, 2);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>上述代码产生错误后，程序运行到<code>System.out.println(&quot;==== 除法计算结束 ====&quot;);</code>就不执行了。<br>范例：正确做法如下：</p><pre class="highlight"><code class="">class MyMath {    // 如果div()出现异常，异常交给调用处处理    public static void div(int x, int y) throws Exception {        System.out.println(&quot;==== 除法计算开始 ====&quot;);        try {            System.out.println(x / y);        } catch (Exception e) {            throw e; // 抛出异常        } finally {            System.out.println(&quot;==== 除法计算结束 ====&quot;);        }    }}public class Demo {    public static void main(String[] args) {        try {            MyMath.div(10, 0);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h3 id="runtimeexception类"><a class="markdownIt-Anchor" href="#runtimeexception类"></a> RuntimeException类</h3><p>范例：观察下述程序</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int temp = Integer.parseInt(&quot;100&quot;);    }}</code></pre><p>parseInt()： <code>public static int parseInt(String s) throws NumberFormatException;</code><br>parseInt()抛出了NumberFormatException，按照之前知识点，此处应强制进行异常捕获，但实际并没有该要求：<br>观察一下NumberFormatException的继承结构:</p><pre class="highlight"><code class="">java.lang.Object  |- java.lang.Throwable      |- java.lang.Exception          |- java.lang.RuntimeException → 运行时异常              |- java.lang.IllegalArgumentException                  |- java.lang.NumberFormatException</code></pre><p>Java为方便代码编写，提供了RuntimeException类，该类的特征是：程序在编译时，不会强制性要求用户处理异常，用户可以根据自己的需求选择性处理，但是没有处理又发生异常，就会交给JVM默认处理。</p><blockquote><p>请解释Exception与RuntimeException的区别，请列举常见的几种RuntimeException<br>· Exception是RuntimeExceptio的父类；<br>· 使用Exception定义的异常必须要被处理，而RuntimeException的异常可以选择性处理。<br>·常见的RuntimeException：ArithmeticException、NullPointerException、ClassCastException。</p></blockquote><h3 id="异常的捕获及处理断言"><a class="markdownIt-Anchor" href="#异常的捕获及处理断言"></a> 异常的捕获及处理（断言）</h3><p>assert关键字在JDK1.4引入，其功能是进行断言。</p><pre class="highlight"><code class="">public class Demo {    public static void main(String[] args) {        int num = 10;        assert num == 20 : &quot;num 不等于20&quot;;        System.out.println(&quot;num = &quot; + num);    }}</code></pre><p>默认情况下，断言是不应该影响程序的运行，即Java在解释程序时，断言是默认不起作用的。<br>启用断言：<code>java -ea Demo</code></p><pre class="highlight"><code class="">Exception in thread &quot;main&quot; java.lang.AssertionError: num的内容不是20        at Demo.main(Demo.java:6)</code></pre><h3 id="异常的捕获及处理自定义异常"><a class="markdownIt-Anchor" href="#异常的捕获及处理自定义异常"></a> 异常的捕获及处理（自定义异常）</h3><ol><li>Java自身提供了大量的异常类，但对于实际开发是不够。例如：进行添加数据操作时，可能出现错误数据，错误数据出现就应该抛出异常，例如AddException，而该异常Java没有，需要自己开发。<br>如果要自己开发一个异常类可以选择继承Exception或RuntimeException。<br>范例：定义AddException</li></ol><pre class="highlight"><code class="">class AddException extends Exception {    public AddException(String msg) {        super(msg);    }}public class Demo {    public static void main(String[] args) {        int num = 11;        try {            if (num &gt; 10) {                throw new AddException(&quot;数值传递过大&quot;);            }        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>上述代码，只是介绍自定义异常的形式，不能说明自定义异常的作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常捕获及处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异常捕获及处理&quot;&gt;&lt;/a&gt; 异常捕获及处理&lt;/h2&gt;
&lt;p&gt;合理使用异常处理，可以让程序更加健壮。&lt;/p&gt;
&lt;h3 id=&quot;异常的产生&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(十六)</title>
    <link href="http://yov.oschina.io/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E5%85%AD)/"/>
    <id>http://yov.oschina.io/article/Java/Java Base/Java基础知识(十六)/</id>
    <published>2017-11-22T02:16:01.974Z</published>
    <updated>2017-11-22T07:04:37.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2><h3 id="访问控制权限-2"><a class="markdownIt-Anchor" href="#访问控制权限-2"></a> 访问控制权限</h3><p>Java有四种访问控制权限：<code>public,protected,default,private</code>。</p><table><thead><tr><th>No.</th><th>范围</th><th style="text-align:center">public</th><th style="text-align:center">protected</th><th style="text-align:center">default</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td>1</td><td>在同一个类中</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>2</td><td>在同一包的不同类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td>3</td><td>在不同包的子类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>4</td><td>在不同包的非子类</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p><code>protected</code>权限与包的定义有关。<br>范例：定义com.java.demoA.A类</p><pre class="highlight"><code class="">package com.java.demoa;public class A {    protected String info = &quot;Hello&quot;;}</code></pre><p>范例：定义com.java.demoB.B类</p><pre class="highlight"><code class="">package com.java.demoB;import com.java.demoa.A;public class B extends A { // 与A处于不同包中    public void print() {        System.out.println(&quot;A中的info：&quot; + super.info);    }}</code></pre><p>范例：测试</p><pre class="highlight"><code class="">package com.java.test;import com.java.demoB.B;public class Test {    public static void main(String[] args) {        new B().print(); // A中的info：Hello    }}</code></pre><p>范例：由Test类直接输出A类中的属性</p><pre class="highlight"><code class="">package com.java.test;import com.java.demoa.A;public class Test {    public static void main(String[] args) {        System.out.println(new A().info); // 报错，无法访问info    }}</code></pre><p>由于Test与A不在同一个包，并且没有继承关系，所以是无法访问protected权限。</p><blockquote><p>总结：<br>1.Java的封装性是以private、protected、default三种权限为主；<br>2.对于权限的选择，建议如下：<br>·声明属性就用private；<br>·声明方法就用public；<br>3.关于命名要求：<br>· 类名称每个单词的首字母大写，其余字母小写，例如：StudentInfo；<br>· 属性名称第一个单词字母小写，而后每个单词首字母大写，例如：studentName；<br>· 方法名称第一个单词字母小写，而后每个单词首字母大写，例如：toString()；<br>· 常量名全部大写，例如：MSG；<br>· 包名全部小写，例如：com.java.demo</p></blockquote><h3 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式"></a> 单例设计模式</h3><p>（1）正常情况下，类只有产生实例化对象后才能操作这个类。<br>范例：观察程序</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = new Singleton(); // 生成实例化对象        singleton.print();    }}</code></pre><p>Singleton类中存在构造方法，没有自定义构造方法时系统会自动生成一个无参无返回值操作的构造方法，即：一个类至少存在一个构造方法。<br>范例：修改Singleton类定义</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = new Singleton(); // 报错,无法访问Singleton()        singleton.print();    }}</code></pre><p>构造方法私有化后，无法调用构造方法实例化对象。<br>范例：调用私有化方法<br>分析步骤：<br>1.构造方法上使用了private声明，导致构造方法只能内部使用，因此直接在内部实例化对象：</p><pre class="highlight"><code class="">class Singleton{    Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}</code></pre><p>2.<code>instance</code>是普通属性，普通属性只有实例化对象才可以调用，因此需要使用static声明instance属性，使其不受实例化对象控制。</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    static Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }}public class Demo {    public static void main(String[] args) {        Singleton singleton = Singleton.instance;         singleton.print();    }}</code></pre><p>3.类中属性需要进行封装<code>private static Singleton instance = new Singleton();</code><br>4.获取封装的属性要使用<code>getter()</code>，因此要定义一个同样不受实例化对象控制的getter()，使用static定义。</p><pre class="highlight"><code class="">package com.java.demo;class Singleton{    private static Singleton instance = new Singleton();    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }    public static Singleton getInstance() {        return instance;    }}public class Demo {    public static void main(String[] args) {        Singleton singletonA = Singleton.getInstance();        Singleton singletonB = Singleton.getInstance();        System.out.println(singletonA == singletonB); // true    }}</code></pre><p>上述代码的意义：要限制一个类实例化底下的个数，首先要锁定的是构造方法，因为实例化对象必须调用构造方法 ，那么构造方法私有化，就无法产生新的对象。此时要实例化一个对象，就需要在类中使用static定义一个公共对象 ，并使用static方法返回该对象，这样不论外部调用多少次，最终该类中只产生了一个对象，这就是<code>单例设计模式（Singleton）</code>。<br>（2）单例设计模式有两种形式：饿汉式、懒汉式<br>上述单例设计模式就属于饿汉式，即在定义Singleton类时就实例化一个对象，不论该对象最后是否被使用。<br>而懒汉式则是在第一次使用时才进行实例化对象，如果不使用， 就不进行实例化操作。<br>范例：实现懒汉式</p><pre class="highlight"><code class="">class Singleton{    private static Singleton instance;    private Singleton() {} // 构造方法私有化    public void print() {        System.out.println(&quot;Hello World!&quot;);    }    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>单例设计模式的目的是让该类在整个系统中只有一个实例化对象。</p><h3 id="多例设计模式"><a class="markdownIt-Anchor" href="#多例设计模式"></a> 多例设计模式</h3><p>多例设计模式，可以让一个类产生指定数量的实例化对象。<br>范例：定义一个表示性别的类</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(int ch) {        switch (ch) {            case 0:                return FEMALe;            case 1:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}public class Demo {    public static void main(String[] args) {        Sex sex = Sex.getInstance(0);        System.out.println(sex);    }}</code></pre><p>JDK1.7之前，switch只能判断int或char，由于数字或字符表示不太直观，在1.7增加了String判断。</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(String sex) {        switch (sex) {            case &quot;woman&quot;:                return FEMALe;            case &quot;man&quot;:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}</code></pre><p>如果不想在switch语句中使用String，则可以引入一个标记接口（该方式不好）</p><pre class="highlight"><code class="">package com.java.demo;class Sex {    private String title;    private static final Sex MALE = new Sex(&quot;男&quot;);    private static final Sex FEMALe = new Sex(&quot;女&quot;);    private Sex(String title) {        this.title = title;    }    public static Sex getInstance(int ch) {        switch (ch) {            case 0:                return FEMALe;            case 1:                return MALE;            default:                return null;        }    }    @Override    public String toString() {        return this.title;    }}interface Choose {    int WOMAN = 0;    int MAN = 1;}public class Demo {    public static void main(String[] args) {        Sex sex = Sex.getInstance(Choose.MAN);        System.out.println(sex);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;访问控制权限&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#访问控制权限&quot;&gt;&lt;/a&gt; 访问控制权限&lt;/h2&gt;
&lt;h3 id=&quot;访问控制权限-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#访问控制权限-2&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://yov.oschina.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yov.oschina.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
