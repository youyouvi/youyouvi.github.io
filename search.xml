<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java基础知识(六)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AD)/</url>
      <content type="html"><![CDATA[<h2 id="关键字this"><a class="markdownIt-Anchor" href="#关键字this"></a> 关键字this</h2>
<h3 id="this调用属性"><a class="markdownIt-Anchor" href="#this调用属性"></a> this调用属性</h3>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String t, double p) {
        title = t;
        price = p;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book book = new Book(&quot;Java开发&quot;, 66.6);
        System.out.println(book.getInfo());
    }
}
</code></pre>
<p>上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。<strong>构造方法的功能是为类的属性初始化，参数名最好与属性名一致。</strong></p>
<pre class="highlight"><code class="">public Book(String title, double price) {
    title = title;
    price = price;
}
</code></pre>
<p>修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的<code>{}</code>的变量名，即数据传到构造方法后，并未传到属性中。<strong>为了明确要访问的变量是类的属性，应在变量名前加<code>this</code>。</strong></p>
<pre class="highlight"><code class="">public Book(String title, double price) {
    this.title = title;
    this.price = price;
}
</code></pre>
<p><strong>在开发中，只要访问类中属性，前面必须加<code>this</code>。</strong></p>
<h3 id="this调用方法"><a class="markdownIt-Anchor" href="#this调用方法"></a> this调用方法</h3>
<p>1.<code>this</code>指的是当前对象，一个类除了属性还有方法，因此可以利用<code>this</code>调用方法。</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public void print() {
        System.out.println(&quot;*********&quot;);
    }

    // setter和getter方法略
    public String getInfo() {
        this.print();
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>在类中调用普通方法，加不加<code>this</code>都一样。但为了代码的严谨性，最好加<code>this</code>。<br>
2.this调用构造方法<br>
多个构造方法间互相调用: <code>this(参数1, 参数2…);</code><br>
<strong>范例</strong>：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息<code>一个新的Book类对象产生</code></p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
        this.title = title;
    }

    public Book(String title, double price) {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码中存在重复，要消除重复代码：</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        this(); // 调用本类中的无参构造
        this.title = title;
    }

    public Book(String title, double price) {
        this(title); // 调用本类中的单参构造方法
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码中存在限制：</p>
<blockquote>
<p>（1）利用<code>this</code>调用构造方法的语句只能放在构造方法首行；<br>
（2）普通方法无法调用构造方法；<br>
（3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() { // 报错，构造递归调用
        this(&quot;Book&quot;,1.1);
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        this(); // 调用本类中的无参构造
        this.title = title;
    }

    public Book(String title, double price) {
        this(title); // 调用本类中的单参构造方法
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码会出现”构造方法递归调用”错误，说明<strong>构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。</strong><br>
3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法;</p>
<blockquote>
<p>（1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”；<br>
（2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”；<br>
（3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”；<br>
（4）四参构造</p>
</blockquote>
<p><strong>实现方式1：不使用this</strong></p>
<pre class="highlight"><code class="">class Emp {
    private int empNo;
    private String eName;
    private double sal;
    private String dept;

    public Emp() {
        this.empNo = 0;
        this.eName = &quot;无名氏&quot;;
        this.sal = 0.0;
        this.dept = &quot;未定&quot;;
    }

    public Emp(int empNo) {
        this.empNo = empNo;
        this.eName = &quot;临时工&quot;;
        this.sal = 800.0;
        this.dept = &quot;后勤部&quot;;
    }

    public Emp(int empNo, String eName) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = 2000.0;
        this.dept = &quot;技术部&quot;;
    }

    public Emp(int empNo, String eName, double sal, String dept) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = sal;
        this.dept = dept;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +
                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +
                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +
                &quot;部   门：&quot; + this.dept;
    }
}
</code></pre>
<p><strong>实现方式2：使用this</strong></p>
<pre class="highlight"><code class="">class Emp {
    private int empNo;
    private String eName;
    private double sal;
    private String dept;

    public Emp() {
        this(0,&quot;无名氏&quot;,0.0,&quot;&quot;);
    }

    public Emp(int empNo) {
        this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;);

    }

    public Emp(int empNo, String eName) {
        this(empNo,eName,2000.0,&quot;技术部&quot;);
    }

    public Emp(int empNo, String eName, double sal, String dept) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = sal;
        this.dept = dept;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +
                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +
                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +
                &quot;部   门：&quot; + this.dept;
    }
}
</code></pre>
<p><strong>通过构造方法互相调用解决了代码重复问题。</strong></p>
<h3 id="当前对象"><a class="markdownIt-Anchor" href="#当前对象"></a> 当前对象</h3>
<p><strong>当前对象指的是当前正在调用类中属性或方法的对象</strong></p>
<pre class="highlight"><code class="">class Book {
    public void print() {
        // 哪个对象调用了print(),this就与该对象指向同一块内存地址
        // this就是当前调用方法的对象
        System.out.println(&quot;this = &quot; + this);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        System.out.println(&quot;bkA = &quot; + bkA);  
        // bkA = com.java.demo.Book@1540e19d
        bkA.print(); 
        // this = com.java.demo.Book@1540e19d
        System.out.println( &quot;===============&quot;);
        Book bkB = new Book(); 
        // bkB = com.java.demo.Book@677327b6
        System.out.println(&quot;bkB = &quot; + bkB); 
        // this = com.java.demo.Book@677327b6
        bkB.print();
    }
}
</code></pre>
<pre class="highlight"><code class="">class A{
    private B b;
    public A(){ // 2.执行A类构造方法
        // 3. 实例化B类对象b，调用B类构造方法
        this.b = new B(this); //此时this是temp
        this.b.get(); // 5. 通过b调用B类的get()
    }
    public void print(){ //8. 执行该方法
        System.out.println(&quot;Hello World !&quot;);
    }
}
class B{
    private A a;
    public B(A a){ // A a = temp
        this.a = a; // 4. 执行B类构造方法
    }
    public void get(){ // 6. 执行该方法
        this.a.print(); // 7. 调用A类的print()
    }
}
public class Demo {
    public static void main(String[] args) {
        // 1.实例化A类对象，调用A类的无参构造方法
        A temp = new A(); // Hello World !
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(五)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%94)/</url>
      <content type="html"><![CDATA[<h2 id="string类的特点及使用"><a class="markdownIt-Anchor" href="#string类的特点及使用"></a> String类的特点及使用</h2>
<blockquote>
<p>JDK_API文档由下面几部分组成：<br>
（1）类的定义以及相关的继承结构<br>
（2）类的简短说明<br>
（3）类的成员组成<br>
（4）类所提供的构造方法<br>
（5）类所提供的普通方法<br>
（6）类的成员，构造方法，普通方法的详细说明<br>
<code>deprecated</code>标记表示不再建议使用。</p>
</blockquote>
<h3 id="string对象的两种实例化方式"><a class="markdownIt-Anchor" href="#string对象的两种实例化方式"></a> String对象的两种实例化方式</h3>
<p>1.<code>String</code>是字符串类,下面将类的角度与内存关系分析其作用：<br>
（1）直接赋值<code>String value_name = &quot;字符串&quot;</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World !&quot;; // 直接赋值
        System.out.println(str);
    }
}
</code></pre>
<p>（2）构造方法<code>public String (String str);</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = new String(&quot;Hello World !&quot;);
        System.out.println(str);
    }
}
</code></pre>
<h3 id="字符串比较"><a class="markdownIt-Anchor" href="#字符串比较"></a> 字符串比较</h3>
<p>1.判断两个int数据是否相等：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int x = 10;
        int y = 10;
        System.out.println(x == y); // true
    }
}
</code></pre>
<p>使用<code>==</code>判断String对象是否相等：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = new String(&quot;Hello&quot;);
        String strC = strB;
        System.out.println(strA == strB); // false
        System.out.println(strA == strC); // false
        System.out.println(strB == strC); // true
    }
}
</code></pre>
<p>对上述代码进行内存分析：<br>
<img src="/article/语言/Java基础知识(五)/8-1.png" alt="无法加载" title="内存分析"><br>
由内存分析可知，String对象使用<code>==</code>比较时，比较的是对象的<strong>栈内存地址的值</strong>。<br>
2.要比较字符串的内容，应使用String类中的方法<code>public boolean equals（String str）</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = new String(&quot;Hello&quot;);
        String strC = strB;
        System.out.println(strA.equals(strB)); // true
        System.out.println(strA.equals(strC)); // true
    }
}
</code></pre>
<p>开发中，字符串比较应用<code>equals(String str)</code>.<br>
3.<strong>章节例题：<code>==</code>与<code>equals(String str)</code>的区别</strong><br>
<code>==</code>是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值;<br>
<code>equals(String str)</code>是String类的方法，用于比较字符串内容。</p>
<h3 id="string常量是匿名对象"><a class="markdownIt-Anchor" href="#string常量是匿名对象"></a> String常量是匿名对象</h3>
<p>1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但<strong>不属于基本数据类型，而是将字符串作为String类的匿名对象。</strong><br>
<strong>范例</strong>：验证字符串是匿名对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        System.out.println(&quot;Hello&quot;.equals(str));
    }
}
</code></pre>
<p>2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化.</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String input = null; // 假设该内容是用户输入的
        if (input.equals(&quot;hello&quot;)){
            System.out.println(&quot;Hello World !&quot;);
            // 报错，NullPointerException
        }
    }
}
</code></pre>
<p>为预防用户输入错误导致input为null，而后调用<code>equals()</code>，出现空指针异常，应使用如下代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String input = null; // 假设该内容是用户输入的
        if (&quot;hello&quot;.equals(input)){
            System.out.println(&quot;Hello World !&quot;);
        }
    }
}
</code></pre>
<p>使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将<strong>指定字符串放在equals()前</strong>。</p>
<h3 id="两种实例化方式的区别"><a class="markdownIt-Anchor" href="#两种实例化方式的区别"></a> 两种实例化方式的区别</h3>
<p>1.<strong>直接赋值</strong><br>
直接赋值就是给字符串匿名对象设置对象名。<br>
此时内存中会开辟堆内存，并且有一块栈内存指向堆内存：<br>
<img src="/article/语言/Java基础知识(五)/8-2.png" alt="无法加载" title="内存分析"><br>
观察下列代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;hello&quot;;
        String strB = &quot;hello&quot;;
        String strC = &quot;hello&quot;;
        String strD = &quot;world&quot;;
        System.out.println(strA == strB); // true
        System.out.println(strA == strC); // true
        System.out.println(strB == strC); // true
        System.out.println(strA == strD); // false
    }
}
</code></pre>
<p>由上述结果可知，strA，strB，strC都指向同一块堆内存：<br>
<img src="/article/语言/Java基础知识(五)/8-3.png" alt="无法加载" title="内存分析"><br>
<strong>共享设计模式</strong>：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。<br>
2.<strong>构造方法实例化</strong><br>
使用构造方法定义String对象，就需要每次开辟新的堆内存。<br>
<img src="/article/语言/Java基础知识(五)/8-4.png" alt="无法加载" title="内存分析"><br>
由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = new String(&quot;hello&quot;);
        String strB = &quot;hello&quot;;
        System.out.println(strA == strB); // false
    }
}
</code></pre>
<p>除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用<code>public String intern()</code>手工入池。</p>
<p>3.<strong>章节小题：String对象两种定义方式的区别</strong><br>
· 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用；<br>
· 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。</p>
<h3 id="字符串内容不可改变"><a class="markdownIt-Anchor" href="#字符串内容不可改变"></a> 字符串内容不可改变</h3>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        str += &quot; World&quot;;
        str += &quot; !!!&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>对上述代码进行内存分析：<br>
<img src="/article/语言/Java基础知识(五)/8-5.png" alt="无法加载" title="内存分析"><br>
分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。</p>
<h3 id="string类常用方法字符与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字符与字符串"></a> String类常用方法(字符与字符串)</h3>
<p>很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法：</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String (char[] value)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将字符数组变为String类对象</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String (char[] value ,int offset,int count)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分字符数组变为String对象</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public char charAt (int index)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">返回指定索引对应的字符信息</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public char[] toCharArray()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串以字符数组的形式返回</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：取出指定索引的字符</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        char c = str.charAt(0);
        System.out.println(c); // H
    }
}
</code></pre>
<p><strong>范例</strong>：将字符串转大写</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello&quot;;
        char [] data = str.toCharArray(); // 字符串转为字符数组
        for (int x = 0; x &lt; data.length ; x++) {
            data[x] -= 32; // 小写编码 - 32 = 大写编码
        }
        // 将字符数组变为字符串
        System.out.println(new String(data)); // HELLO
        // 将部分字符数组变为String对象
        System.out.println(new String(data, 1, 2)); // EL
    }
}
</code></pre>
<p><strong>范例</strong>：判断一个字符换是否为纯数字<br>
<em>思路</em>：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;3146017052&quot;;
        if (isNumber(str)) {
            System.out.println(&quot;字符串全部由数字组成&quot;);
        } else {
            System.out.println(&quot;字符串不是全部由数字组成&quot;);
        }
    }

    // 定义判断字符串是否由数字组成的方法
    public static boolean isNumber(String temp) {
        // 首先将字符串变为字符数组
        char[] data = temp.toCharArray();
        // 一一比较字符
        for (int x = 0; x &lt; data.length; x++) {
            if (data[x] &gt; '9' || data[x] &lt; '0') {
                return false;
            }
        }
        // 全部为数字则返回true
        return true;
    }
}
</code></pre>
<p><strong>建议</strong>：返回值为<code>boolean</code>的方法命名为<code>isXxx</code>。</p>
<h3 id="string类常用方法字节与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字节与字符串"></a> String类常用方法(字节与字符串)</h3>
<p>字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String (byte[] bytes)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将字节数组变为字符串</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String (byte[] bytes ,int offset,int length)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分字节数组变为字符串</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public byte[] getBytes (String charsetName) throws UnsupportedEncodingException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行编码转换</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public byte[] getBytes()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串变为字节数组</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：字符串与字节数组的转换</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        byte [] data = str.getBytes(); // 将字符串转为字节数组
        for (int x = 0; x &lt; data.length ; x++) {
            data[x] -= 32; // 将小写字母转为大写字母
        }
        System.out.println(new String(data)); // HELLOWORLD
        System.out.println(new String(data,5,5)); // WORLD
    }
}
</code></pre>
<h3 id="string类常用方法字符串比较"><a class="markdownIt-Anchor" href="#string类常用方法字符串比较"></a> String类常用方法(字符串比较)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public boolean equals(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行内容判断，区分大小写</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public boolean equalsIgnoreCase(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行内容判断，不区分大小写</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public int compareTo (String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断两个字符串的大小（按照字符编码）,返回值为0,1,-1</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：equals()判断</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.equals(strB)); // false,说明区分大小写
    }
}
</code></pre>
<p><strong>范例</strong>：equalsIgnoreCase()判断</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.equals(strB)); // false,说明区分大小写
        System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写
    }
}
</code></pre>
<p><strong>范例</strong>：compareTo()</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.compareTo(strB)); // -32
        if (strA.compareTo(strB) &gt; 0){
            System.out.println(&quot;大于&quot;);
        } else if (strA.compareTo(strB) == 0){
            System.out.println(&quot;两个字符串相等&quot;);
        } else {
            System.out.println(&quot;小于&quot;);
        }
    }
}
</code></pre>
<p>只有String对象才能进行大小判断。</p>
<h3 id="string类常用方法字符串查找"><a class="markdownIt-Anchor" href="#string类常用方法字符串查找"></a> String类常用方法(字符串查找)</h3>
<p>要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法：</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public boolean contains (String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断指定内容是否存在</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public int indexOf(String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public int indexOf(String s,int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public int lastindexOf(String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">public int lastindexOf(String s, int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">public boolean startsWith (String prefix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定字符串开头</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">public boolean startsWith (String prefix，int toffset)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定位置开始判断是否是以指定字符串开头</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">public boolean endsWith(String suffix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定字符串结尾</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：查找字符串位置</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 返回满足条件的单词的首字母索引
        System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引
        // 从索引5开始查满足条件单词的索引
        System.out.println(str.indexOf(&quot;l&quot;,5)); // 8
        // 从后向前查
        System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8
    }
}
</code></pre>
<p>在某些程序中，需要查找指定字符串是否存在，早期方法如下：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        if (str.indexOf(&quot;world&quot;) != -1){
            System.out.println(&quot;该字符串存在&quot;);
        } else {
            System.out.println(&quot;该字符串不存在&quot;);
        }
    }
}
</code></pre>
<p>JDK1.5出现<code>contains()</code>，使用如下：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        if (str.contains(&quot;world&quot;)) {
            System.out.println(&quot;该字符串存在&quot;);
        } else {
            System.out.println(&quot;该字符串不存在&quot;);
        }
    }
}
</code></pre>
<p><strong>范例</strong>：开头或结尾判断内容</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 从开头开始查
        System.out.println(str.startsWith(&quot;he&quot;));
        // 从索引2开始查找
        System.out.println(str.startsWith(&quot;ll&quot;,2));
        // 从结尾开始查找
        System.out.println(str.endsWith(&quot;ld&quot;));
    }
}
</code></pre>
<h3 id="string类常用方法字符串替换"><a class="markdownIt-Anchor" href="#string类常用方法字符串替换"></a> String类常用方法(字符串替换)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String replaceAll(String regex，String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">全部替换</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String replaceFirst(String regex，String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换首个满足条件的内容</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 替换所有
        String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d
        // 只替换第一个
        String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld
        System.out.println(resultA);
        System.out.println(resultB);
    }
}
</code></pre>
<h3 id="string类常用方法字符串截取"><a class="markdownIt-Anchor" href="#string类常用方法字符串截取"></a> String类常用方法(字符串截取)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String substring(int beginIndex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">从指定索引截取到结尾</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String substring(int beginIndex,int endIndex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">截取指定范围内的内容</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 从索引5开始截取直到结尾
        String resultA = str.substring(5); 
        // 截取索引5到8之间
        String resultB = str.substring(5,8); 
        System.out.println(resultA); // world
        System.out.println(resultB); // wor
    }
}
</code></pre>
<h3 id="string类常用方法字符串拆分"><a class="markdownIt-Anchor" href="#string类常用方法字符串拆分"></a> String类常用方法(字符串拆分)</h3>
<table>
<thead>
<tr>
<th>No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String[] split (String regex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">按照指定的字符串进行全部拆分</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String[] split (String regex，int limit)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">按照指定的字符串进行部分拆分，最后一个数组长度由limit决定</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：全部拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world&quot;;
        // 按照空格拆分单词
        String result[] = str.split(&quot; &quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：hello
            // world
        }
    }
}
</code></pre>
<p>在拆分的时候，只写一个空字符串（<code>&quot;&quot;</code>不是<code>null</code>），表示按照每一个字符进行拆分。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world&quot;;
        // 按照空字符串拆分
        String result[] = str.split(&quot;&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：h e l l o w o r l d
        }
    }
}
</code></pre>
<p><strong>范例</strong>：部分拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world nihao mldn&quot;;
        // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆
        String result[] = str.split(&quot; &quot;,3);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot;
        }
    }
}
</code></pre>
<p><strong>范例</strong>：IP地址拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;192.168.1.1&quot;;
        String result[] = str.split(&quot;\\.&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果为：192 168 1 1
        }
    }
}
</code></pre>
<p>上述代码中，只用<code>.</code>无法拆分，当遇到这种拆分时，需要使用<code>\\.</code>进行转义后拆分。<br>
<strong>范例</strong>：拆分“张三:20|李四:25|王五:23”</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;张三:20|李四:25|王五:23&quot;;
        String result[] = str.split(&quot;\\|&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            String temp[] = result[x].split(&quot;:&quot;);
            System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]);
        }
    }
}
</code></pre>
<h3 id="string类其他方法"><a class="markdownIt-Anchor" href="#string类其他方法"></a> String类其他方法</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String concat (String str)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">字符串连接</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String toLowerCase ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">把字符串转为小写</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public String toUpperCase ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">把字符串转为大写</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public String trim ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">去掉字符串中左右两边的空格，中间空格保留</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">public int length()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">取得字符串长度</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">public String intern ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">数据入池操作</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center"></td>
<td style="text-align:center">public boolean isEmpty ()</td>
<td style="text-align:center">普通方法</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：字符串连接</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;hello&quot;;
        String strB = strA + &quot; world&quot;;
        String strC = &quot;hello&quot; + &quot;world&quot;;
        String strD = &quot;hello world&quot;;
        String strE = strA.concat(&quot; world&quot;);
        System.out.println(strB == strC); // false
        System.out.println(strB == strD); // false
        System.out.println(strB == strE); // false
        System.out.println(strC == strD); // false
        System.out.println(strC == strE); // false
        System.out.println(strD == strE); // false
    }
}
</code></pre>
<p><strong>范例</strong>：字符串进行大小写转换</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;*Hello*&quot;;
        // 只转换小写字母
        System.out.println(str.toUpperCase()); // *HELLO*
        // 只转换大写字母
        System.out.println(str.toLowerCase()); // *hello*
    }
}
</code></pre>
<p><strong>范例</strong>：去掉空格</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot; Hello World &quot;;
        System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】
        System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】
    }
}
</code></pre>
<p>用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了<code>trim()</code>。<br>
<strong>范例</strong>：取得字符串长度</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World&quot;;
        System.out.println(str.length()); // 11
    }
}
</code></pre>
<p>某些情况要求用户输入的数据长度有限制，可以利用此方法判断。<br>
<strong>范例</strong>：判断是否是空字符串</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;&quot;;
        System.out.println(str.isEmpty()); // true
        System.out.println(&quot;&quot;.equals(str)); // true
    }
}
</code></pre>
<p><strong>范例</strong>：实现首字母大写，其余字母小写</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hElLo&quot;;
        System.out.println(initcap(str)); // Hello
    }

    public static String initcap(String temp) {
        // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写
        return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase();
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(四)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%9B)/</url>
      <content type="html"><![CDATA[<h2 id="数组的定义及使用"><a class="markdownIt-Anchor" href="#数组的定义及使用"></a> 数组的定义及使用</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>1.<strong>数组</strong>是一组变量的集合。数组属于引用数据类型。<br>
2.数组的定义语法<br>
（1）声明并开辟数组： <code>数组类型 数组名[] = new 数据类型[数组长度]</code><br>
（2）分步完成：</p>
<pre class="highlight"><code class="">// 声明数组
数组类型 数组名[] = null;
// 开辟数组
数组名 = new 数据类型 [数组长度]
</code></pre>
<p>3.数组开辟空间用，可利用<code>数组名[下标|索引]</code>访问，<strong>下标从0开始</strong>。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现<strong>数组越界异常（ArrayIndexOutOfBoundsException）。</strong><br>
4.数组是顺序结构且长度固定，可使用循环语句输出，可用<code>数组名.length</code>获取数组长度。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[3]; // 声明并开辟一个长度为3的数组
        datas[0] = 1; // 为数组赋值，如不赋值，默认值为0
        datas[1] = 2;
        datas[2] = 3;
        // for循环输出数组内容，datas.length获取数组长度
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p>5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。<br>
<img src="/article/语言/Java基础知识(四)/7-1.png" alt="无法加载" title="数组内存分析"><br>
<strong>范例</strong>：分步完成</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = null; // 声明数组
        datas = new int[3]; // 开辟一个长度为3的数组
        datas[0] = 1;
        datas[1] = 2;
        datas[2] = 3;
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p><img src="/article/语言/Java基础知识(四)/7-2.png" alt="无法加载" title="数组内存分析"><br>
6.数组可以进行引用传递。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[3];
        datas[0] = 1;
        datas[1] = 2;
        datas[2] = 3;
        int temp[] = datas; // 引用传递
        temp[0] = 99;
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]); // 99 2 3
        }
    }
}
</code></pre>
<p><img src="/article/语言/Java基础知识(四)/7-3.png" alt="无法加载" title="数组内存分析"><br>
以上都是<code>动态初始化数组</code>，即先开辟数组，再为数组赋值。<br>
7.静态初始化数组：<br>
在定义数组的同时为其赋值，语法：<br>
（1）<code>数组类型 数组名[] = {v1, v2 ,…,vn};</code><br>
（2）<code>数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn};</code><br>
<strong>范例</strong>：静态初始化数组</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[]{1, 2, 3}; // 静态初始化数组
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p>数组支持顺序数据访问，最大缺点是<strong>长度不能改变</strong>，因此在开发中不直接使用数组，但会使用数组的概念。</p>
<h3 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h3>
<p>1.<strong>一维数组就是一行数据：</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据</td>
<td style="text-align:center">0</td>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
</tr>
</tbody>
</table>
<p>在一维数组中要查询一个数据，只要确定其索引即可。<br>
<strong>二维数组，是一个数据表：</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">12</td>
<td style="text-align:center">123</td>
<td style="text-align:center">231</td>
<td style="text-align:center">233</td>
</tr>
</tbody>
</table>
<p>二维数组中要查询一个数据，需要定位列和行。二维数组中第一个<code>[]</code>确定行，第二个<code>[]</code>确定列。<br>
2. 二维数组定义语法：</p>
<pre class="highlight"><code class="">// 动态初始化：
数据类型 数组名称[][]=new 数据类型[行数][列数];
// 静态初始化：
数据类型 数组名称[][]=new 数据类型[][]{数组元素} ;
</code></pre>
<p>由此可以发现，二维数组就是将多个一维数组变为一个数组。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[][] = new int[][]{
        	{1, 2, 3}, 
        	{4, 5, 6}, 
        	{7, 8, 9}
        }; 
        // 外层循环控制数组的行
        for (int x = 0; x &lt; datas.length; x++) {
            // 内层循环控制数组的列
            for (int y = 0; y &lt; datas[x].length ; y++) {
                System.out.print(datas[x][y] + &quot;\t&quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="数组与方法的引用"><a class="markdownIt-Anchor" href="#数组与方法的引用"></a> 数组与方法的引用</h3>
<p>1.方法的参数可以是数组：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[]{1, 2, 3};
        change(datas);
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }

    public static void change(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            temp[x] *= 2; // 数组元素乘2保存
        }
    }
}
</code></pre>
<p><strong>内存分析：</strong><br>
<img src="/article/语言/Java基础知识(四)/7-4.png" alt="无法加载" title="数组内存分析"><br>
<code>change()</code>执行完毕后，<code>temp</code>不再指向<code>datas</code>的堆内存，但<code>change()</code>对<code>datas</code>数据的修改被保存下来。<br>
2.<strong>数组排序（冒泡排序）</strong>：<br>
数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。</p>
<pre class="highlight"><code class="">public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};
        for (int x = 0; x &lt; datas.length; x++) {
            for (int y = 0; y &lt; datas.length - 1; y++) {
                if (datas[y] &gt; datas[x]) {
                    int t = datas[y];
                    datas[y] = datas[x];
                    datas[x] = t;
                }
            }
            // 为更好地理解冒泡排序，输出每轮排序的结果
            System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;);
            print(datas);
            System.out.println();
        }
        print(datas);
    }
    // 数组输出的方法
    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot; &quot;);
        }
    }
}
</code></pre>
<p><strong>建议</strong>：<code>main()</code>是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。</p>
<pre class="highlight"><code class="">public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};
        sort(datas);
        print(datas);
    }

    // 数组冒泡排序方法
    public static void sort(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            for (int y = 0; y &lt; temp.length - 1; y++) {
                if (temp[y] &gt; temp[x]) {
                    int t = temp[y];
                    temp[y] = temp[x];
                    temp[x] = t;
                }
            }
        }
    }

    // 数组输出的方法
    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot; &quot;);
        }
    }
}
</code></pre>
<p>3.<strong>数组转置</strong><br>
转置的概念（一维数组）：·</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th style="text-align:right">1，2，3，4，5，6，7，8</th>
</tr>
</thead>
<tbody>
<tr>
<td>转置后</td>
<td style="text-align:right">8，7，6，5，4，3，2，1</td>
</tr>
</tbody>
</table>
<p><strong>转置操作的两个思路：</strong><br>
（1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用：</p>
<pre class="highlight"><code class=""> public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{1,2,3,4,5,6,7,8};
        datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾
    }
    // 数组逆序输出方法一
    public static int [] reverseOne(int temp[]) {
        // 定义新数组，长度与原始数组一致
        int temps[] = new int[temp.length];
        int foot = temp.length - 1; // 控制原始数组的索引
        for (int x = 0; x &lt; temps.length ; x++) {
            temps[x] = temp[foot]; // 新数组按照原始数组倒序排列
            foot --;
        }
        return temps;
    }
}
</code></pre>
<p>上述代码实现转置，但产生了垃圾，不合理。<br>
（2）利用算法，直接在数组上完成转置：<br>
不论数组个数是奇数还是偶数,<code>转换次数 = 数组长度 / 2</code>;</p>
<pre class="highlight"><code class="">// 数组逆序输出方法
public static void reverse(int temp[]) {
    int len = temp.length / 2;
    int head = 0;
    int tail = temp.length - 1;
    for (int x = 0; x &lt; len; x++) {
        int t = temp[head];
        temp[head] = temp[tail];
        temp[tail] = t;
        head++;
        tail--;
    }
}
</code></pre>
<p>4.<strong>行列数相等的二维数组转置：</strong></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int data[][] = new int[][]{
        	{1, 2, 3}, 
        	{4, 5, 6}, 
        	{7, 8, 9}
        };
        reverse(data);
        print(data);
    }

    // 专门实现数组的倒置操作
    public static void reverse(int arr[][]) {
        for (int x = 0; x &lt; arr.length; x++) {
            for (int y = x; y &lt; arr.length; y++) {
                if (x != y) { //行和列相同，进行交换
                    int temp = arr[x][y];
                    arr[x][y] = arr[y][x];
                    arr[y][x] = temp;
                }
            }
        }
    }

    // 专门输出的方法
    public static void print(int temp[][]) {
        for (int x = 0; x &lt; temp.length; x++) {
            for (int y = 0; y &lt; temp[x].length; y++) {
                System.out.print(temp[x][y] + &quot;、&quot;);
            }
            System.out.println();
        }
        System.out.println();
    }

}
</code></pre>
<p><strong>转置过程</strong>：</p>
<pre class="highlight"><code class="">1[0][0]  2[0][1]  3[0][2]
4[1][0]  5[1][1]  6[1][2]
7[2][0]  8[2][1]  9[2][2]
第一次转换（x=0，y=x=0，循环3次）
 ·y的第一次循环（x==y）
  1[0][0]  2[0][1]  3[0][2]
  4[1][0]  5[1][1]  6[1][2]
  7[2][0]  8[2][1]  9[2][2]
 ·y的第二次循环（x=0，y=1，进行交换）
  1[0][0]  4[1][0]  3[0][2]
  2[0][1]  5[1][1]  6[1][2]
  7[2][0]  8[2][1]  9[2][2]
 ·y的第三次循环（x=0，y=2，进行交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  6[1][2]
  3[0][2]  8[2][1]  9[2][2]
第二次转换（x=1，y=x=1，循环2次）
 ·y的第一次循环（x=1，y=1，不交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  6[1][2]
  3[0][2]  8[2][1]  9[2][2]
 ·y的第二次循环（x=1，y=2，进行交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  8[2][1]
  3[0][2]  6[1][2]  9[2][2]
第三次转换（x=2，y=x=2，循环11次）
 ·y的第二次循环（x=2，y=2，不交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  8[2][1]
  3[0][2]  6[1][2]  9[2][2]
</code></pre>
<p>行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。<br>
5.方法返回数组：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int data[] = init(); // 接收数组
        print(data);
        System.out.println(init().length);
    }

    public static int[] init() {
        return new int[]{1, 2, 3}; // 方法返回数组
    }

    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot;、&quot;);
        }
        System.out.println();
    }
}
</code></pre>
<h3 id="操作数组的方法"><a class="markdownIt-Anchor" href="#操作数组的方法"></a> 操作数组的方法</h3>
<p>1.Java对数组提供类库支持，下面介绍两个类库中的方法：<br>
（1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。<br>
语法：<code>System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)</code>。<br>
范例：数组拷贝<br>
·数组A：1，2，3，4，5，6，7，8；<br>
·数组B：11，22，33，44，55，66，77，88；<br>
·拷贝后的数组B:11，22，5，6，7，66，77，88</p>
<pre class="highlight"><code class=""> public class Demo {
    public static void main(String[] args) {
        int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8};
        int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88};
        System.arraycopy(dataA, 4, dataB, 2, 3);
        ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法
    }
}
</code></pre>
<p>（2）数组排序：<br>
语法：<code>java.util.Arrays.sort(数组名)</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5};
        java.util.Arrays.sort(dataA);
        ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法
    }
}
</code></pre>
<h3 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h3>
<p>1.<strong>对象数组</strong>是将多个对象交由数组处理。<br>
2.对象数组的定义与一般数组一致：<br>
<strong>范例</strong>： 动态初始化对象数组</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book books[] = new Book[3];
        books[0] = new Book(&quot;Java开发&quot;, 66.6);
        books[1] = new Book(&quot;JSP&quot;, 6.6);
        books[2] = new Book(&quot;C++&quot;, 16.6);
        for (int x = 0; x &lt; books.length; x++) {
            System.out.println(books[x].getInfo()); 
//未实例化对象时，输出值全为null
        }
    }  
}
</code></pre>
<p><strong>范例</strong>：静态初始化对象数组：</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book books[] = new Book[]{
                new Book(&quot;Java开发&quot;, 66.6),
                new Book(&quot;JSP&quot;, 6.6),
                new Book(&quot;C++&quot;, 16.6)
        };
        for (int x = 0; x &lt; books.length; x++) {
            //未实例化对象时，输出值全为null
            System.out.println(books[x].getInfo()); 
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(三)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="方法的定义与使用"><a class="markdownIt-Anchor" href="#方法的定义与使用"></a> 方法的定义与使用</h2>
<h3 id="方法的基本概念"><a class="markdownIt-Anchor" href="#方法的基本概念"></a> 方法的基本概念</h3>
<ol>
<li><strong>方法</strong>就是<code>将一段可重复使用的代码封装</code>。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是<code>定义在主类中，由主方法直接调用</code>的方法。此类方法的语法：</li>
</ol>
<pre class="highlight"><code class="">public static 返回值类型 method_name(v_type v1, v_type v2,...) {
    方法体; // 方法要进行的若干操作
    [return [返回值] ;] // []中内容可写可不写
}
</code></pre>
<p><strong>返回值类型:</strong></p>
<table>
<thead>
<tr>
<th>数据类型(基本数据类型、引用数据类型)</th>
<th style="text-align:right">无返回值(void)</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容</td>
<td style="text-align:right">不需要return语句，但可用return结束方法调用</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>方法名的命名规则：<code>第一个单词小写，随后每个单词首字母大写</code>。<br>
<strong>范例</strong>：定义无参无返回值方法</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        print(); // 直接调用
    }
    public static void print(){
        System.out.println(&quot;无参无返回值方法&quot;);
    }
}
</code></pre>
<p><strong>范例</strong>：定义含参无返回值方法</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        compare(10.2); // 调用时必须写入参数
        compare(-10.2);
    }

    public static void compare(double x){
        String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>有了参数后，方法就可以根据不同的参数内容进行数据的处理。<br>
<strong>范例</strong>：定义含参数有返回值方法</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        //定义变量接收返回值，而后输出
        int result = add(10, 20);
        System.out.println(result);
        // 直接输出返回值
        System.out.println(add(10, 20));
    }

    public static int add(int x, int y) {
        return x + y;
    }
}
</code></pre>
<ol start="3">
<li>一个方法使用<code>void</code>定义，该方法无法使用return返回值，但可以使用return结束调用。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        print(1100); // x = 1100
        print(3); // 结束调用,不输出x
    }

    public static void print(int x) {
        if (x == 3) {
            System.out.println(&quot;结束调用,不输出x&quot;);
            return;
        }
        System.out.println(&quot;x = &quot; + x);
    }
}
</code></pre>
<p><strong>只有返回值类型为void时，才可使用return结束方法的调用。</strong></p>
<h3 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h3>
<ol>
<li>假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为<code>方法重载（overloading）</code>。</li>
<li>方法重载要求<code>方法名一致，参数类型或个数不同</code>。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 根据参数的个数或类型，调用不同方法
        add(10,20);
        add(10.2,20.2);
        add(10,20,30);
    }
    // 方法名相同，参数的类型或个数不同
    public static void add(int x, int y) {
        System.out.println(&quot;两个整数相加：&quot; + (x + y));
    }

    public static void add(double x, double y) {
        System.out.println(&quot;两个小数相加：&quot; + (x + y));
    }

    public static void add(int x, int y, int z) {
        System.out.println(&quot;三个整数相加：&quot; + (x + y + z));
    }
}
</code></pre>
<p><code>System.out.println()</code>可以输出不同类型数据，可知此方法是一个被重载后的方法。</p>
<ol start="3">
<li>方法重载的说明：<br>
（1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致；<br>
（2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
    }
    // 报错,已在类中定义了方法 add(int,int)
    // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同
    public static int add(int x, int y) {
        return x + y;
    }

    public static double add(int x, int y) {
        return x + y;
    }
}
</code></pre>
<h3 id="递归调用"><a class="markdownIt-Anchor" href="#递归调用"></a> 递归调用</h3>
<ol>
<li>递归调用是指<code>方法调用自身</code>。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。<br>
<strong>范例</strong>：递归实现1~100的累加操作</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        System.out.println(sum(100));
    }
    public static int sum(int num){
        if (num == 1) { // 结束递归调用
            return 1;
        }
        // 递归调用
        return num + sum(num - 1); 
    }
}
</code></pre>
<p><strong>代码的执行步骤：</strong></p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">内容</th>
<th style="text-align:right">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">主方法调用sum(100)</td>
<td style="text-align:right">100+sum(99)</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">递归调用sum(99)</td>
<td style="text-align:right">100 + 99 + sum（98)</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">递归调用sum(98)</td>
<td style="text-align:right">100 + 99 + 98+ sum(97)</td>
</tr>
<tr>
<td>…</td>
<td style="text-align:center">依此类推</td>
<td style="text-align:right">…</td>
</tr>
<tr>
<td>最后一次</td>
<td style="text-align:center">递归调用sum(1)</td>
<td style="text-align:right">sum=100+99+98+…+2+1,结束递归</td>
</tr>
</tbody>
</table>
<h2 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h2>
<h3 id="面向对象简介"><a class="markdownIt-Anchor" href="#面向对象简介"></a> 面向对象简介</h3>
<blockquote>
<p>面向过程：指的是针对某一个问题单独提出解决方案和代码开发。<br>
面向对象：以组件化的形式进行代码设计，优点是代码可重用。<br>
面向对象语言的特征：<br>
（1）<code>封装性</code>：保护内部结构安全性。<br>
（2）<code>继承性</code>：在已有的程序结构上扩充新的功能。<br>
（3）<code>多态性</code>：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果<br>
面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。</p>
</blockquote>
<h3 id="类与对象-2"><a class="markdownIt-Anchor" href="#类与对象-2"></a> 类与对象</h3>
<p>1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。<br>
2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含<code>特征(属性)</code>外，还包括许多<code>行为(方法)</code>。根据这个类产生的对象都具有相同的行为。<br>
3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。<br>
4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。</p>
<h3 id="类与对象的定义及使用"><a class="markdownIt-Anchor" href="#类与对象的定义及使用"></a> 类与对象的定义及使用</h3>
<p>1.定义类使用<code>class class_name {}</code>语句完成。类的组成：<br>
(1)<code>field</code>（属性，成员，变量）：一堆变量的集合；<br>
(2)<code>method</code>（方法，行为）：由对象调用。<br>
<strong>范例</strong>：定义类</p>
<pre class="highlight"><code class="">package com.java.entity;
public class Book {
   // 定义属性
   public String title;
   public double price;
   // 定义方法
   public void getInfo(){
       System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
   }
}
</code></pre>
<p>2.要使用类，必须要有对象，对象定义的语法有如下两种：<br>
(1)声明并实例化对象：<code>class_name object_name = new class_name()</code>；<br>
(2)分步完成： 第一步-声明对象：<code>class_name object_name = null</code>;<br>
第二部-实例化对象：<code>object_name =new class_name()</code>;<br>
引用数据类型与基本数据类型最大区别是<strong>需要内存的开辟及使用</strong>，所以关键字<code>new</code>的主要功能就是开辟内存空间。<br>
3.当一个对象实例化后，利用如下方式操作类：<br>
(1)<code>object_name.field</code>：操作类中的属性；<br>
(2)<code>object_name.method()</code>：调用类中的方法。<br>
<strong>范例</strong>：使用类</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book book = new Book(); // 声明并实例化对象
        book.title = &quot;Java开发&quot;; // 定义属性
        book.price = 66.6;
        book.getInfo(); // 调用方法
    }
}
</code></pre>
<p>4.堆内存和栈内存的概念：</p>
<table>
<thead>
<tr>
<th>堆内存</th>
<th style="text-align:right">栈内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>保存对象的属性内容，使用关键字new开辟</td>
<td style="text-align:right">栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字</td>
</tr>
</tbody>
</table>
<p><img src="/article/语言/Java基础知识(三)/6-1.png" alt="无法加载" title="内存分析"><br>
<strong>范例</strong>：分步使用实例化对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book book = null; // 声明对象
        book = new Book(); // 实例化对象
        book.title = &quot;Java开发&quot;;
        book.price = 66.6;
        book.getInfo();
    }
}
</code></pre>
<p><strong>内存分析</strong>：使用关键字<strong>new</strong>开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为<strong>默认值</strong>。<br>
<img src="/article/语言/Java基础知识(三)/6-2.png" alt="无法加载" title="内存分析"><br>
使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）”</p>
<h3 id="对象引用分析"><a class="markdownIt-Anchor" href="#对象引用分析"></a> 对象引用分析</h3>
<p>1.在引用分析中，每次使用<code>new</code>关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么<strong>两个对象占据的是不同的堆内存，因此不会互相影响。</strong><br>
<strong>范例</strong>：声明两个对象</p>
<pre class="highlight"><code class="">public class Demo {
   public static void main(String[] args) {
       Book bkA = new Book();
       Book bkB = new Book();
       bkA.title = &quot;Java开发&quot;;
       bkA.price = 66.6;
       bkA.getInfo();
       bkB.title = &quot;C++开发&quot;;
       bkB.price = 22.6;
       bkB.getInfo();
   }
}
</code></pre>
<p><img src="/article/语言/Java基础知识(三)/6-3.png" alt="无法加载" title="内存分析"><br>
2. <strong>范例</strong>：对象引用传递</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        Book bkB = null;
        bkA.title = &quot;Java开发&quot;;
        bkA.price = 66.6;
        bkA.getInfo(); // 66.6
        bkB = bkA; // 引用传递
        bkB.price = 90.5;
        bkA.getInfo(); // 90.5
        bkB.getInfo(); // 90.5
    }
}
</code></pre>
<p><img src="/article/语言/Java基础知识(三)/6-4.png" alt="无法加载" title="内存分析"><br>
由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。<strong>在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。</strong><br>
3. <strong>范例</strong>：引用传递</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        Book bkB = new Book();
        bkA.title = &quot;Java开发&quot;;
        bkA.price = 66.6;
        bkB.title = &quot;C++开发&quot;;
        bkB.price = 90.5;
        bkB = bkA; // 引用传递
        bkB.price = 100;
        bkA.getInfo(); // 100
        bkB.getInfo(); // 100
    }
}
</code></pre>
<p><img src="/article/语言/Java基础知识(三)/6-5.png" alt="无法加载" title="内存分析"><br>
通过内存分析可知，<strong>在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。</strong></p>
<h3 id="封装性"><a class="markdownIt-Anchor" href="#封装性"></a> 封装性</h3>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.title = &quot;Java开发&quot;;
        bkA.price = -66.6;
        bkA.getInfo();
    }
}

</code></pre>
<p>上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为<strong>对象可以在类的外部直接访问属性。</strong><br>
1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。</p>
<pre class="highlight"><code class="">public class Book {
    private String title;
    private double price;
    public void getInfo(){
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性
    }
}
</code></pre>
<p>此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：<strong>类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter()</strong>.<br>
2. 以Book类中的title属性为例，定义setter()/getter()：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">setter()</th>
<th style="text-align:center">getter()</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用</td>
<td style="text-align:center">设置属性值</td>
<td style="text-align:center">取得属性值</td>
</tr>
<tr>
<td>语法</td>
<td style="text-align:center">public void setTitle(String t)</td>
<td style="text-align:center">public void getTitle()</td>
</tr>
<tr>
<td>是否含参</td>
<td style="text-align:center">有参</td>
<td style="text-align:center">无参</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">package com.java.entity;
public class Book {
    private String title;
    private double price;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public void getInfo(){
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}
</code></pre>
<p>如果要添加如价格不能为负数的功能，应在setter()中添加：</p>
<pre class="highlight"><code class="">public void setPrice(double price) {
    if (price &gt; 0.0){
        this.price = price; 
    }
}
</code></pre>
<p>对于数据的验证，开发中应有其他辅助代码完成，<strong>setter()只是简单地设置数据，getter()只用于返回数据。</strong></p>
<h3 id="构造方法与匿名对象"><a class="markdownIt-Anchor" href="#构造方法与匿名对象"></a> 构造方法与匿名对象</h3>
<blockquote>
<p>定义对象的语法：类名称 对象名称 = new 类名称();<br>
①类名称：定义对象的类型；<br>
②对象名称：标识符，要使用对象，需要有一个对象名；<br>
③new：用于开辟堆内存空间，实例化对象；<br>
④类名称()：一个方法名和类名称一样的方法，这就是构造方法。<br>
通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为<strong>Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。</strong><br>
1.构造方法的定义原则：<strong>方法名称与类名称相同，没有返回值。</strong></p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    public Book() { // 系统自动生成的构造方法
    }
}
</code></pre>
<p>2.构造方法在对象使用new实例化时调用。<br>
<strong>范例</strong>：证明构造方法被调用</p>
<pre class="highlight"><code class="">public class Book {
   public Book() {
       System.out.println(&quot;构造方法被调用&quot;);
   }
}

public class Demo {
   public static void main(String[] args) {
       Book book = null ; // 声明对象
       book = new Book(); // 实例化对象时调用构造方法
       //结果：构造方法被调用
   }
}
</code></pre>
<p>构造方法与普通方法的最大区别：<strong>构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。</strong><br>
3.<strong>范例</strong>：自定义构造方法</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;
    // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法
    public Book(String t, double p) {
        title = t;
        price = p;
    }

    public void getInfo() {
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book book = new Book(&quot;Java开发&quot;, 66.6);
        book.getInfo();
    }
}
</code></pre>
<p>由上述代码可知构造方法的作用：<code>在类对象实例化时设置属性的初始值，即构造方法用于属性初始化</code>。<br>
4.构造方法也属于方法，因此可以进行重载。<br>
<strong>范例</strong>：构造方法重载</p>
<pre class="highlight"><code class="">class Book {
    public Book() {
        System.out.println(&quot;系统自动生成的构造方法&quot;);
    }
    // 进行方法重载的构造方法
    public Book(String t, double p) {
        System.out.println(&quot;方法重载后的构造方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bookA = new Book(); // 系统自动生成的构造方法
        Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法
    }
}
</code></pre>
<p>重载方法时要求：<strong>按照参数个数，对方法进行升序或者降序排列。</strong><br>
5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：<code>类的加载，内存的分配，默认值的设置，构造方法</code>。</p>
<pre class="highlight"><code class="">class Book {
    private String title = &quot;Java开发&quot;; // 设置默认值
    private double price;

    public Book() {
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        if (price &gt; 0.0){
            this.price = price;
        }
    }

    public void getInfo() {
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.getInfo(); // 书名：Java开发,价格：0.0
    }
}
</code></pre>
<p>本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。<strong>真实的对象信息都保存在堆内存中。</strong><br>
6.匿名对象：<code>没有栈内存指向的对象，即没有标识符的对象</code>。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        new Book(&quot;Java开发&quot;,6.6).getInfo();
    }
}
</code></pre>
<p>由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。<br>
<strong>何时使用匿名对象</strong>：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。</p>
<h3 id="简单java类实践"><a class="markdownIt-Anchor" href="#简单java类实践"></a> 简单Java类实践</h3>
<p><strong>题目要求</strong>：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。<br>
<strong>提示</strong>：这种类被称为<code>简单java类</code>，因为这种类不包含过于复杂的程序逻辑。</p>
<blockquote>
<p>对于简单Java类而言，它的要求如下：<br>
·类名必须有意义；<br>
·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法；<br>
·类中可以有多个构造方法，但必须保留无参构造方法；<br>
·类中不允许出现输出语句，信息输出必须交给调用处。<br>
·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。</p>
</blockquote>
<p><strong>第一步：定义类</strong></p>
<pre class="highlight"><code class="">public class Emp {
    private int eId; // 编号
    private String eName; // 姓名
    private String job; // 职位
    private double sal; // 工资
    private double comm; // 佣金
    // 定义构造方法
    public Emp() {
    }
    
    public Emp(int eId, String eName, String job, double sal, double comm) {
        this.eId = eId;
        this.eName = eName;
        this.job = job;
        this.sal = sal;
        this.comm = comm;
    }
    // 定义setter和getter方法
    public int geteId() {
        return eId;
    }

    public void seteId(int eId) {
        this.eId = eId;
    }

    public String geteName() {
        return eName;
    }

    public void seteName(String eName) {
        this.eName = eName;
    }

    public String getJob() {
        return job;
    }

    public void setJob(String job) {
        this.job = job;
    }

    public double getSal() {
        return sal;
    }

    public void setSal(double sal) {
        this.sal = sal;
    }

    public double getComm() {
        return comm;
    }

    public void setComm(double comm) {
        this.comm = comm;
    }
    // 定义普通方法
    public String getInfo() {
        return &quot;编  号&quot; + this.eId + &quot;\n&quot; +
                &quot;姓 名&quot; + this.eName + &quot;\n&quot; +
                &quot;职 位&quot; + this.job + &quot;\n&quot; +
                &quot;工 资&quot; + this.sal + &quot;\n&quot; +
                &quot;佣 金&quot; + this.comm;
    }
}
</code></pre>
<p><strong>第二步：测试</strong></p>
<pre class="highlight"><code class="">public class TEmp {
    public static void main(String[] args) {
        Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0);
        System.out.println(e.getInfo()); // 获取全部信息
        System.out.println(e.geteId()); // 通过getter()获取单一信息
    }
}
</code></pre>
<p>类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。</p>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kubernetes安装及使用]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Kubernetes%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2>
<p><strong>系统要求</strong>: CentOS 7<br>
<strong>软件版本</strong>: 1.5.2</p>
<h2 id="配置目标"><a class="markdownIt-Anchor" href="#配置目标"></a> 配置目标:</h2>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">master端</th>
<th style="text-align:right">node端</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td style="text-align:center">10.0.0.100</td>
<td style="text-align:right">10.0.0.101</td>
</tr>
<tr>
<td>etcd</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>flannel</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kube-scheduler</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kubelet</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>kube-proxy</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>docker</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
</tbody>
</table>
<h2 id="共同配置即master和node都需要进行的操作"><a class="markdownIt-Anchor" href="#共同配置即master和node都需要进行的操作"></a> 共同配置（即master和node都需要进行的操作）</h2>
<p>(1)修改/etc/hosts文件，添加master和node节点IP</p>
<pre class="highlight"><code class="">$ echo &quot;10.0.0.100 centos-master
  10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts
$ cat /etc/hosts
  10.0.0.100 centos-master
  10.0.0.101 centos-minion
</code></pre>
<p>(2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services</p>
<pre class="highlight"><code class=""># 关闭fierwalld
$ systemctl stop firewalld
$ systemctl disable firewalld

# 安装iptables，启动该服务并设置开机自启动
$ yum install iptables
$ systemctl start iptables
$ systemctl enable iptables

# 关闭iptables-services
$ systemctl disable iptables-services 
$ systemctl stop iptables-services 

# 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot;
# 解决方法：修改SElinux配置
$ vi /etc/selinux/config
  # SELINUX=enforcing    #注释掉
  # SELINUXTYPE=targeted #注释掉
    SELINUX=disabled #增加
  :wq! #保存退出
$ setenforce 0 #使配置立即生效
</code></pre>
<p>(3)安装</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Hub Mysql官方镜像实现首次启动后初始化库表]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker%20Hub%20mysql%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%AE%9E%E7%8E%B0%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%93%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>在Docker Hub中查看MySQL官方镜像的Dockerfile:</p>
<pre class="highlight"><code class="">
COPY docker-entrypoint.sh /usr/local/bin/

RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat

ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]
</code></pre>
<p>镜像启动时，会运行<code>entrypoint.sh</code>脚本，该脚本的shell命令中:</p>
<pre class="highlight"><code class="">echo
    for f in /docker-entrypoint-initdb.d/*; do
		case &quot;$f&quot; in
			*.sh)     echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;;
			*.sql)    echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;;
			*.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;;
			*)        echo &quot;$0: ignoring $f&quot; ;;
		esac
		echo
done
</code></pre>
<p>上述shell命令会遍历<code>/docker-entrypoint-initdb.d/</code>文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。</p>
<h2 id="实现首次启动后初始化库表"><a class="markdownIt-Anchor" href="#实现首次启动后初始化库表"></a> 实现首次启动后初始化库表</h2>
<h3 id="创建mysql_data文件夹将datasql放入"><a class="markdownIt-Anchor" href="#创建mysql_data文件夹将datasql放入"></a> 创建mysql_data文件夹，将data.sql放入：</h3>
<pre class="highlight"><code class="data.sql">-- 创建数据库 
DROP database IF EXISTS `docker_database`;
create database `docker_database` default character set utf8 collate utf8_general_ci; 
-- 切换到test_data数据库
use docker_database; 
-- 建表 
DROP TABLE IF EXISTS `person`; 

CREATE TABLE `person` ( 
	`id` bigint(20) NOT NULL, 
	`name` varchar(255) DEFAULT NULL, 
	`age` bigint(20) NOT NULL,
	PRIMARY KEY (`id`) 
) ENGINE=InnoDB DEFAULT CHARSET=latin1; 
-- 插入数据 
INSERT INTO `user` (`id`,`name`,`age` ) 
VALUES 
   (0,'Tom',18);
</code></pre>
<h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3>
<pre><code>$ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456  mysql 
</code></pre>
<h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3>
<pre><code>$ docker exec -it sql /bin/bash
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u root -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);
Query OK, 1 row affected (0.06 sec)
mysql&gt; select * from person;                                
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
|  1 | Jane |   17 |
+----+------+------+
2 rows in set (0.00 sec)
</code></pre>
<p>重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。</p>
<h2 id="指定sql文件运行顺序"><a class="markdownIt-Anchor" href="#指定sql文件运行顺序"></a> 指定sql文件运行顺序</h2>
<p><code>entrypoint.sh</code>脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法：</p>
<ol>
<li>将文件按照预期顺序，进行命名，比如1_xx,2_xx;</li>
<li>将必须有前后顺序的sql文件合并在一个sql文件中;</li>
<li>将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。<br>
假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh</li>
</ol>
<pre class="highlight"><code class="data.sh">#!/bin/bash
mysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOF
source /usr/local/work/database.sql;
source /usr/local/work/table.sql;
source /usr/local/work/data.sql; 
</code></pre>
<p>启动容器：</p>
<pre><code>$ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql
</code></pre>
<p>数据结果应与上述一致。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker实现mysql容器启动后自动建库]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker%E5%AE%9E%E7%8E%B0mysql%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BB%BA%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>通过Dockerfile创建一个mysql镜像,该镜像具有如下功能：</p>
<blockquote>
<p>mysql容器启动时，会自动执行指定的sql文件;<br>
每次启动该容器，数据都进行初始化，删除所有的修改。</p>
</blockquote>
<h2 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h2>
<h3 id="创建dockerfile"><a class="markdownIt-Anchor" href="#创建dockerfile"></a> 创建Dockerfile</h3>
<pre><code>$ vim Dockerfile
</code></pre>
<pre class="highlight"><code class=""># 指定基础镜像，选用docker官方最新mysql镜像
FROM docker.io/mysql:latest

# 环境变量设置，设置mysql登陆时不需密码
ENV MYSQL_ALLOW_EMPTY_PASSWORD yes

# 复制文件到容器中，要复制的文件有：启动脚本和sql文件
COPY setup.sh /mysql/setup.sh
COPY data.sql /mysql/data.sql
COPY privileges.sql /mysql/privileges.sql

# 容器启动命令启动脚本
CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;]
</code></pre>
<h3 id="创建privilegessql用于修改mysql权限"><a class="markdownIt-Anchor" href="#创建privilegessql用于修改mysql权限"></a> 创建privileges.sql用于修改mysql权限</h3>
<pre><code>$vim privileges.sql
</code></pre>
<pre class="highlight"><code class="">use mysql; 

select host, user from user; 

-- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456：
-- 如果用户docker不存在，则创建用户docker
grant all on docker_database.* to docker@'%' identified by '123456' with grant option; 

-- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： 
flush privileges;
</code></pre>
<h3 id="创建datasql导入数据"><a class="markdownIt-Anchor" href="#创建datasql导入数据"></a> 创建data.sql导入数据</h3>
<pre><code>$ vim data.sql
</code></pre>
<pre class="highlight"><code class="">-- 创建数据库 
DROP database IF EXISTS `docker_database`;
create database `docker_database` default character set utf8 collate utf8_general_ci; 
-- 切换到test_data数据库
use docker_database; 
-- 建表 
DROP TABLE IF EXISTS `person`; 

CREATE TABLE `person` ( 
	`id` bigint(20) NOT NULL, 
	`name` varchar(255) DEFAULT NULL, 
	`age` bigint(20) NOT NULL,
	PRIMARY KEY (`id`) 
) ENGINE=InnoDB DEFAULT CHARSET=latin1; 
-- 插入数据 
INSERT INTO `user` (`id`,`name`,`age` ) 
VALUES 
   (0,'Tom',18);
</code></pre>
<h3 id="创建容器启动脚本setupsh"><a class="markdownIt-Anchor" href="#创建容器启动脚本setupsh"></a> 创建容器启动脚本<code>setup.sh</code></h3>
<pre><code>$ vim setup.sh
</code></pre>
<pre class="highlight"><code class=""># !/bin/bash 
set -e 

# 查看mysql服务的状态，方便调试
echo `service mysql status` 

echo '1.启动mysql' 
# 启动mysql 
service mysql start 
# 使进程休眠
sleep 3 
echo `service mysql status` 

echo '2.开始导入数据' 
#导入sql文件
mysql &lt; /mysql/data.sql 
echo '3.导入数据完毕....' 

sleep 3 
echo `service mysql status` 

# 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 
echo '4.开始修改密码....' 
# 导入修改mysql权限设置的文件
mysql &lt; /mysql/privileges.sql 
echo '5.修改密码完毕....' 

#sleep 3 
echo `service mysql status` 
echo 'mysql容器启动完毕,且数据导入成功' 
</code></pre>
<h3 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h3>
<p>创建镜像并命名为mysql:9.29</p>
<pre><code>$ docker build -t mysql:9.29 .
</code></pre>
<h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2>
<h3 id="启动mysql929镜像生成容器"><a class="markdownIt-Anchor" href="#启动mysql929镜像生成容器"></a> 启动mysql:9.29镜像，生成容器</h3>
<pre><code>$ docker run --name sql -d -p 23306:3306 mysql:9.29
6da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41
</code></pre>
<h3 id="查看容器日志"><a class="markdownIt-Anchor" href="#查看容器日志"></a> 查看容器日志</h3>
<pre><code>$ docker log sql
</code></pre>
<pre class="highlight"><code class="">1.启动mysql....
2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=45790
2017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903.
2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.
2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode.
..
MySQL Community Server 5.7.19 is started.
MySQL Community Server 5.7.19 is running.
2.开始导入数据....
3.导入数据完毕....
MySQL Community Server 5.7.19 is running.
4.开始修改密码....
host	user
localhost	mysql.session
localhost	mysql.sys
localhost	root
5.修改密码完毕....
MySQL Community Server 5.7.19 is running.
mysql容器启动完毕,且数据导入成功
</code></pre>
<p>容器启动过程与setup.sh中编写的步骤完全一致。</p>
<h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3>
<pre><code>$ docker exec -it sql /bin/bash 
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="验证重启mysql容器数据库初始化"><a class="markdownIt-Anchor" href="#验证重启mysql容器数据库初始化"></a> 验证重启mysql容器，数据库初始化</h3>
<p>插入数据</p>
<pre><code>mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);
Query OK, 1 row affected (0.06 sec)
</code></pre>
<pre class="highlight"><code class="">mysql&gt; select * from person;                                
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
|  1 | Jane |   17 |
+----+------+------+
2 rows in set (0.00 sec)
</code></pre>
<p>重新启动容器</p>
<pre><code>$ docker stop sql
$ docker start sql
$ docker exec -it sql /bin/bash 
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
</code></pre>
<p>重启容器后，数据初始化。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用TestNG进行单元测试]]></title>
      <url>/article/%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8TestNG%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="testng简介"><a class="markdownIt-Anchor" href="#testng简介"></a> TestNG简介</h2>
<p>TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。</p>
<h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2>
<table>
<thead>
<tr>
<th>Annotation</th>
<th style="text-align:right">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@BeforeSuite</code></td>
<td style="text-align:right">被注释的方法将在所有测试运行前运行</td>
</tr>
<tr>
<td><code>@AfterSuite</code></td>
<td style="text-align:right">被注释的方法将在所有测试运行后运行</td>
</tr>
<tr>
<td><code>@BeforeTest</code></td>
<td style="text-align:right">被注释的方法将在测试运行前运行</td>
</tr>
<tr>
<td><code>@AfterTest</code></td>
<td style="text-align:right">被注释的方法将在测试运行后运行</td>
</tr>
<tr>
<td><code>@BeforeGroups</code></td>
<td style="text-align:right">被注释的方法将在gourp中方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterGroups</code></td>
<td style="text-align:right">被注释的方法将在gourp中方法运行后运行</td>
</tr>
<tr>
<td><code>@BeforeClass</code></td>
<td style="text-align:right">被注释的方法将在当前类的第一个方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterClass</code></td>
<td style="text-align:right">被注释的方法将在当前类的所有方法运行后运行</td>
</tr>
<tr>
<td><code>@BeforeMethod</code></td>
<td style="text-align:right">被注释的方法将在每一个方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterMethod</code></td>
<td style="text-align:right">被注释的方法将在每一个方法运行后运行</td>
</tr>
<tr>
<td><code>@DataProvider</code></td>
<td style="text-align:right">被注释的方法用于为其他方法提供数据</td>
</tr>
<tr>
<td><code>@Factory</code></td>
<td style="text-align:right">被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[]</td>
</tr>
<tr>
<td><code>@Parameters</code></td>
<td style="text-align:right">传递参数给测试方法</td>
</tr>
</tbody>
</table>
<h3 id="使用testng进行单元测试"><a class="markdownIt-Anchor" href="#使用testng进行单元测试"></a> 使用TestNG进行单元测试</h3>
<pre class="highlight"><code class="">@Test()  // Test中所有方法变为测试方法
public class Test {

	@Test(enable = false)  // 该注释后，test1()测试时被忽略，相当于普通方法
	public void test1(){}
    
    @BeforeTest()          // 该注释后，test3(),test4()执行前，test2()先执行
	public void test2(){}

    @
	public void test3(){}

	public void test4(){}
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TestNG </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git使用(Linux)]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8(Linux)/</url>
      <content type="html"><![CDATA[<h2 id="环境安装"><a class="markdownIt-Anchor" href="#环境安装"></a> 环境安装</h2>
<p>安装git</p>
<pre class="highlight"><code class="">sudo apt-get install git
</code></pre>
<p>配置git用户名</p>
<pre class="highlight"><code class="">git config –global user.name &quot;user_name&quot;
</code></pre>
<p>配置用户邮箱地址</p>
<pre class="highlight"><code class="">git config –global user.email &quot;user_mail&quot;
</code></pre>
<h2 id="创建本地仓库"><a class="markdownIt-Anchor" href="#创建本地仓库"></a> 创建本地仓库</h2>
<p>创建空目录</p>
<pre class="highlight"><code class="">mkdir folder_name
</code></pre>
<p>进入空目录</p>
<pre class="highlight"><code class="">cd folder_name
</code></pre>
<p>显示当前目录</p>
<pre class="highlight"><code class="">pwd
</code></pre>
<p>把当前目录变为Git仓库</p>
<pre class="highlight"><code class="">git init
</code></pre>
<p>把文件添加到Git仓库</p>
<pre class="highlight"><code class="">git add file
</code></pre>
<p>把文件提交到Git仓库</p>
<pre class="highlight"><code class="">git commit -m &quot;commit_message&quot;
</code></pre>
<h2 id="版本库操作"><a class="markdownIt-Anchor" href="#版本库操作"></a> 版本库操作</h2>
<p>查看修改内容</p>
<pre class="highlight"><code class="">git diff file_name
</code></pre>
<p>查看工作区状态</p>
<pre class="highlight"><code class="">git status
</code></pre>
<p>查看历史记录</p>
<pre class="highlight"><code class="">git log
</code></pre>
<p>查看精简历史记录</p>
<pre class="highlight"><code class="">git log --pretty=oneline
</code></pre>
<p>回退到上一个版本</p>
<pre class="highlight"><code class="">git reset --hard HEAD^
</code></pre>
<p>回到某个指定版本</p>
<pre class="highlight"><code class="">git reset –-hard commit-id(git log查看)
</code></pre>
<p>查看命令记录</p>
<pre class="highlight"><code class="">git reflog
</code></pre>
<p>撤销全部工作区修改</p>
<pre class="highlight"><code class="">git checkout --file
</code></pre>
<p>将暂存区修改撤销放回工作区</p>
<pre class="highlight"><code class="">git reset HEAD 文件
</code></pre>
<p>linux删除文件</p>
<pre class="highlight"><code class="">rm file
</code></pre>
<p>git库删除文件</p>
<pre class="highlight"><code class="">git rm file
</code></pre>
<p>下载他人项目</p>
<pre class="highlight"><code class="">git clone https://github.com/xxx/xxx.git new_git_name
</code></pre>
<h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2>
<p>创建并切换到分支</p>
<pre class="highlight"><code class="">git checkout -b dev_name
</code></pre>
<p>查看当前分支</p>
<pre class="highlight"><code class="">git branch (*表示当前分支)
</code></pre>
<p>切换分支</p>
<pre class="highlight"><code class="">git checkout dev_name
</code></pre>
<p>合并指定分支到当前分支(fast forward 模式)</p>
<pre class="highlight"><code class="">git merge dev_name
</code></pre>
<p>删除分支</p>
<pre class="highlight"><code class="">git branch -d dev_name
</code></pre>
<p>合并分支时冲突,修改文件后,再提交<br>
查看分支合并图</p>
<pre class="highlight"><code class="">git log --graph --pretty=oneline --addrev-commit
</code></pre>
<p>合并分支（普通模式）</p>
<pre class="highlight"><code class="">git merge -- no-ff -m &quot;commit_message&quot; dev
</code></pre>
<h2 id="多人合作"><a class="markdownIt-Anchor" href="#多人合作"></a> 多人合作</h2>
<p>查看远程库信息</p>
<pre class="highlight"><code class="">git remote -v
</code></pre>
<p>推送主分支</p>
<pre class="highlight"><code class="">git push origin master
</code></pre>
<p>推送其他分支</p>
<pre class="highlight"><code class="">git push origin dev_name
</code></pre>
<p>创建本地分支</p>
<pre class="highlight"><code class="">git checkout -b dev_name origin/dev_name
</code></pre>
<p>指定本地分支与远程分支的链接</p>
<pre class="highlight"><code class="">git branch --set-upstream-to=origin/dev_name
</code></pre>
<p>获取远程库内容</p>
<pre class="highlight"><code class="">git pull  
</code></pre>
<p>解决冲突后commit，再上传</p>
<pre class="highlight"><code class="">git push origin dev_name
</code></pre>
<h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2>
<p>创建标签</p>
<pre class="highlight"><code class="">git tag tag_name
</code></pre>
<p>给指定提交打标签</p>
<pre class="highlight"><code class="">git tag tag_name commit-id
</code></pre>
<p>创建带说明的标签</p>
<pre class="highlight"><code class="">git tag -a tag_name -m &quot;message&quot; commit-id
</code></pre>
<p>查看标签说明</p>
<pre class="highlight"><code class="">git show tag_name
</code></pre>
<p>删除标签</p>
<pre class="highlight"><code class="">git tag -d tag_name
</code></pre>
<p>推送标签</p>
<pre class="highlight"><code class="">git push origin tag_name
</code></pre>
<p>一次性推送所有标签</p>
<pre class="highlight"><code class="">git push origin --tags
</code></pre>
<p>删除标签（本地）</p>
<pre class="highlight"><code class="">git tag -d tag_name
</code></pre>
<p>删除远程标签</p>
<pre class="highlight"><code class="">git push origin :refs/tags/tag_name
</code></pre>
<h2 id="自定义git"><a class="markdownIt-Anchor" href="#自定义git"></a> 自定义Git</h2>
<p>使git显示不同颜色</p>
<pre class="highlight"><code class="">git config --global color.ui true
</code></pre>
<p>忽略某些文件时，需要编写.gitignore	<br>
强制添加被忽略文件</p>
<pre class="highlight"><code class="">git add -f file
</code></pre>
<p>检查某个文件符合被忽略要求</p>
<pre class="highlight"><code class="">git check-ignore -v file
</code></pre>
<p>配置命令别名</p>
<pre class="highlight"><code class="">git config --global alias.别名 命令
</code></pre>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的安装说明]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h2 id="安装及部署docker"><a class="markdownIt-Anchor" href="#安装及部署docker"></a> 安装及部署Docker</h2>
<h3 id="系统和资源说明"><a class="markdownIt-Anchor" href="#系统和资源说明"></a> 系统和资源说明</h3>
<p>Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。<br>
资源需求：Docker1.12.6</p>
<h3 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h3>
<p>(1)安装</p>
<pre><code>$ yum install docker
</code></pre>
<p>(2)设置开机启动Docker Daemon进程</p>
<pre><code>$ systemctl start docker.service   // 启动docker
$ systemctl enable docker.service  // 设置Docker开机自启动
$ systemctl disable firewalld      // 关闭防火墙
$ yum -y install iptables-services // 安装iptable服务
$ systemctl start iptables.service   // 启动iptable
$ systemctl enable iptables.service  // 设置iptable开机自启动
</code></pre>
<p>(3)安装成功的Docker</p>
<pre><code>$ docker version
</code></pre>
<img src="/article/容器/Docker的安装说明/success.png" alt="Docker安装成功">  
<p>(4)建立docker用户组，将使用docker的用户加入docker用户组。</p>
<pre><code>$ groupadd docker
$ usermod -aG docker $USER
</code></pre>
<h3 id="docker的代理配置"><a class="markdownIt-Anchor" href="#docker的代理配置"></a> Docker的代理配置</h3>
<pre><code>$ vim /usr/lib/systemd/system/docker.service
[Service]
Environment=”HTTP_PROXY=http://192.168.13.19:7777”
Environment=”HTTPS_PROXY=http://192.168.13.19:7777”
Type=notify
</code></pre>
<h3 id="docker配置加速器"><a class="markdownIt-Anchor" href="#docker配置加速器"></a> Docker配置加速器</h3>
<p>国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了<a href="https://cr.console.aliyun.com">阿里云加速器</a> 注册用户并且申请加速器后，会获得　<a href="https://xxx.mirror.aliyuncs.com">https://xxx.mirror.aliyuncs.com</a> 这样的地址。<br>
<img src="/article/容器/Docker的安装说明/dockerhub.png" alt="Docker加速器"></p>
<pre><code>$ vim /usr/lib/systemd/system/docker.service
  ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com
$ systemctl daemon-reload  //　重新加载配置
$ systemctl restart docker //　重启docker
</code></pre>
<h3 id="docker配置文件说明"><a class="markdownIt-Anchor" href="#docker配置文件说明"></a> Docker配置文件说明</h3>
<pre><code>$ vim /etc/sysconfig/docker
OPTIONS='
 --selinux-enabled  //　是否开启selinux，默认开启
 --insecure registry ip:port // 添加私人仓库地址
 --bip=ip // 表示网桥docker0的CIDR地址
'
</code></pre>
<h2 id="docker的常用命令"><a class="markdownIt-Anchor" href="#docker的常用命令"></a> Docker的常用命令</h2>
<h3 id="docker信息查看"><a class="markdownIt-Anchor" href="#docker信息查看"></a> Docker信息查看</h3>
<p>(1)查看docker进程状态</p>
<pre><code>$ systemctl status docker
</code></pre>
<p>(2)查看docker的具体信息</p>
<pre><code>$ docker info
</code></pre>
<p>(3)查看docker的版本信息</p>
<pre><code>$ docker version
</code></pre>
<h3 id="docker的镜像操作"><a class="markdownIt-Anchor" href="#docker的镜像操作"></a> Docker的镜像操作</h3>
<p>(1)查找镜像</p>
<pre><code>$ docker search image_name
</code></pre>
<p>(2)拉取镜像</p>
<pre><code>$ docker pull image_name:tag
</code></pre>
<p>(3)列出本地镜像</p>
<pre><code>$ docker images
</code></pre>
<p>列表参数说明</p>
<blockquote>
<p>Repository：镜像的仓库源<br>
Tag：镜像的标签<br>
Image ID： 镜像ID<br>
Created： 镜像的创建时间<br>
Size： 镜像大小</p>
</blockquote>
<p>(4)设置镜像标签</p>
<pre><code>$ docker tag image_id tag
</code></pre>
<p>(5)利用镜像创建容器</p>
<pre><code>$ docker run image_name:tag command
</code></pre>
<p>(6)提交镜像</p>
<pre><code>$ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name
</code></pre>
<h3 id="docker的容器操作"><a class="markdownIt-Anchor" href="#docker的容器操作"></a> Docker的容器操作</h3>
<p>(1)启动容器</p>
<pre><code>$ docker run option host_port:contaniner_port image_name:tag command
</code></pre>
<blockquote>
<p>例如：docker run -it -d -p 5000:5000 java java -version<br>
-d：后台运行容器<br>
-p:将容器端口映射到宿主机端口<br>
-it:进行交互式操作<br>
command: 执行java -version命令</p>
</blockquote>
<p>(2)查看容器</p>
<pre><code>$ docker ps // 查看正在运行的容器
</code></pre>
<p>(3)容器生命周期命令</p>
<pre><code>$ docker create image:tag  // 创建容器但不启动
$ docker start container_name   // 启动容器
$ docker stop contaniner_name   // 停止容器
$ docker restart container_name // 重启容器
$ docker pause contaniner_name  // 暂停容器内所有进程
$ docker unpause contaniner_name // 恢复容器内所有进程
$ docker rm contaniner  // 删除容器
$ docker rm ${docker ps -a -q} // 删除所有停止的容器</code></pre>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的简单说明]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h2 id="docker简介"><a class="markdownIt-Anchor" href="#docker简介"></a> Docker简介</h2>
<h3 id="docker的概念"><a class="markdownIt-Anchor" href="#docker的概念"></a> Docker的概念</h3>
<p><code>Docker</code>最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。<code>Docker</code>被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将<code>应用软件及其依赖软件</code>（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。</p>
<h3 id="dcoker的技术依赖"><a class="markdownIt-Anchor" href="#dcoker的技术依赖"></a> Dcoker的技术依赖</h3>
<p>Docker使用<code>Go</code>语言进行开发实现，基于Linux内核的<code>cgroup</code>、<code>namespace</code>以及AUFS类的<code>UnionFS</code>等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于<code>LXC</code>、0.7后去除LXC，使用自行开发的<code>libcontainer</code>。从1.11开始，则使用<code>runC</code>和<code>containerd</code>。</p>
<blockquote>
<p>（1）<code>cgroup</code>是将任意进程进行分组化管理的Linux内核功能。重要概念是<code>子系统</code>，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。<br>
（2）<code>LXC</code>（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于<code>namespace</code>的隔离机制和<code>cgroup</code>限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。<br>
（3）<code>AUFS</code>是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。<br>
（4）<code>App打包</code>：Docker额外提供的Feature,标准统一的打包部署运行方案。</p>
</blockquote>
<h3 id="docker的优势"><a class="markdownIt-Anchor" href="#docker的优势"></a> Docker的优势</h3>
<p>Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：<code>传统虚拟机技术</code>是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而<code>容器</code>内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。</p>
<blockquote>
<p><strong>（1）更高效的利用系统资源</strong><br>
由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。<br>
<strong>（2）更快速的启动</strong><br>
Docker容器应用由于<code>直接运行于宿主内核</code>，无需启动完整的操作系统，因此可以做到<code>秒级</code>，甚至<code>毫秒级</code>的启动，大大节约了开发、测试、部署的时间。<br>
<strong>（3）一致的运行环境</strong><br>
Docker镜像提供了<code>除内核外完整的运行时环境</code>，确保了应用运行环境的一致性。<br>
<strong>（4）持续交付和部署</strong><br>
Docker可以通过<code>定制应用镜像</code>实现持续集成、持续交付、部署。开发人员可以通过<code>Dockerfile</code>来创建镜像，并结合<code>持续集成（Continuous integration）系统</code>进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合<code>持续部署（Continuous Delivery/Deployment）系统</code>进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。<br>
<strong>（5）更轻松的迁移</strong><br>
由于Docker确保了运行环境的一致性，使得应用迁移更加容易。<br>
<strong>（6）更轻松的维护和扩展</strong><br>
Docker使用的<code>分层存储以及镜像技术</code>，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易.</p>
</blockquote>
<h2 id="docker相关的基础概念"><a class="markdownIt-Anchor" href="#docker相关的基础概念"></a> Docker相关的基础概念</h2>
<h3 id="docker-image"><a class="markdownIt-Anchor" href="#docker-image"></a> Docker Image</h3>
<p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。<code>Docker镜像（Image）</code>就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的<code>程序、库、资源、配置等文件</code>外，还包含一些为运行时准备的<code>配置参数</code>（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。</p>
<h3 id="分层存储"><a class="markdownIt-Anchor" href="#分层存储"></a> 分层存储</h3>
<blockquote>
<p>因为传统镜像包含操作系统<code>完整的root文件系统</code>，其体积往往庞大。因此在Docker设计时，就充分利用<code>Union FS</code>技术，将其设计为<code>分层存储</code>的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。</p>
</blockquote>
<p>镜像构建时，会<code>一层层构建</code>，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，<code>任何额外的东西应在该层构建结束前清理结束</code>。<br>
分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。</p>
<h3 id="docker-container"><a class="markdownIt-Anchor" href="#docker-container"></a> Docker Container</h3>
<p><code>镜像（Image）</code>是静态定义，<code>容器（Container）</code>是镜像运行时的实体。容器可以被创建、启动、停止等。<br>
容器的实质是<code>进程</code>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。<br>
容器也是<code>分层存储</code>的，每个容器运行时<code>以镜像为基础层</code>，在其上创建一个当前容器的<code>存储层</code>，我们可以称这个为容器运行时读写而准备的存储层为<code>容器存储层</code>。<br>
容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。</p>
<blockquote>
<p>按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。</p>
</blockquote>
<h3 id="docker-registry"><a class="markdownIt-Anchor" href="#docker-registry"></a> Docker Registry</h3>
<p>镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即<code>Docker Registry</code>。<br>
一个<code>Docker Registry</code>包含多个<code>仓库（Repository）</code>；每个仓库包含多个标签<code>Tag</code>；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>来获取指定版本的镜像，如果不给出标签，就将以<code>latest</code>为默认标签。<br>
<code>Docker Registry公开服务</code>是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的<code>Docker Hub</code>。<br>
除了公开服务外，用户还可以在本地搭建<code>私有的Docker Registry</code>。Docker官方提供<code>Docker Registry</code>镜像，可以直接使用作为私有Registry服务。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(二)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<blockquote>
<p>常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。</p>
</blockquote>
<h3 id="基本运算符"><a class="markdownIt-Anchor" href="#基本运算符"></a> 基本运算符</h3>
<ol>
<li><code>=</code>为赋值运算符。</li>
<li>四则运算符基本组成：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。<strong>不要使用运算符编写过于复杂的计算。</strong></li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        double numB = 20;
        int numC = 3;
        System.out.println(&quot;加法计算：&quot; + (numA + numB));
        System.out.println(&quot;减法计算：&quot; + (numA - numB));
        System.out.println(&quot;乘法计算：&quot; + (numA * numB));
        System.out.println(&quot;除法计算：&quot; + (numA / numB));
        System.out.println(&quot;求模计算：&quot; + (numA % numC));
    }
}
</code></pre>
<ol start="3">
<li>简化运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>:</li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        numA += 2; // 等同于 numA = numA + 2
        System.out.println(&quot;加法计算&quot; + (numA)); // 12
    }
}
</code></pre>
<ol start="4">
<li><code>++</code>（自增），<code>--</code>（自减）：位置不同，功能也不同：<br>
·<code>++变量</code>，<code>--变量</code>：先对变量加/减1，再使用自增或自减后的变量进行计算;<br>
·<code>变量++</code>，<code>变量--</code>：先使用变量进行计算，再进行变量加/减1。</li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        int numB = 20;
        // ++变量，先numA + 1
        // 然后(numA + 1) + numB内容
        // 最后对numB加1
        int result = (++numA) + (numB++);
        System.out.println(&quot;numA=&quot; + numA); // 11
        System.out.println(&quot;numB=&quot; + numB); // 21
        System.out.println(&quot;result=&quot; + result); // 31
    }
}
</code></pre>
<h3 id="三目运算符"><a class="markdownIt-Anchor" href="#三目运算符"></a> 三目运算符</h3>
<p>三目运算符根据布尔表达式的结果进行赋值：</p>
<pre><code>value_type value_name = 布尔表达式 ? true_value : false_value;
</code></pre>
<p>利用三目运算符可以减少判断代码:</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        int numB = 20;
        int max = 0;
        /** 使用三目运算符
         *  当numA大于numB,返回true,max = numA
         *  当numA小于numB,返回false,max = numB
         */
        max = numA&gt;numB ? numA : numB;
        // 不使用三目运算符
        // if (numA &gt; numB) {
        //    max = numA;
        //} else {
        //    max = numB;
        //}
        System.out.println(max);
    }
}
</code></pre>
<h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3>
<ol>
<li>逻辑运算符：与<code>&amp;，&amp;&amp;</code>、或<code>|，||</code>、非<code>!</code></li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        boolean flag = true;
        System.out.println(!flag); // false
    }
}
</code></pre>
<ol start="2">
<li>布尔表达式的连接，只能使用<code>与</code>和<code>或</code>操作</li>
</ol>
<blockquote>
<p><code>与</code>：所有条件都为true时，结果为true;有一个为false，结果就是false.</p>
</blockquote>
<p><strong>范例</strong>：普通与<code>&amp;</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 除数不能为0
        if ((1 == 2) &amp; (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // 报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>：程序报错，因为<code>&amp;</code>会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。<br>
<strong>范例</strong>：短路与<code>&amp;&amp;</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 除数不能为0
        if ((1 == 2) &amp;&amp; (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // false,不报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>:程序不报错，因为<code>&amp;&amp;</code>只要有一个条件为false后，后续判断就不再进行，从而提高了效率。</p>
<blockquote>
<p>或操作：一个条件为true，结果为true。</p>
</blockquote>
<p><strong>范例</strong>：普通或<code>|</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        if ((1 &lt; 2 ) | (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // 报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>：使用<code>|</code>，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。<br>
<strong>范例</strong>：短路或<code>||</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        if ((1 &lt; 2 ) || (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // true,不报错
        }
    }
}
</code></pre>
<blockquote>
<p>因此使用逻辑运算时就使用<code>&amp;&amp;</code>和<code>||</code>。</p>
</blockquote>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<ol>
<li>数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。</li>
<li>位运算主要是进行二进制数据操作，位运算符：<code>&amp;</code>、<code>|</code>、<code>&gt;&gt;</code>(移位)、<code>&lt;&lt;</code>、<code>^</code>(反码)、<code>~</code>。<br>
<strong>范例</strong>：位与<code>&amp;</code></li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 9;
        int numB = 11;
        System.out.println(numA &amp; numB); // 9
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>  1001 → 9
&amp; 1011 → 11
  1001 →  9
</code></pre>
<p><strong>范例</strong>：位或<code>|</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 9;
        int numB = 11;
        System.out.println(numA | numB); // 11
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>  1001 → 9
| 1011 → 11
  1011 → 11
</code></pre>
<p><strong>范例</strong>：移位（最快方式计算2的3次方）</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int num = 2;
        num = num &lt;&lt; 2; // 向左移位
        System.out.println(num); // 8,相当于2的3次方
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>    0010 → 2
2&lt;&lt; 1000 → 8
</code></pre>
<blockquote>
<p><strong>章节小问题：请解释<code>&amp;</code>与<code>&amp;&amp;</code>的区别，以及<code>|</code>与<code>||</code>的区别:</strong><br>
1. 在逻辑运算中：<br>
  |- <code>&amp;</code>和<code>|</code>会对所有条件进行判断后，返回结果<br>
  |- <code>&amp;&amp;</code>只要一个条件返回false，就不进行后续判断，结果为false<br>
  |- <code>||</code>只要一个条件为true，就不进行后续判断，结果为true<br>
2. 在位运算中：<br>
  |- <code>&amp;</code>为位与元算，<code>|</code>为位或元算<br>
  |- <code>&amp;&amp;</code>和<code>||</code>不能用于位运算</p>
</blockquote>
<h2 id="java程序逻辑控制"><a class="markdownIt-Anchor" href="#java程序逻辑控制"></a> Java程序逻辑控制</h2>
<p>程序逻辑结构主要分为三种：顺序结构、分支结构、循环结构。顺序结构执行顺序是从前到后，但有时是以代码所在的{}为界限。</p>
<h3 id="分支结构"><a class="markdownIt-Anchor" href="#分支结构"></a> 分支结构</h3>
<ol>
<li>分支结构即判断结构，有两种语法：if和switch.</li>
<li>if语句:<br>
if语句的格式:</li>
</ol>
<table>
<thead>
<tr>
<th>if</th>
<th style="text-align:center">if…else</th>
<th style="text-align:right">if…else if…else</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>范例</strong>：if判断</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        double score = 90.0;
        if (score &lt; 60.0) {
            System.out.println(&quot;不及格&quot;);
        } else if (score &lt; 90) {
            System.out.println(&quot;良&quot;);
        } else {
            System.out.println(&quot;优秀&quot;);
        }
    }
}
</code></pre>
<ol start="3">
<li>switch语句:<br>
switch判断<strong>不能使用布尔表达式</strong>，JDK1.5之前只能进行<code>整数或字符</code>判断，JDK1.5增加了<code>枚举</code>判断，JDK1.7增加了<code>String</code>判断，语法：</li>
</ol>
<pre class="highlight"><code class="">switch (数字/字符/枚举/字符串){
    case 内容 : 内容满足时执行的代码 ; break;
    case 内容 : 内容满足时执行的代码 ; break;
    ...
    default {
        内容都不满足case时执行;
        break;
    }
}
</code></pre>
<p><strong>范例</strong>：使用switch</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int num = 2;
        switch (num) {
            case 1:
                System.out.println(&quot;数字1&quot;);
                break;
            case 2:
                System.out.println(&quot;数字2&quot;);
                break;
            default:
                System.out.println(&quot;大于2的数字&quot;);
                break;
        }
    }
}
</code></pre>
<p>switch默认从第一个符合条件的case语句开始执行，直到整个switch执行完毕或遇到break关键字，才停止执行。<strong>程序区分大小写</strong>。</p>
<h3 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h3>
<ol>
<li>当某段代码需要重复执行时，可使用循环语句实现，循环有两种：for循环和while循环。</li>
<li>while循环：</li>
</ol>
<table>
<thead>
<tr>
<th>while循环</th>
<th style="text-align:right">do…while循环</th>
</tr>
</thead>
<tbody>
<tr>
<td>while（布尔语句）｛｝</td>
<td style="text-align:right">do｛｝while（布尔语句);</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：实现1到100的累加（<strong>while循环先判断再执行</strong>）：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
   public static void main(String[] args) {
       int sum = 0;
       int current = 1; // 循环的初始化条件
       while (current &lt;= 100) { // 循环结束条件
           sum += current; // 累加
           current++; // 修改循环的初始化条件
       }
       System.out.println(sum); // 5050
   }
}
</code></pre>
<p><strong>范例</strong>：实现1到100的累加（<strong>do…while循环是先执行再判断）</strong></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int sum = 0;
        int current = 1;
        do {
            sum += current;
            current++;
        } while (current &lt;= 100);
        System.out.println(sum);
    }
}
</code></pre>
<p>do…while循环先执行再判断，即不论循环条件是否满足，都至少执行一次，<strong>因此开发中不建议使用do…while。</strong></p>
<ol start="3">
<li>for循环：</li>
</ol>
<pre class="highlight"><code class="">for (循环初始化条件; 循环结束条件; 循环条件变更) {
    循环语句;
}
</code></pre>
<p>即使三个条件都不写，但是<strong>两个&quot;;&quot;必须保留。</strong><br>
<strong>范例</strong>：实现1~100的累加</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int sum = 0;
        for (int i = 0; i &lt;= 100; i++) {
            sum += i;
        }
        System.out.println(sum);
    }
}
</code></pre>
<ol start="4">
<li>开发原则:<br>
（1）循环次数未知，循环结束条件已知时使用<code>while</code>循环；<br>
（2）循环次数已知，使用<code>for</code>循环。</li>
<li>循环嵌套</li>
</ol>
<pre class="highlight"><code class="">public class 九九乘法表 {
    public static void main(String[] args) {
        for (int x = 1; x &lt;= 9; x++) {
            for (int y = 1; y &lt;= x; y++) {
                System.out.print(x + &quot;*&quot; + y + &quot;=&quot; + (x * y) + &quot;\t&quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h3>
<p>循环控制有两个语句：<code>continue</code>（退出本次循环）和<code>break</code>（结束整个循环）。该语句要和判断语句一起使用。<br>
<strong>范例</strong>：continue使用</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
   public static void main(String[] args) {
       for (int x = 0; x &lt; 5; x++) {
           if (x == 3) {
               continue; // 跳出本次循环，不进行后续的输出操作
           }
           System.out.print(x + &quot;,&quot;); // 0,1,2,4,
       }
   }
}
</code></pre>
<p><strong>范例</strong>：break</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        for (int x = 0; x &lt; 5; x++) {
            if (x == 3) {
                break; // 结束整体循环
            }
            System.out.print(x + &quot;,&quot;); // 0,1,2,
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。</p>
</blockquote>
<h2 id="markdown语法"><a class="markdownIt-Anchor" href="#markdown语法"></a> Markdown语法</h2>
<h3 id="区块元素"><a class="markdownIt-Anchor" href="#区块元素"></a> 区块元素</h3>
<h4 id="段落与换行"><a class="markdownIt-Anchor" href="#段落与换行"></a> 段落与换行</h4>
<p>一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是<strong>无法使用空格或制表符来缩进的</strong>，因为其默认一个空格就是一个空行。</p>
<h4 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h4>
<p>Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个<code>#</code>，对应1到6级标题。</p>
<pre><code># 这是H1
## 这是H2
...
###### 这是H6
</code></pre>
<h4 id="区块引用blockquotes"><a class="markdownIt-Anchor" href="#区块引用blockquotes"></a> 区块引用Blockquotes</h4>
<p>Markdown标记区块引用方式如下：</p>
<pre><code>&gt; 文本内容。
&gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt;
</code></pre>
<p>在引用的区域中，也可以使用其他的Markdown语法。</p>
<h4 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h4>
<p>Markdown支持有序列表和无序列表。无序列表使用<code>星号</code>、<code>减号</code>或<code>加号</code>作为列表标记:</p>
<pre><code>* red
- green
+ blue
</code></pre>
<p>有序列表则使用数字接着一个英文句号：</p>
<pre><code>1. red
2. green
3. blue
</code></pre>
<p>如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即：</p>
<pre class="highlight"><code class="">	* blue

	*red
</code></pre>
<p>会被转换为：</p>
<pre class="highlight"><code class="bash">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>如果要在列表项目中放入引用，就需要缩进</p>
<pre><code>* red
	&gt; this is color
</code></pre>
<p>如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。</p>
<h4 id="代码区域"><a class="markdownIt-Anchor" href="#代码区域"></a> 代码区域</h4>
<p>要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。</p>
<h4 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h4>
<p>你可以在一行使用三个以上的<code>星号</code>、<code>减号</code>、<code>下划线</code>来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。</p>
<pre><code>星号：  * * *
减号：  - - -
下划线：_ _ _ 
</code></pre>
<h3 id="区段元素"><a class="markdownIt-Anchor" href="#区段元素"></a> 区段元素</h3>
<h4 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h4>
<p>Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。</p>
<pre><code>[example](https://www.baidu.com &quot;Title&quot;)
</code></pre>
<h4 id="强调"><a class="markdownIt-Anchor" href="#强调"></a> 强调</h4>
<p>Markdown使用星号和下划线标记强调，被<code>*</code>或<code>_</code>包围的字词会被转为用<code>&lt;em&gt;</code>标签包围，而用两个<code>*</code>或<code>_</code>包起来，则变为<code>&lt;strong&gt;</code></p>
<pre><code>*强调*
_强调_
**强调**
__强调__
</code></pre>
<p>如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠：</p>
<pre><code>\*文字\*
</code></pre>
<h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4>
<p>如果要标记一小段行内代码，可以使用反引号把它包起来，例如：</p>
<pre><code>`printf()`
</code></pre>
<p>如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段:</p>
<pre><code>`` (`) `` 将变为  &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt;
</code></pre>
<h4 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h4>
<p>插入图片有两种方式：行内式和参考式</p>
<pre><code>![替代图片的文字](/path/to/img.jpg &quot;文字&quot;)
</code></pre>
<h2 id="结束"><a class="markdownIt-Anchor" href="#结束"></a> 结束</h2>
<p>感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot使用]]></title>
      <url>/article/%E6%A1%86%E6%9E%B6/SpringBoot%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go基础知识]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(一)]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="java基础知识"><a class="markdownIt-Anchor" href="#java基础知识"></a> Java基础知识</h2>
<blockquote>
<p>Java是一门<strong>面向对象</strong>语言，支持多线程编程;通过使用更为简单的<strong>引用</strong>来进行内存关系的匹配，而不是复杂的指针;Java提供<strong>垃圾自动回收机制</strong>，能更好地处理垃圾空间;可以实现多平台的移植。</p>
</blockquote>
<h3 id="第一个java程序"><a class="markdownIt-Anchor" href="#第一个java程序"></a> 第一个Java程序</h3>
<ol>
<li>运行Java程序的步骤<br>
<code>javac xx.java</code>:对Java程序进行编译，生成字节码文件<code>xx.class</code>。<br>
<code>java xx</code>：对Java程序进行解释。</li>
<li>Java程序的核心单元—<strong>类</strong><br>
类的声明方式有两种:<br>
<code>public class class_name {}</code>：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。<br>
<code>class class_name {}</code>：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。</li>
<li>第一个Java程序：Hello World</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;    		// 包名
public class HelloWorld {		// 类
	public static void main(String[] args) {    // 主方法
		System.out.println(&quot;Hello World&quot;);    // 方法体
	}
}
</code></pre>
<p>Java程序都是从<strong>主方法</strong>开始执行的.<code>System.out.println()</code>将内容输出后换行。</p>
<h3 id="classpath环境属性"><a class="markdownIt-Anchor" href="#classpath环境属性"></a> CLASSPATH环境属性</h3>
<p>PATH和CLASSPTH的<strong>区别</strong>：<code>PATH</code>是操作系统路径，定义了所有可执行程序的路径；<code>CLASSPATH</code>是Java解释类文件时的加载路径，当<code>java</code>命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。<br>
配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。</p>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p><code>// 注释内容</code>：    单行注释<br>
<code>/* 注释内容 */</code>： 多行注释<br>
<code>/** 注释内容 */</code>：文档注释</p>
<h3 id="标识符与关键字"><a class="markdownIt-Anchor" href="#标识符与关键字"></a> 标识符与关键字</h3>
<ol>
<li>标识符<br>
标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下：
<blockquote>
<p>（1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字；<br>
（2）标识符应尽量有意义，可见名知意。<br>
（3）Java标识符可以是中文，但不建议使用中文命名标识符。</p>
</blockquote>
</li>
<li>关键字<br>
Java中有两个未使用的关键字<code>goto</code>和<code>const</code>；JDK1.4之后增加了<code>assert</code>关键字；JDK1.5之后增加了<code>enum</code>关键字。</li>
</ol>
<h2 id="java数据类型"><a class="markdownIt-Anchor" href="#java数据类型"></a> Java数据类型</h2>
<ol>
<li>Java数据类型分为两大类：<code>基础数据类型</code>和<code>引用数据类型</code><br>
<strong>两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。</strong></li>
</ol>
<blockquote>
<p>基本数据类型：<br>
    |-数值型：<br>
        |-整型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>； →默认值：<code>0</code>；<br>
        |-浮点型：<code>float</code>、<code>double</code>；        →默认值：<code>0.0</code><br>
        |-字符型：<code>char</code>；                      →默认值：<code>‘\u0000’</code><br>
        |-布尔型：<code>boolean</code>；       			 →默认值：<code>false</code><br>
    |-引用数据类型：数组、类、接口等。 		 →默认值：<code>null</code></p>
</blockquote>
<ol start="2">
<li>数据类型的选择原则</li>
</ol>
<blockquote>
<p>（1）整数用<code>int</code>，小数用<code>double</code>；<br>
（2）描述日期时间或内存大小，用<code>long</code>；<br>
（3）实现内容传递或编码转换用<code>byte</code>；<br>
（4）逻辑控制用<code>boolean</code>；<br>
（5）避免中文乱码用<code>char</code>。</p>
</blockquote>
<h3 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h3>
<ol>
<li>数字常量属于<code>int</code>型数据，如数字30。<br>
常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 一个变量名在同一块代码中只允许声明一次
        // 变量赋值语法：value_type value_name = value ;
        int num = 10; 
        num = num * 2;
        System.out.println(num);
    }
}
</code></pre>
<ol start="2">
<li>每个数据类型都有其对应的存储范围</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int max = Integer.MAX_VALUE;  // int型数据的最大值
        int min = Integer.MIN_VALUE;  // int型数据的最小值
        System.out.println(max);      // 2147483647
        System.out.println(max + 1);  // -2147483648
        System.out.println(min);      // -2147483648
        System.out.println(min - 1);  // 2147483647
        System.out.println(min - 2);  // 2147483646
    }
}
</code></pre>
<p>当数据超过<code>int</code>型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为<code>数据溢出</code>，解决方法是<strong>扩大数据范围</strong>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int max = Integer.MAX_VALUE;
        int min = Integer.MIN_VALUE;
        // int变量 + long变量 = long变量,扩大了数据的范围
        System.out.println(max + 1L); // 2147483648
        System.out.println(min - (long)1); // -2147483649
        System.out.println((long)min - 2); // -2147483650
    }
}
</code></pre>
<ol start="3">
<li>数据类型的转换规律</li>
</ol>
<blockquote>
<p>范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型；<br>
范围大的数据类型只能通过强制转换变为范围小的数据类型。<br>
常量进行强制转换，可通过使用常量标记（如<code>L，l</code>可将<code>int</code>型常量变为<code>long</code>型）或使用<code>(数据类型)常量</code>。范例–强制转换：</p>
</blockquote>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 1000是int型，使用long型变量接收，发生自动转换
        long num = 1000;
	    // long型变为int型，强制转换
        int x = (int) num; 
        System.out.println(x); // 1000
    }
}
</code></pre>
<p>当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生<strong>数据溢出</strong>。</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 2147483650L是long型数据，超出int型的范围
        long num = 2147483650L ;
        int x = (int) num; 
        System.out.println(x); // -2147483646，数据溢出
    }
}
</code></pre>
<p><code>byte</code>型数据的取值范围为<code>-128~127</code>，当整数数值在这个范围内时，会自动转型；超出<code>byte</code>范围时会发生数据溢出。<br>
4. 注意点<br>
变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 未给变量赋值
		int num;  
		// 报错,未初始化变量,无法使用该变量
        System.out.println(num); 
    }
}
</code></pre>
<h3 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h3>
<ol>
<li>Java中浮点数属于<code>double</code>型（<code>double</code>型是保存范围最广的类型）。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        double num = 10.2; // 10.2是小数，属于double型
        // double型 * int型 = double型
        System.out.println(num * 2); // 20.4
    }
}
</code></pre>
<p>所以使用<code>float</code>数据须将<code>double强制转换为float型</code>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        float fA = 10.2F;         // 强制转型方式一
        float fB = (float) 10.2; // 强制转型方式二
        System.out.println(fA);  // 10.2
        System.out.println(fB);  // 10.2
        System.out.println(fA * fB); // 104.03999,该bug无法解决
    }
}
</code></pre>
<p>开发过程中要考虑到<code>整型数据不保留小数位</code>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        int y = 9;
        System.out.println(y / x); // 1
    }
}
</code></pre>
<p>因为<code>int型/int型=int型</code>，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        int y = 9;
        System.out.println(y / (double) x); // 1.8
    }
}
</code></pre>
<h3 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> 字符型</h3>
<ol>
<li>byte<br>
<code>byte</code>是字节，1字符=2字节。Java使用十六进制<code>UNICODE</code>编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。</li>
<li>字符使用单引号<code>'</code>声明，一对单引号只能保存一位字符。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = 'A';
        int num = c; // char型可以自动转换为int型
        System.out.println(c);
        System.out.println(num); // 65,是A的ASCII码值
    }
}
</code></pre>
<ol start="3">
<li>编码：<code>'A'</code>(65)~<code>'Z'</code>(90); <code>'a'</code>（97）~<code>'z'</code>（122）; <code>'0'</code>（48）~<code>'9'</code>(57),可利用A和a的编码差为32，实现字母大小写转换：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = 'A';
        int num = c;     // char型变为int型才能进行四则运算
        num = num + 32;  // 大写与小写编码值差为32
        c = (char) num;  // int型只能强制转换为char型
        System.out.println(c); // a
    }
}
</code></pre>
<ol start="4">
<li>传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = '游';
        int num = c;
        System.out.println(num); // 28216
    }
}
</code></pre>
<p>由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。</p>
<h3 id="布尔型"><a class="markdownIt-Anchor" href="#布尔型"></a> 布尔型</h3>
<p>布尔型返回逻辑结果，只保存两种数据：<code>true</code>和<code>false</code>，主要用于逻辑控制：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        boolean flag = false;
        //  if (布尔值){满足条件时的操作}
        if (!flag) {
            System.out.println(&quot;Hello World !&quot;);
        }
    }
}
</code></pre>
<h3 id="string型"><a class="markdownIt-Anchor" href="#string型"></a> String型</h3>
<ol>
<li>String型<br>
<code>String</code>属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号<code>&quot;&quot;</code>声明。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World !&quot;; // str为字符串变量
        System.out.println(str);
        // &quot;Hello World !&quot;为字符串常量
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<ol start="2">
<li><code>+</code>可实现字符串连接</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        str = str + &quot; World !&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>当四则运算与字符串连接同时存在时：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 100;
        double numB = 99.9;
        String str = &quot;加法计算：&quot; + numA + numB;
        System.out.println(str); // 加法计算：10099.9
    }
}
</code></pre>
<p>出现上述结果是因为小范围数据会自动转型为大范围数据，即<code>String型+任意数据类型=String型</code>，然后进行字符串连接，可使用()来实现正确的运算：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 100;
        double numB = 99.9;
        String str = &quot;加法计算：&quot; + (numA + numB);
        System.out.println(str); // 加法计算：199.9
    }
}
</code></pre>
<ol start="3">
<li>Java支持转义字符，<br>
例如：换行<code>\n</code>、制表符<code>\t</code>、反斜杠<code>\\</code>、双引号<code>\&quot;</code>、单引号<code>\'</code>：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello \&quot;World\&quot; \nHello MLDN&quot;;
        System.out.println(str);
        /**
         * Hello &quot;World&quot;
         * Hello MLDN
         */
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gitee+Hexo搭建个人博客]]></title>
      <url>/article/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Gitee+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><a href="https://gitee.com">Gitee</a>: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。<br>
Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。</p>
<h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2>
<h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装Node.js</h3>
<p>Windows用户访问<a href="https://nodejs.org/en">Node.js</a>下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。</p>
<pre><code>$ npm config set registry http://registry.npm.taobao.org/
</code></pre>
<h3 id="hexo安装"><a class="markdownIt-Anchor" href="#hexo安装"></a> Hexo安装</h3>
<pre><code>$ npm install -g hexo-cli
</code></pre>
<p>Hexo的基本使用请查看hello-world文中所写。</p>
<h3 id="本地运行hexo"><a class="markdownIt-Anchor" href="#本地运行hexo"></a> 本地运行Hexo</h3>
<p>在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件：</p>
<pre><code>$ hexo init
</code></pre>
<p>初始化后，文件夹的目录如下：</p>
<pre><code>.
├── .deploy       #需要部署的文件
├── node_modules  #Hexo插件
├── public        #生成的静态网页文件
├── scaffolds     #模板
├── source        #博客正文和其他源文件等都应该放在这里
|   ├── _drafts   #草稿
|   └── _posts    #文章
├── themes        #主题
├── _config.yml   #全局配置文件
└── package.json
</code></pre>
<p>之后在本地执行如下命令后，即可访问 <a href="http://localhost:4000">http://localhost:4000</a> 访问Hexo页面</p>
<pre><code>$ hexo s
</code></pre>
<h3 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> Git安装</h3>
<p><a href="https://git-scm.com/downloads">Git安装包地址</a>,根据操作系统选择安装包下载后安装即可。</p>
<h3 id="注册码云账号并创建一个项目"><a class="markdownIt-Anchor" href="#注册码云账号并创建一个项目"></a> 注册码云账号，并创建一个项目</h3>
<p><img src="/article/博客搭建/Gitee+Hexo搭建个人博客/new project.png" alt="创建新项目"><br><br>
<img src="/article/博客搭建/Gitee+Hexo搭建个人博客/new project2.png" alt="创建新项目"><br></p>
<h3 id="获取项目地址"><a class="markdownIt-Anchor" href="#获取项目地址"></a> 获取项目地址</h3>
<p><img src="/article/博客搭建/Gitee+Hexo搭建个人博客/get.png" alt="获取项目地址"><br></p>
<h2 id="发布博客"><a class="markdownIt-Anchor" href="#发布博客"></a> 发布博客</h2>
<h3 id="修改hexo配置文件_configyml"><a class="markdownIt-Anchor" href="#修改hexo配置文件_configyml"></a> 修改Hexo配置文件_config.yml</h3>
<pre><code>deploy:
	type: git
	repo: 码云的项目地址
	branch: master
</code></pre>
<h3 id="部署博客"><a class="markdownIt-Anchor" href="#部署博客"></a> 部署博客</h3>
<pre><code>$ npm install hexo-deployer-git --save 
$ hexo g --d  #一键部署
</code></pre>
<p>此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。</p>
<h3 id="开启page功能"><a class="markdownIt-Anchor" href="#开启page功能"></a> 开启Page功能</h3>
<p><img src="/article/博客搭建/Gitee+Hexo搭建个人博客/open.png" alt="开启Page功能"><br><br>
<img src="/article/博客搭建/Gitee+Hexo搭建个人博客/start.png" alt="开启Page功能"><br><br>
<img src="/article/博客搭建/Gitee+Hexo搭建个人博客/success.png" alt="博客部署成功"></p>
<h3 id="访问博客"><a class="markdownIt-Anchor" href="#访问博客"></a> 访问博客</h3>
<p>在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下：<br>
<img src="/article/博客搭建/Gitee+Hexo搭建个人博客/blog.png" alt="我的博客"></p>
<h2 id="博客使用"><a class="markdownIt-Anchor" href="#博客使用"></a> 博客使用</h2>
<p>在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为<code>file_name.md</code><br>
<code>file_name.md</code>的文件开头如下:</p>
<pre class="highlight"><code class="">---
title: file_name
tag: 标签名
categories: 分类
comment: 是否允许评论(true or false)
description: 描述
---
文档正文编写，请参照markdown语法。
</code></pre>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>如果搭建过程中，还有什么问题，请在下方留言。谢谢您的阅读！</p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/article/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<pre class="highlight"><code class="bash">$ hexo new <span class="string">"My New Post"</span>
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<pre class="highlight"><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<pre class="highlight"><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<pre class="highlight"><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[About]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>一个被现实从网络架构逼到了编程开发的小菜鸟x.x</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
