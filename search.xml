<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[并发]]></title>
      <url>/article/Go/Go%20Base/%E5%B9%B6%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>通常程序都是顺序执行且代码只是为了完成独立的一个任务，因为这样的代码易写易维护。但某些情况下，并行执行多个任务更有好处，比如Web服务需要在各自的套接字（socket）上同时接收多少数据请求。每个套接字请求都是独立的，可以独立其他套接字进行处理，此时并行执行多个请求可以显著提高服务。Go语言的语法和运行时内置了对并发的支持。</p>
<p>Go中的并发指的是能让某个函数独立于其他函数运行。当一个函数创建为<code>goroutime</code>时，Go会将其视为一个独立的工作单元，这个单元会被调度到可用的逻辑处理器上运行。Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有	<code>goroutime</code>并为其分配执行时间。这个调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行<code>goroutime</code>。调度器在任何给定的时间，都会全面控制某个<code>goroutime</code>要在某个逻辑处理器上运行。</p>
<p>Go语言的并发同步模型来自一个叫做通信顺序进程<code>Communicating Sequential Processes, CSP</code>的范型<code>paradigm</code>。CSP是一种消息传递模型，通过在<code>goroutime</code>间传递数据来传递消息，而不是对数据进行加锁从而实现同步。用于在<code>goroutime</code>之间同步和传递数据的关键数据类型叫作通道<code>channel</code>。</p>
<h2 id="并发与并行"><a class="markdownIt-Anchor" href="#并发与并行"></a> 并发与并行</h2>
<p>什么是操作系统的线程（thread）和进程（process）。当运行一个应用程序时，操作系统会为其启动一个进程。可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。</p>
<p>进程中的资源包括但不限于内存地址空间、文件和设备的句柄以及线程。一个线程是一个执行空间，这个空间会被操作系统调度用来运行函数中所写的代码。每个进程至少包含一个线程，每个进程的初始线程被称为<code>主线程</code>。因为执行这个线程的空间是应用程本身的空间，所以当主线程终止时，应用程序也会终止。操作系统会将线程调度到某个处理器上运行，但这个处理器不一定是进程所在的处理器。</p>
<p>操作系统会在物理处理器上调度线程来运行，而Go的运行时会在逻辑处理器上调度<code>goroutime</code>来运行。Go1.5之前，默认给整个应用程序只分配一个逻辑处理器；1.5之后运行时会默认为每个可用的物理处理器分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的<code>goroutime</code>，即便只有一个逻辑处理器，Go依然可以并发调度无数个<code>goroutime</code>。</p>
<p>如果创建一个<code>goroutime</code>并准备运行，这个<code>goroutime</code>就会被放到调度器的全局队列中，之后调度器就会将队列中的<code>goroutime</code>分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中，本地运行队列中的<code>goroutime</code>会一直等待直到自己被分配逻辑处理器执行。</p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组、切片和映射]]></title>
      <url>/article/Go/Go%20Base/%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="数组-切片和映射"><a class="markdownIt-Anchor" href="#数组-切片和映射"></a> 数组、切片和映射</h2>
<h3 id="数组的内部实现和基本功能"><a class="markdownIt-Anchor" href="#数组的内部实现和基本功能"></a> 数组的内部实现和基本功能</h3>
<p>数组是切片和映射的基础数据结构。</p>
<h4 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现</h4>
<p>在Go中，数组是一个长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。存储的数据类型可以是内置的，如整型，也可以是某种结构类型。数组的每个元素都紧邻着下一个元素，可以通过索引来访问。</p>
<p>数据占用的内存是连续分配的，因此CPU能把正在使用的数据缓存更久的时间，同时内存连续很容易计算索引，可以快速迭代数组里的所有元素。数组的元素类型相同，且连续分配，就可以以固定速度索引数组中的任意数据，速度非常快。</p>
<h4 id="声明和初始化"><a class="markdownIt-Anchor" href="#声明和初始化"></a> 声明和初始化</h4>
<p>声明数组时需要指定内部存储的数据类型以及长度。一旦声明，数据里存储的数据类型和长度就不能改变。如果要存储更多元素，就需要创建一个更长的数组，将源数组的值复制过去。数组初始化时，会将每个元素初始化为对应类型的零值。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	<span class="comment">// 声明一个长度为5的数组</span>
	<span class="keyword">var</span> array1 [<span class="number">5</span>]<span class="keyword">int</span>
	<span class="comment">// 声明一个长度为5的数组并用具体值初始化每个元素</span>
	array2 := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>,<span class="number">40</span>, <span class="number">50</span>}
	<span class="comment">// 让Go自动那个计算声明的数组长度</span>
	array3 := [...]<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}
	<span class="comment">// 指定特定元素的值，index:value，指定索引为index的元素值为value</span>
	array4 := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>}
    <span class="comment">// for循环输出语句</span>
	<span class="keyword">for</span> index, value := <span class="keyword">range</span> array4{
		fmt.Printf(<span class="string">"arr[%d] = %d \n"</span>, index, value)
	}

	fmt.Println(<span class="built_in">len</span>(array1)) <span class="comment">// 5</span>
	fmt.Println(<span class="built_in">len</span>(array2)) <span class="comment">// 5</span>
	fmt.Println(<span class="built_in">len</span>(array3)) <span class="comment">// 5</span>
}

</code></pre>
<h4 id="使用数组"><a class="markdownIt-Anchor" href="#使用数组"></a> 使用数组</h4>
<p>要访问数组时，可以利用<code>[]</code>运算符，通过索引访问元素。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	<span class="comment">/* 使用索引访问数组元素 */</span>
	array := [<span class="number">5</span>]<span class="keyword">int</span> {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}
	<span class="comment">// 修改索引为2的元素的值</span>
	array[<span class="number">2</span>] = <span class="number">35</span>

	<span class="comment">/* 声明一个元素都是指针的数组，使用*运算符就能访问元素指针所指向的值 */</span>
	array1 := [<span class="number">5</span>]*<span class="keyword">int</span>{<span class="number">0</span>: <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="number">1</span>: <span class="built_in">new</span>(<span class="keyword">int</span>)}
	*array1[<span class="number">0</span>] = <span class="number">10</span>
	*array1[<span class="number">1</span>] = <span class="number">20</span>

	<span class="comment">/* 将同类型的数组赋值给另一个数组,类型相同指的是数据类型和长度都相等 */</span>
	colorArray := [<span class="number">5</span>]<span class="keyword">string</span>{<span class="string">"Blue"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}
	<span class="keyword">var</span> colorArray1 [<span class="number">5</span>]<span class="keyword">string</span>
	colorArray1 = colorArray
	<span class="keyword">for</span> _, value := <span class="keyword">range</span> colorArray1{
		fmt.Println(value)
	}

	<span class="comment">/* 编译器会阻止不同类型的数组互相赋值 */</span>
	<span class="keyword">var</span> stringarray [<span class="number">5</span>]<span class="keyword">string</span>
	<span class="keyword">var</span> shortarray [<span class="number">4</span>]<span class="keyword">int</span>
	<span class="keyword">var</span> longarray [<span class="number">6</span>]<span class="keyword">int</span>
	intarray := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}
	<span class="comment">// 类型不同的数组不能互相赋值</span>
	stringarray = intarray
	<span class="comment">// 不能将长数组赋值给短数组</span>
	shortarray = intarray
	<span class="comment">// 不能将短数组赋值给长数组</span>
	longarray = intarray

	<span class="comment">/* 把一个指针数组赋值给另一个 */</span>
	<span class="keyword">var</span> array3 [<span class="number">3</span>]*<span class="keyword">string</span>
	array4 := [<span class="number">3</span>]*<span class="keyword">string</span>{<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)}
	*array4[<span class="number">0</span>] = <span class="string">"Red"</span>
	*array4[<span class="number">1</span>] = <span class="string">"Blue"</span>
	*array4[<span class="number">2</span>] = <span class="string">"Green"</span>
	array3 = array4
	<span class="keyword">for</span> _, value := <span class="keyword">range</span> array3{
		fmt.Println(value)
	}
}

</code></pre>
<h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	<span class="comment">/* 声明一个二维数组 */</span>
	<span class="keyword">var</span> a1 [<span class="number">4</span>][<span class="number">2</span>] <span class="keyword">int</span>
	a2 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ {<span class="number">10</span>, <span class="number">11</span>}, {<span class="number">12</span>, <span class="number">13</span>}, {<span class="number">14</span>, <span class="number">15</span>}, {<span class="number">16</span>, <span class="number">17</span>} }
	
	<span class="comment">/* 声明数组并初始化外层索引为1和3的元素 */</span>
	a3 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ <span class="number">1</span>: {<span class="number">20</span>, <span class="number">21</span>}, <span class="number">3</span>: {<span class="number">40</span>, <span class="number">41</span>}}
	
	<span class="comment">/* 声明数组并初始化外层数组和内层数组的单个元素 */</span>
	a4 := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>{ <span class="number">1</span>: {<span class="number">0</span>: <span class="number">20</span>}, <span class="number">3</span>: {<span class="number">1</span>: <span class="number">41</span>}}
	
	<span class="comment">/* 访问数组中的元素 */</span>
	a1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>
	
	<span class="comment">/* 同类型数组可以互相赋值，此处的同类型指的是长度，数据类型相同 */</span>
	a1 = a2
	
	<span class="comment">/* 使用索引为多维数组赋值*/</span>
	<span class="comment">// 将数组a1中索引为1的值复制到一个同类型数组中</span>
	<span class="keyword">var</span> a5 [<span class="number">2</span>]<span class="keyword">int</span> = a1[<span class="number">1</span>]
	
	<span class="comment">// 将数组a1中外层索引为1，内层索引为0的元素赋予变量</span>
	<span class="keyword">var</span> value <span class="keyword">int</span> = a1[<span class="number">1</span>][<span class="number">0</span>]
	
}
</code></pre>
<h4 id="在函数间传递数组"><a class="markdownIt-Anchor" href="#在函数间传递数组"></a> 在函数间传递数组</h4>
<p>从内存和性能来看，在函数间传递数组是一个开销很大的操作，因为不论数组多长，都会被完整的复制并传递给函数。假设现在有一个int型数组长度为100万，在64位架构上需要8MB的内存。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	
	<span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span>
	foo(array)
	
}

<span class="comment">// 函数foo接收一个长度为100万的数组</span>
<span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array [1e6]<span class="keyword">int</span>)</span></span> {
	
}
</code></pre>
<p>每次<code>foo</code>被调用时，必须在栈上分配8MB的内存。之后，整数组的值被复制到刚分配的内存中。这开销十分的大。我们可以通过<code>只传入指向数组的指针</code>的方式解决这个问题。这样只需要复制8字节的数据而不需要复制8MB的数据到栈上，。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

	<span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span>
	<span class="comment">// 将array的地址传给foo</span>
	foo(&amp;array)

}

<span class="comment">// 函数foo接收一个指向长度为100万的数组的指针</span>
<span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array *[1e6]<span class="keyword">int</span>)</span></span> {

}

</code></pre>
<p>这样操作会更有效地利用内存，性能也更好。但由于传递的是指针，所以如果改变指针指向的值，会改变共享的内存。切片能更好地处理这类共享问题。</p>
<h3 id="切片的内部实现和基础功能"><a class="markdownIt-Anchor" href="#切片的内部实现和基础功能"></a> 切片的内部实现和基础功能</h3>
<blockquote>
<p><code>切片</code>是一种数据结构，便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以自动增长和缩小。切片的动态增长是通过函数<code>append</code>实现的。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能取得索引，迭代以及为垃圾回收优化的好处。</p>
</blockquote>
<h4 id="内部实现-2"><a class="markdownIt-Anchor" href="#内部实现-2"></a> 内部实现</h4>
<p>切片是很小的对象，对底层数组进行抽象，并提供相关的操作方法。切片有3个字段的数据结构，这三个字段分别是指向底层数组的指针，切片访问的元素的个数（即长度）和切片允许增长的到的元素个数（即容量）。</p>
<h4 id="创建和初始化"><a class="markdownIt-Anchor" href="#创建和初始化"></a> 创建和初始化</h4>
<p>是否能提前知道切片需要的容量通常会决定要如何创建切片。</p>
<h5 id="make和切片字面量"><a class="markdownIt-Anchor" href="#make和切片字面量"></a> make和切片字面量</h5>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

	<span class="comment">/* 创建一个字符串切片，长度和容量都是5 */</span>
	slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)

	<span class="comment">/* 创建一个长度为3，容量为5的字符串切片 */</span>
	s1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)
  
    <span class="comment">/* 创建长度和容量都是5的切片 */</span>
    s2 := []<span class="keyword">string</span> {<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}
  
    <span class="comment">/* 创建chang*/</span>

}
</code></pre>
<p>上述切片可以访问3个元素，而底层数组拥有5个元素，剩下2个元素可以后期操作合并到切片，并通过切片访问这些元素。如果基于这个切片创建新的切片，新切片会和原有切片共享底层数组，也能通过后期操作访问多余容量的元素。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   <span class="comment">/* 切片的容量不能小于长度 */</span>
   slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">3</span>)
   
   <span class="comment">// Error:len larger than cap in make([]string)</span>

   fmt.Println(slice)

}
</code></pre>
<p>如果在<code>[]</code>元素符中指定了值，那么创建的就是数组而不是切片。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   <span class="comment">/* 声明长度和容量皆为100的切片 */</span>
   slice := []<span class="keyword">string</span>{<span class="number">99</span>:<span class="string">"Red"</span>}

   <span class="comment">/* 声明长度为100的数组 */</span>
   s1 := [<span class="number">100</span>]<span class="keyword">string</span>{<span class="number">99</span>:<span class="string">"Red"</span>}
   fmt.Println(s1)
   fmt.Println(slice)

}
</code></pre>
<h5 id="nil和空切片"><a class="markdownIt-Anchor" href="#nil和空切片"></a> nil和空切片</h5>
<p>nil切片常用于描述一个不存在的切片，例如当函数要求返回一个切片但返回异常时。而空切片在底层数组包含0个元素，也没有分配任何存储空间，可用于当数据库查询返回0个结果时。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   <span class="comment">/* nil切片，指针为nil */</span>
   <span class="keyword">var</span> slice []<span class="keyword">int</span>
   
   <span class="comment">/* 空切片，指针为空 */</span>
   s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)
   s2 := []<span class="keyword">int</span>{}

}
</code></pre>
<h4 id="使用切片"><a class="markdownIt-Anchor" href="#使用切片"></a> 使用切片</h4>
<ul>
<li>赋值和切片</li>
</ul>
<p>对于切片中某个索引指向的元素赋值和数据操作一致。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   <span class="comment">// 创建长度和容量都是5的切片</span>
   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}
   
   <span class="comment">// 修改索引为0的元素</span>
   slice[<span class="number">0</span>] = <span class="number">0</span>

}
</code></pre>
<p>切片之所以被称为切片，是因为创建一个新切片就是把底层数组切出一部分。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

	slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {
		fmt.Println(slice[i]) <span class="comment">// 10, 20, 30, 40, 50</span>
	}

	<span class="comment">// 创建一个新切片，长度为2，容量为4</span>
	newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]

	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(newSlice) ; i++ {
		fmt.Println(newSlice[i]) <span class="comment">// 20 30</span>
	}
}
</code></pre>
<p><img src="/article/Go/Go Base/数组、切片和映射/slice.png" alt="无法加载" title="共享同一底层数组的两个切片"></p>
<p>上述结果显示，两个切片共享同一段底层数组，但是不同的切片看到的是数组的不同部分。对于底层数组容量为k的<code>lices[i:j]</code>，新切片的长度为<code>j-i</code>,容量为<code>k-i</code>。</p>
<p>此时两个数组共享同一个底层数组，如果一个切片修改了底层数组的共享部分，另一个切片也能感受到。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]
   <span class="comment">// 修改新切片索引为1的元素</span>
   newSlice[<span class="number">1</span>] = <span class="number">35</span>

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {
      fmt.Println(slice[i]) <span class="comment">// 10, 20, 35, 40, 50</span>
   }
}
</code></pre>
<p>修改newSlice索引为1的元素其实也是修改了slice索引为2的元素。</p>
<p>切片只能访问其长度内的元素。与切片容量相关联的元素只能用于增长元素，在使用这部分元素前，必须将其合并到切片的长度里。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]
   
   <span class="comment">// newSlice长度为2，所以索引为3的元素对其而言不存在</span>
   newSlice[<span class="number">3</span>] = <span class="number">35</span>
   <span class="comment">// Error：runtime error: index out of range</span>

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice) ; i++ {
      fmt.Println(slice[i]) <span class="comment">// 10, 20, 35, 40, 50</span>
   }
}
</code></pre>
<p>切片有额外的容量很好，但如果没有把这些容量合并到切片的长度中，这些容量就是没用的。</p>
<ul>
<li>
<p>切片增长</p>
<p>切片可以按需增长容量，Go中的<code>append</code>函数会处理增长长度的所有操作细节。要使用<code>append</code>需要一个被操作的切片和一个要追加的值。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]

   <span class="comment">// 使用原有的容量来分配一个新元素</span>
   newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {
      fmt.Println(slice[i]) <span class="comment">// 10 20 30 40 50 </span>
   }
}
</code></pre>
</li>
</ul>
<p><code>newSlice</code>在底层数组还有可用容量，因此<code>append</code>会将可用元素合并到切片的长度中，并对其赋值。但由于和slice共享同一个数组，所以slice中索引为3的元素也会被改变。</p>
<p>如果切片的底层数组没有可用容量，append会创建一个新的数组，将被引用的现有的值复制到新数组中，再追加新的值。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>}

   newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {
      fmt.Println(slice[i]) <span class="comment">// 10 20 30 40</span>
   }

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(newSlice); i++ {
      fmt.Println(newSlice[i]) <span class="comment">// 10 20 30 40 50</span>
   }
   
}
</code></pre>
<p><code>append</code>会智能处理底层数组的容量增长，当切片容量小于1000时，会成倍增长容量。但超过1000时，会将增长因子设为1.25.</p>
<ul>
<li>创建切片时的3个索引</li>
</ul>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

	source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

    <span class="comment">// 定义一个长度为1，容量为2的切片</span>
    <span class="comment">// 2为新切片开始的索引</span>
    <span class="comment">// 3为新切片的长度+2</span>
    <span class="comment">// 4为新切片的容量+2</span>
	slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]

	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ {
		fmt.Println(slice[i]) <span class="comment">// 30</span>
	}

	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(source); i++ {
		fmt.Println(source[i]) <span class="comment">// 10 20 30 40 50</span>
	}
}
</code></pre>
<p>此时切片的长度，对于<code>slice[i:j:k]</code>，其长度为<code>j-i</code>，容量为<code>k-i</code>.如果设置的容量比可用容量大，就会运行出错。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}
   slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">6</span>]
   <span class="comment">// panic: runtime error: slice bounds out of range</span>
  
}
</code></pre>
<p>append会先使用可用容量，如果没有可用容量就会创建新的底层数组。这导致很容易忘记切片间正在共享一个数组，一旦发生这种情况，会导致问题，对切片内容的修改会影响多个切片。</p>
<p>因此设置长度和容量一样的好处就是，会强制让新的切片的第一个<code>append</code>操作创建一个新的底层数组，与原有的数组分离。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   slice := []<span class="keyword">int</span>{<span class="number">60</span>, <span class="number">70</span>}

   <span class="comment">// 将两个切片追加。source追加slice元素</span>
   fmt.Printf(<span class="string">"%v\n"</span>, <span class="built_in">append</span>(source, slice...)) <span class="comment">// [10 20 30 40 50 60 70]</span>

   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(source); i++ {
      fmt.Println(source[i]) <span class="comment">// 10 20 30 40 50</span>
   }

}
</code></pre>
<ul>
<li>迭代切片</li>
</ul>
<p>切片是一个集合，可以迭代其中的元素。Go可以使用关键字<code>range</code>配合关键字<code>for</code>迭代切片里的元素。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   <span class="keyword">for</span> index, value := <span class="keyword">range</span> source {
      fmt.Printf(<span class="string">"index = %d, value = %d \n"</span>, index, value)
   }

}
</code></pre>
<p>迭代切片时，关键字<code>range</code>会返回两个值，一个是当前元素的索引，一个是当前元素值的一个副本。此处要注意的是，切片返回的是元素值的副本，不是对该元素的直接引用。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}
   
   <span class="keyword">for</span> index, value := <span class="keyword">range</span> source {
      fmt.Printf(<span class="string">"Value: %d Value-Addr: %X ElemAddr: %X \n"</span>, value, &amp;value,
         &amp;source[index])
   }
   
   <span class="comment">/** Output
   Value: 10 Value-Addr: C04204A088 ElemAddr: C042066030 
   Value: 20 Value-Addr: C04204A088 ElemAddr: C042066038 
   Value: 30 Value-Addr: C04204A088 ElemAddr: C042066040 
   Value: 40 Value-Addr: C04204A088 ElemAddr: C042066048 
   Value: 50 Value-Addr: C04204A088 ElemAddr: C042066050 
    */</span>
}
</code></pre>
<p>此时我们可以看到副本的地址一直是不变的是因为迭代返回的变量是在迭代过程中根据切片依次赋予的新值，但其本身不变。要想获取元素真正的地址，需要使用切片变量和索引值。</p>
<p><code>range</code>的迭代是从切片索引0开始的，要像从其他索引开始迭代，可以使用<code>for</code>循环。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   <span class="comment">// 从索引2开始迭代切片</span>
   <span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(source); index ++ {
      fmt.Printf(<span class="string">"value = %d, index = %d \n"</span>, source[index], index)
   }

}
</code></pre>
<p>Go中有两个内置函数<code>len()</code>和<code>cap()</code>，可以用于处理数组、切片和通道。对于切片，<code>len()</code>返回切片的长度，<code>cap()</code>返回切片的容量。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   source := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

   slice := <span class="built_in">append</span>(source, <span class="number">60</span>)

    <span class="comment">// 当append超出原切片容量时，会创建新数组，且当元素为1000时，容量会翻倍</span>
   fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 10</span>
}
</code></pre>
<h4 id="多维切片"><a class="markdownIt-Anchor" href="#多维切片"></a> 多维切片</h4>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {

   <span class="comment">// 创建多维切片，该切片中包含两个切片{10},{10, 20}</span>
   slice := [][]<span class="keyword">int</span>{ {<span class="number">10</span>}, {<span class="number">10</span>, <span class="number">20</span>}} 
   fmt.Println(slice) <span class="comment">// [[10] [10 20]]</span>
   <span class="comment">// 为切片中的第一个切片追加值为20的元素</span>
   slice[<span class="number">0</span>] = <span class="built_in">append</span>(slice[<span class="number">0</span>], <span class="number">20</span>)
   fmt.Println(slice) <span class="comment">// [[10 20] [10 20]]</span>
}
</code></pre>
<p>多维切片<code>append</code>的过程是先增长<code>{10}</code>，然后将增长后的<code>{10, 20}</code>赋值给<code>slice[0]</code>。多维切片，操作时会涉及众多布局和值，但是切片本身结构简单，可以以很小的成本在函数间传递。</p>
<h4 id="切片在函数间传递"><a class="markdownIt-Anchor" href="#切片在函数间传递"></a> 切片在函数间传递</h4>
<p>切片的尺寸小，在函数间赋值和传递切片的成本也低。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {

   slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1e6</span>)
   foo(slice)
}

<span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> {
   <span class="keyword">return</span> slice
}
</code></pre>
<p>在64位架构的机器上，一个切片需要24字节的内存：指针字段需要8字节，长度和容量字段分别需要8字节。由于切片关联的数据包含在底层数组中，不属于切片本身，所以将切片复制到任何函数时，对底层数组大小都不会有影响。复制的只是切片本身，不会涉及底层数组 。</p>
<h3 id="映射的内部实现和基本功能"><a class="markdownIt-Anchor" href="#映射的内部实现和基本功能"></a> 映射的内部实现和基本功能</h3>
<p>映射是一种数据结构，用于存储一系列的键值对。映射里基于键来存储值。映射的优势是，能够基于键快速检索数据，键就像是索引一样，指向与该键关联的值。</p>
<h4 id="内部实现-3"><a class="markdownIt-Anchor" href="#内部实现-3"></a> 内部实现</h4>
<p>映射是一个集合，可以使用类似切片的方式迭代映射中的元素。但映射是无序集合，这使得无法预测键值对被返回的顺序，即使用同样的顺序保存键值对，但每次迭代映射的时候，顺序也会不一样。这是因为映射的实现使用了散列表。散列表的具体细节暂时不描述。</p>
<h4 id="创建和初始化-2"><a class="markdownIt-Anchor" href="#创建和初始化-2"></a> 创建和初始化</h4>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {

   <span class="comment">// 创建一个键值类型都是string的映射</span>
   dict1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)
   
   fmt.Println(dict1)

   <span class="comment">// 创建一个映射，key为int,value为string</span>
   dict := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{<span class="number">1</span>:<span class="string">"One"</span>,<span class="number">2</span>:<span class="string">"Two"</span>,<span class="number">3</span>:<span class="string">"Three"</span>}
   <span class="comment">// 迭代循环，由结果可得，其是无序集合，每次输出的顺序可能都不一样</span>
   <span class="keyword">for</span> key, value := <span class="keyword">range</span> dict {
      fmt.Printf(<span class="string">"%d = %s \n"</span>, key, value)
   }
}
</code></pre>
<p>映射的长度会根据初始化时指定的键值对数量来确定。映射的键可以是任何只，可以是基本数据类型，也可以是结构类型，只要这个值可以用<code>==</code>运算符做比较。切片、函数以及包含切片的结构类型由于使用了引用，都不能作为映射的键。但可以作为映射的值。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {

   <span class="comment">// 将切片作为映射的键</span>
   dict1 := <span class="keyword">map</span>[[]<span class="keyword">string</span>] <span class="keyword">int</span>{}
   <span class="comment">// Exception: invalid map key type []string</span>
   fmt.Println(dict1)
   <span class="comment">// 将切片作为映射的值</span>
   dict2 := <span class="keyword">map</span>[<span class="keyword">int</span>] []<span class="keyword">string</span>{}
   fmt.Println(dict2)
}
</code></pre>
<h4 id="使用映射"><a class="markdownIt-Anchor" href="#使用映射"></a> 使用映射</h4>
<p>键值对赋值给映射，是通过指定适当类型的键并给这个键赋值来完成的。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">//  声明一个空映射</span>
   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{}

   <span class="comment">// 将"1"对应的英文"One"加入到映射中</span>
   nums[<span class="string">"1"</span>] = <span class="string">"One"</span>

   <span class="comment">// 空映射可以用于存储键值对，但nil映射不能</span>
   <span class="keyword">var</span> colors <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>

   colors[<span class="string">"Red"</span>] = <span class="string">"#da1337"</span>
   <span class="comment">// panic: assignment to entry in nil map</span>


}
</code></pre>
<p>检测映射中是否存在某个键是映射的常用操作。这个操作允许用户写一些逻辑来确定是否完成了某个操作或是否在映射中缓存了特定数据，也可以用于比较两个映射，来确定哪些键值对互相匹配。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">//  声明一个空映射</span>
   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{}

   <span class="comment">// 将"1"对应的英文"One"加入到映射中</span>
   nums[<span class="string">"1"</span>] = <span class="string">"One"</span>

   <span class="comment">// 同时获取映射中key对应的值，以及这个键是否存在</span>
   value, exists := nums[<span class="string">"1"</span>]
   <span class="keyword">if</span> exists {
      fmt.Println(value)
   }
    
   <span class="comment">// 只返回键对应的值，从而判断这个值是不是零值，以此来判断key是否存在</span>
   v := nums[<span class="string">"1"</span>]
   <span class="keyword">if</span> v != <span class="string">""</span> {
      fmt.Println(value)
   }

}
</code></pre>
<p>Go中即使键不存在，也会返回一个值。这个值是值对应的数据类型的零值。</p>
<p>可以使用<code>delete()</code>函数删除映射中的键值对</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">//  声明一个空映射</span>
   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{
      <span class="string">"1"</span>: <span class="string">"One"</span>,
      <span class="string">"2"</span>: <span class="string">"Two"</span>,
      <span class="string">"3"</span>: <span class="string">"Three"</span>,
   }

   <span class="built_in">delete</span>(nums, <span class="string">"2"</span>)

   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {
      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value)
   }

}
</code></pre>
<h4 id="在函数间传递映射"><a class="markdownIt-Anchor" href="#在函数间传递映射"></a> 在函数间传递映射</h4>
<p>在函数间传递映射时，并不会造出该映射的副本，即将映射传递给函数后，所有对这个映射的映射都会收到函数的操作带来的影响。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">//  声明一个空映射</span>
   nums := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{
      <span class="string">"1"</span>: <span class="string">"One"</span>,
      <span class="string">"2"</span>: <span class="string">"Two"</span>,
      <span class="string">"3"</span>: <span class="string">"Three"</span>,
   }

   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {
      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value)
      <span class="comment">// Output:</span>
      <span class="comment">// 1 = One </span>
      <span class="comment">// 2 = Two</span>
      <span class="comment">// 3 = Three </span>
   }

   remove(nums, <span class="string">"2"</span>)

   <span class="keyword">for</span> key, value := <span class="keyword">range</span> nums {
      fmt.Printf(<span class="string">"%s = %s \n"</span>, key, value) 
      <span class="comment">// Output:</span>
      <span class="comment">// 1 = One </span>
      <span class="comment">// 3 = Three </span>
   }
}

<span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, key <span class="keyword">string</span>)</span></span>  {
   <span class="built_in">delete</span>(dict, key)
}

</code></pre>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go中的类型]]></title>
      <url>/article/Go/Go%20Base/Go%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>Go是一种静态类型的语言。这意味着编译器需要在编译时知道程序中每个值的类型。这有助于减少潜在的内存异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。</p>
<h3 id="自定义类型"><a class="markdownIt-Anchor" href="#自定义类型"></a> 自定义类型</h3>
<p>Go允许用户自定义类型，当用户声明一个新类型时，该声明就给编译器提供一个框架，告知必要的内存大小和表示信息Go中有两种声明类型的方式，，一种是使用关键字<code>struct</code>，用于创建一个结构类型。结构类型通过组合一系列固定且唯一的字段来声明。结构中的字段可以用Go内置的类型声明，也可以用自定义的类型声明。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义一个user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
	name <span class="keyword">string</span>
	age <span class="keyword">int</span>
	sex <span class="keyword">bool</span>
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {

	<span class="comment">// 声明user型变量</span>
	<span class="keyword">var</span> u user

	<span class="comment">// 不赋值时，每个字段为其对应数据类型的默认值</span>
	fmt.Println(u) <span class="comment">// &amp;#123"" 0 false&amp;#125</span>
	<span class="comment">// 给结构中的字段赋值</span>
	u.name = <span class="string">"Tom"</span>
	u.age = <span class="number">18</span>
	u.sex = <span class="literal">true</span>

	<span class="comment">// 给结构中的字段赋值，可以不按照结构中字段的顺序进行赋值</span>
	lisa := user{
		name: <span class="string">"Lisa"</span>,
		age:<span class="number">21</span>,
		sex: <span class="literal">false</span>,
	}

	<span class="comment">// 给结构中的字段赋值，必须按照结构中字段的顺序进行赋值</span>
	bill := user{
		<span class="string">"Bill"</span>, 
		<span class="number">8</span>, 
		<span class="literal">true</span>
	}

	fmt.Println(u)
	fmt.Println(lisa)
	fmt.Println(bill)
}
</code></pre>
<p>使用自定义类型声明类型中的字段</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义一个user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name <span class="keyword">string</span>
   age <span class="keyword">int</span>
   sex <span class="keyword">bool</span>
}

<span class="comment">// 使用自定义类型声明结构中的字段</span>
<span class="keyword">type</span> admin <span class="keyword">struct</span> {
   person user
   level <span class="keyword">string</span>
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   u := admin{
      person:user {
         name:<span class="string">"admin"</span>,
         age:<span class="number">18</span>,
         sex:<span class="literal">true</span>,
      },
      level:<span class="string">"1"</span>,
   }

   fmt.Println(u) 

</code></pre>
<p>此外还可以基于已有的类型，声明新类型的类型。当需要一个可以用已有类型表示新的类型时，这个方式很好用。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">type</span> Duration <span class="keyword">int64</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="keyword">var</span> dur Duration
   dur = <span class="keyword">int64</span>(<span class="number">1000</span>)
   <span class="comment">// cannot use int64(1000) (type int64) as type Duration in assignment</span>

   fmt.Println(dur) 
}
</code></pre>
<p>尽管	<code>int64</code>是<code>Duration</code>的基础类型，但是Go不会认为它们是同一种类型。因此当将<code>int64</code>的值赋予<code>dur</code>时会报错。两种类型即使互相兼容，但不能互相赋值，编译器不会对不同类型的值做隐式转换。</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p>方法能给用户定义的类型添加新的行为。方法实际也是函数，只是在声明时，在关键字<code>func</code>和方法名之间增加了一个参数。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义一个user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="keyword">type</span> people <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="comment">// 定义一个方法,(u user)表示只有类型为user的变量才可以接收该方法</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span>{
   fmt.Printf(<span class="string">"Sending User Email To %s&lt;%s&gt; \n"</span>, u.name, u.email)
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   bill := user{
   	<span class="string">"bill"</span>, 
   	<span class="string">"bill@email.com"</span>
   }
   <span class="comment">// 只有类型为user的变量才能调用notify()</span>
   bill.notify()
   lisa := people{
   	<span class="string">"lisa"</span>, 
   	<span class="string">"lisa@email.com"</span>
   }
   <span class="comment">// 报错，type people has no field or method notify</span>
   lisa.notify()

}
</code></pre>
<p>该参数用于定义方法的接收者，即定义调用方法的变量。Go中的接收者有两种类型：值接收者和指针接收者。值接受者声明的方法，在调用时，会用这个值的副本来执行。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义一个user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="comment">// 定义一个指针接收者方法</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">changeEmail</span><span class="params">(email <span class="keyword">string</span>)</span></span>  {
   u.email = email
}

<span class="comment">// 定义一个值接收者方法</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">changeName</span><span class="params">(name <span class="keyword">string</span>)</span></span>  {
   u.name = name
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">// user类型的值可以调用值接收者方法，也可以调用指针接收者方法</span>
   bill := user{
   	<span class="string">"bill"</span>, 
   	<span class="string">"bill@email.com"</span>
   }
   bill.changeName(<span class="string">"lisa"</span>)
   bill.changeEmail(<span class="string">"lisa@email.com"</span>)
   fmt.Print(bill) <span class="comment">// {bill lisa@email.com}</span>

   <span class="comment">// user类型的值的指针可以调用指针接收者方法，也可以调用值接收者方法</span>
   lisa := &amp;user{<span class="string">"lisa"</span>, <span class="string">"lisa@email.com"</span>}
   lisa.changeName(<span class="string">"Lisa"</span>)
   lisa.changeEmail(<span class="string">"Lisa@mail.com"</span>)
   fmt.Println(lisa) <span class="comment">// {lisa Lisa@mail.com}</span>
}

</code></pre>
<p>由结果我们可以看出，值接收者声明的方法，执行后不会改变调用该方法的变量本身的值。但指针接收者声明的方法，不论是普通变量还是指针变量调用后，都会改变自身的值。这是因为值接收者声明的方法，被调用后，接收到的是<code>bill</code>的副本，而指针接收者声明的方法被调用后接收到的是变量自身的实际值。指针变量能够调用值接收者方法，是因为Go调整了指针的值，指针被解引用为值，即等价于<code>(*lisa).changeName(&quot;Lisa&quot;)</code>。普通变量能够调用指针接收者方法，是因为Go先引用<code>bill</code>得到了一个指针，即等价于<code>(&amp;bill).changeEmail(&quot;lisa@email.com&quot;)</code></p>
<h3 id="类型的本质"><a class="markdownIt-Anchor" href="#类型的本质"></a> 类型的本质</h3>
<p>声明一个类型之后，声明一个该类型的方法之前，需要考虑以下几点：</p>
<ul>
<li>该类型的本质是什么</li>
<li>给该类型增加或删除某个值，是要创建新值还是改变当前值。如果是创建新值，则使用值接收者声明方法；如果是修改当前值，则使用指针接收者声明方法。</li>
</ul>
<h4 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h4>
<p>基本类型是由语言自身提供的一组类型，如数值类型、字符串类型、布尔类型。这些类型是本质是原始的类型，因此对这些值进行操作时，会创建新值。基于这个 理论，当这些类型的值传递给方法或函数时，应该传递一个对应值的副本。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
   <span class="string">"fmt"</span>
   <span class="string">"strings"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"Hello, World"</span>
   <span class="comment">// Trim删除s中的H、e、l、o、d字母</span>
   fmt.Println(strings.Trim(s, <span class="string">"Helod"</span>)) <span class="comment">// 生成了新的字符串 ", Wor"</span>
   fmt.Println(s)  <span class="comment">// s本身不变</span>
}
</code></pre>
<p>字符串本质上是基本类型，所以在函数或方法内外传递时，传递的是字符串的副本。</p>
<h4 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h4>
<p>Go中的引用类型有：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称为<code>header</code>值。从技术细节来讲，字符串也是引用类型。每个引用类型的创建的<code>header</code>值，包含一个指向底层数据结构的指针，还包含一组独特的字段，用于管理底层数据结构。因为<code>header</code>值是为复制而设计的，所以永远不需要共享一个引用类型的值。<code>header</code>值里包含一个指针，因此通过复制来传递引用类型的值的副本，本质上就是共享底层数据结构。即引用类型的函数或方法内外传递时，依然使用的是数据副本。</p>
<h4 id="结构类型"><a class="markdownIt-Anchor" href="#结构类型"></a> 结构类型</h4>
<p>结构类型可以用于描述一组数据，这组数据的本质可以是原始的，也可以是非原始的，如果要决定在某些数据需要删除或添加结构类型的值时，该结构类型的值不应该被更改，那么需要遵守之前提到的基本类型和引用类型的规范。使用值接收者还是指针接收者，不应该由这个方法是否修改了值的本身决定，而是应该基于该类型的本质。其本质为原始，则使用值接收，非原始则使用指针接收。</p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</p>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<p>接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。</p>
<h4 id="方法集"><a class="markdownIt-Anchor" href="#方法集"></a> 方法集</h4>
<p>方法集定义了接口的接收规则。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义notifier接口，具有notify()行为</span>
<span class="keyword">type</span> notifier <span class="keyword">interface</span> {
   notify()
}

<span class="comment">// 定义user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="comment">// 使用指针接收者实现notify()</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {
   fmt.Printf(<span class="string">"Sending user email to  %s&lt;%s&gt;\n"</span>, u.name, u.email)
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>
   u := user{
   	<span class="string">"Bill"</span>, 
   	<span class="string">"bill@email.com"</span>
   }
   SendNotification(u)
   <span class="comment">// cannot use u (type user) as type notifier in argument to SendNotification:</span>
   <span class="comment">// user does not implement notifier (notify method has pointer receiver)</span>
}

<span class="comment">// 接收一个实现了notifier接口的值</span>
<span class="function"><span class="keyword">func</span> <span class="title">SendNotification</span><span class="params">(n notifier)</span></span>  {
   n.notify()
}
</code></pre>
<p>由报错的原因，我们可以看出notify()是指针接收者声明的。要想了解指针接收者来实现接口时为什么user类型的值无法实现该接口，就需要先了解方法集。方法集定义了一组关联到给定类型的值或指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针。</p>
<p>从接收者类型角度来看方法集，值接收者定义的方法可以接收值或指针，而指针接收者定义的方法只能接收指针。所以将代码改为下述形式后，就不会报错了：</p>
<pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>
   u := user{
   	<span class="string">"Bill"</span>, 
   	<span class="string">"bill@email.com"</span>
   }
   SendNotification(&amp;u)
}
</code></pre>
<h4 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h4>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义notifier接口，具有notify()行为</span>
<span class="keyword">type</span> notifier <span class="keyword">interface</span> {
   notify()
}

<span class="comment">// 定义user类型</span>
<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="comment">// user实现的notify()</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {
   fmt.Printf(<span class="string">"Sending user email to  %s&lt;%s&gt;\n"</span>, u.name, u.email)
}

<span class="comment">// 定义admin类型</span>
<span class="keyword">type</span> admin <span class="keyword">struct</span> {
   name <span class="keyword">string</span>
   age  <span class="keyword">int</span>
}

<span class="comment">// admin实现的notify()</span>
<span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> {
   fmt.Printf(<span class="string">"%s is %d years old."</span>, a.name, a.age)
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   <span class="comment">// 创建一个user类型的变量，并调用notify()</span>
   u := user{
   	<span class="string">"Bill"</span>, 
   	<span class="string">"bill@email.com"</span>
   }
   SendNotification(&amp;u)

   <span class="comment">// 创建一个admin类型的变量，并调用notify()</span>
   a := admin{
   	<span class="string">"Lisa"</span>, 
   	<span class="number">18</span>}
   SendNotification(&amp;a)
}

<span class="comment">// 接收一个实现了notifier接口的值</span>
<span class="function"><span class="keyword">func</span> <span class="title">SendNotification</span><span class="params">(n notifier)</span></span>  {
   n.notify()
}
</code></pre>
<p>任意一个实体类型都能实现接口<code>notifier</code>，因此<code>SendNotification</code>可以针对实现接口的类型，实现具体的行为。这就是多态。</p>
<h3 id="嵌入类型"><a class="markdownIt-Anchor" href="#嵌入类型"></a> 嵌入类型</h3>
<p>Go语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候很重要。这个功能是通过<code>嵌入类型（type embedding）</code>完成的。嵌入类型是将已有的类型直接声明在新结构类型中。被嵌入的类型被称为新的外部类型的内部类型。</p>
<p>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。外部类也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符或者方法。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {
   fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)
}

<span class="keyword">type</span> admin <span class="keyword">struct</span> {
   user <span class="comment">// 嵌入类型</span>
   level <span class="keyword">string</span>
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   ad := admin{
      user: user{
         name:  <span class="string">"john smith"</span>,
         email: <span class="string">"john@yohoo.com"</span>,
      },
      level: <span class="string">"super"</span>,
   }

   <span class="comment">// 可通过内部类型调用内部类型的方法</span>
   ad.user.notify()

   <span class="comment">// 也可以直接使用外部类型直接调用方法</span>
   ad.notify()
}
</code></pre>
<p>上述代码中将<code>user</code>嵌入<code>admin</code>类型中只需要在外部类型中声明要嵌入的类型名即可。对于外部类型而言，内部类型是存在的，所以即使外部类型可以使用内部类型的属性名来访问内部类型的值。也可以直接访问内部类型<code>user</code>来调用外部类型方法，也可以直接用外部类型的变量调用<code>notify()</code>。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 定义个接口，接口有notify()</span>
<span class="keyword">type</span> notifier <span class="keyword">interface</span> {
   notify()
}

<span class="keyword">type</span> user <span class="keyword">struct</span> {
   name  <span class="keyword">string</span>
   email <span class="keyword">string</span>
}

<span class="comment">// 通过user类型的值的指针调用notify()</span>
<span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> {
   fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)
}

<span class="keyword">type</span> admin <span class="keyword">struct</span> {
   user <span class="comment">// 嵌入类型</span>
   level <span class="keyword">string</span>
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   ad := admin{
      user: user{
         name:  <span class="string">"john smith"</span>,
         email: <span class="string">"john@yohoo.com"</span>,
      },
      level: <span class="string">"super"</span>,
   }

   <span class="comment">// admin类型的值的指针也可以传入</span>
   sendNotification(&amp;ad)
}

<span class="comment">// 接收一个实现notifier接口的值</span>
<span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> {
   n.notify()
}                     
</code></pre>
<p>由上述代码可知，如果嵌入类型实现了某接口，外部类型也相当于实现了该接口。如果外部类型并不需要使用内部类型对接口的实现方式，想定义属于自己的实现方式，应按照下述代码：</p>
<pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> {
	fmt.Printf(<span class="string">"Sending admin email to %s&lt;%s&gt;\n"</span>, a.name, a.email)
}
</code></pre>
<p>在上述代码添加由admin类型的值的指针调用的方法，此时再运行上述代码，调用的就不再是user类型的值的指针调用的方法。</p>
<pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   ad := admin{
      user: user{
         name:  <span class="string">"john smith"</span>,
         email: <span class="string">"john@yohoo.com"</span>,
      },
      level: <span class="string">"super"</span>,
   }

   <span class="comment">// admin类型的值的指针也可以传入</span>
   sendNotification(&amp;ad)  <span class="comment">// Sending admin email to john smith&lt;john@yohoo.com&gt;</span>
   sendNotification(&amp;ad.user) <span class="comment">// Sending user email to john smith&lt;john@yohoo.com&gt;</span>
}
</code></pre>
<h3 id="公开或未公开的标识符"><a class="markdownIt-Anchor" href="#公开或未公开的标识符"></a> 公开或未公开的标识符</h3>
<p>定义一个<code>counters/counters.go</code></p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> counters

<span class="comment">// 未公开类型</span>
<span class="keyword">type</span> alertCounter <span class="keyword">int</span>

</code></pre>
<p>此时在主程序中调用该类型</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
   <span class="string">"demo/counters"</span>
   <span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   counter := counters.alertCounter(<span class="number">10</span>)
   fmt.Println(counter)
   <span class="comment">/*
   .\main.go:9:13: cannot refer to unexported name counters.alertCounter
   .\main.go:9:13: undefined: counters.alertCounter
    */</span>

}

</code></pre>
<p>在Go中，当一个标识符以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。当一个标识符以大写字母开头，其就是公开的，即包外可见。修改上述程序：</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> counters

<span class="comment">// 公开类型</span>
<span class="keyword">type</span> AlertCounter <span class="keyword">int</span>

=======================================

<span class="keyword">package</span> main

<span class="keyword">import</span> (
   <span class="string">"demo/counters"</span>
   <span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
   counter := counters.AlertCounter(<span class="number">10</span>)
   fmt.Println(counter) <span class="comment">// 10</span>
}

</code></pre>
<p>或者在不修改<code>counter.go</code>中<code>alertCounter</code>的情况下，也可以使用以下方式调用未公开的类型：</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> counters

<span class="comment">// 未公开类型</span>
<span class="keyword">type</span> alertCounter <span class="keyword">int</span>

<span class="comment">// 创建并返回一个alertCounter类型的值</span>
<span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">alertCounter</span></span>  {
   <span class="keyword">return</span> alertCounter(value)
}

===========================================
<span class="keyword">package</span> main

<span class="keyword">import</span> (
	<span class="string">"demo/counters"</span>
	<span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	counter := counters.New(<span class="number">10</span>)
	fmt.Println(counter) <span class="comment">// 10</span>
}

</code></pre>
<p>我们可以实现工厂函数，来返回一个未公开类型的值。Go语言习惯将工厂函数命名为<code>New</code>，它创建了一个未公开类型的值，并将其返回给调用者。该程序能通过编译，需要两个条件：第一、公开或未公开的标识符不是一个值；第二、短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> entities

<span class="keyword">type</span> User <span class="keyword">struct</span> {
   Name <span class="keyword">string</span>
   <span class="comment">// 未公开字段</span>
   email <span class="keyword">string</span>
}

==================

<span class="keyword">package</span> main

<span class="keyword">import</span> (
	<span class="string">"demo/entities"</span>
	<span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	u := entities.User{
		Name:  <span class="string">"Bill"</span>,
		email: <span class="string">"bill@email.com"</span>,
		<span class="comment">// unknown field 'email' in struct literal of type entities.User</span>
	}
	fmt.Println(u)
}

</code></pre>
<p>上述代码出错，是由于<code>email</code>字段首字母为小写，是不公开字段。下面看展示公开和未公开的内嵌类型是如何工作的。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> entities

<span class="keyword">type</span> user <span class="keyword">struct</span> {
   Name <span class="keyword">string</span>
   Email <span class="keyword">string</span>
}

<span class="keyword">type</span> Admin <span class="keyword">struct</span> {
   user <span class="comment">// 嵌入的类型未公开</span>
   Rights <span class="keyword">int</span>
}

=====================

<span class="keyword">package</span> main

<span class="keyword">import</span> (
	<span class="string">"demo/entities"</span>
	<span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	a := entities.Admin{
		Rights: <span class="number">10</span>,
	}

	a.Name = <span class="string">"Bill"</span>
	a.Email = <span class="string">"bill@email.com"</span>

	fmt.Println(a)
}

</code></pre>
<p>上述代码无法直接通过结构字面量的方式初始化该内部类型。但即便内部类型是未公开，内部类型里声明的字段依旧是公开的，。既然内部类型的标识符提升到了外部类型，这些公开字段也可以通过外部类型的字段的值来访问。</p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实践篇03--Spring Cloud Eureka]]></title>
      <url>/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%AE%9E%E8%B7%B5%E7%AF%8703--Spring%20Cloud%20Eureka/</url>
      <content type="html"><![CDATA[<p><code>Spring Cloud Eureka</code>是<code>Spring Cloud Netflix</code>微服务套件中的一部分，它基于<code>Netflix Eureka</code>的二次封装，主要是负责完成微服务架构的服务治理能力。我们只需通过简单引入依赖和注解配置就能使<code>Spring Boot</code>构建的微服务应用轻松地与Eureka服务治理体系进行整合。下面将构建用于服务治理的基础设施：</p>
<ul>
<li>构建服务注册中心</li>
<li>服务注册与服务发现</li>
<li>Eureka的基础架构</li>
<li>Eureka的服务治理机制</li>
<li>Eureka的配置</li>
</ul>
<h2 id="服务治理"><a class="markdownIt-Anchor" href="#服务治理"></a> 服务治理</h2>
<p>服务治理是微服务架构中最为核心和基础的模块，主要用于实现各个微服务实例的自动化注册与发现。随着业务的发展、功能的复杂、微服务应用的增加，静态配置维护难度会递增，且面对不断发展的业务，集群规模、服务位置和命名都有可能改变，手工维护的方式容易导致错误和冲突。</p>
<p>因此为了解决微服务架构中实例维护问题，出现了许多服务治理框架和产品，他们的实现主要都围绕着服务注册与服务发现机制来实现对微服务应用实例的自动化管理。</p>
<ul>
<li>服务注册：在服务治理框架中，会构建一个注册中心，每个服务向注册中心登记自己提供的服务，将主机、端口号、通信协议等信息告知。注册中心会在服务启动和注册后，维护一个服务清单，并以心跳的方式检测清单中的服务是否可用，若不可用则剔除，以达到排除故障的效果。</li>
<li>服务发现：由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来发现，而是通过向服务名发起请求调用实现。所以，服务调用放在调用服务提供方接口时，并不知道具体的服务实例位置。因此调用发需要向服务注册中心咨询服务，并获取所有的服务的实例清单，以实现对具体服务实例的访问。</li>
</ul>
<h2 id="netflix-eureka"><a class="markdownIt-Anchor" href="#netflix-eureka"></a> Netflix Eureka</h2>
<p><code>Spring Cloud Eureka</code>,使用<code>Netflix Eureka</code>实现服务注册与发现，既包含服务端组件，也包含客户端组件，提供了完备的RESTful API，支持将非Java语言构建的微服务纳入其服务治理体系中。</p>
<p>Eureka服务端，也称为服务注册中心，支持高可用配置，依托于强一致性提供良好的服务实例可用性，可以应对多重不同的故障场景。当Eureka以集群模式部署，集群中有分片出现故障时，Eureka会转入自动保护模式。它允许分片故障期间继续提供服务的发现和注册，当故障分片回复运行时，集群中其它分片会它们的状态再次同步回来。</p>
<p>Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入到客户端应用程序的代码中，当应用程序运行时，客户端向注册中心注册自身的提供的服务，并周期性地发送心跳来更新它的服务租约。同时它也能从服务端查询当前注册的服务信息并将它们缓存到本地并周期地刷新服务状态。</p>
<h3 id="搭建服务注册中心"><a class="markdownIt-Anchor" href="#搭建服务注册中心"></a> 搭建服务注册中心</h3>
<p>创建一个Spring Boot工程<code>enreka-server</code>，在<code>pom.xml</code>中引入相关依赖：</p>
<pre class="highlight"><code class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>
<span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>
   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>

   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>

   <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span>
   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>

   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>
      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>
   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>

   <span class="tag">&lt;<span class="name">properties</span>&gt;</span>
      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>
      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>
      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>
      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>

   <span class="comment">&lt;!-- eureka服务依赖 --&gt;</span>
   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>
      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>

   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>
      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>
         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring-cloud.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>
            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>
         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>

   <span class="tag">&lt;<span class="name">build</span>&gt;</span>
      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>
         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>
            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">build</span>&gt;</span>

<span class="tag">&lt;/<span class="name">project</span>&gt;</span>
</code></pre>
<p>在项目启动器中添加<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其他应用进行对话。</p>
<pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaserver;

<span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

<span class="meta">@EnableEurekaServer</span>
<span class="meta">@SpringBootApplication</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      SpringApplication.run(EurekaServerApplication.class, args);
   }
}

</code></pre>
<p>默认情况下，该服务注册中心也会将自己作为客户端进行注册。可在配置文件<code>application.yml</code>中禁用该项:</p>
<pre class="highlight"><code class="yaml"><span class="attr">spring:</span>
<span class="attr">  application:</span>
<span class="attr">    name:</span> <span class="string">Eureka-Server</span>
<span class="attr">server:</span>
<span class="attr">  port:</span> <span class="number">10000</span>
<span class="attr">eureka:</span>
<span class="attr">  instance:</span>
<span class="attr">    hostname:</span> <span class="string">localhost</span>
<span class="attr">  client:</span>
<span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span>
<span class="attr">    fetch-registry:</span> <span class="literal">false</span>  <span class="comment"># 注册中心的职责是维护服务实例，不需要检索服务</span>
</code></pre>
<p>启动应用，并访问<code>http://localhost:10000</code>，界面如下：</p>
<p><img src="/article/微服务/Micro Service/实践篇03--Spring Cloud Eureka/eureka-server.png" alt="无法加载" title="服务注册中心"></p>
<p>此时可见<code>Instances currently registered with Eureka</code>为空，这是因为还没有服务向注册中心注册。</p>
<h3 id="构建服务"><a class="markdownIt-Anchor" href="#构建服务"></a> 构建服务</h3>
<p>接下来构建一个微服务向服务中心注册自己。新建Spring Boot项目<code>eureka-client</code>，在<code>pom.xml</code>添加依赖：</p>
<pre class="highlight"><code class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>
<span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>
   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>

   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>

   <span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">name</span>&gt;</span>
   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>

   <span class="tag">&lt;<span class="name">parent</span>&gt;</span>
      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>
   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>

   <span class="tag">&lt;<span class="name">properties</span>&gt;</span>
      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>
      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>
      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>
      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>

   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>
      <span class="comment">&lt;!-- 添加Eureka依赖 --&gt;</span>
      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>
      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>

      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>

   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>
      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>
         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring-cloud.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>
            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>
            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>
         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>

   <span class="tag">&lt;<span class="name">build</span>&gt;</span>
      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>
         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>
            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>
      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>
   <span class="tag">&lt;/<span class="name">build</span>&gt;</span>

<span class="tag">&lt;/<span class="name">project</span>&gt;</span>
</code></pre>
<p>添加<code>/hello</code>接口，通过注入<code>DiscoveryClient</code>对象，在日志中输出服务的相关信息。</p>
<pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaclient;

<span class="keyword">import</span> org.apache.log4j.Logger;
<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;
<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="comment">/**
 * <span class="doctag">@author</span> Yov
 * <span class="doctag">@date</span> 2018/1/14 20:10
 */</span>
<span class="meta">@RestController</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(getClass());

    <span class="meta">@Autowired</span>
    <span class="keyword">private</span> DiscoveryClient discoveryClient; <span class="comment">// 用于获取服务</span>

    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)
    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>{
        discoveryClient.getServices().forEach(id -&gt; {
            discoveryClient.getInstances(id).forEach(instance -&gt; {
                <span class="comment">// 在日志中输出服务的相关信息</span>
                logger.info(<span class="string">"Hello, host:"</span> + instance.getHost() +
                        <span class="string">", server_id: "</span> + instance.getServiceId());
            });
        });
        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;
    }
}

</code></pre>
<p>在程序入口添加<code>@EnableDiscoveryClient</code>注解，激活Eureka中的<code>DiscoveryClient</code>(自动化配置，创建<code>DiscoveryClient</code>接口针对Eureka的<code>EnrekaDiscoveryClient</code>实例)，这样才能实现Controller中对服务信息的输出。</p>
<pre class="highlight"><code class="java"><span class="keyword">package</span> com.example.eurekaclient;

<span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="meta">@EnableDiscoveryClient</span>
<span class="meta">@SpringBootApplication</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      SpringApplication.run(EurekaClientApplication.class, args);
   }
}
</code></pre>
<p>修改配置文件<code>application.yml</code></p>
<pre class="highlight"><code class="yaml"><span class="attr">spring:</span>
<span class="attr">  application:</span>
<span class="attr">    name:</span> <span class="string">hello-service</span>  <span class="comment"># 为服务命名</span>
<span class="attr">eureka:</span>
<span class="attr">  client:</span>
<span class="attr">    service-url:</span>
<span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka</span> <span class="comment"># 为服务指定注册中心</span>
<span class="attr">server:</span>
<span class="attr">  port:</span> <span class="number">10001</span>
</code></pre>
<p>启动服务后，可以在<code>eureka-client</code>控制台看到如下信息：</p>
<pre class="highlight"><code class="verilog">Registering application hello-service <span class="keyword">with</span> eureka <span class="keyword">with</span> status UP
Saw <span class="keyword">local</span> status change <span class="keyword">event</span> StatusChangeEvent [timestamp=<span class="number">1516155585227</span>, current=UP, previous=STARTING]
DiscoveryClient_HELLO-SERVICE/youw:hello-service:<span class="number">10001</span>: registering service...
DiscoveryClient_HELLO-SERVICE/youw:hello-service:<span class="number">10001</span> - registration status: <span class="number">204</span>
Tomcat started on port(s): <span class="number">10001</span> (http)
Updating port to <span class="number">10001</span>
</code></pre>
<p>当访问该服务时，会出现控制台输出如下信息：<code>Hello, host:youw, server_id: HELLO-SERVICE</code>。</p>
<p>在<code>eureka-server</code>控制台可看到如下信息：<code>Registered instance HELLO-SERVICE/youw:hello-service:10001 with status UP (replication=false)</code>。访问<code>http://localhost:10000</code>，此时可见<code>Instances currently registered with Eureka</code>为增加了一个服务：<code>HELLO-SERVICE</code>。</p>
<h3 id="高可用注册中心"><a class="markdownIt-Anchor" href="#高可用注册中心"></a> 高可用注册中心</h3>
<p>在微服务这样分布式的环境中，需要充分考虑发生故障的情况，所以在生产环节需要对各个组件进行高可用部署。Eureka Server充分考虑了这一点，每一个节点既可以是服务提供者，也可以是服务消费者。服务注册中心也可以向其他服务注册自身。</p>
<p>新建一个项目<code>eureka-center</code>，作为另一个服务注册中心，参照<code>enreka-server</code>，但要修改<code>application.qml</code>文件:</p>
<pre class="highlight"><code class="yaml"><span class="attr">server:</span>
<span class="attr">  port:</span> <span class="number">20000</span>
<span class="attr">spring:</span>
<span class="attr">  application:</span>
<span class="attr">    name:</span> <span class="string">eureka-server</span>
<span class="attr">eureka:</span>
<span class="attr">  instance:</span>
<span class="attr">    hostname:</span> <span class="string">center</span>
<span class="attr">  client:</span>
<span class="attr">    service-url:</span>
<span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka/</span> <span class="comment"># 指向注册中心</span>
</code></pre>
<p>修改<code>eureka-server</code>的<code>application.yml</code>启动:</p>
<pre class="highlight"><code class="yaml"><span class="attr">spring:</span>
<span class="attr">  application:</span>
<span class="attr">    name:</span> <span class="string">eureka-Server</span>
<span class="attr">server:</span>
<span class="attr">  port:</span> <span class="number">10000</span>
<span class="attr">eureka:</span>
<span class="attr">  instance:</span>
<span class="attr">    hostname:</span> <span class="string">localhost</span>
<span class="attr">  client:</span>
<span class="attr">    service-url:</span>
<span class="attr">      defaultZone:</span> <span class="attr">http://center:20000/eureka/</span> <span class="comment"># 指向注册中心</span>
</code></pre>
<p>修改<code>eureka-client</code>的<code>application.yml</code></p>
<pre class="highlight"><code class="yaml"><span class="attr">spring:</span>
<span class="attr">  application:</span>
<span class="attr">    name:</span> <span class="string">hello-service</span>  <span class="comment"># 为服务命名</span>
<span class="attr">eureka:</span>
<span class="attr">  client:</span>
<span class="attr">    service-url:</span>
      <span class="comment"># 同时向两个注册中心注册自己</span>
<span class="attr">      defaultZone:</span> <span class="attr">http://localhost:10000/eureka/,http://center:20000/eureka/</span>
<span class="attr">server:</span>
<span class="attr">  port:</span> <span class="number">10001</span>
</code></pre>
<p>其实启动三个应用程序，访问两个注册中心，均能看到：</p>
<p><img src="/article/微服务/Micro Service/实践篇03--Spring Cloud Eureka/%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="无法加载" title="高可用服务注册中心"></p>
<p>此时两个注册中心即使有一个中断了，在另一个注册中心的服务依然可以访问<code>hello-server</code>。</p>
]]></content>
      
        <categories>
            
            <category> 微服务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[打包和工具链]]></title>
      <url>/article/Go/Go%20Base/%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="打包和工具链"><a class="markdownIt-Anchor" href="#打包和工具链"></a> 打包和工具链</h2>
<h3 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h3>
<p>Go程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，以标准库中的http包为例：</p>
<pre class="highlight"><code class="xml">net/http/
     cgi/
     cookiejar/
        testdata/
     fcgi/
     httptest/
     httputil/
     pprof/
     testdata/
</code></pre>
<p>这些目录将实现HTTP服务器、客户端、测试工具和性能调试工具的相关代码拆分成功能清晰、小的代码单元。以<code>cookiejar</code>包为例，这个包里包含了存储与获取网页会话上的cookie相关代码。每个包都可以单独导入和使用。</p>
<p>所有的go文件，除了空行和注释都应该在第一行声明自己所属的包，每个包都在单独的目录里，不能将多个包放在同一个目录下，也不能把同一包的文件拆分到不同目录中。</p>
<h4 id="包的命名原则"><a class="markdownIt-Anchor" href="#包的命名原则"></a> 包的命名原则</h4>
<p>包名应使用简洁、清晰且全小写的名字。</p>
<h4 id="main包"><a class="markdownIt-Anchor" href="#main包"></a> main包</h4>
<p><code>main</code>包具有特殊含义，Go的编译器会将其编译为二进制可执行文件。所有Go编译的可执行文件都必须有一个<code>main</code>包。当编译器发现main包后，会寻找<code>main()</code>，然后创建可执行文件。main()是程序的入口，程序编译时会使用声明<code>main包</code>的代码所在的目录的目录名作为二进制可执行文件的文件名。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// fmt包提供格式化输出功能</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	fmt.Println(<span class="string">"Hello World!"</span>)
}
</code></pre>
<p>此时可在<code>$GOPATH/src/hello</code>目录执行<code>go build</code>，会生成一个二进制文件，该文件会根据系统改变文件形式，比如在windows上会变为<code>hello.exe</code>。此时执行该程序，会在控制台显示<code>Hello World!</code>。如果将包名改为其他，编译器会认为其只是一个包，而不是命令。</p>
<h3 id="导入"><a class="markdownIt-Anchor" href="#导入"></a> 导入</h3>
<p><code>import</code>告诉编译器要导入包的路径。如果要导入多个包，可按照如下格式：</p>
<pre class="highlight"><code class="go"><span class="keyword">import</span> (
  <span class="string">"fmt"</span>
  <span class="string">"strings"</span>  <span class="comment">// strings包提供关于字符串的操作，如查找、替换和变换</span>
)
</code></pre>
<p>编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。开发者创建的包会在<code>GOPATH</code>环境变量指定的目录里查找。<code>GOPATH</code>指订的目录就是开发者的个人工作空间。如果Go安装在<code>/user/local/go</code>，并把<code>GOPATH</code>设置为<code>/home/myproject:/home/mylibraries</code>，编译器会按照以下顺序查找<code>net/http</code>包：</p>
<pre class="highlight"><code class="">/usr/local/go/src/pkg/net/http
/home/myproject/src/net/http
/home/mylibraries/src/net/http
</code></pre>
<p>如果编译器找到满足的包，就会停止查找。编译器会优先查找Go的安装目录，然后才是GOPATH中的目录。</p>
<h4 id="远程导入"><a class="markdownIt-Anchor" href="#远程导入"></a> 远程导入</h4>
<p>目前趋势是，使用分布式版本控制系统（Distributed Version Control Systems, <code>DVCS</code>）分享代码。Go的工具链支持远程导入。如：</p>
<pre class="highlight"><code class="go"><span class="keyword">import</span> <span class="string">"github.com/spf13/viper"</span>	
</code></pre>
<p>编译程序时，编译器会通过<code>go get</code>根据指定的URL获取包。</p>
<h4 id="命名导入"><a class="markdownIt-Anchor" href="#命名导入"></a> 命名导入</h4>
<p>当要导入的多个包具有相同名字时，可以为其定义别名，格式如下：</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
  <span class="string">"fmt"</span>
  myfmt <span class="string">"mylib.fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
  fmt.Println(<span class="string">"Hello"</span>)
  myfmt.Println(<span class="string">"Hello"</span>)
}
</code></pre>
<p>当导入一个包，但不使用它，Go编译器会编译失败，并输出一个错误。这样会避免代码变得臃肿。有时可能需要导入一个包，但不需要引用该包的标识符，此时可以使用空白标识符<code>_</code>来重命名这个导入。</p>
<blockquote>
<p>空白标识符  下划线<code>_</code>在Go中被称为空白标识符，用来i抛弃不想继续使用的值，比如忽略函数返回的不需要的值。</p>
</blockquote>
<h3 id="函数-init"><a class="markdownIt-Anchor" href="#函数-init"></a> 函数 init</h3>
<p>每个包都可以包含任意多个<code>init</code>函数，这些函数会在程序开始执行的时间被调用。<code>init</code>函数会在<code>main</code>函数之前执行。<code>init</code>函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。</p>
<p>例子：以数据库驱动为例，<code>database</code>下的驱动在启动时执行<code>init</code>函数会被自身注册到sql包中，因为sql包在编译时并不知道这些驱动的存在，等启动后sql才会调用这些驱动，其代码实现如下：</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> postgres

<span class="keyword">import</span> <span class="string">"database/sql"</span>

<span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  {
	<span class="comment">// 创建一个postgres驱动的实例，此处不进行细节定义</span>
	sql.Register(<span class="string">"postgres"</span>, <span class="built_in">new</span>(PostgresDriver)) 
}
</code></pre>
<p>这段示例代码包含在PostgreSQL数据库的驱动中，如果程序导入了这个包，就会调用<code>init</code>函数，促使驱动注册到GO的<code>sql</code>包中成为一个可用驱动。</p>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
	<span class="string">"database/sql"</span>
	_ <span class="string">"./postgres"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	sql.Open(<span class="string">"postgres"</span>, <span class="string">"mydb"</span>)
}
</code></pre>
<p>在使用这个新的数据库驱动写程序时，使用空白标识符导入包，以便新的驱动会包含到<code>sql</code>包中，这样就可以让<code>init</code>函数被调用运行，且不会由于没有使用这个包中方法而产生错误。</p>
<h3 id="使用go的工具"><a class="markdownIt-Anchor" href="#使用go的工具"></a> 使用Go的工具</h3>
<pre class="highlight"><code class="shell">λ go
Go is a tool for managing Go source code.

Usage:

        go command [arguments]

The commands are:

        build       compile packages and dependencies
        clean       remove object files
        doc         show documentation for package or symbol
        env         print Go environment information
        bug         start a bug report
        fix         run go tool fix on packages
        fmt         run gofmt on package sources
        generate    generate Go files by processing source
        get         download and install packages and dependencies
        install     compile and install packages and dependencies
        list        list packages
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         run go tool vet on packages

Use "go help [command]" for more information about a command.

Additional help topics:

        c           calling between Go and C
        buildmode   description of build modes
        filetype    file types
        gopath      GOPATH environment variable
        environment environment variables
        importpath  import path syntax
        packages    description of package lists
        testflag    description of testing flags
        testfunc    description of testing functions

Use "go help [topic]" for more information about that topic.
</code></pre>
<ul>
<li>编译源代码使用<code>go build xx.go</code></li>
<li>删除编译生成的可执行文件<code>go clean xx.go</code></li>
</ul>
<p>范例：编写代码获取text文本中的内容长度。</p>
<pre class="highlight"><code class="go">---------------------- count.<span class="keyword">go</span> ------------------------------
<span class="keyword">package</span> words

<span class="keyword">import</span> <span class="string">"strings"</span>

<span class="function"><span class="keyword">func</span> <span class="title">CountWords</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="params">(count <span class="keyword">int</span>)</span></span> {
    <span class="comment">// 计算文本长度</span>
	count = <span class="built_in">len</span>(strings.Fields(text))
	<span class="keyword">return</span>
}
---------------------- main.<span class="keyword">go</span> -------------------------------
<span class="keyword">package</span> main

<span class="keyword">import</span> (
	<span class="string">"os"</span>
	<span class="string">"io/ioutil"</span>
	<span class="string">"../words"</span>   <span class="comment">// 导入上述的包</span>
	<span class="string">"fmt"</span>
)

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {
	filename := os.Args[<span class="number">1</span>]

	contents, err := ioutil.ReadFile(filename)
	<span class="keyword">if</span> err != <span class="literal">nil</span> {
		fmt.Println(<span class="string">"There was an error opening the file:"</span>, err)
		<span class="keyword">return</span>
	}

	text := <span class="keyword">string</span>(contents)
	count := words.CountWords(text)
	fmt.Printf(<span class="string">"There are %d words in your text. \n"</span>, count)
}
</code></pre>
<p>直接使用<code>go build</code>，go编译器会默认使用<code>当前目录</code>编译。</p>
<p>可以指定包编译<code>go build xxx/xxx</code>，</p>
<p>也可以使用通配符<code>...</code>,会编译目录下所有包<code>go build xx/xx/...</code></p>
<p>要执行程序，需要先编译，虽然执行生成的可执行文件。此处可以使用<code>go run</code>完成一次性完成这两步，该命令会先构建<code>main.go</code>里包含的程序，然后执行创建后的程序。</p>
<h3 id="go开发工具"><a class="markdownIt-Anchor" href="#go开发工具"></a> Go开发工具</h3>
<h4 id="go-vet"><a class="markdownIt-Anchor" href="#go-vet"></a> go vet</h4>
<p><code>go vet</code>会帮助开发人员检测代码常见的错误，可以捕获以下类型错误：</p>
<ul>
<li><code>Printf</code>类函数调用时，类型匹配错误的参数；</li>
<li>定义常用方法时，方法签名的错误</li>
<li>错误的结构标签</li>
<li>没有指定字段名的结构字面量</li>
</ul>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	fmt.Printf(<span class="string">"There is dogs"</span>, <span class="number">3</span>)
}
</code></pre>
<p>上述程序要输出一个整数3，但是格式化字符串中没有对应的格式化参数，执行<code>go vet</code>会得到如下信息：</p>
<pre class="highlight"><code class="shell">λ go vet main.go
main.go:6: no formatting directive in Printf call
</code></pre>
<h4 id="go-fmt"><a class="markdownIt-Anchor" href="#go-fmt"></a> go fmt</h4>
<p><code>go fmt</code>会自动格式化源代码文件并保存。</p>
<h4 id="go语言开发文档"><a class="markdownIt-Anchor" href="#go语言开发文档"></a> Go语言开发文档</h4>
<ul>
<li>从命令行获取文档</li>
</ul>
<p>比如要了解<code>fmt</code>包相关信息，就可以使用命令 <code>go doc fmt</code>。就能获取<code>fmt</code>包的详细信息，比如函数，格式化参数等。</p>
<ul>
<li>浏览器查看文档</li>
</ul>
<p>使用<code>godoc -http=:port</code>，此时就可以打开浏览器输入<code>ip:port</code>查看Go的文档</p>
<ul>
<li>给代码编写文档</li>
</ul>
<p>GO文档工具也支持开发人员自己写的代码。如果开发人员按照规则来编写代码，这些代码也会自动包含在<code>godoc</code>生成的文档中。</p>
<p>用户可以在标识符前，将文档内容作为注释添加到代码中。注释可以以<code>//</code>开头，也可以以<code>/**/</code>。此外还可以在包中添加<code>doc.go</code>，其包名与包一致，将包的介绍使用注释加载包名声明之前。</p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础篇02--微服务架构综述]]></title>
      <url>/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%9F%BA%E7%A1%80%E7%AF%8702--%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BB%BC%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="微服务架构综述"><a class="markdownIt-Anchor" href="#微服务架构综述"></a> 微服务架构综述</h2>
<h3 id="什么是微服务架构"><a class="markdownIt-Anchor" href="#什么是微服务架构"></a> 什么是微服务架构</h3>
<blockquote>
<p>微服务架构是一种架构模式，它提倡将单一的应用程序划分为一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。                                                                      ---------Martin Fowler</p>
</blockquote>
<h4 id="微服务要多微"><a class="markdownIt-Anchor" href="#微服务要多微"></a> 微服务要多“微”？</h4>
<p>微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低且高度自治的一组服务，每个服务都是很小的应用，那么“微”的程度到底是怎样的？</p>
<p>由于不同语言有不同特点，不同功能的替换或重写很大程度取决于成员的能力，因此代码行数的多少以及重写时间的长短都不能用于衡量“微”。</p>
<p>微服务的“微”并不是一个真正可衡量、看得见、摸得着的微，其所表达是一种设计思想和指导方针。这需要团队觉得合适，在此之前应遵循以下两个基本前提：</p>
<ul>
<li>业务独立性</li>
</ul>
<p>应保证微服务具有业务独立性的单元，并不是只是为了微而微。</p>
<ul>
<li>团队自主性</li>
</ul>
<p>团队应该由不同技能、不同角色的成员组成且团队规模要小。</p>
<h4 id="单一职责"><a class="markdownIt-Anchor" href="#单一职责"></a> 单一职责</h4>
<p>编写代码的原则是“高内聚，低耦合”。高内聚指的是一个模块中各个元素彼此结合紧密；低耦合指的是一个完整的系统中，模块与模块之间应尽可能独立存在。符合该原则的系统具有良好的重用性、可维护性和扩展性，能够持续支持业务的发展。</p>
<p>面向对象的设计中有“SOLID”原则，S指的是SRP（<code>Single Responsibility Principle</code>，单一职责原则）：即一个对象应该只有一个发生变化的原因，如果该对象可以被多个原因改变，则其承担了多个职责。</p>
<p>Linux中的每个命令都独立负责一个功能，但命令与命令可以通过管道连接起来可以实现更强大的功能。类似的，对于每个服务而言，我们希望它处理的业务逻辑能够单一，在服务架构层面遵循单一职责原则。即微服务架构中的每个服务都是具有业务逻辑 ，符合高内聚、低耦合原则以及单一职责原则的单元，不同服务通过“管道”方式灵活组合，从而构建庞大的系统。</p>
<h4 id="轻量级通信"><a class="markdownIt-Anchor" href="#轻量级通信"></a> 轻量级通信</h4>
<p>服务之间应该通过轻量级的通信机制，实现彼此的互通互联，互相协作。所谓轻量级通信机制，通常指语言无关、平台无关的交互方式。</p>
<p>对于轻量级通信的格式而言，XML或JSON的解析与使用基本与语言无关、平台无关。对于轻量级通信的协议而言，通常基于HTTP，能让服务间的通信变得标准化且无状态化。REST(<code>Representational State Transfer</code>）是实现服务之间互相协作的轻量级通信机制之一。</p>
<p>对于微服务而言，通过使用语言无关、平台无关的轻量级通信机制，使服务与服务之间的协作变得更加标准化，这就意味着团队可以选择更合适的语言、工具或者平台来开发服务本身。</p>
<h4 id="独立性"><a class="markdownIt-Anchor" href="#独立性"></a> 独立性</h4>
<p>独立性指在应用交付的过程中，开发、测试以及部署的独立。</p>
<p>传统单块架构应用，所有功能都存在于同一块代码块中，当修改某部分时，容易出现功能之间互相影响，即功能的开发不具有独立性。此外，但代码实现后，需要集成、回归测试，才能保证功能互相配合、正常工作且互不影响，因此测试过程不具有独立性。当测试完毕，单块应用被部署后，由于某个特性存在缺陷将导致部署失败或回滚。</p>
<p>因此单块架构中，功能的开发、测试、构建以及部署耦合度较高。</p>
<p>微服务架构中，每个服务都是独立的业务单元，服务与服务之间是独立的：</p>
<ul>
<li>每个服务都有独立的代码库，从代码库的层面，服务与服务是隔离的；</li>
<li>每个服务都有独立的测试机制，从测试的角度而言，服务与服务之间是松耦合的；</li>
<li>构建包是独立的，部署流程是也是独立的，服务能运行在不同进程中。从部署角度考虑，服务与服务之间也是高度解耦的</li>
</ul>
<h4 id="进程隔离"><a class="markdownIt-Anchor" href="#进程隔离"></a> 进程隔离</h4>
<p>单块架构应用，所有功能都运行在同一进程中，当要部署时，需要停掉当前的应用，无法独立部署。为了提高代码的重用以及可维护性，在应用开发中，开发人员会将重复的代码提取出来，封装成组件（此处指的是可以独立审升级、替换掉的部分）。在传统的单块架构中，组件的通常形态叫共享库，例如JAR包或DLL。应用程序在运行时，所有的组件最终也会被加载到同一进程中运行。</p>
<p>微服务架构中，应用程序由多个服务组成，每个服务都具一个高度自制的独立业务实体。每个服务都能运行在一个独立的操作系统进程中，这意味着不同服务能被部署到不同主机上。理论上，能将多个服务部署到同一节点上，但这样增加了部署和扩展的复杂度。</p>
<p>综上所诉，微服务架构其实是将单一的应用程序划分为一组小的服务，每个服务都具有业务属性的独立单元，同时能够被独立开发、独立运行、独立测试以及独立部署。</p>
<h3 id="微服务架构与soa"><a class="markdownIt-Anchor" href="#微服务架构与soa"></a> 微服务架构与SOA</h3>
<p>面向服务架构<code>SOA</code>，对于复杂的企业IT系统，应按照不同的，可重用的粒度划分，将功能相关的一组功能提供者组织在一起为消费者服务。其目的是为了解决企业内部不同IT系统资源之间无法互联而导致的信息孤岛问题。</p>
<h4 id="微服务与soa"><a class="markdownIt-Anchor" href="#微服务与soa"></a> 微服务与SOA</h4>
<table>
<thead>
<tr>
<th>SOA实现</th>
<th>微服务架构实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>企业级，自上向下开展实施</td>
<td>团队级，自下向上开展实施</td>
</tr>
<tr>
<td>服务由多个子系统组成，力粒度大</td>
<td>一个系统被拆分成多个服务，粒度细</td>
</tr>
<tr>
<td>企业服务总线，集中式的服务架构</td>
<td>无集中式总线，松散的服务架构</td>
</tr>
<tr>
<td>集成方式复杂（ESB/WS/SOAP）</td>
<td>集成方式简单（HTTP/REST/JSON）</td>
</tr>
<tr>
<td>单块架构系统，相互依赖，部署复杂</td>
<td>服务能独立部署</td>
</tr>
</tbody>
</table>
<h3 id="微服务的本质"><a class="markdownIt-Anchor" href="#微服务的本质"></a> 微服务的本质</h3>
<ul>
<li>服务作为组件</li>
<li>围绕业务组织团队</li>
<li>关注产品而非项目</li>
<li>技术多样性</li>
<li>业务数据独立</li>
<li>基础设施自动化</li>
<li>演进式架构</li>
</ul>
<h4 id="服务作为组件"><a class="markdownIt-Anchor" href="#服务作为组件"></a> 服务作为组件</h4>
<p>软件领域一直提倡使用组件<code>Component</code>的方式将应用模块化并为其构建相对独立的单元。传统实现组件的方式是给独立的部分或者抽取公用部分构建库<code>Library</code>，从而达到解耦和复用的效果。这样的共享库一般是语言相关、平台相关，且与应用程序运行在同一个进程中。即库的变化可能导致整个应用都要更新，重新部署。</p>
<p>将微服务作为组件，与传统使用组件方式最大的区别是，组件可以被独立部署。即，每个服务的变更仅需重新部署自身，不影响其他服务。</p>
<p>因此，微服务架构的一个优势就是能以松散的服务形式，构建可独立化部署的模块化应用。把服务当成组件的另一个优点是，组件和组件之间定义了清晰的、语言无关的、平台无关的接口。许多开发虽然有良好的公共调用接口，但依赖于特定平台和语言，导致组件间耦合度高。</p>
<p>微服务通过语言无关、平台无关的轻量级通信机制协作，灵活性高。不足的是分布式调用比进程内调用更消耗时间，且严重依赖于网络的可靠性与稳定性。</p>
<h4 id="围绕业务组织团队"><a class="markdownIt-Anchor" href="#围绕业务组织团队"></a> 围绕业务组织团队</h4>
<p>微服务架构团队组织方式提倡以业务为核心，按照业务能力来组织团队，团队中的成员具有多样性的技能。单块应用架构根据技能划分团队。</p>
<h4 id="关注产品而非项目"><a class="markdownIt-Anchor" href="#关注产品而非项目"></a> 关注产品而非项目</h4>
<blockquote>
<p>项目模式：当项目启动后，企业或组织根据不通过的技能资源池中抽取相关的资源，组成团队并完成项目，</p>
</blockquote>
<p>单块架构应用大部分是基于项目模式构建，其弊端如下：</p>
<ul>
<li>团队成员缺乏主人翁精神；</li>
<li>难以制定有效的奖惩机制；</li>
<li>团队成员缺乏产品成就感。</li>
</ul>
<p>微服务架构提倡的是采用产品模式构建，即让团队负责整个服务的生命周期，从服务的分析、开发、测试、部署、运维，所有成员的个人目标和团队目标一致，都是为了更有效、高效、以可持续性发展的方式为消费者提供服务。最终目标是通过多个服务的协调、组合实现产品的功能，以及传递价值。</p>
<h4 id="技术多样性"><a class="markdownIt-Anchor" href="#技术多样性"></a> 技术多样性</h4>
<p>传统的单块应用架构，倾向于采用统一的技术皮平台或方案解决问题。</p>
<p>微服务架构中，提倡针对不同的业务特征选择合适的技术方案，有针对性地解决具体的业务问题。</p>
<h4 id="业务数据独立"><a class="markdownIt-Anchor" href="#业务数据独立"></a> 业务数据独立</h4>
<p>传统的单块应用架构，多采用统一的数据存储平台来存储所有数据。随着业务快速发展，需求不断变化，数据变得复杂难以管理，同时随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的继承作用。</p>
<p>传统的数据库大多是关系型数据库，存储的信息以结构化信息为主，但随着互联网的快速发展，其维护成本会越来越高。</p>
<p>微服务架构提倡服务自主管理其相关的业务数据，这样的优势在于：</p>
<ul>
<li>能随着业务发展，提供业务数据接口集成，而不是以数据库的方式同其他服务集成；</li>
<li>能随着业务发展，选择更合适的工具管理或者迁移业务理数据。</li>
</ul>
<h4 id="基础服务自动化"><a class="markdownIt-Anchor" href="#基础服务自动化"></a> 基础服务自动化</h4>
<p>传统单块架构应用只需要部署一次就能上线。而微服务架构将应用分为多个小的服务，需要对每个服务分别部署，此外每个服务都需要部署带来的健康监控、错误回滚等，这会导致部署和运维的成本随着服务的增多呈指数级增长。</p>
<p>因此微服务需要更稳定的基础设置自动化机制，能够创建运行环境、安装依赖、部署应用。</p>
<h4 id="演进式架构"><a class="markdownIt-Anchor" href="#演进式架构"></a> 演进式架构</h4>
<h3 id="微服务不是银弹"><a class="markdownIt-Anchor" href="#微服务不是银弹"></a> 微服务不是银弹</h3>
<p>微服务的优势性在于独立性、单一职责、技术多样性。此外微服务的实施也会推动基础设施自动化以及DevOps文化在团队中的发展，有利于构建全功能的团队。</p>
<p>微服务在实施的过程中需要考虑如下因素：</p>
<ul>
<li>分布式系统的复杂度</li>
<li>运维成本</li>
<li>部署自动化</li>
<li>DevOps与组织架构</li>
<li>服务间依赖测试</li>
<li>服务间依赖管理</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 微服务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDEA中Spring Boot实现热部署]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/Tool/IDEA%E4%B8%ADSpringBoot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>IntelliJ IDEA 作为当下较为热门的Java IDE,当使用Spring Boot进行开发时，由于静态页面经常修改，每次重启十分麻烦。因此实现Spring Boot热部署尤为重要。</p>
</blockquote>
<h3 id="devtools"><a class="markdownIt-Anchor" href="#devtools"></a> Devtools</h3>
<p>Spring为开发者提供了spring-boot-devtools模块进行Spring Boot热部署,提高了开发效率，无需手动重启应用。使用需要在<code>pom.xml</code>添加如下配置：</p>
<pre class="highlight"><code class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>
<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>

<span class="tag">&lt;<span class="name">plugin</span>&gt;</span>
  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span>
    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>
<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>
</code></pre>
<p>在application.yml中添加配置</p>
<pre class="highlight"><code class="yaml"><span class="attr">  thymeleaf:</span>
<span class="attr">    cache:</span> <span class="literal">false</span>   <span class="comment"># 关闭cache，刷新即可显示新页面</span>
<span class="attr">  devtools:</span>
<span class="attr">    restart:</span>
<span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 启用热部署</span>
<span class="attr">      additional-paths:</span> <span class="string">src/main/resources</span> <span class="comment"># 设置重启目录</span>
</code></pre>
<h3 id="idea设置"><a class="markdownIt-Anchor" href="#idea设置"></a> IDEA设置</h3>
<p>（1）File-&gt;Settings-&gt;Compiler-&gt;Build project automatically，将其打勾。</p>
<p>（2）ctrl + shift + A，在检索框输入Registry，随后找到<code>Compiler autoMake allow when app running</code>，勾选。</p>
<p>重启应用，此时不论是修改java文件还是修改html文件都会自动重新加载，不会重启应用。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个Go程序]]></title>
      <url>/article/Go/Go%20Base/%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="一个go程序"><a class="markdownIt-Anchor" href="#一个go程序"></a> 一个Go程序</h2>
<h3 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h3>
<p><img src="/article/Go/Go Base/一个Go程序/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="无法加载" title="程序架构流程图"></p>
<h3 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h3>
<pre class="highlight"><code class="go">- sample
    - data
        data.json   -- 数据源
    - matchers
        rss.<span class="keyword">go</span>      -- 搜索rss源的匹配器  
    - search
        <span class="keyword">default</span>.<span class="keyword">go</span>  -- 搜索数据用的默认匹配器
        feed.<span class="keyword">go</span>     -- 用于读取json数据文件
        match.<span class="keyword">go</span>    -- 用于支持不同匹配器的接口
        search.<span class="keyword">go</span>   -- 执行搜索的主控制逻辑
    - main
        main.<span class="keyword">go</span>     -- 程序的入口
</code></pre>
<h3 id="main包maingo"><a class="markdownIt-Anchor" href="#main包maingo"></a> main包(main.go)</h3>
<pre class="highlight"><code class="go"><span class="comment">/* 程序入口 */</span>
<span class="keyword">package</span> main

<span class="comment">/* 导入外部包，让用户可以访问其中的标识符 */</span>
<span class="keyword">import</span> (
	<span class="string">"log"</span>
	<span class="string">"os"</span>

	<span class="comment">/* _ "package_name" 该方式是为了调用包中的初始化函数，而不是使用其中的标识符 */</span>
	_ <span class="string">"sample/matchers"</span>
	<span class="string">"sample/search"</span>
)

<span class="comment">// init在main之前调用</span>
<span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  {
	<span class="comment">// 将日志输出到标准输出</span>
	log.SetOutput(os.Stdout)
}

<span class="comment">// main函数是程序的入口</span>
<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
	<span class="comment">// 使用特定项进行搜索</span>
	search.Run(<span class="string">"president"</span>)
}
</code></pre>
<h3 id="search包"><a class="markdownIt-Anchor" href="#search包"></a> search包</h3>
<p>程序所使用的框架和业务逻辑都在search包中，其由4个go文件组成，分别对应一个独立的职责。</p>
<h4 id="searchgo"><a class="markdownIt-Anchor" href="#searchgo"></a> search.go</h4>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础篇01--单块架构及其面临的挑战]]></title>
      <url>/article/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Micro%20Service/%E5%9F%BA%E7%A1%80%E7%AF%8701--%E5%8D%95%E5%9D%97%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/</url>
      <content type="html"><![CDATA[<h2 id="第一部分-基础篇"><a class="markdownIt-Anchor" href="#第一部分-基础篇"></a> 第一部分 基础篇</h2>
<blockquote>
<p>系统的架构设计是每个系统构建过程及其关键的一部分，决定了系统是否能够被正确、有效地构建。</p>
<p><code>系统架构设计</code>描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多重因素，将应用系统划分成不同的部分，并使这些部分相互分工，相互协作，从而为用户提供某种特定价值的方式。</p>
<p>随着面向对象分析、设计模式、企业架构模式等方法论的深入人心，从功能实现、代码组织的角度考虑，系统中不同职责的部分逐渐被划分到了如下三个部分：</p>
<ul>
<li>表示层：聚焦数据显示和用户交互</li>
<li>业务逻辑层：聚焦业务逻辑处理</li>
<li>数据访问层：聚焦数据的存储与访问</li>
</ul>
<p>每层负责的部分更趋向于具体化、细致化，这就是最初的软件三层架构，该架构解决了系统间调用复杂、职责不清的问题，更有效地降低了层与层之间的依赖关系。这是将系统在逻辑上进行划分，而不是物理上划分，即不同层的代码在进行编译、打包、部署后依然运行在同一个进程中。</p>
<p>对于这种功能集中、代码中心化、一个发布包、部署后运行在同一进程的应用程序，通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或项目。</p>
<p>随着业务的扩大，需求的增加，单块架构很难满足业务快速变化的需求：一方面代码的可维护性、扩展性、灵活性在降低；另一方面系统的修改成本、构建以及维护成本在显著增加。</p>
</blockquote>
<h3 id="单块架构及其面临的挑战"><a class="markdownIt-Anchor" href="#单块架构及其面临的挑战"></a> 单块架构及其面临的挑战</h3>
<h4 id="三层应用架构"><a class="markdownIt-Anchor" href="#三层应用架构"></a> 三层应用架构</h4>
<h5 id="三层应用架构的发展"><a class="markdownIt-Anchor" href="#三层应用架构的发展"></a> 三层应用架构的发展</h5>
<p><code>层</code>能帮助我们划分出构成某整体事务的、上下互相支撑的不同部分。层的概念：</p>
<ul>
<li>层能被单独构造；</li>
<li>每层具有区别于其它层的显著特点；</li>
<li>层与层之间能够互相连接，互相支撑，互相作用，相互协作，从而构成一个整体；</li>
<li>层的内部可以被替换成其他可工作的部分，但对整体的影响不大。</li>
</ul>
<p>Web程序开发早期收到面向过程思维以及设计方式的影响，所有的逻辑代码调用相互交错，错综复杂，如早期的PHP、JSP以及ASP便是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，即一层架构。</p>
<p>随着Java、.NET的发展，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，即二层架构。</p>
<p>随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从而为用户提供以及有效组织软件结构的考虑，Web根据职责的不同逐渐被定义在不同的层次，每一层负责的部分更趋向于具体化、细致化，即三层架构。</p>
<h5 id="什么是三层架构"><a class="markdownIt-Anchor" href="#什么是三层架构"></a> 什么是三层架构</h5>
<p>三层架构通常包括表示层、业务逻辑层以及数据访问层、</p>
<ul>
<li>表示层</li>
</ul>
<p>表示层指的是用户使用应用程序时与其交互操作的部分，通过该部分进行交互并获取期望的结果。目前用户接口大部分为Web形式，也可以是桌面软件形式。</p>
<ul>
<li>业务逻辑层</li>
</ul>
<p>业务逻辑层是根据用户输入的信息，进行逻辑计算或业务处理的部分。业务逻辑层主要聚焦应用程序对业务问题的逻辑处理，以及业务流程的操作，它是大部分软件系统区别于其他系统的核心。</p>
<ul>
<li>数据访问层</li>
</ul>
<p>在用户同应用程序交互的过程中就会产生数据，这类数据需要通过某种机制被有效地存储，以便将来使用。这种机制或方法就是数据访问层最关注的部分。它关注的是对原始数据的操作，而不是对数据存储介质，即数据库的操作。</p>
<h5 id="三层架构的优势"><a class="markdownIt-Anchor" href="#三层架构的优势"></a> 三层架构的优势</h5>
<p>三层架构一方面解决了应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接口与实现分离，可以很容易地利用不同的实现来替换原有层次的实现，从而降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。</p>
<p>另一方面，三层架构的出现从某种程度上解决了企业内部如何有效根据技能调配人员，提高生产效率的问题。</p>
<h4 id="单块架构"><a class="markdownIt-Anchor" href="#单块架构"></a> 单块架构</h4>
<h5 id="什么是单块架构"><a class="markdownIt-Anchor" href="#什么是单块架构"></a> 什么是单块架构</h5>
<p>三层架构将应用从逻辑上分为三层，但最终经历编译、打包、部署后，不考虑负载均衡以及水平扩展的情况，最终还是运行在同一台机器的同一个进程中。对于这种功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序，我们称之为单块架构应用。</p>
<h5 id="单块架构的优势"><a class="markdownIt-Anchor" href="#单块架构的优势"></a> 单块架构的优势</h5>
<ul>
<li>
<p>易于开发</p>
</li>
<li>
<p>易于测试</p>
<p>由于所有功能都运行在一个进程中，启动开发环境或将发布包部署到某一环境，一旦启动该进程，就能立即开始策测试。</p>
</li>
<li>
<p>易于部署</p>
</li>
</ul>
<p>所有功能最终都会被打成一个包，因此只需复制该软件包到服务器相应的位置即可。最简单的方式是使用<code>scp</code>远程复制到指定目录下。</p>
<ul>
<li>易于水平伸缩</li>
</ul>
<h5 id="单块架构面临的挑战"><a class="markdownIt-Anchor" href="#单块架构面临的挑战"></a> 单块架构面临的挑战</h5>
<ul>
<li>维护成本增加</li>
</ul>
<p>随着应用程序功能越来越多，团队越来越大，相应的成本必然增加。此外当出现缺陷时，由于引起缺陷的原因组合会比较多，这将导致修复缺陷的成本增加，周期增长。</p>
<p>另外随着代码量增加，在开发人员对全局功能缺乏深度理解下，修复一个缺陷，可能引入其他缺陷。</p>
<ul>
<li>持续交付周期长</li>
</ul>
<p>随着应用程序的功能越来越多，代码越来越复杂，构建和部署的时间也会响应增加。</p>
<ul>
<li>新人培养周期长</li>
</ul>
<p>随着应用程序的功能越来越多，对于新加入的团队成员而言，了解行业背景、熟悉应用程序业务、配置本地开发环境这些任务将消耗其大量的时间。</p>
<ul>
<li>技术选型成本高</li>
</ul>
<p>传统的单块架构系统倾向于采用统一的技术平台或方案解决所有问题。因此对于单块架构的应用而言，初始的技术选型严重限制了将来采用不同语言或框架的能力。</p>
<ul>
<li>可扩展性差</li>
</ul>
<p>（1）垂直扩展：所有代码都运行在同一台服务器上，将会导致应用程序扩展非常困难。相对而言垂直扩展是最容易的，但成本会越来越高；</p>
<p>（2）水平扩展：水平扩展的通常方法是建立一个集群，通过在集群中不断添加新节点，然后借助前端的负载均衡器，将用户请求根据某种算法合理地分配到不同的节点上。</p>
<p>对于单块架构而言，所有程序代码都运行在服务器同一个进程中，则会导致应用程序的水平扩展成本高。比如某部分功能是内存密集型，另一个部分是CPU密集型，当扩展时就需要新节点必须有足够的内存和强劲的CPU。</p>
<ul>
<li>构建全功能团队难</li>
</ul>
<p>单块架构的开发模式在分工时以进呢个为单位，这样的分工会导致任何功能的改变都需要跨团队沟通和协调。</p>
]]></content>
      
        <categories>
            
            <category> 微服务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go语言简介]]></title>
      <url>/article/Go/Go%20Base/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="用go解决现有编程难题"><a class="markdownIt-Anchor" href="#用go解决现有编程难题"></a> 用Go解决现有编程难题</h2>
<h3 id="开发速度"><a class="markdownIt-Anchor" href="#开发速度"></a> 开发速度</h3>
<p>编译一个大型的C或C++项目需要花费较长的时间。而Go使用了更为智能的编译器，简化了解决依赖的算法，最终提高了编译速度。编译Go程序时，编译器只会关注那些被直接引用的库，而不像Java或C那样遍历依赖链中所有依赖的库。</p>
<p>因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出，代价是动态语言不提供静态语言提供的类型安全特性，因此经常需要使用大量的测试套件来避免运行时出现<code>类型错误</code>这类bug。</p>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<p>Go语言对并发的支持是这门语言最重要的特性之一。<code>goroutine</code>很像线程，但它占据的内存远少于线程，且使用它需要的代码更少。<code>channel(通道)</code>是一种内置的数据结构，可以让不同用户在不同的<code>goroutine</code>之间同步发送具有类型的消息，这让编程模型更倾向于在<code>goroutine</code>间发送消息，而不是让多个<code>goroutine</code>争夺同一个数据的试用权。</p>
<h4 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> <code>goroutine</code></h4>
<p><code>goroutine</code>是可以与其它<code>goroutine</code>并行执行的函数，同时也会与主程序并行执行。在其他编程代码中，需要使用线程来完成同样的事，而在Go中会使用同一个线程来执行多个<code>goroutine</code>。例如：用户在写一个Web服务器，希望同时处理不同的Web请求，Java需要写大量额外的代码来使用线程。而在Go中，<code>net/http</code>库直接使用了内置的<code>goroutine</code>，每个请求都自动在自己的<code>goroutine</code>里处理。Go运行时会自动在配置的一组逻辑处理器上调度运行<code>goroutine</code>，每个逻辑处理器绑定到一个操作系统线程上，这让应用程序执行效率更高，而开发工作量减少。</p>
<p>如果想在执行一段代码时，并行去做另外的事，<code>goroutine</code>是很好的选择，下面是一个简单的例子：</p>
<pre class="highlight"><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(msg <span class="keyword">string</span>)</span></span> {
  <span class="comment">// 此处是处理日志的代码</span>
}

<span class="comment">// 代码中有些地方检测到错误</span>
<span class="keyword">go</span> log(<span class="string">"发生错误"</span>)
</code></pre>
<p>关键字<code>go</code>是唯一需要去编写的代码，调用<code>log()</code>作为独立的<code>goroutine</code>去运行，以便与其他<code>goroutine</code>并行执行，这意味着应用程序的其他部分会与记录日志并行执行。</p>
<h4 id="通道"><a class="markdownIt-Anchor" href="#通道"></a> 通道</h4>
<p>通道是一种数据结构，可以让<code>goroutine</code>之间安全的通信，可以避免其他语言中常见的共享内存访问的问题。</p>
<p>并发最难的部分就是要确保其他并发运行的进程、线程或<code>goroutine</code>不会意外修改用户的数据。当不同线程在没有同步保护的情况下修改同一个数据时，将会导致错误。在其他语言中如果使用全局变量或共享内存，需要使用复杂的锁规则来防止对同一个变量的不同步修改。</p>
<p>通道提供了新模式，这一模式保证同一时刻只会有一个<code>goroutine</code>修改数据。通道用于在几个<code>goroutine</code>之间发哦那个数据。例子：一个应用程序，有多个进程需要顺序读取或修改某个数据，使用<code>goroutine</code>和通道可以为这个过程建立安全的模型。运行过程如下图所示：</p>
<p><img src="/article/Go/Go Base/Go语言简介/channel.png" alt="无法加载" title="使用通道在goroutine之间安全地发送数据"></p>
<p>上图有三个<code>goroutine</code>，还有2个不带缓存的通道。第一个<code>goroutine</code>通过通道将数据传给已经在等待的第二个<code>goroutine</code>。两个<code>goroutine</code>间传输数据是同步的，一旦传输完成，两者都会知道数据完成传输。第二个<code>goroutine</code>lion个数据完成任务后，会将数据传给第三个<code>goroutine</code>，传输依然是同步的。这种在<code>goroutine</code>之间安全传输数据的方法不需要任何锁或者同步机制。</p>
<p>需要注意的是，通道不提供跨<code>goroutine</code>的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个<code>goroutine</code>都会持有一份副本，各自对自己的副本做修改是安全的。当传输指向数据的指针时，如果读和写是由不同的<code>goroutine</code>完成，每个<code>goroutine</code>依旧需要额外的同步动作。</p>
<h3 id="go的数据类型"><a class="markdownIt-Anchor" href="#go的数据类型"></a> Go的数据类型</h3>
<p>Go提供灵活的、无继承的类型系统，无需降低运行性能就能最大程度复用代码，这个类型依然支持面向对象开发。Go使用组合<code>composition</code>设计模式，只需要简单地将一个类型嵌入另一个类型，就能复用所有的功能。</p>
<p>此外Go还有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行建模。在Go中不需要声明某个类型实现某个接口，编译器会判断类型的实例是否符合正在使用的接口。</p>
<h4 id="类型简单"><a class="markdownIt-Anchor" href="#类型简单"></a> 类型简单</h4>
<p>Go不仅有<code>int</code>和<code>string</code>这样的内置类型，还支持自定义类型。Go中自定义的类型通常包含一组带类型的子弹，用于存储数据，类似于C语言的结构，但Go的类型可以声明操作该类型数据的方法。传统语言使用继承来扩展结构，而Go构建更小的开发类型，然后将这些小类型组合为更大的类型。</p>
<h4 id="go接口对一组行为建模"><a class="markdownIt-Anchor" href="#go接口对一组行为建模"></a> Go接口对一组行为建模</h4>
<p>接口用于描述类型的行为，如果一个类型的实例实现了一个接口，意味着这个实例可以执行一组特地的行为。你甚至不要去声明这个实例实现了某个接口，只需要实现这组行为就好了，这种特性被称为<code>鸭子特性</code>。Go中如果一个类型实现了一个接口所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。</p>
<p>Go的接口一般只会描述一个单一的动作，在Go中最常用的接口之一就是<code>io.Reader</code>，该接口提供了一个简单的方法，用来声明一个类型有数据可以读取，其定义如下：</p>
<pre class="highlight"><code class="go"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {
  Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)
}
</code></pre>
<p>为了实现该接口，你只需要实现一个Read方法，这个方法接受一个byte切片，返回一个整数和可能出现的错误。</p>
<p>这个与传统接口有本质区别，更有利于使用组合来复用代码，用户几乎可以给所有包含数据的类型实现<code>io.Reader</code>,然后把这个类型的实例传给任何一个知道如何读取<code>io.Reader</code>的Go函数。</p>
<h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3>
<p>不当的内存管理会导致程序崩溃或者内存泄漏，甚至系统崩溃。Go具有现代化的垃圾回收机制。其他语言使用内存前要先分配这段内存，然后使用完毕后释放。哪怕出现一点失误，就会导致程序崩溃或内存泄漏。这存在一个问题，追踪内存是否还在被使用是件艰难的事，而要想支持多线程和高并发，更是让这件事愈发困难。虽然Go的垃圾回收会造成额外开销，但降低了开发难度。</p>
<h2 id="hello-go"><a class="markdownIt-Anchor" href="#hello-go"></a> Hello ，Go</h2>
<pre class="highlight"><code class="go"><span class="keyword">package</span> main     <span class="comment">// Go程序都组织成包</span>

<span class="keyword">import</span> <span class="string">"fmt"</span>     <span class="comment">// 导入外部代码，fmt包用于格式化并输出数据</span>

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {   <span class="comment">// main函数是程序的入口</span>
	fmt.Println(<span class="string">"Hello World!"</span>)
}			
</code></pre>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js安装及环境配置]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/Tool/Node.js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常好。</p>
</blockquote>
<h2 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h2>
<p>1.系统：Window10 Pro（64位）</p>
<p>2.Node.js：v6.11.3LTS（64位）</p>
<h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2>
<h3 id="下载nodejs"><a class="markdownIt-Anchor" href="#下载nodejs"></a> 下载Node.js</h3>
<p>打开<a href="https://nodejs.org/en/download/">Node.js官网</a>下载安装包<img src="/article/工具/Tool/Node.js安装说明/install.png" alt="无法加载" title="安装页面"></p>
<h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装Node.js</h3>
<p><img src="/article/工具/Tool/Node.js安装说明/install1.png" alt="无法加载" title="安装页面"></p>
<p><img src="/article/工具/Tool/Node.js安装说明/install2.png" alt="无法加载" title="安装页面"></p>
<p>安装目录可修改,默认为C盘:</p>
<p><img src="/article/工具/Tool/Node.js安装说明/install3.png" alt="无法加载" title="安装页面"></p>
<p><img src="/article/工具/Tool/Node.js安装说明/install4.png" alt="无法加载" title="安装页面"></p>
<p>安装成功:</p>
<p><img src="/article/工具/Tool/Node.js安装说明/success.png" alt="无法加载" title="安装成功"></p>
<p>安装成功则可以查看node.js版本以及npm版本:</p>
<p><img src="/article/工具/Tool/Node.js安装说明/version.png" alt="无法加载" title="安装成功"></p>
<h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2>
<blockquote>
<p>此处配置的是npm安装的全局模块锁在路径，以及缓存cache的路径。进行该项配置是当执行<code>npm install xxxx -g</code>时，会默认安装到<code>C:\User\用户名\npm</code>路径下，占据C盘空间。</p>
</blockquote>
<h3 id="修改全局模块安装路径和缓存路径"><a class="markdownIt-Anchor" href="#修改全局模块安装路径和缓存路径"></a> 修改全局模块安装路径和缓存路径</h3>
<p>在node.js的安装文件中新建<code>node_cache</code>和<code>node_global</code>，在<code>node_global</code>下新建<code>node_modules</code>文件夹。随后使用cmd命令进行配置：</p>
<pre class="highlight"><code class="shell">npm config set prefix "D:\Program Files\nodejs\node_global"
npm config set cace "D:\Program Files\nodejs\node_cache"
</code></pre>
<h3 id="设置环境变量"><a class="markdownIt-Anchor" href="#设置环境变量"></a> 设置环境变量</h3>
<p>“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”</p>
<p>在系统变量(S)中新建<code>NODE_PATH</code>，变量值为<code>D:\Program Files\nodejs\node_global\node_modules</code>;</p>
<p>修改用户变量(U)中的<code>PATH</code>将<code>C:\User\用户名\npm</code>改为<code>D:\Program Files\nodejs\node_global</code></p>
<p>测试环境变量修改成功，使用cmd命令进行安装</p>
<pre class="highlight"><code class="shell">npm install express -g # -g 全局安装
D:\Program Files\nodejs\node_global
`-- express@4.16.2
  +-- accepts@1.3.4
  | +-- mime-types@2.1.17
  | | `-- mime-db@1.30.0
  | `-- negotiator@0.6.1
  +-- array-flatten@1.1.1
  +-- body-parser@1.18.2
  | +-- bytes@3.0.0
  | +-- http-errors@1.6.2
  | | +-- inherits@2.0.3
  | | `-- setprototypeof@1.0.3
  | +-- iconv-lite@0.4.19
  | `-- raw-body@2.3.2
  +-- content-disposition@0.5.2
  +-- content-type@1.0.4
  +-- cookie@0.3.1
  +-- cookie-signature@1.0.6
  +-- debug@2.6.9
  | `-- ms@2.0.0
  +-- depd@1.1.1
  +-- encodeurl@1.0.1
  +-- escape-html@1.0.3
  +-- etag@1.8.1
  +-- finalhandler@1.1.0
  | `-- unpipe@1.0.0
  +-- fresh@0.5.2
  +-- merge-descriptors@1.0.1
  +-- methods@1.1.2
  +-- on-finished@2.3.0
  | `-- ee-first@1.1.1
  +-- parseurl@1.3.2
  +-- path-to-regexp@0.1.7
  +-- proxy-addr@2.0.2
  | +-- forwarded@0.1.2
  | `-- ipaddr.js@1.5.2
  +-- qs@6.5.1
  +-- range-parser@1.2.0
  +-- safe-buffer@5.1.1
  +-- send@0.16.1
  | +-- destroy@1.0.4
  | `-- mime@1.4.1
  +-- serve-static@1.13.1
  +-- setprototypeof@1.1.0
  +-- statuses@1.3.1
  +-- type-is@1.6.15
  | `-- media-typer@0.3.0
  +-- utils-merge@1.0.1
  `-- vary@1.1.2
</code></pre>
<p>安装时不加<code>-g</code>参数则会默认安装在路径下。</p>
<h3 id="配置nodejs源"><a class="markdownIt-Anchor" href="#配置nodejs源"></a> 配置Node.js源</h3>
<p>node.js安装速度缓慢,因此需要更换npm的源,打开cmd使用如下命令:</p>
<pre class="highlight"><code class="shell">npm config set registry http://registry.npm.taobao.org/
</code></pre>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的小问题（不断更新中）]]></title>
      <url>/article/Java/Java/Java%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98(%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      <content type="html"><![CDATA[<blockquote>
<p>1、使用private声明main()会怎样?<br>
A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。</p>
</blockquote>
<blockquote>
<p>2、Java中传引用和传值的区别是什么？<br>
A：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。</p>
</blockquote>
<blockquote>
<p>3、如果要重写一个对象的equals()，还要考虑什么？<br>
A：hashCode。</p>
</blockquote>
<blockquote>
<p>*4、Java的”一次编写，处处运行”是如何实现的？<br>
A：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。</p>
</blockquote>
<blockquote>
<p>*5、public static void main(String args[])这段声明里每个关键字的作用<br>
A：<code>public</code>: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见,所以可见性设置为pulic.<br>
<code>static</code>: Java平台调用这个方法时不会创建这个类的实例对象，因此这个方法必须声明为static。<br>
<code>void</code>: main方法没有返回值。<br>
<code>String</code>是命令行传进参数的类型，<code>args</code>是指命令行传进的字符串数组。</p>
</blockquote>
<blockquote>
<p>*6、<code>==</code>与equals()的区别<br>
A：<code>==</code>比较两个对象在内存里是不是同一个对象，即内存地址是否一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .<code>==</code>比较的是引用<br>
而equals()比较的是内容。<code>public boolean equals(Object obj)</code>这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,此时和==是等价的。String, BitSet, Date, 和File都对equals()进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。</p>
</blockquote>
<pre class="highlight"><code class="">public class EqualsTest {
   public static void main(String[] args) {
      Strings1 = &quot;abc&quot;;
      Strings2 = s1;
      Strings5 = &quot;abc&quot;;
      Strings3 = newString(&quot;abc&quot;);
      Strings4 = newString(&quot;abc&quot;);
      System.out.println(&quot; == comparison:&quot; + (s1 == s5));
      System.out.println(&quot; == comparison:&quot; + (s1 == s2));
      System.out.println(&quot;Using equals method:&quot; + s1.equals(s2));
      System.out.println(&quot; == comparison:&quot; + s3 == s4);
      System.out.println(&quot;Using equals method : &quot; + s3.equals(s4));
   }
}
</code></pre>
<p>结果：</p>
<pre class="highlight"><code class="">==comparison:true
==comparison:true
Usingequals method:true
false
Usingequals method:true
</code></pre>
<blockquote>
<p>7 main()去掉static修饰符会怎样？<br>
A：报错，main 方法不是类 com.java.demo.Demo 中的static</p>
</blockquote>
<blockquote>
<p>8、为什么oracle type4驱动被称作瘦驱动？<br>
A：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的,可以在运行时由浏览器下载,不依赖任何客户端的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。</p>
</blockquote>
<blockquote>
<p>9、final,finally,finalize()<br>
A：<code>final</code>: 常量声明。 <code>finally</code>: 处理异常。 <code>finalize()</code>: 帮助进行垃圾回收。<br>
接口里声明的变量默认是final的。final类无法继承,也就是没有子类。这么做是出于基本类型的安全考虑，比如String和Integer,这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。<br>
finalize()在对象被销毁和回收前会被调用。<br>
finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如,关闭连接通常放到finally块中完成。</p>
</blockquote>
<blockquote>
<p>10、什么是Java API？<br>
A：Java API是大量软件组件的集合,它们提供了大量有用的功能,比如GUI组件。</p>
</blockquote>
<blockquote>
<p>11、GregorianCalendar类是什么东西？<br>
A：GregorianCalendar提供了西方传统日历的支持。</p>
</blockquote>
<blockquote>
<p>12、ResourceBundle类是什么?<br>
A：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。</p>
</blockquote>
<blockquote>
<p>13、为什么Java里没有全局变量?<br>
A：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。</p>
</blockquote>
<blockquote>
<p>14、如何将String类型转化成Number类型？<br>
A：Integer类的valueOf方法可以将String转成Number。下面是代码示例：</p>
</blockquote>
<pre class="highlight"><code class="">String numString = &quot;1000&quot;;
int id = Integer.valueOf(numString).intValue();
</code></pre>
<blockquote>
<p>15、SimpleTimeZone类是什么?<br>
A：SimpleTimeZone提供公历日期支持。</p>
</blockquote>
<blockquote>
<p>16、while循环和do循环有什么不同？<br>
A：while结构在循环的开始判断下一个迭代是否应该继续。<br>
do/while结构在循环的结尾来判断是否将继续下一轮迭代,do结构至少会执行一次循环体。</p>
</blockquote>
<blockquote>
<p>17、Locale类是什么？<br>
A：Locale类用来根据语言环境来动态调整程序的输出。</p>
</blockquote>
<blockquote>
<p>*18、面向对象编程的原则是什么?<br>
A：多态,继承和封装。</p>
</blockquote>
<blockquote>
<p>19、简述继承性<br>
A：继承使得一个类可以获取另一个类的属性和方法。使用继承可以让已经测试完备的功能得以复用,并且可以一次修改,所有继承的地方都同时生效。</p>
</blockquote>
<blockquote>
<p>20、什么是隐式的类型转化?<br>
A：隐式的类型转化就是直接将一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。<br>
代码示例：</p>
</blockquote>
<pre class="highlight"><code class="">int i = 1000;
long j = i;//Implicit casting
</code></pre>
<blockquote>
<p>21、sizeof是Java的关键字吗?<br>
A：不是。</p>
</blockquote>
<blockquote>
<p>22、native方法是什么?<br>
A：native方法是非Java代码实现的方法。</p>
</blockquote>
<blockquote>
<p>23、在System.out.println()里面,System, out, println分别是什么?<br>
A：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。</p>
</blockquote>
<blockquote>
<p>24、多态是什么？<br>
A：简单来说,多态是指一个名字多种实现,多态使得一个实体通过一个通用的方式来实现不同的操作,具体的操作是由实际的实现来决定的。<br>
多态在Java里有三种表现方式：方法重载通过继承实现方法重写通过Java接口进行方法重写。</p>
</blockquote>
<blockquote>
<p>25、显式的类型转化是什么?<br>
A：显式的类型转化是明确告诉了编译器来进行对象的转化。<br>
代码示例：</p>
</blockquote>
<pre class="highlight"><code class="">long i = 700.20;
int j = (int)i;
</code></pre>
<blockquote>
<p>26、什么是Java虚拟机?<br>
A：Java虚拟机是能移植到不同硬件平台上的软件系统。</p>
</blockquote>
<blockquote>
<p>27、类型向下转换是什么?<br>
A：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。</p>
</blockquote>
<blockquote>
<p>28、Java的访问修饰符是什么?<br>
A：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：<br>
public: 所有类都可以访问<br>
protected: 同一个包内以及所有子类都可以访问<br>
private: 只有归属的类才能访问默认: 归属类及相同包下的子类可以访问</p>
</blockquote>
<blockquote>
<p>29、所有类的父类是什么？<br>
A：Object.</p>
</blockquote>
<blockquote>
<p>30、Java的基本类型有哪些?<br>
A：byte,char, short, int, long, float, double, boolean。</p>
</blockquote>
<blockquote>
<p>31、静态类型有什么特点?<br>
A：static定义的变量与类绑定,即每个实例对象都共享同一个静态变量。不论有多少个实例对象,静态变量只有一个。static定义的变量通常使用类名访问,当程序运行时,这个变量就会被创建直到程序结束才会被销毁。静态变量的作用域与普通变量一致,初始值也是一致的。变量没被初始化时根据其数据类型会有一个默认值。<br>
static定义的方法属于类,而不是类对象,其调用不作用于类对象,也不需要创建类实例.静态方法本身就带有final,因为重写只会发生在类实例上，即只要原方法没声明为final,非静态方法就不能重写静态方法。父类的静态方法会被子类的静态方法屏蔽，但你不能在子类把父类的静态方法改为实例方法。</p>
</blockquote>
<blockquote>
<p>32、&amp;操作符和&amp;&amp;操作符有什么区别?<br>
A：当一个<code>&amp;</code>表达式在求值的时候，两个操作数都会被求值。<br>
当一个<code>&amp;&amp;</code>表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。</p>
</blockquote>
<blockquote>
<p>33、Java是如何处理整型的溢出和下溢的?<br>
A：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。</p>
</blockquote>
<blockquote>
<p>34、public static void写成static public void会怎样？<br>
A：程序正常编译及运行.</p>
</blockquote>
<blockquote>
<p>35、声明变量和定义变量有什么不同？<br>
答案：声明变量只提供变量的类型和名字,并没有进行初始化。<br>
定义包括声明和初始化两个阶段：<code>String s;</code>只是变量声明,<code>String s = new String(&quot;bob&quot;);</code>或者<code>String s = &quot;bob&quot;;</code>是变量定义。</p>
</blockquote>
<blockquote>
<p>36、Java支持哪种参数传递类型?<br>
A：Java参数都是进行传值.对于对象而言,传递的值是对象的引用,也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。</p>
</blockquote>
<blockquote>
<p>37、对象封装的原则是什么?<br>
A：封装是将数据及操作数据的代码绑定到一个独立的单元,这样保障了数据的安全,防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。</p>
</blockquote>
<blockquote>
<p>38、你怎么理解变量？<br>
A：变量是一块命名的内存区域,以便程序进行访问。变量用来存储数据,随着程序的执行,存储的数据也可能跟着改变。</p>
</blockquote>
<blockquote>
<p>39、数值提升是什么?<br>
A：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中,byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。</p>
</blockquote>
<blockquote>
<p>40、Java的类型转化是什么?<br>
A：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的类型转换，一个是隐式的。</p>
</blockquote>
<blockquote>
<p>41、main()方法的参数里面,字符串数组的第一个参数是什么?<br>
A：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。</p>
</blockquote>
<blockquote>
<p>42、怎么判断数组是null还是为空?<br>
A：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。</p>
</blockquote>
<blockquote>
<p>43、程序中可以允许多个类同时拥有都有main方法吗?<br>
A：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。</p>
</blockquote>
<blockquote>
<p>44、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？<br>
A：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。</p>
</blockquote>
<blockquote>
<p>45、一个类能拥有多个main方法吗？<br>
A：可以，但只能有一个main方法拥有以下签名：<br>
public static void main(String[] args) {}<br>
否则程序将无法通过编译。编译器会警告你main方法已经存在。</p>
</blockquote>
<blockquote>
<p>46、简述JVM是如何工作的?<br>
A：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。</p>
</blockquote>
<blockquote>
<p>47、如何原地交换两个变量的值？<br>
A：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：</p>
</blockquote>
<pre class="highlight"><code class="">int a = 5, b = 10; a = a + b; b = a - b; a = a - b;
</code></pre>
<p>使用异或操作也可以交换。第一个方法还可能会引起溢出。异或的方法如下：</p>
<pre class="highlight"><code class="">int a = 5;int b = 10;
a=a^b;
b=a^b;
a=a^b;
</code></pre>
<blockquote>
<p>48、什么是数据的封装?<br>
A：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。</p>
</blockquote>
<blockquote>
<p>49、什么是反射API？它是如何实现的？<br>
A：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。</p>
</blockquote>
<blockquote>
<p>50、JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？<br>
A：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。</p>
</blockquote>
<blockquote>
<p>51、虚拟内存是什么?<br>
A：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。</p>
</blockquote>
<blockquote>
<p>52、方法可以同时即是static又是synchronized的吗?<br>
A：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于：</p>
</blockquote>
<pre class="highlight"><code class="">synchronized(XYZ.class){
}
</code></pre>
<blockquote>
<p>53、String和StringTokenizer的区别是什么？<br>
A：StringTokenizer是一个用来分割字符串的工具类。</p>
</blockquote>
<pre class="highlight"><code class="">String Tokenizerst = new StringTokenizer(&quot;Hello World&quot;);
while(st.hasMoreTokens()){
   System.out.println(st.nextToken());
}
输出：
Hello
World
</code></pre>
<blockquote>
<p>54、transient变量有什么特点?<br>
A：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
</blockquote>
<blockquote>
<p>55、哪些容器使用Border布局作为它们的默认布局?<br>
A：Window, Frame, Dialog。</p>
</blockquote>
<blockquote>
<p>56、什么是同步?<br>
A：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。<br>
对方法进行同步：</p>
</blockquote>
<pre class="highlight"><code class="">public synchronized void Method1(){
    // Appropriate method-related code.
}
</code></pre>
<p>在方法内部对代码块进行同步：</p>
<pre class="highlight"><code class="">public myFunction() {
   synchronized(this){
     // Synchronized code here.
   }
}
</code></pre>
<blockquote>
<p>57、问题：给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？<br>
A：</p>
</blockquote>
<pre class="highlight"><code class="">public class Test{
  public static void main(String[] args) {
     //给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？
     int a = 8;
     //打印二进制
     System.out.println(Integer.toBinaryString(a));   //输出  1000
     System.out.println(Integer.toBinaryString(a|4)); //输出 1100
  }
}</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识(四)]]></title>
      <url>/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E5%9B%9B)/</url>
      <content type="html"><![CDATA[<h2 id="java多线程实现"><a class="markdownIt-Anchor" href="#java多线程实现"></a> Java多线程实现</h2>
<p>Java可通过以下两种方式实现多线程：</p>
<blockquote>
<p>· 继承Thread类；<br>
· 实现Runnable接口（此外扩充了Callable接口）</p>
</blockquote>
<h3 id="线程与进程"><a class="markdownIt-Anchor" href="#线程与进程"></a> 线程与进程</h3>
<p>Java支持多线程。<br>
1、进程指的是一次程序的完整运行，在运行过程中内存、处理器、IO等资源都是为该进程服务。<br>
DOS系统时代，有一种现象：假如病毒运行，那电脑就无法运行，因为所有资源都被病毒占用。但在windows时代，即使病毒在运行，电脑也可以运行。<br>
这是因为windows系统是多进程操作系统。其资源分配方法是：在同一时间段，多进程轮流抢占资源，但在某时间点，只会有一个进程在运行<br>
2、线程是在进程基础上进一步地划分的结果：即一个进程可以同时创建多个线程。线程是比进程更快的处理单元，而且所占的资源更小。多线程的应用也是性能最高的应用。</p>
<h3 id="thread类实现多线程"><a class="markdownIt-Anchor" href="#thread类实现多线程"></a> Thread类实现多线程</h3>
<p>1、<code>Thread类</code>是一个支持多线程的功能类，只要是其子类，就可以实现多线程。<br>
<code>class MyThread extends Thread { // 多线程操作类}</code><br>
程序的起点是<code>main()</code>。而每个线程也有它的起点<code>run()</code>。多线程类必须覆写Thread类的<code>run()</code>：<code>public void run(){}</code>，该方法没有返回值，表示线程一旦开始，就需要一直运行，不能返回内容。</p>
<pre class="highlight"><code class="">// 线程操作主类
class MyThread extends Thread { 
    private String name;

    public MyThread(String name) {
        this.name = name;
    }

    @Override
    public void run() { // 覆写run(),作为线程的主体操作方法
        for (int x = 0; x &lt; 200; x++) {
            System.out.println(this.name + &quot;--&gt;&quot; + x);
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        MyThread mA = new MyThread(&quot;线程A&quot;);
        MyThread mB = new MyThread(&quot;线程B&quot;);
        MyThread mC = new MyThread(&quot;线程C&quot;);

        mA.run();
        mB.run();
        mC.run();
    }
}
</code></pre>
<p>运行上述代码，输出结果是线程A、B、C依次进行循环输出。<br>
2、线程与进程是一样的，都必须轮流去抢占资源，多线程的执行应该是多个线程彼此交替执行。但直接调用run()并不能启用多线程，多线程启用依靠的是Thread类的start()：<code>public void start()</code>（调用此方法，执行的方法体是run()定义的）。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) { // 主类
        MyThread mtA = new MyThread(&quot;线程A&quot;);
        MyThread mtB = new MyThread(&quot;线程B&quot;);
        MyThread mtC = new MyThread(&quot;线程C&quot;);

        mtA.start();
        mtB.start();
        mtC.start();
    }
}
</code></pre>
<p>上述代码结果中每个线程对象交替执行。</p>
<blockquote>
<p>问题：为什么多线程启用不是调用run()而是调用start()？<br>
打开Java的源代码，观察start()的定义</p>
</blockquote>
<pre class="highlight"><code class="">public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}
private native void start0();
</code></pre>
<p>start()利用throw抛出<code>IllegalThreadStateException</code>，本应使用<code>try…catch</code>处理，或者start()上使用<code>throws</code>声明，但此处没有这样处理，这是因为该异常是<code>RuntimeException</code>的子类，属于选择性处理。如果某一个线程重复启动，就会抛出异常。<br>
<code>start()</code>要调用<code>start0()</code>，而且该方法结构与抽象方法类似，唯一不同的是使用<code>native</code>声明。Java中有一个<code>JNI</code>技术（Java Native Interface），其特点是：使用Java调用本机操作系统提供的函数。其缺点：不能离开特定的操作系统。<br>
如果线程要执行，需要操作系统进行资源分配，所以此操作是由JVM根据不同的操作系统实现的。即：使用Thread类的start()不仅仅要启动多线程的执行代码，还要根据不同的操作系统进行资源的分配。</p>
<h3 id="runnable接口实现多线程"><a class="markdownIt-Anchor" href="#runnable接口实现多线程"></a> Runnable接口实现多线程</h3>
<p>1、虽然Thread类可以实现多线程。但存在问题：Java存在单继承限制。任何情况下，对于类的单继承都是应该尽量回避的，多线程也一样。为了解决单继承的限制，在Java中专门提供了Runnable接口，此接口定义如下：</p>
<pre class="highlight"><code class="">@FunctionalInterface
public interface Runnable{
    public void run();
}
</code></pre>
<p>接口中都是public权限，不存在default权限。那么只需要让一个类实现Runnable接扣，并覆写run()方法即可。</p>
<pre class="highlight"><code class="">class MyThread implements Runnable {
    private String name;

    public MyThread(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 10; x++) {
            System.out.println(this.name + &quot;--&gt;&quot; + x);
        }
    }
}
</code></pre>
<p>与继承Thread类相比，此时MyThread类在结构上并没有区别，但存在一个不同：继承Thread类，可以直接继承start()，但是实现Runnable接口，并没有start()。<br>
2、要想启用多线程，一定依靠Thread类完成，在Thread类定义有如下构造方法：<br>
<code>public Thread（Runnable target）</code>，接收的是Runable接口对象；<br>
范例：启动多线程</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) { // 主类
        MyThread mtA = new MyThread(&quot;线程A&quot;);
        MyThread mtB = new MyThread(&quot;线程B&quot;);
        MyThread mtC = new MyThread(&quot;线程C&quot;);
        new Thread(mtA).start();
        new Thread(mtB).start();
        new Thread(mtC).start();
    }
}
</code></pre>
<p>此时就避免了单继承局限，所以实际开发中使用接口是最合适的。</p>
<h3 id="两种实现方式的区别"><a class="markdownIt-Anchor" href="#两种实现方式的区别"></a> 两种实现方式的区别</h3>
<p>Runnable接口与Thread类相比，解决了单继承的局限，所以如果要使用，一定使用Runnable接口。<br>
1、观察Thread类的定义<br>
<code>public class Thread extends Object implements Runnable</code><br>
Thread类实现了Runnable接口。<br>
<img src="/article/Java/Java/Java知识(四)/31-1.png" alt="无法加载" title="结构分析"><br>
2、除了以上的联系外，还有一点：使用Runnable接口可以比Thread类更好地描述出数据共享这一概念。此时的数据共享指的是多个线程访问同一资源的操作。<br>
范例：观察代码（每一个线程对象都必须通过start()启动）</p>
<pre class="highlight"><code class="">class MyThread extends Thread {
    private int ticket = 10;

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            if (this.ticket &gt; 0) {
                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);
            }
        }
    }
}

public class Demo {
    public static void main(String[] args) { // 主类
        MyThread mtA = new MyThread();
        MyThread mtB = new MyThread();
        MyThread mtC = new MyThread();
        mtA.start();
        mtB.start();
        mtC.start();
    }
}
</code></pre>
<p>上述代码声明了三个MyThread对象，并且分别调用start()方法，启动线程，发现每个线程都在卖各自的十张票，此时的内存关系如下：<br>
<img src="/article/Java/Java/Java知识(四)/31-2.png" alt="无法加载" title="内存分析"><br>
此时并不存在数据共享。<br>
范例：利用Runnable实现</p>
<pre class="highlight"><code class="">class MyThread implements Runnable {
    private int ticket = 10;

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            if (this.ticket &gt; 0) {
                System.out.println(&quot;卖票，ticket = &quot; + this.ticket--);
            }
        }
    }
}

public class Demo {
    public static void main(String[] args) { // 主类
        MyThread mt = new MyThread();
        new Thread(mt).start();
        new Thread(mt).start();
        new Thread(mt).start();
    }
}
</code></pre>
<p>上述代码的内存分析如下：<br>
<img src="/article/Java/Java/Java知识(四)/31-3.png" alt="无法加载" title="内存年分析"><br>
此时也属于三个线程对象，唯一的区别是，这三个线程对象都直接占用了同一个MyThread类对象引用，即这三个线程对象都直接访问同一个数据资源。</p>
<blockquote>
<p>请解释Thread与Runnable实现多线程的区别？（请解释多线程两种实现方式的区别？）<br>
1、Thread类是Runnable接口的子类，使用Runnable接口多线程可以避免单继承局限；<br>
2、Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚地描述数据共享的概念；</p>
</blockquote>
<h3 id="callable接口实现多继承"><a class="markdownIt-Anchor" href="#callable接口实现多继承"></a> Callable接口实现多继承</h3>
<p>1、使用Runnable实现多线程可以避免单继承局限，但是Runnable中的run()不能返回操作结果。为了解该问题，Java提供了一个新的接口<code>java.util.concurrent.Callable</code>。</p>
<pre class="highlight"><code class="java"><span class="meta">@FunctionalInterface</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>{
    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;
}
</code></pre>
<p>call()执行完线程的主体功能之后可以返回一个结果，而返回类型由Callable的泛型决定。<br>
范例：定义一个线程主体类</p>
<pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) {
            <span class="keyword">if</span> (<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) {
                System.out.println(<span class="string">"卖票，ticket = "</span> + <span class="keyword">this</span>.ticket--);
            }
        }
        <span class="keyword">return</span> <span class="string">"票已经卖光"</span>;
    }
}
</code></pre>
<p>此时发现Thread类中没有接收Callable对象的应用。但从JDK1.5开始增加<code>java.util.concurrent.FutureTask&lt;V&gt;</code>类，这个类主要负责Callable接口对象的操作。这个类的结构：<br>
<code>public class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt;</code><br>
而上述的<code>RunnableFuture</code>结构如下：<br>
<code>public interface RunnableFuture&lt;V&gt; extends Runnable,Future&lt;V&gt;</code><br>
在FutureTask类中定义有构造方法：<code>public FutureTask(Callable&lt;V&gt; callable)</code>，接收的是call()的返回值。<br>
范例：启动多线程</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) throws Exception { 
    
        MyThread mtA = new MyThread();
        MyThread mtB = new MyThread();
        FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mtA);
        FutureTask&lt;String&gt; taskB = new FutureTask&lt;String&gt;(mtB);
        // 目的是取得call()的返回值
        // FutureTask是Runnable接口的子类，所以可以使用Thread的构造接收
        new Thread(taskA).start(); // 启动多线程
        new Thread(taskB).start();
        // 多线程执行完毕后，可以通过FutureTask的父接口Future中的get()方法取得返回内容
        System.out.println(&quot;A线程的返回结果:&quot; + taskA.get());
        System.out.println(&quot;B线程的返回结果:&quot; + taskB.get());
    }
}
</code></pre>
<p>上述代码最麻烦的地方在于需要接收返回值，并且又要与原始的多线程实现靠拢（向Thread类靠拢）。</p>
<h2 id="多线程常用操作方法"><a class="markdownIt-Anchor" href="#多线程常用操作方法"></a> 多线程常用操作方法</h2>
<p>多线程有许多方法，但大部分方法都定义在Thread类中，本章只介绍几种开发常用方法。</p>
<h3 id="线程命名和获取线程"><a class="markdownIt-Anchor" href="#线程命名和获取线程"></a> 线程命名和获取线程</h3>
<p>1、线程的每次运行结果都不同，因为其会根据实际情况进行资源抢占。因此要区分每个线程，必须依靠线程名。线程名一般是在其启动前定义。不建议更改已经启动的线程名或为不同线程设置相同的名字。</p>
<p>2.、对线程进行命名，可以利用Thread类的如下方法：</p>
<blockquote>
<ol>
<li>构造方法：<code>public Thread(Runnable target, String name);</code></li>
</ol>
<p>2）设置名字：<code>public final void setName(String name);</code></p>
<p>3）取得名字：<code>public final String getName();</code></p>
</blockquote>
<p><code>Runable</code>子类没有继承<code>Thread</code>类，要想获取线程名即获取当前执行方法的线程名需要利用Thread类中提供的取得当前线程对象的方法:<code>public static Thread currentThread()</code>；</p>
<p>**范例：**不设置线程名</p>
<pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        System.out.println(Thread.currentThread().getName());
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        MyThread mt = <span class="keyword">new</span> MyThread();
        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>
        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-1</span>
        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-2</span>
    }
}

</code></pre>
<p>实例化<code>Thread</code>类对象时，如果没有为其设置名字，会自动进行编号命名<code>Thread-x</code>，来保证线程名字不重复。</p>
<p>**范例：**设置线程名</p>
<pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        System.out.println(Thread.currentThread().getName());
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        MyThread mt = <span class="keyword">new</span> MyThread();
        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>
        <span class="keyword">new</span> Thread(mt).start(); <span class="comment">// Thread-0</span>
        <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>).start(); <span class="comment">// 线程B</span>
    }
}

</code></pre>
<p>3、观察下述代码</p>
<pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        MyThread mt = <span class="keyword">new</span> MyThread();
        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start(); <span class="comment">// 线程A</span>
        mt.run(); <span class="comment">// 直接调用run()方法，结果为main</span>
    }
}
</code></pre>
<p>上述代码说明主方法就是一个线程<code>main线程</code>，所有在主方法上创建的线程实际上都可以将其视为子线程。上述代码也说明线程一直都存在（主方法就是主线程），每当使用<code>java</code>命令去解释一个程序类时，对于操作系统而言，都相当于启动了一个进程，而main只是这进程上的一个子线程而已。</p>
<blockquote>
<p>**问题：**一个JVM进程启动时至少启动几个线程？</p>
<p>**答：**至少启用了2个线程</p>
<p>1.main线程：程序的主要执行，以及启动子线程；</p>
<p>2.gc线程：负责垃圾收集</p>
</blockquote>
<hr>
<h3 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h3>
<p>1、线程休眠指的是让线程的执行暂时停顿，其方法：<code>public static void sleep(longmillis) throws InterruptedException</code></p>
<p>**范例：**观察休眠特点</p>
<pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10000</span>; x++) {
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让其休眠1秒</span>
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);
        }
	}
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        MyThread mt = <span class="keyword">new</span> MyThread();
        <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start();
    }
}
</code></pre>
<p>由于每次执行<code>run()</code>都要休眠1秒，所以执行的速度变慢。一般情况下，休眠时设置多个线程对象将导致所有线程对象一起进入<code>run()</code>（所谓一起进入实际上是因为先后进入的顺序时间间隔短，肉眼忽略，但实际上不是同时进入）。</p>
<h3 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h3>
<p>1、 线程优先级越高，越有可能先被执行。在Thread类中提供有以下两个方法设置和获取优先级：</p>
<blockquote>
<p>​       · 设置优先级：<code>public final void setPriority(int new Priority)</code>；</p>
<p>​       · 取得优先级：<code>public final int getPriority()</code>；</p>
</blockquote>
<p>设置和取得优先级都是使用int型数据类型，对于此内容有三种取值：</p>
<blockquote>
<p>​       · 最高优先级：<code>public static final int MAX_PRIORITY；// 值为10</code></p>
<p>​       · 默认优先级：<code>public static final int NORM_PRIORITY；// 值为5</code></p>
<p>​       · 最低优先级：<code>public static final int MIN_PRIORITY。 // 值为1</code></p>
</blockquote>
<p>**范例：**优先级</p>
<pre class="highlight"><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) {
            System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        MyThread mt = <span class="keyword">new</span> MyThread();
        Thread tA = <span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>);
        Thread tB = <span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>);
        Thread tC = <span class="keyword">new</span> Thread(mt, <span class="string">"线程C"</span>);
        tA.setPriority(Thread.MAX_PRIORITY);
        tA.start();
        tB.start();
        tC.start();
    }
}
</code></pre>
<p>**范例：**主线程优先级</p>
<pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
      <span class="comment">// 获取主线程的优先级</span>
      System.out.println(Thread.currentThread().getPriority());     <span class="comment">// 5</span>
    }
}
</code></pre>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3>
<blockquote>
<p><code>Thread.currentThread()</code>可以取得当前线程类对象；</p>
<p><code>Thread.sleep()</code>用于线程休眠，看起来是一起休眠，实际存在时间间隔</p>
<p>优先级越高的线程越有可能先执行。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识(三)]]></title>
      <url>/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="java8特性"><a class="markdownIt-Anchor" href="#java8特性"></a> Java8特性</h2>
<h3 id="接口定义增强"><a class="markdownIt-Anchor" href="#接口定义增强"></a> 接口定义增强</h3>
<p>JDK1.8之前，接口的组成只有<code>全局变量</code>和<code>抽象方法</code>。从JDK1.8开始，接口的组成增加了。<br>
假设：现有一个接口，其子类有2W个。现在发现该接口功能不足，要增加一个方法，该方法对于所有子类而言的功能是一样的（即方法体是一样的）。此时要修改每个子类的方法，要修改2W次。<br>
上述问题在JDK1.8中不存在，因为其允许接口中定义普通方法，但普通方法必须使用default定义。</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(); // 接口原本定义的方法

    default public void fun() { // 普通方法
        System.out.println(&quot;JDK1.8&quot;);
    }
}

class Apple implements Fruit {
    @Override
    public void print() {
        System.out.println(&quot;苹果&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Fruit f = new Apple();
        f.fun();
        f.print();
    }
}
</code></pre>
<p>除了使用<code>default</code>定义方法，还可以使用<code>stati</code>c定义方法<br>
范例：定义static方法</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(); // 接口原本定义的方法

    default public void fun() { // 普通方法
        System.out.println(&quot;JDK1.8&quot;);
    }

    static void get() {
        System.out.println(&quot;直接由接口调用&quot;);
    }
}

class Apple implements Fruit {
    @Override
    public void print() {
        System.out.println(&quot;苹果&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Fruit f = new Apple();
        f.fun();
        f.print();
        Fruit.get();
    }
}
</code></pre>
<p>JDK1.8有个新功能：内部类访问方法参数时可以不加上final关键字。<br>
这些新特性，完全打破了Java已有的代码组成形式。</p>
<h3 id="lamda表达式"><a class="markdownIt-Anchor" href="#lamda表达式"></a> Lamda表达式</h3>
<p>Lamda属于函数式编程的概念，下面通过匿名内部类，来分析函数式编程的产生目的。<br>
范例：匿名内部类</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(); // 接口原本定义的方法
}


public class Demo {
    public static void main(String[] args) {
        fun(new Fruit() {
            @Override
            public void print() {
                System.out.println(&quot;水果&quot;);
            }
        });
    }

    public static void fun(Fruit fru) {
        fru.print();
    }
}
</code></pre>
<p>上述代码中fun()最终需要的只是输出，但是由于Java的开发结构的完整性要求，不得不在这个核心语句上嵌套更多的内容。但是该做法过于严谨复杂，在JDK1.8引入函数式编程，简化过程。<br>
范例：使用Lamda表达式</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(); // 接口原本定义的方法
}

public class Demo {
    public static void main(String[] args) {
        fun(()-&gt; System.out.println(&quot;水果&quot;));
    }
    public static void fun(Fruit fru) {
        fru.print();
    }
}
</code></pre>
<p>Lamda语法有三种形式：</p>
<blockquote>
<p>·(参数)-&gt;单行语句；<br>
·(参数)-&gt;｛单行语句｝；<br>
·(参数)-&gt;表达式；</p>
</blockquote>
<p>范例：观察有参单行</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(String str); // 接口原本定义的方法
}

public class Demo {
    public static void main(String[] args) {
        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出
        fun((s) -&gt; System.out.println(s));
    }

    public static void fun(Fruit fru) {
        fru.print(&quot;苹果&quot;); // 设置参数的内容
    }
}
</code></pre>
<p>范例：编写多行语句</p>
<pre class="highlight"><code class="">interface Fruit {
    public void print(String str); // 接口原本定义的方法
}

public class Demo {
    public static void main(String[] args) {
        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出
        fun((s) -&gt; {
            s = s.toUpperCase();
            System.out.println(s);
        });
    }

    public static void fun(Fruit fru) {
        fru.print(&quot;Hello&quot;); // 设置参数的内容
    }
}
</code></pre>
<p>范例：编写表达式</p>
<pre class="highlight"><code class="">interface Fruit {
    public int add(int x, int y);
}

public class Demo {
    public static void main(String[] args) {
        // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出
        fun((s1, s2) -&gt; s1 + s2);
    }

    public static void fun(Fruit fru) {
        System.out.println(fru.add(10, 20));
    }
}
</code></pre>
<h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h3>
<p>对象引用的特点：不同对象可以操作同一块内容。而方法引用就是指为一个方法设置别名，相当于一个方法定义了不同的名字。<br>
1、方法引用在Java8中一共定义了四种形式：</p>
<blockquote>
<p>· 引用静态方法： 类名称::static 方法名称;<br>
· 引用某个对象的方法：实例化对象::普通方法；<br>
· 引用特定类型的方法：特定类::普通方法;<br>
· 引用构造方法：类名称::new。</p>
</blockquote>
<p>范例：引用静态方法<br>
String类中的valueof()：<code>public static String valueof(int x)</code></p>
<pre class="highlight"><code class="">package com.java.demo;

/**
 * 只有一个方法的接口
 * @param &lt;P&gt; 参数的数据类型
 * @param &lt;R&gt; 返回值的数据类型
 */
interface Math&lt;P, R&gt; {
    public R exchange(P p);
}

public class Demo {
    public static void main(String[] args) {
        // 覆写了exchange(),使其具有valueOf()的功能
        Math&lt;Integer, String&gt; math = String::valueOf;
        String msg = math.exchange(10000);
        // 将所有的0替换成9
        System.out.println(msg.replaceAll(&quot;0&quot;, &quot;9&quot;));
    }
}
</code></pre>
<p>范例：普通方法引用<br>
String类中的toUpperCase()：<code>public String toUpperCase()</code></p>
<pre class="highlight"><code class="">package com.java.demo;

interface Math&lt;R&gt; {
    public R upper();
}

public class Demo {
    public static void main(String[] args) {
        // 覆写了upper,使其具有toUpperCase的功能
        // toUpperCase是普通方法,必须由String对象调用
        // hello是String对象,代码如下
        Math&lt;String&gt; math = &quot;hello&quot;::toUpperCase;
        String msg = math.upper();
        System.out.println(msg);
    }
}
</code></pre>
<p>上述例子显示，要实现方法引用，必须要有接口，且该接口只能有一个方法。为了保证该接口只有一个方法，可对其进行注解说明。</p>
<pre class="highlight"><code class="">@FunctionalInterface // 此为函数式接口，只能定义一个方法
interface ITest&lt;R&gt; {
    public R upper();
}
</code></pre>
<p>2、在进行方法引用的过程中，还有一种形式的引用（这种形式需要特定类的对象支持）。一般使用“类::方法”，引用的是类中的静态方法。但是这种形式也可以引用普通方法。<br>
例如：在String类中有一个方法：<code>public int compareTo(String anotherString)</code>，比较的形式是<code>String对象1.compareTo(String对象2)</code>，即要引用该方法，需要有两个参数。<br>
范例：引用特定类的方法</p>
<pre class="highlight"><code class="">interface IMessage&lt;P&gt; {
    public int compare(P p1, P p2);
}

public class Demo {
    public static void main(String[] args) {
        IMessage&lt;String&gt; msg = String::compareTo;
        System.out.println(msg.compare(&quot;A&quot;, &quot;B&quot;));
    }
}
</code></pre>
<p>与之前相比，方法引用前不需要定义对象，可以理解为将对象定义在参数上。<br>
范例：引用构造方法</p>
<pre class="highlight"><code class="">interface IMessage&lt;C&gt; {
    public C create(String t, double p);
}

class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String toString() {
        return &quot;书名:&quot; + this.title + &quot;,价格：&quot; + this.price;
    }
}

public class Demo {
    public static void main(String[] args) {
        IMessage&lt;Book&gt; msg = Book::new; // 引用构造方法
        // 虽然调用的是create()，实际引用了Book类的构造方法
        Book book = msg.create(&quot;Java开发&quot;, 66.6);
        System.out.println(book);
    }
}
</code></pre>
<p>对象引用是使用不同的名字，而方法引用需要一个函数接口。</p>
<h3 id="内建函数式接口"><a class="markdownIt-Anchor" href="#内建函数式接口"></a> 内建函数式接口</h3>
<p>1、JDK1.8中提供了一个包：<code>java.util.function</code>，提供有以下四个核心接口：</p>
<blockquote>
<p>(1)功能性接口（Function）：public interface Function&lt;T,R&gt;{public R apply(T t);}<br>
|- 此接口需要接收一个参数，并且返回一个处理结果；<br>
(2)消费型接口（Consumer）：public interface Consumer<T>{public void accept(T t);}<br>
|- 此接口只负责接收数据（引用数据是不需要返回的），并且不返回结果；<br>
(3)供给型接口（Suplier）：public interface Supplier<T>{public T get();}<br>
|- 此接口不接收参数，但是可以返回结果<br>
(4)断言型接口（Predicate）：public interface Predicate<T>{public boolean Test(T t);}<br>
|- 进行判断操作使用；</T></T></T></p>
</blockquote>
<p>在JDK1.8中存在以上四个功能型接口，所以很少会由用户去定义新的函数式接口。<br>
范例：函数式接口——接收参数并返回处理结果<br>
· String类有一个方法：<code>public boolean startsWith(String str)</code></p>
<pre class="highlight"><code class="">package com.java.demo;

import java.util.function.Function;

public class Demo {
    public static void main(String[] args) {
        Function&lt;String, Boolean&gt; fun = &quot;##hello&quot;::startsWith;
        System.out.println(fun.apply(&quot;##&quot;)); // true
    }
}
</code></pre>
<p>范例：消费型接口</p>
<pre class="highlight"><code class="">package com.java.demo;

import java.util.function.Consumer;

class MyDemo {
    // 此方法没有返回值，但是有参数
    public void print(String str) {
        System.out.println(str);
    }
}

public class Demo {
    public static void main(String[] args) {
        Consumer&lt;String&gt; cons = new MyDemo()::print;
        cons.accept(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>范例：供给型接口<br>
· 引用String类的toUpperCase()：<code>public String toUpperCase()</code>;</p>
<pre class="highlight"><code class="">package com.java.demo;

import java.util.function.Supplier;

public class Demo {
    public static void main(String[] args) {
        Supplier&lt;String&gt; sup = &quot;hello&quot;::toUpperCase;
        System.out.println(sup.get());
    }
}
</code></pre>
<p>范例：断言型接口<br>
· String类中有<code>equalsIgnoreCase()</code></p>
<pre class="highlight"><code class="">import java.util.function.Predicate;

public class Demo {
    public static void main(String[] args) {
        Predicate&lt;String&gt; pre = &quot;hello&quot;::equalsIgnoreCase;
        System.out.println(pre.test(&quot;Hello&quot;));
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识(二)]]></title>
      <url>/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2>
<h3 id="枚举简介"><a class="markdownIt-Anchor" href="#枚举简介"></a> 枚举简介</h3>
<p>1、多例设计模式：<br>
构造方法私有化，而后在类的内部提供有若干个实例化对象，并且通过static方法返回。<br>
范例：定义一个表示颜色基色的多例</p>
<pre class="highlight"><code class="">class Color {
    private String title;
    private static final Color RED = new Color(&quot;红色&quot;);
    private static final Color GREEN = new Color(&quot;绿色&quot;);
    private static final Color BLUE = new Color(&quot;蓝色&quot;);

    private Color(String title) {
        this.title = title;
    }

    public static Color getInstance(int ch) {
        switch (ch) {
            case 1:
                return RED;
            case 2:
                return GREEN;
            case 3:
                return BLUE;
            default:
                return null;
        }

    }

    public String toString() {
        return this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        Color red = Color.getInstance(1);
        System.out.println(red);
    }
}
</code></pre>
<p>2005年之前，Java定义枚举采用上述方式，即多例设计解决了Java无法直接定义枚举的问题。<br>
2、从2005年之后，Java增加了枚举的概念，使用<code>enum</code>关键字定义。<br>
范例：定义枚举</p>
<pre class="highlight"><code class="">enum Color { // 定义枚举类
    RED, GREEN, BLUE; // 实例化对象
}

public class Demo {
    public static void main(String[] args) {
        Color red = Color.RED;
        System.out.println(red);
    }
}
</code></pre>
<p>枚举可以地替代多例设计模式。<br>
3、Java使用enum定义枚举，相当于一个类继承了<code>Enum</code>类。</p>
<blockquote>
<p>public abstract class Enum&lt;E extends Enum<E>&gt;<br>
extends Object<br>
implements Comparable<E>, Serializable</E></E></p>
</blockquote>
<p><code>Enum</code>是一个抽象类，里面定义的构造方法如下：<code>protected Enum(String name, int ordinal)</code><br>
Enum类的构造方法依然是被封装的，也属于构造方法私有化。多例设计模式的前提：构造方法私有化。<br>
4、在Enum类中定义了两个方法：</p>
<blockquote>
<p>· 取得枚举的索引：public final int ordinal();<br>
· 取得枚举的名字：public final String name();<br>
除了以上支持的方法外，使用enum关键字定义的枚举类还有一个<code>values()</code>方法，可以将枚举对象以对象数组的形式的返回。</p>
</blockquote>
<pre class="highlight"><code class="">enum Color { // 定义枚举类
    RED, GREEN, BLUE;
}

public class Demo {
    public static void main(String[] args) {
        for (Color c : Color.values()) {
            System.out.println(c.ordinal() + &quot;-&quot; + c.name());
        }
    }
}
</code></pre>
<blockquote>
<p>请解释enum和Enum的区别？<br>
· enum是一个关键字，而Enum是一个抽象类；<br>
· 使用enum定义的枚举就相当于一个类继承了Enum类。</p>
</blockquote>
<h3 id="定义其它结构"><a class="markdownIt-Anchor" href="#定义其它结构"></a> 定义其它结构</h3>
<p>1、多例设计模式可以在类中定义属性和方法等；枚举也可以，但有如下要求：</p>
<blockquote>
<p>· 枚举之中定义的构造方法不能使用public声明，如果没有无参构造方法，要手工调用构造传递参数；<br>
· 枚举对象必须要放在首行，随后才可以定义属性、构造方法、普通方法。</p>
</blockquote>
<p>范例：扩充枚举功能</p>
<pre class="highlight"><code class="">enum Color { // 定义枚举类
    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行
    private String title; //属性

    private Color(String title) {
        this.title = title;
    }

    public String toString() {
        return this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        for (Color c : Color.values()) {
            System.out.println(c); // 调用toString()
        }
    }
}
</code></pre>
<p>此时与之前定义的多例设计模式操作方式完全相同，而且代码更加简单。<br>
2. 枚举还可以实现接口<br>
范例：枚举实现接口</p>
<pre class="highlight"><code class="">interface Message {
    public String getTitle();
}

enum Color implements Message { // 定义枚举类
    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行
    private String title; //属性

    private Color(String title) {
        this.title = title;
    }

    public String getTitle() {
        return this.title;
    }

    public String toString() {
        return this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        Message msg = Color.RED;
        System.out.println(msg.getTitle());
    }
}
</code></pre>
<p>3、枚举还可以在每个对象后面以匿名内部类的形式使用抽象方法。<br>
范例：另一种形式的接口</p>
<pre class="highlight"><code class="">interface Message {
    public String getTitle();
}

enum Color implements Message { // 定义枚举类
    RED(&quot;红色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }, GREEN(&quot;绿色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }, BLUE(&quot;蓝色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }; // 对象必须要放在首行
    private String title; //属性

    private Color(String title) {
        this.title = title;
    }

    public String getTitle() {
        return this.title;
    }

    public String toString() {
        return this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        Message msg = Color.RED;
        System.out.println(msg.getTitle());
    }
}
</code></pre>
<p>4、枚举中还能直接定义抽象方法，此时每一个枚举对象必须分别覆写抽象方法。<br>
范例：定义抽象方法并覆写</p>
<pre class="highlight"><code class="">enum Color { // 定义枚举类
    RED(&quot;红色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }, GREEN(&quot;绿色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }, BLUE(&quot;蓝色&quot;) {
        public String getTitle() {
            return &quot;自己的&quot; + this;
        }
    }; // 对象必须要放在首行
    private String title; //属性

    private Color(String title) {
        this.title = title;
    }

    public String toString() {
        return this.title;
    }

    public abstract String getTitle();
}

public class Demo {
    public static void main(String[] args) {
        System.out.println(Color.RED.getTitle());
    }
}
</code></pre>
<h3 id="枚举应用"><a class="markdownIt-Anchor" href="#枚举应用"></a> 枚举应用</h3>
<p>1、枚举应用于switch。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Color c =Color.RED;
        switch (c){ // 枚举判断
            case RED:
                System.out.println(&quot;这是红色&quot;);
                break;
            case GREEN:
                System.out.println(&quot;这是绿色&quot;);
                break;
            case BULE:
                System.out.println(&quot;这是蓝色&quot;);
                break;
        }
    }
}
</code></pre>
<p>范例：利用枚举编写一个程序：</p>
<pre class="highlight"><code class="">enum Sex {
    MALE(&quot;男&quot;), FEMALE(&quot;女&quot;);
    private String title;

    private Sex(String title){
        this.title = title;
    }
    public String toString(){
        return this.title;
    }
}

class Person{
    private String name;
    private int age;
    private Sex sex;
    public Person(String name,int age,Sex sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    public String toString(){
        return &quot;姓名:&quot; + this.name +
                &quot;,年龄:&quot; + this.age +
                &quot;,性别:&quot; + this.sex;
    }
}
public class Demo {
    public static void main(String[] args) {
        System.out.println(new Person(&quot;张三&quot;, 24, Sex.FEMALE));
    }
}
</code></pre>
<h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2>
<blockquote>
<p>软件开发经历了三个阶段：<br>
（1）与配置相关的代码写在程序中；<br>
（2）配置与程序代码独立，即程序运行时根据配置文件操作；但会造成配置文件过多时，查错困难；<br>
（3）配置信息对用户而言无用，而且错误的修改还会导致程序异常。因此将配置信息写回到程序中，但利用一些明显的标记来区分配置信息与程序。</p>
</blockquote>
<h3 id="annotation简介"><a class="markdownIt-Anchor" href="#annotation简介"></a> Annotation简介</h3>
<p><code>Annotation</code>是JDK1.5最大的特色，利用注解的形式来实现程序的不同功能。在Java SE中支持自定义<code>Annotation</code>的开发，并且提供了三个最为常用的基础Annotation：<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>。</p>
<h3 id="准确覆写"><a class="markdownIt-Anchor" href="#准确覆写"></a> 准确覆写</h3>
<p>如果在输出对象时，希望其可以返回需要的内容，就必须覆写<code>toString()</code>。<br>
在覆写方法时，可能由于写错方法名等错误，导致未进行覆写，并且这种错误在编译时，并不能被发现。所以为了告诉编译器toString()是覆写的方法，应该加上@Override。</p>
<h3 id="过期声明"><a class="markdownIt-Anchor" href="#过期声明"></a> 过期声明</h3>
<p>假设现在有工具包，其中有一个Demo类，类中有一个fun()。在项目最初阶段，fun()非常适用。但随着技术提升，fun()显得功能不足，此时开发者有两个选择：</p>
<blockquote>
<p>· 1. 直接在新版本的工具包里删除fun()，同时给出新的fun2()；<br>
· 2. 在新版本的开发包里保存fun()，但是通过某种途径告诉开发者，这个方法有问题，同时提供fun2()供开发者使用。</p>
</blockquote>
<p>明显，第二种选择比较合适，可以兼顾已使用fun()的项目。这时，就可以使用<code>@Deprecated</code>声明。<br>
范例：声明过期操作</p>
<pre class="highlight"><code class="">class Book{
    @Deprecated
    public void fun(){}
}


public class Demo {
    public static void main(String[] args) {
        Book bk = new Book();
        bk.fun();
    }
}
</code></pre>
<p>利用此操作可以很好地实现方法功能的新旧交替。</p>
<h3 id="压制警告"><a class="markdownIt-Anchor" href="#压制警告"></a> 压制警告</h3>
<p>可以压制多个警告（warning）</p>
<pre class="highlight"><code class="">class Book&lt;T&gt;{
    private T title;
    public void setTitle(T title){
        this.title = title;
    }
}

public class Demo {
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        Book bk = new Book();
        bk.setTitle(&quot;Hello&quot;);
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL避免乱码]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/MySQL%E9%81%BF%E5%85%8D%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="编码简介"><a class="markdownIt-Anchor" href="#编码简介"></a> 编码简介</h3>
<p>（1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制字符（退格、响铃等）组成；<br>
（2）latin1，占1byte，在ASCII基础上，增加128 ～ 255区间的字符；<br>
（3）GB2312等CJK字符集，可变长字符集，最多占2bytes，用于存储常见的CJK字符；<br>
（4）UTF8，可变长字符集，最多占3bytes，可以囊括ASCII、CJK及其他绝大多数常用语言文字；这中间其实还有个UNICODE字符集，它也是2bytes的，也能囊括ASCII字符，但即便是ASCII字符也需要消耗2bytes，存在一定浪费，而用UTF8存储ASCII字符时，实际只需要1byte，更为节省存储空间；<br>
（5）UTF8MB4，可变长字符集，最多占4bytes，可以包含上面其他几种字符集；同样地，以UTF8MB4存储ASCII字符时，实际上也是只占用1bytes，存储一般的汉字占用3bytes，而存储个别汉字则需要4bytes，存储emoji也至少需要4bytes；<br>
MySQL采用UTF8MB4字符集时,存储文本实际消耗字节数是由文本内容的字节数决定的,并非总是需要4字节,列举几种情况：</p>
<blockquote>
<p>输入字符集任意，且存储ASCII字符时，每个字符需要1byte；<br>
输入字符集是GB2312，且存储的字符是汉字时，每个字符需要2bytes；<br>
输入字符集是UTF8/UTF8MB4，且存储的字符是低编码汉字时，每个字符需要3bytes；<br>
输入字符集是UTF8/UTF8MB4，且存储的字符是高编码汉字时，每个字符需要4bytes；<br>
输入字符集是binary，且存储的字符是高编码汉字时，每个字符需要4bytes；</p>
</blockquote>
<h3 id="表字符集由utf8直接转换成utf8mb4的方法"><a class="markdownIt-Anchor" href="#表字符集由utf8直接转换成utf8mb4的方法"></a> 表字符集由UTF8直接转换成UTF8MB4的方法</h3>
<p>1、只修改字符集（使用默认校验集）</p>
<pre class="highlight"><code class="">mysql&gt; alter table t1 convert to character set utf8mb4
</code></pre>
<p>2、同时修改表字符集和校验集</p>
<pre class="highlight"><code class="">mysql&gt; alter table t1 convert to
  character set utf8mb4 collate utf8mb4_bin;
</code></pre>
<p>3、只修改某列的字符集</p>
<pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)
  character set utf8mb4 not null default ‘’
</code></pre>
<p>4、同时修改某列的字符集和校验集</p>
<pre class="highlight"><code class="">mysql&gt; alter table t1 modify c1 varchar(20)
  character set utf8mb4
  collate utf8mb4_unicode_ci
  not null default ‘’
</code></pre>
<h3 id="mysql端字符集"><a class="markdownIt-Anchor" href="#mysql端字符集"></a> MySQL端字符集</h3>
<blockquote>
<p>character_set_server：server端默认字符集；<br>
character_set_database：database默认字符集，若未设定，则和 character_set_server 的设定一样；database中的数据表/stored procedure/stored function 也可以自行设定字符集，若未指定，则和 character_set_database的设置一样；数据表中的字符类型列，也可以单独设定字符集，若未设定，则和该表指定的字符集一样；<br>
character_set_client：客户端显示读取结果的字符集；<br>
character_set_connection：客户端从server端读取数据时传输字符集；<br>
character_set_results：server端将数据发送给客户端时的字符集；</p>
</blockquote>
<p>MySQL涉及到字符集的设置实在太多，因此强烈建议各个环节全部采用同一种字符集，避免出现意外状况。</p>
<h3 id="总结建议"><a class="markdownIt-Anchor" href="#总结建议"></a> 总结建议</h3>
<p>(1)从前端到后端（浏览器=&gt;WEB Server=&gt;MySQL连接层=&gt;Server层=&gt;DB层&gt;TABLE层）,尽可能使用同一种字符集；<br>
(2)尽可能采用大字符集，也就是优先级：UTF8Mb4 &gt; UTF8 &gt; GBK &gt; LATIN1;<br>
(3)采用逻辑备份数据时，切记要不定期进行恢复测试.</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识(一)]]></title>
      <url>/article/Java/Java/Java%E7%9F%A5%E8%AF%86(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="java5特性"><a class="markdownIt-Anchor" href="#java5特性"></a> Java5特性</h2>
<h3 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h3>
<p>要求：定义一个方法，可以接收多个整型数据的相加。<br>
范例：用数组解决该问题</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(add(new int[]{1, 2, 3}));
        System.out.println(add(new int[]{1, 2}));
    }
    // 实现任意多个整型数据的相加
    // 因为有多个数据，所以用数组接收
    // return 累加的结果

    public static int add(int[] data) {
        int sum = 0;
        for (int x = 0; x &lt; data.length; x++) {
            sum += data[x];
        }
        return sum;
    }
}
</code></pre>
<p>使用数组是因为方法的参数个数是固定的，无法接收随机个参数。但通过数组接收参数不符合预期，理想的调用形式：add(1,2,3),add(10,20);<br>
该功能从JDK1.5后实现，它主要是在方法上使用，定义形式：</p>
<pre class="highlight"><code class="">[public | protected | private] [static] [final] [abstract] 返回值类型 方法名称(数据类型 ... 变量){
    [return [返回值] ;]
}
</code></pre>
<p>上述代码中，[]中的内容可以忽略。上述形式中的参数不再是一个内容，而是多个内容，尽管参数的定义形式变了，但是参数的访问却没变，即进行参数访问的时候按照数组的形式操作。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main (String [] args){
        // 可变参数支持数组
        System.out.println(add(new int[] {1,2,3}));// 传递3个整型数据
        // 可变参数支持参数
        System.out.println(add(1,2,3));// 传递3个整型数据
        System.out.println(add(10,20));// 传递2个整型数据
        System.out.println(add());// 不传递数据
    }
    //        实现任意多个整型数据的相加操作
    //        由于要接收多个整型数据，所以要用数组完成接收
    //        return 多个整型数据的累加结果
    public static int add(int ... data){
        int sum = 0 ;
        for (int x = 0 ; x &lt; data.length ; x ++){
            sum += data[x] ;
        }
        return sum;
    }
}
</code></pre>
<p>在大部分开发中，应该要求参数的个数是准确的，因此可变参数多用于一些程序相关系统类的设计使用上，而不是开发中。可变参数属于数组的变形应用。</p>
<h3 id="foreach循环"><a class="markdownIt-Anchor" href="#foreach循环"></a> foreach循环</h3>
<p>foreach的功能是进行数组或者是集合数据的输出。语法如下：</p>
<pre class="highlight"><code class="">for(类型 变量 : 数组 | 集合)  { 
//  每一次循环会自动将数组内容设置给变量
}
</code></pre>
<p>范例：for循环输出</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main (String [] args){
        int data [] = new int[] {1,2,3,4,5,6};
        for (int x = 0 ; x &lt; data.length ; x ++){
            System.out.println(data[x]) ;
        }
    }
}
</code></pre>
<p>范例：foreach输出</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main (String [] args){
        int data [] = new int[] {1,2,3,4,5,6};
        for (int x : data) { // 循环次数由数组长度决定
            // 每一次循环都表示数组的脚标增长，会取得每个数组的内容，并将其设置给了x
            System.out.println(x);
        }
    }
}
</code></pre>
<h3 id="静态导入"><a class="markdownIt-Anchor" href="#静态导入"></a> 静态导入</h3>
<p>假设一个类中定义的方法都是static方法，那么其他类引用此类时必须用“类名称.方法（）”进行调用。<br>
范例：</p>
<pre class="highlight"><code class="">package com.java.util;

public class MyMath {
    public static int add(int x, int y) {
        return x + y;
    }
    public static int div(int x, int y) {
        return x / y;
    }
}
</code></pre>
<p>此时MyMath中方法都是static方法，随后在其它类中使用这些方法。<br>
范例：基本使用形式</p>
<pre class="highlight"><code class="">package com.java.demo;

import com.java.util.MyMath;

public class Demo {
    public static void main(String [] args) {
        System.out.println(&quot;加法操作：&quot; + MyMath.add(10,20));
        System.out.println(&quot;加法操作：&quot; + MyMath.div(20,10));
    }
}
</code></pre>
<p>范例：静态导入</p>
<pre class="highlight"><code class="">package com.java.demo;
// 将MyMath类中的全部static方法导入，这些方法就好比直接定义在了main方法中
import static com.java.util.MyMath.* ;

public class Demo {
    public static void main(String [] args) {
        System.out.println(&quot;加法操作：&quot; + add(10,20));
        System.out.println(&quot;加法操作：&quot; + div(20,10));
    }
}
</code></pre>
<h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<h3 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h3>
<p>1、要求：定义一个表示坐标的类（Point），该类要保存以下几种坐标：</p>
<blockquote>
<p>· 整数：x = 10、y = 20；<br>
· 小数：x = 10.2、y = 20.3；<br>
· 字符串：x = 东经20度、y = 北纬15度。</p>
</blockquote>
<p>Poin类的设计关键在于x和y的类型。必须有一种类型可以保存这三类数据，首先想到的是Object类型：</p>
<blockquote>
<p>· int：int自动装箱为Integer，Integer向上转型为Object；<br>
· double：double自动装箱为Double，Double向上转型为Object；<br>
· String：直接向上转型为Object；</p>
</blockquote>
<p>范例：设计如下</p>
<pre class="highlight"><code class="">class Point{ // 定义坐标类
    private Object x;
    private Object y;

    public Object getX() {
        return x;
    }

    public void setX(Object x) {
        this.x = x;
    }

    public Object getY() {
        return y;
    }

    public void setY(Object y) {
        this.y = y;
    }
}
</code></pre>
<p>范例：测试上述代码</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Point pA = new Point();
        pA.setX(10);
        pA.setY(20);
        // 2. 取出数据
        int x = (Integer) pA.getX();
        int y = (Integer) pA.getY();
        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);
    }
}
</code></pre>
<p>上述代码利用Object数据类型解决了问题，但依然可能有一定问题。<br>
范例：错误代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Point pA = new Point();
        pA.setX(&quot;东经10度&quot;);
        pA.setY(10);
        // 2. 取出数据
        String x = (String) pA.getX();
        String y = (String) pA.getY();
        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);
    }
}
</code></pre>
<p>上述问题产生的原因是因为设置时存放的是int(Integer),而取出时是String。两个没有任何关系的类对象之间发生强制转换，会出现<code>java.lang.ClassCastException</code>错误。<br>
2、向上转型是为了统一参数，向下转型是为了调用子类定义的特殊功能。向下转型是一种不安全的操作，那么这操作应该在代码运行前排查出来。从JDK1.5增加了泛型，泛型的核心作用在于：类在定义的时候，可以使用一个标记，此标记动态表示类中属性或方法参数的类型，使用时设置具体类型。</p>
<pre class="highlight"><code class="">// T在Point类定义上只表示一个标记，使用时需要为其设置具体的类型
class Point&lt;T&gt; { // 定义坐标,Type = T
    private T x; // 该属性类型未知，由Point动态设置
    private T y; // 该属性类型未知，由Point动态设置

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}
</code></pre>
<p>在使用Point类时，才设置标记的类型，即设置类中属性的类型。<br>
范例：设置为String</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Point&lt;String&gt; pA = new Point();
        pA.setX(&quot;东经10度&quot;);
        pA.setY(&quot;北纬20度&quot;);
        // 此时Point类的类型为String，不需要向下转型
        // 2. 取出数据
        String x = pA.getX();
        String y = pA.getY();
        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);
    }
}
</code></pre>
<p>3、使用泛型后，类中属性的类型都是动态设置的，这样避免了向下转型的问题。但是泛型只能用于类，即不能用于基本数据类型，只能是引用类型（例如，不能用<code>&lt;int&gt;</code>，只能用<code>&lt;Integer&gt;</code>）</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Point&lt;Integer&gt; pA = new Point();
        pA.setX(10);
        pA.setY(20);
        // 利用包装类的自动装箱和自动拆箱
        // 2. 取出数据
        int x = pA.getX();
        int y = pA.getY();
        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);
    }
}
</code></pre>
<p>4、对于泛型有两点说明：</p>
<blockquote>
<p>· 使用泛型类或接口时，没有设置接口的具体类型会出现编译警告，为了保证程序不出错，将默认使用Object表示。</p>
</blockquote>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Point pA = new Point(); // 将使用Object描述泛型
        pA.setX(10);
        pA.setY(20);
        // 2. 取出数据,需要转型
        int x = (Integer) pA.getX();
        int y = (Integer) pA.getY();
        System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;);
    }
}
</code></pre>
<blockquote>
<p>· JDK1.7开始，可以简化泛型声明</p>
</blockquote>
<pre class="highlight"><code class="">Point&lt;Integer&gt; pA = new Point();
</code></pre>
<p>即实例化时只要在前面声明一个泛型的具体类型。</p>
<h3 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h3>
<p>范例：观察下述程序</p>
<pre class="highlight"><code class="">class Message&lt;T&gt; {
    private T msg;

    public void setMsg(T msg) {
        this.msg = msg;
    }

    public T getMsg() {
        return msg;
    }

}

public class Demo {
    public static void main(String[] args) {
        Message&lt;String&gt; m = new Message&lt;String&gt;();
        m.setMsg(&quot;Hello&quot;);
        fun(m); // 引用传递
    }

    public static void fun(Message&lt;String&gt; temp) {
        System.out.println(temp.getMsg());
    }
}
</code></pre>
<p>上述代码为Message类设置String型的泛型，但是此时设置其他类型时，fun()中的Message<String>就不能使用了，并且fun()不能针对不同的泛型进行重载，因为方法重载只认得参数类型，无法辨别泛型的不同。<br>
解决方法一：不设置方法参数的泛型</String></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();
        Message&lt;String&gt; mB = new Message&lt;String&gt;();
        mA.setMsg(100);
        mB.setMsg(&quot;Hello&quot;);
        fun(mA); // 引用传递
        fun(mB);
    }

    public static void fun(Message temp) {
        System.out.println(temp.getMsg());
    }
}
</code></pre>
<p>此时fun()存在警告，因为不设置具体泛型，就会存在警告。并且存在下述问题：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();
        mA.setMsg(100);
        fun(mA); // 引用传递
    }

    public static void fun(Message temp) { // 不设置泛型，默认为Object型
        temp.setMsg(&quot;Hello&quot;); // 设置Striing型
        System.out.println(temp.getMsg());
    }
}
</code></pre>
<p>1、上述代码说明，需要一种方式可以接收任意的泛型类型，但是不可以修改，只能取出。就可以使用<code>?</code>来描述</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) throws Exception {
        Message&lt;Integer&gt; num = new Message&lt;&gt;();
        num.setMsg(100);
        fun(num);
    }

    public static void fun (Message&lt;?&gt; tmp) {
        //tmp.setMsg(&quot;String&quot;); 报错,无法应用
        System.out.println(tmp.getMsg());

    }
}
</code></pre>
<ol start="3">
<li>在<code>?</code>通配符基础上还有两个子通配符：</li>
</ol>
<blockquote>
<p>· ?extends 类：设置泛型上限，可以在声明上和方法参数上使用；<br>
|- ?extends Number：意味着可以设置Number或者Number的子类(Integer，Double等)<br>
· ?super 类：设置泛型下限，方法参数使用；<br>
|-?super String：意味着只能设置String或者它的父类Object.</p>
</blockquote>
<p>范例：设置泛型上限</p>
<pre class="highlight"><code class="">class Message&lt;T extends Number&gt; {
    private T msg;

    public void setMsg(T msg) {
        this.msg = msg;
    }

    public T getMsg() {
        return msg;
    }

}

public class Demo {
    public static void main(String[] args) {
        Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;();
        mA.setMsg(100);
        fun(mA); // 引用传递
    }

    public static void fun(Message&lt;? extends Number&gt; temp) {
        System.out.println(temp.getMsg());
    }
}
</code></pre>
<p>范例：将Integer改为String</p>
<pre class="highlight"><code class="">Message&lt;String&gt; mA = new Message&lt;String&gt;();
</code></pre>
<p>此时设置为非Number或其子类，那就会出现语法错误。<br>
范例：设置泛型下限</p>
<pre class="highlight"><code class="">class Message&lt;T&gt; {
    private T msg;

    public void setMsg(T msg) {
        this.msg = msg;
    }

    public T getMsg() {
        return msg;
    }

}

public class Demo {
    public static void main(String[] args) {
        Message&lt;String&gt; mA = new Message&lt;String&gt;();
        mA.setMsg(&quot;Hello&quot;);
        fun(mA); // 引用传递
    }

    public static void fun(Message&lt;? super String&gt; temp) {
        System.out.println(temp.getMsg());
    }
}
</code></pre>
<h3 id="泛型接口"><a class="markdownIt-Anchor" href="#泛型接口"></a> 泛型接口</h3>
<p>1、泛型可以在接口上声明，这样的接口称为泛型接口。<br>
范例：定义泛型接口</p>
<pre class="highlight"><code class="">// 如果是接口在前面加“I”，例如：IMessage;
// 如果是抽象类前面加Abstract,例如:AbstractMessage
// 如果是普通类直接写，例如：Message
interface IMessage&lt;T&gt; { // 设置泛型接口
    public void print(T t);
}
</code></pre>
<p>2、接口必须定义其相应的子类，定义子类有两种形式：<br>
形式一：在子类继续设置泛型</p>
<pre class="highlight"><code class="">// 子类也继续使用泛型，接口使用和子类一样的泛型标记
class Message&lt;T&gt; implements IMessage&lt;T&gt; {
    public void print(T t) {
        System.out.println(t);
    }
}

public class Demo {
    public static void main(String[] args) {
        IMessage&lt;String&gt; msg = new Message&lt;String&gt;();
        msg.print(&quot;Hello&quot;);
    }
}
</code></pre>
<p>形式二：在子类不设置泛型，但为接口明确定义一个泛型</p>
<pre class="highlight"><code class="">class Message implements IMessage&lt;String&gt; {
    public void print(String t) {
        System.out.println(t);
    }
}

public class Demo {
    public static void main(String[] args) {
        IMessage&lt;String&gt; msg = new Message();
        msg.print(&quot;Hello&quot;);
    }
}
</code></pre>
<h3 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h3>
<p>泛型方法也可以定义在普通类中。<br>
范例：泛型方法定义</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = fun(&quot;Hello&quot;);
        System.out.println(str.length());
    }

    // T的类型由传入的参数类型决定
    public static &lt;T&gt; T fun(T t) {
        return t;
    }
}
</code></pre>
<blockquote>
<p>总结：<br>
1、泛型解决的是向下转型所带来的安全隐患，其核心是在声明类或接口时不设置参数或属性的类型；<br>
2、“?”可以接收任意的泛型类型，只能取出，不能修改泛型</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse使用]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/Tool/Eclipse%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="eclipse简介"><a class="markdownIt-Anchor" href="#eclipse简介"></a> Eclipse简介</h3>
<p>Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包含以下几个部分：JDT、JUNIT、CVS客户端、插件开发、GIT客户端。</p>
<h3 id="jdt使用"><a class="markdownIt-Anchor" href="#jdt使用"></a> JDT使用</h3>
<p>JDT是Eclipse中进行Java程序开发的基础工具。<br>
Eclipse中项目建立完成后，会在项目的文件目录下生成两个子目录：</p>
<blockquote>
<p>· src：保存所有的.java源文件；<br>
· bin：保存所有的.class文件；</p>
</blockquote>
<p>Eclipse最大特点在于代码生成功能。<br>
1、Eclipse中最常用的快捷键：</p>
<blockquote>
<p>·Alt + / ：进行代码提示；<br>
·Ctrl + 1：为错误的代码给出纠正方案；<br>
·Ctrl + Shift + O：组织导入，导入其它包的类；<br>
·Ctrl + D：删除当前行代码；<br>
·Ctrl + Alt + ↓：删除当前行代码；<br>
·Ctrl + /：使用单行注释；<br>
·Ctrl + H：强力搜索；<br>
·Ctrl + Shift + L：全部快捷键列表；</p>
</blockquote>
<p>2、Eclipse中有debug（代码跟踪调试）功能，设置好断点之后，采用调试的方式运行程序。<br>
进入到调试视图后，Eclipse将等待用户的操作指令，并且在设置断点处停止执行，调试方式有如下几个：</p>
<blockquote>
<p>· 单步进入【F5】：指的是进入到执行的方法之中观察方法的执行效果；<br>
· 单步跳过【F6】：在当前代码的表面上执行；<br>
· 单步返回【F7】：不再观察了，返回进入处；<br>
· 恢复执行【F8】：停止调试，直接正常执行完毕；</p>
</blockquote>
<p>在调试过程之中可以清楚地知道方法中所有变量的数值的变化情况。</p>
<h3 id="junit测试工具"><a class="markdownIt-Anchor" href="#junit测试工具"></a> Junit测试工具</h3>
<p>junit是一个测试工具。对于软件测试分为两种：<br>
·黑盒测试：针对功能测试，看不见代码<br>
·白盒测试：针对性能测试，算法的调整<br>
除了上述两种测试，还有一类测试----用例测试（UseCase测试工程师），junit是一个use case测试工具，但是其使用不麻烦。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十七)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%83)/</url>
      <content type="html"><![CDATA[<h2 id="异常捕获及处理"><a class="markdownIt-Anchor" href="#异常捕获及处理"></a> 异常捕获及处理</h2>
<p>合理使用异常处理，可以让程序更加健壮。</p>
<h3 id="异常的产生"><a class="markdownIt-Anchor" href="#异常的产生"></a> 异常的产生</h3>
<p>异常是导致程序中断执行的一种指令流。当异常出现时，如果没有合理处理，程序就会中断执行。<br>
范例：不产生异常的代码</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 2));
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}
</code></pre>
<p>范例：产生异常</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        // 2.中将出现异常
        System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}

// 结果为：
// 1.除法计算开始
// Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
// at com.java.util.Demo.main(Demo.java:7)
</code></pre>
<p>异常产生后，产生异常的语句以及之后的语句将不再执行。默认情况下系统会输出异常信息，而后自动结束程序的执行。</p>
<h3 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h3>
<p>1、Java中进行处理异常，使用<code>try</code>、<code>catch</code>、<code>finally</code>这三个关键字，语法如下：</p>
<pre class="highlight"><code class="">try {
    // 可能出现异常的语句
} catch (异常类型 对象1) {
    // 异常处理
} catch (异常类型 对象2) {
    // 异常处理
} finally {
    // 不论是否出现异常都执行的语句
}
</code></pre>
<p>对于上述操作的组合有：<code>try…catch</code>、<code>try…catch…finally</code>、<code>try…finally</code>(这个不建议使用)。<br>
范例：应用异常处理格式</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));
        } catch (ArithmeticException e) {

        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}

// 结果为：
// 1.除法计算开始
// 3.除法计算结束
</code></pre>
<p>2、出现异常就要处理异常，为了能进行异常处理，可以使用异常类中的<code>printStackTrace()</code>输出完整的异常信息：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));
        } catch (ArithmeticException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}

// 结果为：
// 1.除法计算开始
// java.lang.ArithmeticException: / by zero
// at com.java.util.Demo.main(Demo.java:7)
// 3.除法计算结束
</code></pre>
<p>范例：使用try…catch…finally</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0));
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } finally {
            System.out.println(&quot;不论是否异常，都执行&quot;);
        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}
</code></pre>
<p>3、异常捕获时，一个try语句可以跟多个catch语句。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            int x = Integer.parseInt(args[0]);
            int y = Integer.parseInt(args[1]);
            System.out.println(&quot;2.出发计算：&quot; + (x / y));
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } finally {
            System.out.println(&quot;不论是否异常，都执行&quot;);
        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}
</code></pre>
<p>上述程序将由用户输入数据，可能存在以下异常：<br>
· 用户执行时不输入参数（java Demo）：<code>java.lang.ArrayIndexOutOfBoundsException</code>数组越界错误；<br>
· 输入的数据不是数字（java Demo a b）：<code>java.lang.NumberFormatException</code>；<br>
· 被除数为0（java Demo 10 0）：<code>java.lang.ArithmeticException</code><br>
以上代码只有一个catch，只能处理一个异常，其他异常依然会导致程序中断<br>
范例：增加多个catch</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            int x = Integer.parseInt(args[0]);
            int y = Integer.parseInt(args[1]);
            System.out.println(&quot;2.出发计算：&quot; + (x / y));
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } catch (NumberFormatException e) {
            e.printStackTrace();
        } catch (ArrayIndexOutOfBoundsException e) {
            e.printStackTrace();
        } finally {
            System.out.println(&quot;不论是否异常，都执行&quot;);
        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}
</code></pre>
<h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3>
<p>1、观察两个异常类的继承结构：</p>
<pre class="highlight"><code class="">NumberFormatException：	
java.lang.Object
  |- java.lang.Throwable
      |- Exception
          |- RuntimeException
              |- IllegalArgumentException
                  |- NumberFormatException	
ArithmeticException：
java.lang.Object
  |-java.lang.Throwable
      |- Exception
          |- RuntimeException
              |- ArithmeticException
</code></pre>
<p>由上表可得，所有异常类都是<code>Throwable</code>的子类。Throwable下有两个子类<code>Error</code>和<code>Exception</code>。</p>
<blockquote>
<p>请解释Error和Exception的区别：<br>
· Error：指的是JVM错误，即：此时程序还没有执行，用户不能处理；<br>
· Exception：指的是程序运行中产生的异常，用户可以处理。</p>
</blockquote>
<p>所谓的异常处理指的是Exception以及它的子类异常。<br>
2、异常处理流程图<br>
<img src="/article/Java/Java Base/Java基础知识(十七)/24-1.png" alt="无法加载" title="异常处理流程图"><br>
流程描述：<br>
1）当程序运行时出现异常，由JVM自动根据异常类型实例化一个与之类型匹配的异常类对象；<br>
2）产生异常对象后，会判断当前语句是否存在异常处理。如果没有异常处理，就交给JVM进行默认的异常处理（输出异常信息，结束程序调用）；<br>
3）如果有异常捕获操作，会由try语句捕获产生的异常类实例化对象，之后与catch语句进行比较，如果有符合的捕获类型，则使用catch语句进行异常处理；如果不匹配，则继续向下匹配其它catch语句；<br>
4）不论异常处理是否能够匹配，都要继续执行，如果程序中存在finally语句，就先执行finally语句中的代码，执行完毕后根据之前catch匹配结果来决定如何执行，如果之前成功捕获异常，那就继续执行finally之后的语句；如果没有成功捕获，就交给JVM进行默认处理。<br>
整个过程和catch中的异常类型进行匹配，但是所有Java对象都可以自动向上转型。即如果真的要匹配类型，简单的做法就是匹配Exception。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        System.out.println(&quot;1.除法计算开始&quot;);
        try {
            int x = Integer.parseInt(args[0]);
            int y = Integer.parseInt(args[1]);
            System.out.println(&quot;2.出发计算：&quot; + (x / y));
        } catch (Exception e) {
            e.printStackTrace();
        }  finally {
            System.out.println(&quot;不论是否异常，都执行&quot;);
        }
        System.out.println(&quot;3.除法计算结束&quot;);
    }
}
</code></pre>
<p>上述将所有的异常都交由Exception类处理，因此程序无法知道具体产生的是什么异常。</p>
<blockquote>
<p>说明：<br>
· 使用多个catch时，范围大的异常一定要放在范围小的异常后面，否则会出现语法错误。<br>
· 直接捕获Exception比较方便，但不合理，因为所有异常都按照同种方式处理。项目中应根据具体异常类型处理。</p>
</blockquote>
<h3 id="throws关键字"><a class="markdownIt-Anchor" href="#throws关键字"></a> throws关键字</h3>
<p>1、throws关键字主要用于方法声明，将异常交由被调用处（如main方法）处理。<br>
范例：使用throws关键字</p>
<pre class="highlight"><code class="">class MyMath {
    public static int div(int x, int y) throws Exception {
        // 使用了throws,所以该方法产生的异常交由调用处处理
        return x / y;
    }
}
</code></pre>
<p>范例：调用上述方法</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 必须进行异常处理，否则代码报错
        try {
            System.out.println(MyMath.div(10, 2));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>调用了具有throws声明的方法，不论操作是否异常，都需要使用<code>try..catch</code>进行异常处理。<br>
2.在主方法使用throws关键字后，异常将交给JVM处理，即采用默认处理方式。由于开发的程序多数希望正常结束调用，因此主方法不应该使用throws关键字。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) throws Exception {
        System.out.println(MyMath.div(10, 0));
    }
}
</code></pre>
<h3 id="throw关键字"><a class="markdownIt-Anchor" href="#throw关键字"></a> throw关键字</h3>
<p>1、程序中可以使用throw手工抛出一个异常类的对象。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        try {
            throw new Exception(&quot;自定义异常&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<blockquote>
<p>throws与throw的区别：<br>
·throw：在方法中手工抛出一个异常类对象（该对象可以是自定义的，或者已经存在的）；<br>
·throws：用于方法声明上，使得调用该方法时必须处理异常。</p>
</blockquote>
<h3 id="异常处理标准格式"><a class="markdownIt-Anchor" href="#异常处理标准格式"></a> 异常处理标准格式</h3>
<p>要求：定义div()，在执行除法前打印提示信息，在计算结束后打印提示信息；如果计算中产生了异常，交给调用处处理。<br>
范例：</p>
<pre class="highlight"><code class="">class MyMath {
    public static void div(int x, int y) {
        System.out.println(&quot;==== 除法计算开始 ====&quot;);
        System.out.println(x / y);
        System.out.println(&quot;==== 除法计算结束 ====&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        MyMath.div(10,2);
    }
}
</code></pre>
<p>上述代码可能出现异常，因此要进行异常处理。根据要求，异常交由调用处处理，因此使用throws关键字。</p>
<pre class="highlight"><code class="">class MyMath {
    // 如果div()出现异常，异常交给调用处处理
    public static void div(int x, int y) throws Exception {
        System.out.println(&quot;==== 除法计算开始 ====&quot;);
        System.out.println(x / y);
        System.out.println(&quot;==== 除法计算结束 ====&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        try {
            MyMath.div(10, 2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>上述代码产生错误后，程序运行到<code>System.out.println(&quot;==== 除法计算结束 ====&quot;);</code>就不执行了。<br>
范例：正确做法如下：</p>
<pre class="highlight"><code class="">class MyMath {
    // 如果div()出现异常，异常交给调用处处理
    public static void div(int x, int y) throws Exception {
        System.out.println(&quot;==== 除法计算开始 ====&quot;);
        try {
            System.out.println(x / y);
        } catch (Exception e) {
            throw e; // 抛出异常
        } finally {
            System.out.println(&quot;==== 除法计算结束 ====&quot;);
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        try {
            MyMath.div(10, 0);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="runtimeexception类"><a class="markdownIt-Anchor" href="#runtimeexception类"></a> RuntimeException类</h3>
<p>范例：观察下述程序</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int temp = Integer.parseInt(&quot;100&quot;);
    }
}
</code></pre>
<p>parseInt()： <code>public static int parseInt(String s) throws NumberFormatException;</code><br>
parseInt()抛出了NumberFormatException，按照之前知识点，此处应强制进行异常捕获，但实际并没有该要求：<br>
观察一下NumberFormatException的继承结构:</p>
<pre class="highlight"><code class="">java.lang.Object
  |- java.lang.Throwable
      |- java.lang.Exception
          |- java.lang.RuntimeException → 运行时异常
              |- java.lang.IllegalArgumentException
                  |- java.lang.NumberFormatException
</code></pre>
<p>Java为方便代码编写，提供了RuntimeException类，该类的特征是：程序在编译时，不会强制性要求用户处理异常，用户可以根据自己的需求选择性处理，但是没有处理又发生异常，就会交给JVM默认处理。</p>
<blockquote>
<p>请解释Exception与RuntimeException的区别，请列举常见的几种RuntimeException<br>
· Exception是RuntimeExceptio的父类；<br>
· 使用Exception定义的异常必须要被处理，而RuntimeException的异常可以选择性处理。<br>
·常见的RuntimeException：ArithmeticException、NullPointerException、ClassCastException。</p>
</blockquote>
<h3 id="异常的捕获及处理断言"><a class="markdownIt-Anchor" href="#异常的捕获及处理断言"></a> 异常的捕获及处理（断言）</h3>
<p>assert关键字在JDK1.4引入，其功能是进行断言。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int num = 10;
        assert num == 20 : &quot;num 不等于20&quot;;
        System.out.println(&quot;num = &quot; + num);
    }
}
</code></pre>
<p>默认情况下，断言是不应该影响程序的运行，即Java在解释程序时，断言是默认不起作用的。<br>
启用断言：<code>java -ea Demo</code></p>
<pre class="highlight"><code class="">Exception in thread &quot;main&quot; java.lang.AssertionError: num的内容不是20
        at Demo.main(Demo.java:6)
</code></pre>
<h3 id="异常的捕获及处理自定义异常"><a class="markdownIt-Anchor" href="#异常的捕获及处理自定义异常"></a> 异常的捕获及处理（自定义异常）</h3>
<ol>
<li>Java自身提供了大量的异常类，但对于实际开发是不够。例如：进行添加数据操作时，可能出现错误数据，错误数据出现就应该抛出异常，例如AddException，而该异常Java没有，需要自己开发。<br>
如果要自己开发一个异常类可以选择继承Exception或RuntimeException。<br>
范例：定义AddException</li>
</ol>
<pre class="highlight"><code class="">class AddException extends Exception {
    public AddException(String msg) {
        super(msg);
    }
}

public class Demo {
    public static void main(String[] args) {
        int num = 11;
        try {
            if (num &gt; 10) {
                throw new AddException(&quot;数值传递过大&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>上述代码，只是介绍自定义异常的形式，不能说明自定义异常的作用。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十六)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E5%85%AD)/</url>
      <content type="html"><![CDATA[<h2 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h2>
<h3 id="访问控制权限-2"><a class="markdownIt-Anchor" href="#访问控制权限-2"></a> 访问控制权限</h3>
<p>Java有四种访问控制权限：<code>public,protected,default,private</code>。</p>
<table>
<thead>
<tr>
<th>No.</th>
<th>范围</th>
<th style="text-align:center">public</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">default</th>
<th style="text-align:center">private</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>在同一个类中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>2</td>
<td>在同一包的不同类</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>3</td>
<td>在不同包的子类</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>4</td>
<td>在不同包的非子类</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p><code>protected</code>权限与包的定义有关。<br>
范例：定义com.java.demoA.A类</p>
<pre class="highlight"><code class="">package com.java.demoa;

public class A {
    protected String info = &quot;Hello&quot;;
}
</code></pre>
<p>范例：定义com.java.demoB.B类</p>
<pre class="highlight"><code class="">package com.java.demoB;

import com.java.demoa.A;

public class B extends A { // 与A处于不同包中
    public void print() {
        System.out.println(&quot;A中的info：&quot; + super.info);
    }
}
</code></pre>
<p>范例：测试</p>
<pre class="highlight"><code class="">package com.java.test;

import com.java.demoB.B;

public class Test {
    public static void main(String[] args) {
        new B().print(); // A中的info：Hello
    }
}
</code></pre>
<p>范例：由Test类直接输出A类中的属性</p>
<pre class="highlight"><code class="">package com.java.test;

import com.java.demoa.A;

public class Test {
    public static void main(String[] args) {
        System.out.println(new A().info); // 报错，无法访问info
    }
}
</code></pre>
<p>由于Test与A不在同一个包，并且没有继承关系，所以是无法访问protected权限。</p>
<blockquote>
<p>总结：<br>
1.Java的封装性是以private、protected、default三种权限为主；<br>
2.对于权限的选择，建议如下：<br>
·声明属性就用private；<br>
·声明方法就用public；<br>
3.关于命名要求：<br>
· 类名称每个单词的首字母大写，其余字母小写，例如：StudentInfo；<br>
· 属性名称第一个单词字母小写，而后每个单词首字母大写，例如：studentName；<br>
· 方法名称第一个单词字母小写，而后每个单词首字母大写，例如：toString()；<br>
· 常量名全部大写，例如：MSG；<br>
· 包名全部小写，例如：com.java.demo</p>
</blockquote>
<h3 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式"></a> 单例设计模式</h3>
<p>（1）正常情况下，类只有产生实例化对象后才能操作这个类。<br>
范例：观察程序</p>
<pre class="highlight"><code class="">package com.java.demo;

class Singleton{
    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Singleton singleton = new Singleton(); // 生成实例化对象
        singleton.print();
    }
}
</code></pre>
<p>Singleton类中存在构造方法，没有自定义构造方法时系统会自动生成一个无参无返回值操作的构造方法，即：一个类至少存在一个构造方法。<br>
范例：修改Singleton类定义</p>
<pre class="highlight"><code class="">package com.java.demo;

class Singleton{

    private Singleton() {} // 构造方法私有化

    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Singleton singleton = new Singleton(); // 报错,无法访问Singleton()
        singleton.print();
    }
}
</code></pre>
<p>构造方法私有化后，无法调用构造方法实例化对象。<br>
范例：调用私有化方法<br>
分析步骤：<br>
1.构造方法上使用了private声明，导致构造方法只能内部使用，因此直接在内部实例化对象：</p>
<pre class="highlight"><code class="">class Singleton{
    Singleton instance = new Singleton();

    private Singleton() {} // 构造方法私有化

    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<p>2.<code>instance</code>是普通属性，普通属性只有实例化对象才可以调用，因此需要使用static声明instance属性，使其不受实例化对象控制。</p>
<pre class="highlight"><code class="">package com.java.demo;

class Singleton{
    static Singleton instance = new Singleton();

    private Singleton() {} // 构造方法私有化

    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Singleton singleton = Singleton.instance; 
        singleton.print();
    }
}
</code></pre>
<p>3.类中属性需要进行封装<code>private static Singleton instance = new Singleton();</code><br>
4.获取封装的属性要使用<code>getter()</code>，因此要定义一个同样不受实例化对象控制的getter()，使用static定义。</p>
<pre class="highlight"><code class="">package com.java.demo;

class Singleton{
    private static Singleton instance = new Singleton();

    private Singleton() {} // 构造方法私有化

    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }

    public static Singleton getInstance() {
        return instance;
    }
}

public class Demo {
    public static void main(String[] args) {
        Singleton singletonA = Singleton.getInstance();
        Singleton singletonB = Singleton.getInstance();
        System.out.println(singletonA == singletonB); // true
    }
}
</code></pre>
<p>上述代码的意义：要限制一个类实例化底下的个数，首先要锁定的是构造方法，因为实例化对象必须调用构造方法 ，那么构造方法私有化，就无法产生新的对象。此时要实例化一个对象，就需要在类中使用static定义一个公共对象 ，并使用static方法返回该对象，这样不论外部调用多少次，最终该类中只产生了一个对象，这就是<code>单例设计模式（Singleton）</code>。<br>
（2）单例设计模式有两种形式：饿汉式、懒汉式<br>
上述单例设计模式就属于饿汉式，即在定义Singleton类时就实例化一个对象，不论该对象最后是否被使用。<br>
而懒汉式则是在第一次使用时才进行实例化对象，如果不使用， 就不进行实例化操作。<br>
范例：实现懒汉式</p>
<pre class="highlight"><code class="">class Singleton{
    private static Singleton instance;

    private Singleton() {} // 构造方法私有化

    public void print() {
        System.out.println(&quot;Hello World!&quot;);
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>单例设计模式的目的是让该类在整个系统中只有一个实例化对象。</p>
<h3 id="多例设计模式"><a class="markdownIt-Anchor" href="#多例设计模式"></a> 多例设计模式</h3>
<p>多例设计模式，可以让一个类产生指定数量的实例化对象。<br>
范例：定义一个表示性别的类</p>
<pre class="highlight"><code class="">package com.java.demo;

class Sex {
    private String title;
    private static final Sex MALE = new Sex(&quot;男&quot;);
    private static final Sex FEMALe = new Sex(&quot;女&quot;);

    private Sex(String title) {
        this.title = title;
    }

    public static Sex getInstance(int ch) {
        switch (ch) {
            case 0:
                return FEMALe;
            case 1:
                return MALE;
            default:
                return null;
        }
    }

    @Override
    public String toString() {
        return this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        Sex sex = Sex.getInstance(0);
        System.out.println(sex);
    }
}
</code></pre>
<p>JDK1.7之前，switch只能判断int或char，由于数字或字符表示不太直观，在1.7增加了String判断。</p>
<pre class="highlight"><code class="">package com.java.demo;

class Sex {
    private String title;
    private static final Sex MALE = new Sex(&quot;男&quot;);
    private static final Sex FEMALe = new Sex(&quot;女&quot;);

    private Sex(String title) {
        this.title = title;
    }

    public static Sex getInstance(String sex) {
        switch (sex) {
            case &quot;woman&quot;:
                return FEMALe;
            case &quot;man&quot;:
                return MALE;
            default:
                return null;
        }
    }

    @Override
    public String toString() {
        return this.title;
    }
}
</code></pre>
<p>如果不想在switch语句中使用String，则可以引入一个标记接口（该方式不好）</p>
<pre class="highlight"><code class="">package com.java.demo;

class Sex {
    private String title;
    private static final Sex MALE = new Sex(&quot;男&quot;);
    private static final Sex FEMALe = new Sex(&quot;女&quot;);

    private Sex(String title) {
        this.title = title;
    }

    public static Sex getInstance(int ch) {
        switch (ch) {
            case 0:
                return FEMALe;
            case 1:
                return MALE;
            default:
                return null;
        }
    }

    @Override
    public String toString() {
        return this.title;
    }
}

interface Choose {
    int WOMAN = 0;
    int MAN = 1;
}
public class Demo {
    public static void main(String[] args) {
        Sex sex = Sex.getInstance(Choose.MAN);
        System.out.println(sex);
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十五)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%BA%94)/</url>
      <content type="html"><![CDATA[<h2 id="扩展概念"><a class="markdownIt-Anchor" href="#扩展概念"></a> 扩展概念</h2>
<h3 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h3>
<pre class="highlight"><code class="">interface Message {
    public void print();
}

class Messagelmpl implements Message {
    public void print() {
        System.out.println(&quot;Hello&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        fun(new Messagelmpl());
    }

    public static void fun(Message msg) {
        msg.print();
    }
}
</code></pre>
<p>假如<code>Messagelmpl</code>只使用一次，那么就可以利用匿名内部类。<br>
<strong>范例</strong>：使用匿名内部类</p>
<pre class="highlight"><code class="">interface Message {
    public void print();
}

public class Demo {
    public static void main(String[] args) {
        fun(new Message() {
            // 匿名内部类
            public void print() {
                System.out.println(&quot;Hello&quot;);
            }
        });
    }

    public static void fun(Message msg) {
        msg.print();
    }
}
</code></pre>
<p>使用匿名内部类的前提：<strong>必须基于接口或抽象类的应用。</strong><br>
匿名内部类定义在方法中，方法的参数或是变量要被匿名内部类访问，必须加上<code>final</code>关键字。<strong>匿名内部类的优点在于减少了类的定义。</strong></p>
<h3 id="基本数据类型的包装类"><a class="markdownIt-Anchor" href="#基本数据类型的包装类"></a> 基本数据类型的包装类</h3>
<p>1、Java设计的基本原则：一切皆对象，一切操作都以对象的形式进行描述。此时我们发现，有一个矛盾点，基本数据类型不是对象。对于这个矛盾点，我们可以进行处理：</p>
<pre class="highlight"><code class="">class MyInt { // 定义类
    private int num; // 类封装基本数据类型

    // 定义构造方法，将基本数据类型传递给对象
    public MyInt(int num) {
        this.num = num;
    }

    public int intValue() { // 返回被封装的数据
        return this.num;
    }
}

public class Demo {
    public static void main(String[] args) {
        MyInt mi = new MyInt(10); // 装箱
        int temp = mi.intValue(); // 拆箱
        // 被封装的数据只有拆箱后才能进行计算
        System.out.println(temp * 2);
    }
}
</code></pre>
<p>Java为了方便用户使用，专门提供了一组包装类，来包装所有的基本类型：<code>byte(Byte)</code>、<code>short(Short)</code>、<code>int(Integer)</code>、<code>long(Long)</code>、<code>float(Float)</code>、<code>double(Double)</code>、<code>boolean(Boolean)</code>、<code>char（Character）</code>。（）中为基本类型对应的包装类。</p>
<blockquote>
<p>以上包装类严格讲分为两种子类型：<br>
· 对象型包装类（Object直接子类）：Character，Boolean；<br>
· 数值型包装类（Number直接子类）：Byte、Short、Integer、Float、Long、Double</p>
</blockquote>
<p><code>Numbe</code>是一个抽象类，一共定义了六个操作方法：<code>byteValue()</code>、<code>shortValue()</code>、<code>integerValue()</code>、<code>floatValue()</code>、<code>longValue()</code>、<code>doubleValue()</code>。</p>
<h3 id="装箱与拆箱"><a class="markdownIt-Anchor" href="#装箱与拆箱"></a> 装箱与拆箱</h3>
<p>1、基本数据类型与包装类间的转换通过以下方式：</p>
<blockquote>
<p>· 装箱操作： 将基本数据类型变为包装类的形式：<br>
|- 每个包装类的构造方法都可以接收各自数据类型的变量；<br>
· 拆箱操作： 将包装类取出被包装基本数据类型数据：<br>
|- 利用Number类中提供的一些列xxValue()方法<br>
<strong>范例</strong>：使用int和Integer</p>
</blockquote>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Integer obj = new Integer(10); // 装箱
        int temp = obj.intValue(); // 拆箱
        System.out.println(temp * 2);
    }
}
</code></pre>
<p><strong>范例</strong>：使用double和Double</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Double obj = new Double(10.2); // 装箱
        double temp = obj.doubleValue(); // 拆箱
        System.out.println(temp * 2);
    }
}
</code></pre>
<p><strong>范例</strong>：使用boolean和Boolean</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Boolean obj = new Boolean(true); // 装箱
        boolean temp = obj.booleanValue(); // 拆箱
        System.out.println(!temp);
    }
}
</code></pre>
<p>2、所有包装类都利用同种格式的方法进行操作。但在JDK1.5之后，增加了自动装箱和自动拆箱的机制，并且可以直接使用包装类的对象进行数字计算，为开发提供了便利。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Integer obj = 10; // 自动装箱
        int temp = obj; // 自动拆箱
        obj++; // 包装类直接进行数学计算
        System.out.println(temp * obj);
    }
}
</code></pre>
<p>3、注意点：Integer对象可以直接赋值，也可以使用构造方法赋值，二者有何区别？<br>
两者的区别可以参考String类直接赋值和构造方法赋值的区别。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Integer objA = 10; // 自动装箱
        Integer objB = 10; // 自动装箱
        Integer objC = new Integer(10);
        System.out.println(objA == objB); // true
        System.out.println(objA == objC); // false
        System.out.println(objA.equals(objC)); // true
    }
}
</code></pre>
<p>使用包装类时，几乎都是直接赋值，很少使用构造方法，判断内容是否相等时依然使用<code>equals()</code>方法。<br>
4、Object类可以接收一切引用数据类型，由于自动装箱机制的存在，Object也可以接收基本数据类型。</p>
<blockquote>
<p>流程：基本数据类型 → 自动装箱（成为对象） → 向上转型为Object。</p>
</blockquote>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Object obj = 10;
        // Object不能直接向下转型向int
        // Object只能自动转型为Integer
        int temp = (Integer) obj;
        System.out.println(temp * 2);
    }
}
</code></pre>
<h3 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换"></a> 数据类型转换</h3>
<p>1、包装类多用于数据类型转换：在包装类中提供了将String数据变为基本数据类型的方法。<br>
如下：</p>
<blockquote>
<p>· Integer类：public static int parseInt（String s）；<br>
· Double类：public static double parseDouble（String s）；<br>
· Boolean类：public static boolean parseBoolean（String s）；</p>
</blockquote>
<p><strong>注意</strong>：<code>Character</code>类不存在将字符串变为字符的方法，但<code>String</code>类的<code>charAt()</code>可以根据索引取出字符。<br>
<strong>范例</strong>：将String变为int型</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;123&quot;;
        int temp = Integer.parseInt(str);
        System.out.println(temp * 2);
    }
}
</code></pre>
<p>将字符串变为int型的前提是：<strong>该字符串全部为数字</strong>.<br>
<strong>范例</strong>：将String变为double型</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;12.3&quot;;
        double temp = Double.parseDouble(str);
        System.out.println(temp * 2);
    }
}
</code></pre>
<p><strong>范例</strong>：将String变为boolean</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;true&quot;;
        boolean temp = Boolean.parseBoolean(str);
        System.out.println(!temp);
    }
}
</code></pre>
<p>Boolean转换时，如果字符串的值不是true或false，默认转为false。<br>
2、字符串可以变为基本数据类型，基本数据类型也可变为字符串。方法有两种：<br>
（1）任何基本数据类型与字符串使用<code>+</code>连接后，都会变为String类型数据</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int num = 100;
        String str = num + &quot;&quot;; // 变为String类
        System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199
    }
}
</code></pre>
<p>上述方式虽然完成了转换，但产生了垃圾<code>&quot;&quot;</code><br>
（2）利用<code>public static String valueOf(数据类型 变量)</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int num = 100;
        String str = String.valueOf(num);
        System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199
    }
}
</code></pre>
<p>上述方式不会产生垃圾，因此开发中常用上述方法。</p>
<h2 id="包的定义及使用"><a class="markdownIt-Anchor" href="#包的定义及使用"></a> 包的定义及使用</h2>
<h3 id="包的定义"><a class="markdownIt-Anchor" href="#包的定义"></a> 包的定义</h3>
<p>1、包指的是程序的目录。早期开发一个程序是将所有类写在一个java文件中，编译后程序将直接保存在根目录下。利用包可以实现程序拆分，将不同的类根据要求保存在不同目录中。<br>
包的定义通过关键字<code>package</code>完成。<br>
范例：定义包</p>
<pre class="highlight"><code class="">package com.java.demo;

public class Demo {
    public static void main(String[] args) {
    }
}
</code></pre>
<p>2、定义包时用<code>.</code>表示子目录。如果类中有包的定义，就必须使其保存在对应的目录下，而这些目录不需要手动创建，可以使用命令自动生成：<br>
（1）打包编译：<code>java -d . Demo.java</code><br>
|- <code>-d</code>: 根据<code>package</code>定义生成目录；<br>
|-<code>.</code>：设置保存路径。<code>.</code>表示在当前路径下生成。<br>
（2）解释程序时不要进入包中解释程序，而是在包外输入类的完整名称<code>包.类</code>：<br>
|- <code>java com.java.demo.Demo</code></p>
<h3 id="包的导入"><a class="markdownIt-Anchor" href="#包的导入"></a> 包的导入</h3>
<p>1、使用包可以将一个完整的程序拆分为不同文件，从而分别保存。这存在问题：不同包间可能要进行互相访问，就需要进行导包操作，使用<code>import</code>语句完成。<br>
范例：定义com.java.util.Message</p>
<pre class="highlight"><code class="">package com.java.util;

class Message{
    public static void print(){
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<p>定义com.java.test.TestMessage</p>
<pre class="highlight"><code class="">package com.java.test;

import com.java..util.Message;

public class TestMessage {
    public static void print() {
        Message msg = new Message();
        msg.print();
    }
}
</code></pre>
<p>编译时，应先编译Message，再编译TestMessage：<br>
|- <code>javac -d . Message.java</code><br>
|- <code>javac -d . TestMessage.java</code><br>
此时报错：<strong>Message在com.java.util中不是公共的; 无法从外部程序包中对其进行访问</strong><br>
出现上述问题是因为public class定义的类可以被不同的包访问；而class定义的类只能被本包所访问。因此我们要修改Message.java:</p>
<pre class="highlight"><code class="">package com.java.util;

public class Message{
    public static void print(){
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<p>Java编译器考虑到大型程序开发,因此可以使用通配符<code>*</code>：<code>java -d . *.java</code>编译当前目录下所有java文件。<br>
2、当要导入一个包中多个类时，可以使用<code>import 包.*</code></p>
<pre class="highlight"><code class="">package com.java.test;

import com.java..util.*;

public class TestMessage {
    public static void print() {
        Message msg = new Message();
        msg.print();
    }
}
</code></pre>
<p><code>import 包.*</code>并不是导入包中所有的类，而是只导入程序所需的类，因此不用担心性能问题。<br>
3、一个Java文件可能导入多个包，而不同包中可能存在同名的类。现假设：<br>
·com.java.util.Message;<br>
·com.java.demo.Message.</p>
<pre class="highlight"><code class="">package com.java.demo;

public class Message {
    public static void print() {
        System.out.println(&quot;世界你好！&quot;);
    }
}
</code></pre>
<p>由于需要，要同时导入上述两个类：</p>
<pre class="highlight"><code class="">package com.java.test;

import com.java.demo.Message;
import com.java.util.Message;

public class TestMessage {
    public static void main(String[] args) {
        Message msg = new Message();
        msg.print();
    }
}
</code></pre>
<p>系统报错：<code>Error:(4, 1) java: com.java.demo.Message的 single-type-import 已定义具有相同简名的类型。</code>为了避免该错误，在使用类时，应加上包名：</p>
<pre class="highlight"><code class="">package com.java.test;

import com.java.demo.Message;
import com.java.util.Message;

public class TestMessage {
    public static void main(String[] args) {
        com.java.demo.Message msg = new com.java.demo.Message();
        Message.print();
    }
}
</code></pre>
<h3 id="系统常用包"><a class="markdownIt-Anchor" href="#系统常用包"></a> 系统常用包</h3>
<p>Java提供了许多程序开发包，此外还有许多第三方包。Java自带的常见系统包如下：</p>
<blockquote>
<p>（1）java.lang：包含了String、Object、Integer等类，此包系统自动导入；<br>
（2）java.lang.reflect：反射开发包；<br>
（3）java.util：Java的工具包，提供了大量的工具类，像链表；<br>
（4）java.util.regex：正则工具包；<br>
（5）java.text：国际化处理程序包；<br>
（6）<a href="http://java.io">java.io</a>：进行输入、输出处理以及文件操作；<br>
（7）<a href="http://java.net">java.net</a>：网络编程开发包；<br>
（8）java.sql：数据库程序开发包；<br>
（9）java.applet：Applet程序开发包（已经不用了）；<br>
|-Applet指的是在网页上嵌套的程序，可以使用Applet做一些动态效果，是采用绘图的方式完成的显示。随着时间的发展，Applet程序已经不再使用了（如果要再实现同样的功能，都是用Canvas绘图）。<br>
（10）java.awt、javax.swing：图形界面的开发包，主要功能是开发单机程序界面。<br>
|-JDK1.0时推出了awt开发包，但是这个开发包使用了大量的windows图形函数，使Java丧失了可移植性；<br>
|-JDK1.2时推出了javax.swing开发包，是一个轻量级（Java自己开发的，不再使用windows），所以Java更名为Java2；</p>
</blockquote>
<h3 id="jar命令"><a class="markdownIt-Anchor" href="#jar命令"></a> jar命令</h3>
<p>使用jar命令压缩class文件，压缩的单位为包。<br>
<img src="/article/Java/Java Base/Java基础知识(十五)/22-1.png" alt="无法加载" title="jar命令"><br>
范例：定义Message.java文件</p>
<pre class="highlight"><code class="">package com.java.util;

class Message{
    public static void print(){
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<p>编译后会生成class文件，此时要交付给用户使用，将改包的代码压缩：<code>jar -cvf my.jar com</code>。生成的jar文件不能直接使用，必须配置CLASSPATH才能使用：<code>SET CLASSPATH = .;jar包所在路径</code>。开发中需要使用大量的第三方jar文件，都需要配置CLASSPATH，最简单的配置就是在环境变量中配置。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十四)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E5%9B%9B)/</url>
      <content type="html"><![CDATA[<h2 id="object类"><a class="markdownIt-Anchor" href="#object类"></a> Object类</h2>
<p>Object类用于统一对象、数组和接口。</p>
<h3 id="object类基本描述"><a class="markdownIt-Anchor" href="#object类基本描述"></a> Object类基本描述</h3>
<p>1、<code>Object</code>类是所有类的父类，即任何一个类在没有定义继承某个类时，Object类就是其父类。</p>
<pre class="highlight"><code class="">class Book{}	
class Book extends Object{}
</code></pre>
<p>上述两个类声明是等价的，Object类是唯一没有父类的类。Object类是所有类的父类，因此可以利用Object类通过向上转型，接收所有类型的对象。</p>
<pre class="highlight"><code class="">class Book extends Object {
}

public class Demo {
    public static void main(String[] args) {
        Object objA = new Book(); // 向上转型
        Object objB = &quot;Hello&quot;; // 向上转型
        Book b = (Book) objA; // 向下转型
        String s = (String) objB; // 向下转型
    }
}
</code></pre>
<p>因此在不确定参数类型时，使用Object类型是最好的选择。<br>
2、Object类中定义了一个无参构造方法，因为其是所有类的父类，所以实例化子类对象时必然会调用父类的无参构造方法。</p>
<blockquote>
<p>一般而言，定义简单Java类时应覆写Object类中的如下方法：<br>
· 取得对象信息：public String toString();<br>
· 对象比较：public boolean equals(Object obj);<br>
· 取得对象HASH码：public int hashCode();</p>
</blockquote>
<h3 id="tostring"><a class="markdownIt-Anchor" href="#tostring"></a> toString()</h3>
<pre class="highlight"><code class="">class Book extends Object {
}

public class Demo {
    public static void main(String[] args) {
        Book b = new Book();
        String s = &quot;Hello&quot;;
        System.out.println(b); // Book@1540e19d
        System.out.println(b.toString()); // Book@1540e19d
        System.out.println(s); // Hello
    }
}
</code></pre>
<p>上述代码中直接输出实例对象和使用toString()输出的结果是一样。因为输出对象时，会自动调用toString()将对象变为字符串后输出。Object类中的<code>toString()</code>为了适应对象的输出，仅输出对象的编码。<br>
但是这和我们的想法不符，我们想输出的应该是实例化对象的属性信息，因此要覆写toString()。<br>
<strong>范例</strong>：覆写toString()</p>
<pre class="highlight"><code class="">class Book extends Object {
    private String title;
    private double price;

    // getter,setter,无参构造方法暂时略
    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String toString() {
        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book b = new Book(&quot;Java开发&quot;, 20.3);
        System.out.println(b); // 书名：Java开发,价格：20.3
    }
}
</code></pre>
<p>此时直接输出对象，调用的就是覆写后的方法。</p>
<h3 id="equals"><a class="markdownIt-Anchor" href="#equals"></a> equals()</h3>
<p><strong>范例</strong>：对象比较</p>
<pre class="highlight"><code class="">class Book extends Object {
    private String title;
    private double price;

    // getter,setter,无参构造方法暂时略
    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String toString() {
        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price;
    }

    public boolean equals(Object obj) {
        if (this == obj) { // 地址相同
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof Book)) { // 不是Book类对象
            return false;
        }
        Book book = (Book) obj;
        if (this.title.equals(book.title)
                &amp;&amp; this.price == book.price) {
            return true;
        }
        return false;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bA = new Book(&quot;Java开发&quot;, 20.3);
        Book bB = new Book(&quot;Java开发&quot;, 20.3);
        System.out.println(bA.equals(bB)); // true
        System.out.println(bA.equals(&quot;Hello&quot;)); // false
    }
}
</code></pre>
<p>覆写后的equals()用于进行对象比较。</p>
<h3 id="object接收引用类型"><a class="markdownIt-Anchor" href="#object接收引用类型"></a> Object接收引用类型</h3>
<p>1、Object类是所有类的父类，因此Object类对象可以接收所有类型的对象，包括数组和接口对象。<br>
<strong>范例</strong>：接收数组数据</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Object obj = new int[]{1, 2, 3};
        System.out.println(obj); // [I@1540e19d表示数组
        if (obj instanceof int[]) { // 如果是数组，则输出
            int data[] = (int[]) obj; // 向下转型
            for (int x = 0; x &lt; data.length; x++) {
                System.out.println(data[x]);
            }
        }
    }
}
</code></pre>
<p><strong>范例</strong>：接收接口对象</p>
<pre class="highlight"><code class="">interface A {
    public void fun();
}

class B implements A {
    public void fun() {
        System.out.println(&quot;Hello&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new B();
        Object obj = a;
        A t = (A) obj;
        t.fun(); // Hello
    }
}
</code></pre>
<p>上述代码把参数类型统一为<code>Object</code>，有利于开发。</p>
<h3 id="object修改链表"><a class="markdownIt-Anchor" href="#object修改链表"></a> Object修改链表</h3>
<p>此时我们可以利用Object类的特点解决之前开发的链表存在的问题：<strong>由于参数类型不统一，每次使用都要进行重新开发</strong>。<br>
<strong>范例</strong>：修改链表</p>
<pre class="highlight"><code class="">class Link { // 链表类，外部可见
    private class Node { // 节点类
        private Object data; // 保存数据
        private Node next; // 引用关系

        public Node(Object data) { // 有数据才有Node
            this.data = data;
        }

        // 设置关系
        public void addNode(Node newNode) {
            if (this.next == null) {
                this.next = newNode;
            } else {
                this.next.addNode(newNode);
            }
        }

        // 数据查询
        public boolean containsNode(Object data) {
            if (data.equals(this.data)) { // 当前数据等于要目标数据
                return true; // 结束查询
            } else { // 当前数据不等于目标数据
                if (this.next != null) { // 有后续节点
                    return this.next.containsNode(data);
                } else { // 没有后续节点
                    return false;
                }
            }
        }


        public Object getNode(int index) {
            // 当前foot内容与要查询的索引比较
            // foot自增，目的是下次查询方便
            if (Link.this.foot++ == index) {
                return this.data;
            } else {
                return this.next.getNode(index);
            }
        }

        // 修改节点信息
        public void setNode(int index, Object data) {
            if (Link.this.foot++ == index) {
                this.data = data;
            } else {
                this.next.setNode(index, data);
            }
        }

        // 删除非根节点
        public void removeNode(Node previous, Object data) {
            // 参数中传递上一个节点和要删除的数据
            if (data.equals(this.data)) {
                previous.next = this.next;
            } else {
                this.next.removeNode(this, data);
            }
        }


        public void toArrayNode() {
            Link.this.retArray[Link.this.foot++] = this.data;
            if (this.next != null) {
                this.next.toArrayNode();
            }
        }
    }


    // ====================以上为内部类=====================
    private Node root; // 根节点
    private int count = 0; // 节点的个数
    private int foot = 0; // 索引
    private Object[] retArray; // 返回的数组

    public void add(Object data) {
        if (data == null) { // 输入数据为空
            return;
        }
        Node newNode = new Node(data); // 要保存的数据
        if (this.root == null) { // 根节点不存在
            this.root = newNode; // 设为根节点
        } else { //  根节点存在，交由Node处理
            this.root.addNode(newNode);
        }
        this.count++; // 每次增加节点，count+1
    }


    // 获取链表长度
    public int size() {
        return this.count;
    }

    // 判断是否为空链表
    public boolean isEmpty() {
        return this.count == 0;
    }


    // 判断数据是否存在
    public boolean contains(Object data) {
        if (data == null || root == null) {
            return false;
        }
        return this.root.containsNode(data);
    }

    // 根据索引获取信息
    public Object get(int index) {
        if (index &gt; this.count) { // 超出查询范围
            return null;
        }
        this.foot = 0;
        return this.root.getNode(index); // 查询交给Node类
    }


    // 设置信息
    public void set(int index, Object data) {
        if (index &gt; this.count) {
            return;
        }
        this.foot = 0; // 重置foot,作为索引
        this.root.setNode(index, data); // Node进行修改数据
    }

    // 判断删除节点是否为root
    public void remove(Object data) {
        if (this.contains(data)) { // 判断数据是否存在
            if (data.equals(this.root.data)) { // 判断数据是否是root数据
                this.root = this.root.next;
            } else {
                // root是Node对象，此处直接访问内部类私有操作
                this.root.next.removeNode(this.root, data);
            }
            this.count--; // 删除后数据个数减少
        }
    }

    public Object[] toArray() {
        if (this.root == null) {
            return null;
        }
        this.foot = 0; // 需要脚标控制
        this.retArray = new Object[this.count]; // 根据保存内容开辟数组
        this.root.toArrayNode();
        return this.retArray;
    }
}
</code></pre>
<p><strong>范例</strong>: 测试程序</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Link all = new Link();
        all.add(&quot;A&quot;);
        all.add(&quot;B&quot;);
        all.add(&quot;C&quot;);
        System.out.println(all.size());
        all.remove(&quot;B&quot;);
        Object[] data = all.toArray();
        for (int x = 0; x &lt; data.length; x++) {
            String str = (String) data[x];
            System.out.println(str);
        }
    }
}
</code></pre>
<h3 id="综合实战-宠物商店"><a class="markdownIt-Anchor" href="#综合实战-宠物商店"></a> 综合实战: 宠物商店</h3>
<p><strong>要求</strong>: 以程序结构为主,实现一个宠物商店的模型,具有保存多个宠物的信息(名字,年龄),宠物上架、下架、模糊查询功能。<br>
<strong>思路图</strong>：<br>
<img src="/article/Java/Java Base/Java基础知识(十四)/20-1.png" alt="无法加载" title="思路图"><br>
宠物商店的商品（宠物）要符合宠物这一标准（接口），宠物商店借助链表实现上架、下架和模糊查询功能。<br>
<strong>范例</strong>：定义宠物的标准</p>
<pre class="highlight"><code class="">interface Pet { // 定义宠物的标准
    public String getName();

    public int getAge();
}
</code></pre>
<p>宠物商店与具体的宠物无关，只和宠物这一接口有联系。<br>
<strong>范例</strong>：定义宠物商店</p>
<pre class="highlight"><code class="">class PetShop {
    private Link pets = new Link(); // 要保存的宠物信息

    public void add(Pet pet) { // 上架
        this.pets.add(pet);
    }

    public void delete(Pet pet) { // 下架
        this.pets.remove(pet);
    }

    public Link search(String keyWord) { // 模糊查询，返回的内容个数不明
        Link result = new Link();
        // 将集合以数组的形式返回，
        // 真正要查询的数据是Pet接口对象的getName()的返回值
        Object obj[] = this.pets.toArray();
        for (int x = 0; x &lt; obj.length; x++) {
            Pet p = (Pet) obj[x];
            if (p.getName().contains(keyWord)) {
                result.add(p);
            }
        }
        return result;
    }
}
</code></pre>
<p><strong>范例</strong>： 定义猫类</p>
<pre class="highlight"><code class="">class Cat implements Pet {
    private String name;
    private int age;

    public Cat(String name, int age) {
        this.name = name;
        this.age = age;
    }


    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }

        if (!(obj instanceof Cat)) {
            return false;
        }
        Cat cat = (Cat) obj;
        if (this.name.equals(cat.name)
                &amp;&amp; this.age == cat.age) {
            return true;
        }
        return false;
    }

    public String toString() {
        return &quot;猫名：&quot; + this.name + &quot;, 年龄&quot; + this.age;
    }
}
</code></pre>
<p>可参照上述结构，定义一个狗类。<br>
<strong>范例</strong>：测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        PetShop shop = new PetShop();
        shop.add(new Cat(&quot;阿猫&quot;, 9));
        shop.add(new Cat(&quot;猫咪&quot;, 19));
        shop.add(new Dog(&quot;阿狗&quot;, 10));
        shop.add(new Dog(&quot;狗子&quot;, 8));
        // 模糊查询
        Link all = shop.search(&quot;阿&quot;);
        Object obj[] = all.toArray();
        for (int x = 0; x &lt; obj.length; x++) {
            System.out.println(obj[x]);
        }
        shop.delete(new Dog(&quot;狗子&quot;, 8));
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十三)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2>
<h3 id="接口的基本定义"><a class="markdownIt-Anchor" href="#接口的基本定义"></a> 接口的基本定义</h3>
<p>1、<code>接口</code>是只由抽象方法和全局变量组成的类,使用<code>interface</code>关键字定义。</p>
<pre class="highlight"><code class="">interface A { // 定义接口
    public static final String MSG = &quot;Hello&quot;; // 全局常量

    public abstract void print(); // 抽象方法
}
</code></pre>
<p>由于接口中存在抽象方法，因此接口对象不能直接实例化，其使用原则如下：</p>
<blockquote>
<p>（1）接口必须要有子类，子类可以使用implements关键字实现多接口；<br>
（2）接口的子类（非抽象类时），必须对接口的抽象方法进行覆写；<br>
（3）接口的对象可以利用子类对象通过向上转型实现实例化。</p>
</blockquote>
<pre class="highlight"><code class="">interface A { // 定义接口
    public static final String MSG = &quot;Hello&quot;; // 全局常量

    public abstract void print(); // 抽象方法
}

interface B {
    public abstract void get();
}

class X implements A, B { // X 实现A和B两个接口
    public void print() {
        System.out.println(&quot;A.抽象方法&quot;);
    }

    public void get() {
        System.out.println(&quot;B.抽象方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        X x = new X(); // 实例化子类对象
        A a = x; // 向上转型
        B b = x; // 向上转型
        a.print();
        b.get();
    }
}
</code></pre>
<p>X是A和B的子类，因此X的对象可以变为A或者B接口的对象。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        A a = new X();
        B b = (B) a;
        b.get(); // B.抽象方法
        System.out.println(a instanceof A); // true
        System.out.println(b instanceof B); // true
    }
}
</code></pre>
<p>从结构上来说，A和B接口没有直接关系，但是两个接口拥有共同的子类X，最终实例化的是X，这个子类向上转型为B类对象，因此代码可以执行。<br>
2、子类同时继承类和接口时，语法:<code>class X extends A implements B {}</code><br>
接口的组成只有抽象方法和全局变量，因此可以不写<code>abstract</code>和<code>public static final</code>,并且方法是否使用<code>public</code>定义都是一样的，因为接口只能使用<code>public</code>权限。</p>
<pre class="highlight"><code class="">|interface A{ 
    public static final String MSG = &quot;Hello&quot;; //全局常量
	public abstract void print(); //抽象方法
}	
|interface A{
    String MSG = &quot;Hello&quot;; //全局常量
	void print(); //抽象方法
}
</code></pre>
<p>上述代码是等价的。在接口中，<strong>默认访问权限为<code>public</code></strong>，而不是<code>default</code>。但开发时，定义接口中的方法时要写上public。<br>
3、一个抽象类只能继承一个抽象类，但一个接口可以使用<code>extends</code>关键字同时继承多个接口，接口不能继承抽象类。</p>
<pre class="highlight"><code class="">interface A {
    public void funA();
}

interface B {
    public void funB();
}

interface C extends A, B {
    public void funC();
}

class X implements C {
    public void funA() {
    }

    public void funB() {
    }

    public void funC() {
    }
}
</code></pre>
<p>从继承上来说，抽象类的限制比接口多：</p>
<blockquote>
<p>（1）一个抽象类只能继承一个抽象父类，而接口没有该限制；<br>
（2）一个子类只能继承一个抽象类，但可以实现多接口。</p>
</blockquote>
<p>因此Java中接口的功能是<strong>解决单继承限制</strong>。<br>
4、从概念而言，接口只能由<code>抽象方法和全局变量</code>组成。但接口中可以定义<code>普通内部类、抽象内部类、内部接口</code>。这些内部接口不受接口的概念限制。</p>
<pre class="highlight"><code class="">interface A {
    public void funA();

    abstract class B { // 定义抽象内部类
        public abstract void funB();
    }
}

class X implements A { // X实现A接口
    public void funA() {
    }

    class Y extends B { // 抽象内部类的子类
        public void funB() {
        }
    }
}
</code></pre>
<p>上述代码形式，几乎不会用到。<br>
5、在接口中使用<code>static</code>定义一个内部接口，相当于外部接口。</p>
<pre class="highlight"><code class="">interface A {
    public void funA();

    static interface B { // 相当于外部接口
        public void funB();
    }
}

class X implements A.B { // X实现B接口
    public void funB() {
    }
}
</code></pre>
<blockquote>
<p>总结：<br>
接口在实际开发中的三大作用：<br>
（1）定义不同层之间的操作标准；<br>
（2）表示一种操作的能力；<br>
（3）表示将服务器端的远程方法视图暴露给客户端。</p>
</blockquote>
<h3 id="定义标准"><a class="markdownIt-Anchor" href="#定义标准"></a> 定义标准</h3>
<p><img src="/article/Java/Java Base/Java基础知识(十三)/19-1.png" alt="无法加载" title="定义标准"><br>
根据上图编写代码：电脑利用USB接口标准和其他设备关联。<br>
<strong>范例</strong>：定义USB标准</p>
<pre class="highlight"><code class="">// 标准可以连接不同层的操作类
interface USB { // 接口就是标准
    public void start();
    public void stop();
}
</code></pre>
<p><strong>范例</strong>：定义电脑</p>
<pre class="highlight"><code class="">class Computer{
    public void plugin(USB usb){ // 插入USB设备
        usb.start();
        usb.stop();
    }
}
</code></pre>
<p>不论是什么设备，只要实现了USB标准，就可以在电脑上使用。<br>
<strong>范例</strong>：定义U盘</p>
<pre class="highlight"><code class="">class Flash implements USB {
    public void start() {
        System.out.println(&quot;U盘开始使用&quot;);
    }

    public void stop() {
        System.out.println(&quot;U盘停止使用&quot;);
    }
}
</code></pre>
<p><strong>范例</strong>：定义打印机</p>
<pre class="highlight"><code class="">class Print implements USB {
    public void start() {
        System.out.println(&quot;打印机开始使用&quot;);
    }

    public void stop() {
        System.out.println(&quot;打印机停止使用&quot;);
    }
}
</code></pre>
<p><strong>范例</strong>：测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Computer com = new Computer();
        com.plugin(new Flash());
        com.plugin(new Print());
    }
}
</code></pre>
<p>Java中，<strong>标准就是被定义为接口</strong>。</p>
<h3 id="工厂设计模式"><a class="markdownIt-Anchor" href="#工厂设计模式"></a> 工厂设计模式</h3>
<pre class="highlight"><code class="">interface Fruit {
    public void eat();
}

class Apple implements Fruit {
    public void eat() {
        System.out.println(&quot;吃苹果&quot;);
    }
}
</code></pre>
<p>上述代码通过主方法可以取得Fruit对象，但存在如下问题：</p>
<blockquote>
<p>附：要确定代码是否合理，标准如下：<br>
（1）客户端调用简单，不用关注具体实现；<br>
（2）客户端之外的代码修改，不影响用户的使用，即用户不用关注代码的变更。</p>
</blockquote>
<p>由上述标准可知该程序的问题是一个接口不一定只有子类，现在添加一个Fruit子类：</p>
<pre class="highlight"><code class="">class Orange implements Fruit {
    public void eat() {
        System.out.println(&quot;吃橘子&quot;);
    }
}
</code></pre>
<p>客户端要使用这个新子类，需要修改代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Fruit f = new Orange ();
        f.eat(); // 吃橘子
    }
}
</code></pre>
<p>在上述代码，我们最关注的是如何获得Fruit对象,之后进行方法调用。至于该对象是怎么实例的,不是客户端的工作。<br>
1、上述程序中，客户端每次更换对象，就需要修改主方法的代码，这不符合标准。该问题的关键在于<code>new</code>的使用，这种问题是因为<code>耦合度太高（两者联系程度太高）</code>。<strong>耦合度太高，代码不便于维护</strong>。</p>
<blockquote>
<p>解决思路：参考Java虚拟机的设定-程序→JVM→适应不同的操作系统。</p>
</blockquote>
<p><strong>范例</strong>：增加一个过渡</p>
<pre class="highlight"><code class="">class Factory { // 工厂设计模式
    public static Fruit getInstance(String className) {
        if (&quot;apple&quot;.equals(className)) {
            return new Apple();
        } else if (&quot;orange&quot;.equals(className)) {
            return new Orange();
        } else {
            return null;
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        Fruit f = Factory.getInstance(&quot;apple&quot;);
        f.eat(); // 吃苹果
    }
}
</code></pre>
<p>此时，所有子类对于客户端是不可见的，因为Fruit对象的实例化是通过Factory对象获取的，日后扩充Fruit子类时，只需修改Factory即可，不用修改客户端代码。<br>
<img src="/article/Java/Java Base/Java基础知识(十三)/19-2.png" alt="无法加载" title="工厂设计模式"><br>
上图描述的是工厂设计模式，客户端可见的只有接口和Factory。</p>
<h3 id="代理设计模式"><a class="markdownIt-Anchor" href="#代理设计模式"></a> 代理设计模式</h3>
<p><img src="/article/Java/Java Base/Java基础知识(十三)/19-3.png" alt="无法加载" title="代理设计模式"><br>
代理设计模式的核心在于有一个主题操作接口（可能有很多接口），核心操作类只完成核心功能，而代理主题负责完成所有与核心操作有关的辅助性操作。<br>
1、以<code>去餐馆吃饭为例</code>,外人只看到吃饭,看不到厨师和顾客。皇帝完成核心业务,厨师完成辅助业务。<br>
<img src="/article/Java/Java Base/Java基础知识(十三)/19-4.png" alt="无法加载" title="去餐馆吃饭"></p>
<pre class="highlight"><code class="">package com.java.demo;

interface Subject {  // 核心业务
    public void eat();
}

class RealSubject implements Subject {   // 实际进行核心业务的对象
    public void eat() {
        System.out.println(&quot;顾客在吃饭&quot;);
    }
}

class ProxySubject implements Subject {  // 执行代理操作的对象
    private Subject subject;  // 接收进行核心业务的对象

    public ProxySubject(Subject subject) {
        this.subject = subject;
    }

    public void prepared() {
        System.out.println(&quot;为吃做准备&quot;);
    }

    public void eat() {
        this.prepared();
        this.subject.eat();
        this.destory();
    }

    public void destory() {
        System.out.println(&quot;为吃收尾&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Subject sub = new ProxySubject(new RealSubject());
        sub.eat();  // 调用代理操作
    }
}
</code></pre>
<h3 id="接口与抽象类的区别"><a class="markdownIt-Anchor" href="#接口与抽象类的区别"></a> 接口与抽象类的区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">区别</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">关键字</td>
<td>abstract class</td>
<td>interface</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">组成</td>
<td>构造方法、普通方法、抽象方法、static方法、变量、常量</td>
<td>抽象方法，全局常量</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">子类使用</td>
<td>class 子类 extends 抽象类</td>
<td>class 子类implements 接口,接口…</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">关系</td>
<td>抽象类可以实现多接口</td>
<td>接口不能继承抽象类，却可以继承多个接口</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">权限</td>
<td>可以使用任意权限</td>
<td>只能使用public权限</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">限制</td>
<td>单继承局限</td>
<td>没有单继承局限</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">子类</td>
<td>抽象类和接口都必须有子类，子类必须要覆写全部抽象方法</td>
<td>抽象类和接口都必须有子类，子类必须要覆写全部抽象方法</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">实例化对象</td>
<td>依靠子类对象的向上转型进行对象的实例化</td>
<td>依靠子类对象的向上转型进行对象的实例化</td>
</tr>
</tbody>
</table>
<p>经过比较发现，抽象类存在单继承限制，因此当抽象类和接口都可以使用时，优先考虑接口。</p>
<blockquote>
<p>（1）当进行公共操作时，要定义接口；<br>
（2）有了接口就需要使用子类完善方法<br>
（3）自定义的接口，不能直接实例化接口子类，应使用工厂设计模式。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十二)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="辅助概念"><a class="markdownIt-Anchor" href="#辅助概念"></a> 辅助概念</h2>
<h3 id="关键字final"><a class="markdownIt-Anchor" href="#关键字final"></a> 关键字final</h3>
<p>Java中，<code>final</code>被称为终结器，可以用于定义类、方法、属性，具有如下特点：<br>
1、final定义的类不能有子类</p>
<pre class="highlight"><code class="">final class A{}
class B extends A{} //报错，无法继承A类
</code></pre>
<p>开发系统类或者进行一些架构代码开发时使用到<code>final</code>定义类。<br>
2、final定义的方法不能被方法覆写<br>
父类中某些方法具备某种隐藏的特性，或子类必须使用该方法时，使用final定义，意思是子类不要破坏父类中该方法的结构。</p>
<pre class="highlight"><code class="">class A{
    public final void fun(){}
}
class B extends A{
    public void fun(){} // 报错，无法覆写方法
}

</code></pre>
<p>3、final定义的变量就成了常量。常量必须在定义时设置好值，且不能修改。</p>
<pre class="highlight"><code class="">class A {
    final double GOOD = 100.0;

    public void fun() {
        GOOD = 200; // 无法修改常量GOOD的值
    }
}
</code></pre>
<p>用final定义变量，就可以使用变量名来描述一些数据。开发中常量名均为大写，变量名首个单词小写，之后的单词首字母大写。<br>
4、全局常量：public static final 声明的变量就是全局常量:</p>
<pre class="highlight"><code class="">public static final String MSG = &quot;MLDN&quot;;
</code></pre>
<p>static数据存在公共数据区，因此MSG是一个公共常量。</p>
<blockquote>
<p>总结：<br>
（1）final定义的类和方法不能继承，不能覆写；<br>
（2）public static final 定义的是全局常量，常量名全部大写。</p>
</blockquote>
<h3 id="对象多态性"><a class="markdownIt-Anchor" href="#对象多态性"></a> 对象多态性</h3>
<p>多态性依赖于方法覆写。</p>
<pre class="highlight"><code class="">class A {
    public void print() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
    public void print() {
        System.out.println(&quot;覆写的方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.print(); // 覆写的方法
    }
}
</code></pre>
<p>1、多态性分为两种：</p>
<pre class="highlight"><code class="">（1）方法的多态性
	|- 方法重载：同一个方法名，根据传入的参数类型或个数的不同，执行不同方法体；
	|- 方法覆写：同一个方法，根据对象所属的子类不同，执行不同方法体。
（2）对象的多态性：指发生在具有继承关系的类中，父类与子类的转换。
	|- 向上转型（自动完成）：父类 父类对象 = 子类实例化;
	|- 向下转型（强制完成）：子类 子类对象 = （父类）父类实例化;
</code></pre>
<p><strong>范例</strong>：向上转型</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        A a = new B();
        a.print(); // 覆写的方法
    }
}
</code></pre>
<p><strong>范例</strong>：向下转型</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        B b = (B) new A(); // 向下转型
        b.print(); // 覆写的方法
    }
}
</code></pre>
<p>2、向上转型：由于子类对象都可以自动向上转型，所以可应用于参数的统一。</p>
<pre class="highlight"><code class="">class A {
    public void print() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
    public void print() {
        System.out.println(&quot;B覆写的方法&quot;);
    }
}

class C extends A {
    public void print() {
        System.out.println(&quot;C覆写的方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a1 = new B(); // 向上转型
        A a2 = new C(); // 向上转型
        a1.print(); // B覆写的方法
        a2.print(); // C覆写的方法
    }
}
</code></pre>
<p>a1,a2参数统一后，还可以调用子类覆写的方法，即同一个方法针对不同子类可以有不同实现。<br>
3、向下转型：父类发生向上转型后，不能调用子类中自定义的方法。因此当父类要调用子类自定义方法时，需要进行向下转型，将父类对象变为子类对象。</p>
<pre class="highlight"><code class="">class A {
}

class B extends A {
    public void fun() {
        System.out.println(&quot;自定义方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new B(); // 向上转型
        a.fun(); // 报错，无法调用B自定义方法
    }
}
</code></pre>
<p>向下转型后，可以调用子类自定义的方法：</p>
<pre class="highlight"><code class="">class A {
}

class B extends A {
    public void fun() {
        System.out.println(&quot;自定义方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new B(); // 向上转型
        B b = (B) a; // 向下转型
        b.fun();
    }
}
</code></pre>
<blockquote>
<p>问题：上述代码中不适用向下转型,直接实例化子类对象就可以直接调用fun(),为什么还要转型？<br>
答：数据的操作分为两步：设置数据（最需要进行参数统一）和取出数据。</p>
</blockquote>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        fun(new B()); // 向上转型
    }
    public static void fun(A a){ // 统一参数
        B b = (B) a; // 向下转型
        b.fun(); // 调用子类自定义方法
    }
}
</code></pre>
<p>5、个性化操作在开发中尽量少出现，因为对象的强制转型容易带来安全隐患。</p>
<pre class="highlight"><code class="">class A {
    public void print() {
        System.out.println(&quot;A.print()&quot;);
    }
}

class B extends A {
    public void print() {
        System.out.println(&quot;B.print()&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new A();
        B b = (B) a;
        b.print();
    }
}
</code></pre>
<p>上述代码会报错,<code>Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at ExDemo.main(ExDemo.java:15)</code>，表示类转换异常，指的是两个没有关系的类对象强制进行向下转型时发生的异常，因此向下转型存在风险。<br>
为保证转型的安全性，Java提供关键字<code>instanceof</code>,其返回结果为boolean:<code>对象 instanceof 类</code><br>
如果某个对象是某个类的实例，则会返回true，反之返回false。</p>
<pre class="highlight"><code class="">class A {
    public void print() {
        System.out.println(&quot;A.print()&quot;);
    }
}

class B extends A {
    public void print() {
        System.out.println(&quot;B.print()&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a instanceof A); // true
        System.out.println(a instanceof B); // true
        if (a instanceof B) {
            B b = (B) a;
            b.print(); // B.print()
        }
    }
}
</code></pre>
<p>向下转型前应先进行对象的向上转型，建立关系后才能进行向下转型。</p>
<blockquote>
<p>总结：<br>
（1）大多数情况只使用向上转型，使得参数统一，便于程序设计；子类尽量覆写方法，而不是自定义方法；<br>
（2）极少情况使用向下转型调用子类的自定义方法，或者不转型。</p>
</blockquote>
<h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>1、抽象类是含有抽象方法的类。抽象方法没有方法体，必须用<code>abstract</code>定义。</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    public void fun(){方法体;} // 普通方法
    public abstract void print(); // 抽象方法
}

public class Demo {
    public static void main(String[] args) {
        A a = new A(); // 报错，A是抽象类，无法实例化
    }
}
</code></pre>
<p>结果显示，<strong>无法直接实例化抽象类对象</strong>.普通类的对象实例化后,该对象可以调用类中的属性和方法.而抽象类中存在抽象方法,抽象方法没有方法体无法调用，因此无法产生实例化对象.<br>
2、抽象类使用原则：</p>
<blockquote>
<p>（1）抽象类必须有子类；<br>
（2）抽象类的子类（非抽象类时）必须覆写抽象类中所有的抽象方法（强制子类进行方法覆写）<br>
（3）抽象类对象的实例化依靠子类完成，采用向上转型方式。</p>
</blockquote>
<p><strong>范例</strong>：使用抽象类</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    public void fun() { // 普通方法
        System.out.println(&quot;普通方法&quot;);
    }

    public abstract void print(); // 抽象方法
}

class B extends A {
    // 强制要求对抽象方法进行覆写，否则会报错
    public void print() {
        System.out.println(&quot;覆写后的抽象方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A a = new B(); // 向上转型
        a.fun();
        a.print();
    }
}
</code></pre>
<p>由上述代码，可知：</p>
<blockquote>
<p>（1）抽象类的子类明确要求方法覆写，而普通类没有；<br>
（2）抽象类只比普通类多了抽象方法，其他部分相同；<br>
（3）抽象类对象必须经过向上转型才能实例化；<br>
（4）虽然子类可以继承任何类，但开发中，普通类最好继承抽象类。</p>
</blockquote>
<h3 id="使用限制"><a class="markdownIt-Anchor" href="#使用限制"></a> 使用限制</h3>
<p>1、抽象类由于存在属性，因此会有构造方法来初始化属性。子类对象实例化时依然先执行父类构造方法，再调用子类构造方法。<br>
2、抽象类不能使用final定义，因为抽象类必须有子类。<br>
3、抽象外部类不允许使用<code>static</code>定义，而抽象内部类可以使用<code>static</code>声明。使用<code>static</code>定义的抽象内部类相当于抽象外部类，继承时使用<code>外部类.内部类</code>的形式表示类名。</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    static abstract class B {
        public abstract void print();
    }
}

class X extends A.B {
    public void print() {
        System.out.println(&quot;*****&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A.B ab = new X(); // 向上转型
        ab.print();
    }
}
</code></pre>
<p>4、<code>static</code>定义的方法可以没有实例化对象的情况下直接调用，即使是抽象类中的static方法。</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    public static void print() {
        System.out.println(&quot;static方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        A.print(); // static方法
        A a = new A() ; // 报错
    }
}
</code></pre>
<p>5、有时抽象类只需要一个特定的子类操作，因此可以将该子类定义为该抽象类的内部类。</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    public abstract void print();

    private static class B extends A { // 内部抽象类子类
        public void print() {
            System.out.println(&quot;Hello&quot;);
        }
    }

    public static A getInstance() { // 获取B的实例化对象
        return new B();
    }
}

public class Demo {
    public static void main(String[] args) {
        // 客户端得到抽象类对象时，B对其不可见
        A a = A.getInstance();
        a.print();
    }
}
</code></pre>
<p>上述设计在系统类库中较为常见，目的是：为用户隐藏不需要知道的子类。<br>
6、观察下述代码：</p>
<pre class="highlight"><code class="">abstract class A { // 抽象类
    // 1. 先调用父类构造
    public A() {
        this.print();
    }

    public abstract void print();
}

class B extends A {
    private int num = 100;
    // 3.调用子类构造，并初始化num = 30.运行结束，未输出初始化后的num
    public B(int num) {
        this.num = num;
    }
    // 2. 父类构造调用子类的print，此时num = 0,打印输出。
    public void print() {
        System.out.println(&quot;num = &quot; + num);
    }
}

public class Demo {
    public static void main(String[] args) {
        new B(30); // 4. 结果为0
    }
}
</code></pre>
<p>在构造方法执行完之前，属性的内容均为其对应的数据类型的默认值。子类在执行构造方法前必先执行父类的构造方法，因为此时子类构造方法还没执行，就调用<code>print()</code>输出了num的值，所以num为<code>0</code>.</p>
<h3 id="模板设计模式"><a class="markdownIt-Anchor" href="#模板设计模式"></a> 模板设计模式</h3>
<blockquote>
<p>要求：设计三个类，通过类描述如下行为：<br>
（1）机器人：充电、工作；<br>
（2）人：吃饭、工作、睡觉；<br>
（3）猪：吃饭、睡觉<br>
<strong>思路</strong>：定义一个抽象类，具有吃饭、睡觉、工作的抽象方法。根据子类的不同，具体实现抽象方法。<br>
<img src="/article/Java/Java Base/Java基础知识(十二)/18-2.png" alt="无法加载" title="思路图"></p>
</blockquote>
<pre class="highlight"><code class="">abstract class Action {
    public static final int EAT = 1;
    public static final int SLEEP = 5;
    public static final int WORK = 7;

    public void command(int flag) {
        switch (flag) {
            case EAT:
                this.eat();
                break;
            case SLEEP:
                this.sleep();
                break;
            case WORK:
                this.work();
                break;
            case EAT + WORK:
                this.eat();
                this.work();
                break;
        }
    }
    // 不确定方法中的具体行为，定义为抽象类
    public abstract void eat();

    public abstract void sleep();

    public abstract void work();
}
</code></pre>
<p><strong>定义子类</strong>：</p>
<pre class="highlight"><code class="">class Robot extends Action {
    public void eat() {
        System.out.println(&quot;机器人正在补充能量&quot;);
    }

    public void sleep() {
    }

    public void work() {
        System.out.println(&quot;机器人正在工作&quot;);
    }
}

class Human extends Action {
    public void eat() {
        System.out.println(&quot;人正在吃饭&quot;);
    }

    public void sleep() {
        System.out.println(&quot;人正在睡觉&quot;);
    }

    public void work() {
        System.out.println(&quot;人正在工作&quot;);
    }
}

class Pig extends Action {
    public void eat() {
        System.out.println(&quot;猪正在吃饭&quot;);
    }

    public void sleep() {
        System.out.println(&quot;猪正在睡觉&quot;);
    }

    public void work() {
    }
}
</code></pre>
<p><strong>范例</strong>：测试程序</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        fun(new Robot());
        fun(new Human());
        fun(new Pig());
    }

    public static void fun(Action act) {
        act.command(Action.EAT);
        act.command(Action.SLEEP);
        act.command(Action.WORK);
    }
}
</code></pre>
<p>结果显示：子类要实现操作，必须按照Action类的标准。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IDEA将SpringBoot打包成war]]></title>
      <url>/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/%E4%BD%BF%E7%94%A8IDEA%E5%B0%86SpringBoot%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="修改pomxml"><a class="markdownIt-Anchor" href="#修改pomxml"></a> 修改pom.xml</h2>
<h3 id="将package格式改为war"><a class="markdownIt-Anchor" href="#将package格式改为war"></a> 将package格式改为war</h3>
<pre class="highlight"><code class="">&lt;groupId&gt;com&lt;/groupId&gt;
&lt;artifactId&gt;demo&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre>
<h3 id="排除内置tomcat"><a class="markdownIt-Anchor" href="#排除内置tomcat"></a> 排除内置tomcat</h3>
<pre class="highlight"><code class="">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
	&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="打包过程跳过测试"><a class="markdownIt-Anchor" href="#打包过程跳过测试"></a> 打包过程跳过测试</h3>
<pre class="highlight"><code class="">&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;skip&gt;true&lt;/skip&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<h2 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h2>
<p>打开IDE右侧边栏的<code>Maven Projects</code></p>
<pre class="highlight"><code class="">demo
 |- Lifecycle
	 |- clean
	 |- validate
	 |- compile
	 |- test
	 |- package
	 |- verify
	 |- install
	 |- site
	 |- deploy
 |- Plugins
 |- Dependencies
</code></pre>
<p>双击<code>package</code>即可开始打包，打包后,会在项目文件<code>target</code>中。</p>
<h2 id="发布war包"><a class="markdownIt-Anchor" href="#发布war包"></a> 发布war包</h2>
<p>删除tomcat下webapps中的文件,将文件war包文件复制放入。点击tomcat中bin文件夹下的startup.bat，此时便可进行访问localhost查看SpringBoot。</p>
<pre class="highlight"><code class="">
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.8.RELEASE)

20:45:57 CST 2017]; root of context hierarchy
2017-10-22 20:46:01.008  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello],methods=[GET]}&quot; onto public java.lang.String com.demo.DemoApplication.hello()
2017-10-22 20:46:01.016  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2017-10-22 20:46:01.030  INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView 
2017-10-22 20:46:01.635  INFO 5972 --- [ost-startStop-1] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2017-10-22 20:46:01.687  INFO 5972 --- [ost-startStop-1] com.demo.DemoApplication                 : Started DemoApplication in 5.963 seconds (JVM running for 11.781)
2017-10-22 20:46:02.385  WARN 5972 --- [ost-startStop-1] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [682] milliseconds.
application archive E:\apache-tomcat-8.0.45\webapps\ROOT.war has finished in 10,051 ms
22-Oct-2017 20:46:02.430 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8888&quot;]
22-Oct-2017 20:46:02.454 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]
22-Oct-2017 20:46:02.468 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 10192 ms
</code></pre>
<p>在上述信息中，告诉了我们可以访问的端口为8888.</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十一)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="继承性"><a class="markdownIt-Anchor" href="#继承性"></a> 继承性</h2>
<blockquote>
<p>继承性的作用是解决代码重用问题。</p>
</blockquote>
<h3 id="继承问题的引出"><a class="markdownIt-Anchor" href="#继承问题的引出"></a> 继承问题的引出</h3>
<p>范例:定义两个类Person和Student</p>
<pre class="highlight"><code class="">class Person{
	private String name;
	private int age;
	public void setName(String name){
		this.name = name;
	}
	public void setAge(int age){
		this.age = age;
	}
	public String getName(){
		return this.name; 
	}
	public int getAge(){
		return this.age;
	}
}	
class Student{
    private String name;
	private int age;
	private String school;
	public void setName(String name){
		this.name = name;
	}
	public void setAge(int age){
		this.age = age;
	}
	public void setSchool(String school){
		this.school = school;
	}
	public String getName(){
		return this.name; 
	}
	public int getAge(){
		return this.age;
	}
	public String getSchool(){
		return this.school; 
	}
}
</code></pre>
<p>由代码可见Studen和Person存在代码重复。在自然关系上，Student是Person的一种，只是Student描述的更细致，范围更小。</p>
<h3 id="实现继承"><a class="markdownIt-Anchor" href="#实现继承"></a> 实现继承</h3>
<p>继承使用关键字<code>extends</code>实现，语法如下：<code>class 子类 extends 父类{}</code><br>
子类也被称为<code>派生类</code>，父类也被称为<code>基类、超类或super类</code>。<br>
<strong>范例</strong>：实现继承</p>
<pre class="highlight"><code class="">class Person { // 父类
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

class Student extends Person { // 继承Person类
}

public class Demo {
    public static void main(String[] args) {
        Student stu = new Student();
        stu.setName(&quot;张三&quot;);
        stu.setAge(18);
        System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;,年龄：&quot; + stu.getAge());
    }
}
</code></pre>
<p>Student继承了Person，可以使用Person类中的方法。<br>
<strong>范例</strong>：在Student中添加属性和方法</p>
<pre class="highlight"><code class="">class Student extends Person { // 继承Person类
    private String school;

    public String getSchool() {
        return school;
    }

    public void setSchool(String school) {
        this.school = school;
    }
}
</code></pre>
<p>由上述代码，可知继承性的优点：</p>
<blockquote>
<p>（1）子类可以直接使用父类的属性和方法，进行代码重用；<br>
（2）子类可以扩充属于自己的操作。</p>
</blockquote>
<h3 id="继承的限制"><a class="markdownIt-Anchor" href="#继承的限制"></a> 继承的限制</h3>
<p><strong>Java中继承存在如下限制：</strong><br>
1、Java不允许多重继承，但允许多层继承。<br>
C++允许多继承，即一个子类可以同时继承多个父类。但该操作在Java中是不允许的。多继承是为了使子类可以同时拥有多个父类的操作。Java中使用多层继承替代，语法如下：</p>
<pre class="highlight"><code class="">class A{}
class B extends A{}
class C extends B{}
</code></pre>
<p>相当于C是B的子类，是A的孙子类。多层继承没有层数限制，但最好不超过三层。<br>
2、子类继承父类时，会继承父类全部操作。对于私有操作属于隐式继承，对于非私有操作属于显式继承。</p>
<pre class="highlight"><code class="">class A {
    private String msg;

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}

class B extends A {
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.setMsg(&quot;Hello&quot;);
        System.out.println(b.getMsg()); // Hello
    }
}
</code></pre>
<p>上述代码显示B类中也存在属性msg,因为如果msg不存在，setMsg()设置的内容就不能保存，即getMsg()无法输出内容。</p>
<pre class="highlight"><code class="">class B extends A {
    public void fun() {
        System.out.println(msg); // 报错，无法访问
    }
}
</code></pre>
<p>但是在B类中无法直接访问msg，因为msg是A类的私有属性，只能间接访问。<br>
3、在实例化子类对象之前，会先调用父类构造方法（默认是无参构造方法），以保证父类对象先实例化，而后在实例化子类对象。</p>
<pre class="highlight"><code class="">class A {
    public A() {
        System.out.println(&quot;A 构造方法&quot;);
    }
}

class B extends A {
    public B() {
        System.out.println(&quot;B 构造方法&quot;);
    }

}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        // A 构造方法
        // B 构造方法
    }
}
</code></pre>
<p>由结果可知，在实例化子类对象前，会先实例化父类对象。对于子类构造方法来说相当于隐藏一个”super()”.</p>
<pre class="highlight"><code class="">class B extends A {
    public B() {
        super(); // 父类有无参构造方法时，加不加都一样
        System.out.println(&quot;B 构造方法&quot;);
    }
}
</code></pre>
<blockquote>
<p>何时要在子类构造方法中添加super()：如果父类中没有无参构造方法，就必须使用super调用父类的有参构造方法。</p>
</blockquote>
<pre class="highlight"><code class="">class A {
    public A(String title) {
        System.out.println(&quot;A 构造方法&quot;);
    }
}

class B extends A {
    public B() {
        // 子类默认调用无参构造，但A中没有无参构造
        System.out.println(&quot;B 构造方法&quot;);
    }
}
</code></pre>
<p>上述代码执行后，不会调用A中的有参构造，因此需要在B类中的构造方法添加super():</p>
<pre class="highlight"><code class="">class A {
    public A(String title) {
        System.out.println(&quot;A 构造方法&quot;);
    }
}

class B extends A {
    public B(String title) {
        super(title);
        System.out.println(&quot;B 构造方法&quot;);
    }
}
</code></pre>
<p><code>super()</code>必须放在子类构造方法的第一行。而<code>this()</code>也应该放在构造方法的首行。</p>
<blockquote>
<p><strong>问题：子类构造方法未添加super()，系统默认使用super()调用父类的无参构造方法。如果在子类构造方法中添加this()，那么子类是不是无法调用父类构造方法？</strong></p>
</blockquote>
<pre class="highlight"><code class="">class B extends A {
    public B() { // 报错，构造递归调用
        this(); 
        System.out.println(&quot;B 构造方法&quot;);
    }
}
</code></pre>
<p>由结果可知，super()和this()不能同时存在。不论子类怎么修改，子类构造方法执行前都必须先执行父类的构造方法。</p>
<h3 id="方法覆写"><a class="markdownIt-Anchor" href="#方法覆写"></a> 方法覆写</h3>
<p>继承性的特点是子类可以对父类已有的功能进行扩展。子类在定义属性或方法时有可能与父类重名，该操作就称为覆写。<br>
1、<strong>方法覆写</strong>：子类定义一个与父类方法的方法名、参数类型及个数、返回值都相同的方法。</p>
<pre class="highlight"><code class="">class A {
    public void fun() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.fun(); // A中的方法
    }
}
</code></pre>
<p>此时B中没有fun()，所以调用的是从A继承的fun().<br>
<strong>范例</strong>：方法覆写</p>
<pre class="highlight"><code class="">class A {
    public void fun() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
    public void fun(){ // 方法覆写
        System.out.println(&quot;覆写的方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.fun(); // 覆写的方法
    }
}
</code></pre>
<p>当方法覆写后，此时会调用子类中覆写的方法。<br>
2、覆写结果的分析要素：</p>
<blockquote>
<p>（1）实例化的是那个类；<br>
（2）该对象调用的方法是否被覆写，如果未覆写将调用父类中的方法。</p>
</blockquote>
<pre class="highlight"><code class="">class B extends A {
    public String fun(){ 
        System.out.println(&quot;覆写的方法&quot;);
        // 报错，B中fun()无法覆盖A中fun()，返回类型不兼容
        return &quot;Hello&quot;;
    }
}
</code></pre>
<p><strong>进行方法覆写时，不能改变方法中的返回值和参数个数。</strong><br>
3、方法覆写的使用原则：父类方法不能满足子类需求，但又必须使用该方法名时，要进行方法覆写。<br>
方法覆写时还要考虑到权限问题，被子类覆写的方法不能拥有比父类更高的访问控制权限。</p>
<blockquote>
<p>访问控制权限：public&gt;default&gt;private，private的访问权限最严格。即如果父类方法使用public方法，子类覆写此方法时，只能使用public。父类使用的是default，子类覆写时，只能用default或public.</p>
</blockquote>
<p><strong>范例</strong>：正确覆写</p>
<pre class="highlight"><code class="">class A {
    void fun() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
    public void fun(){
        System.out.println(&quot;覆写的方法&quot;);
    }
}
</code></pre>
<p><strong>错误覆写</strong>：</p>
<pre class="highlight"><code class="">class A {
    public void fun() {
        System.out.println(&quot;A中的方法&quot;);
    }
}

class B extends A {
    void fun(){
        System.out.println(&quot;覆写的方法&quot;);
        // 报错，正在尝试分配更低权限。
    }
}
</code></pre>
<p>上述代码中子类使用default，比public权限更严格，不符合方法覆写原则。</p>
<blockquote>
<p>问题：父类方法使用private声明，子类使用public声明该方法，是覆写吗？<br>
答：从概念上，private声明权限高于public，因此从权限上而言符合覆写的要求。观察下述代码：</p>
</blockquote>
<pre class="highlight"><code class="">class A {
    public void fun() {
        print();
    }
    private void print(){
        System.out.println(&quot;Hello&quot;);
    }
}

class B extends A {
    public void print(){
        System.out.println(&quot;World&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.fun(); // Hello
    }
}
</code></pre>
<p>从上述代码来看，子类并没有覆写print()，因为使用private定义的方法对于子类而言是不可见，因此子类定义的print()虽然符合覆写的要求，但是实际只是相当于定义了一个全新的方法，而不是方法覆写。而正确的覆写结果应该如下：</p>
<pre class="highlight"><code class="">class A {
    public void fun() {
        print();
    }
    public void print(){
        System.out.println(&quot;Hello&quot;);
    }
}

class B extends A {
    public void print(){
        System.out.println(&quot;World&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.fun(); // World
    }
}
</code></pre>
<p>5、默认情况下，子类对象调用是一定是覆写后的方法。</p>
<pre class="highlight"><code class="">class A {
    public void print(){
        System.out.println(&quot;Hello&quot;);
    }
}

class B extends A {
    public void print(){
        print();  // 等同于this.print()
        System.out.println(&quot;World&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.print(); // 报错，方法递归调用，死循环
    }
}
</code></pre>
<p>上述代码中，B类会优先调用B中print()，因此发生了递归调用。如果B中没有print()，则会调用父类中的。<br>
<strong>范例</strong>：调用父类中方法<code>super.方法名()</code></p>
<pre class="highlight"><code class="">class B extends A {
    public void print(){
        super.print();
        System.out.println(&quot;World&quot;);
    }
}
</code></pre>
<blockquote>
<p><strong>super.方法名()与this.方法名()的区别：</strong><br>
（1）this.方法名()会优先查找本类中是否有目标方法，如果有则直接调用，没有就继续在父类中查找。<br>
（2）super.方法名()会直接在父类中查找目标方法，不会在子类中查找。</p>
</blockquote>
<blockquote>
<p><strong>问题：请说明重载（overloading）和覆写（override）的区别</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>No.</th>
<th>区别</th>
<th>重载</th>
<th>覆写</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>英文单词</td>
<td>Overloading</td>
<td>Overrid</td>
</tr>
<tr>
<td>2</td>
<td>发生范围</td>
<td>发生在一个类中</td>
<td>发生在继承关系中</td>
</tr>
<tr>
<td>3</td>
<td>定义</td>
<td>方法名相同，参数类型及个数不相同</td>
<td>方法名称、参数类型及个数，方法返回值都相同</td>
</tr>
<tr>
<td>4</td>
<td>权限</td>
<td>没有权限限制</td>
<td>被覆写的方法不能拥有比父类更严格的权限</td>
</tr>
</tbody>
</table>
<p>在方法重载时，返回值可以不同，但为了程序设计的统一性，应尽量保证返回值类型一致。</p>
<h3 id="属性覆写"><a class="markdownIt-Anchor" href="#属性覆写"></a> 属性覆写</h3>
<p>1、子类定义了与父类完全相同的属性名时，称为属性覆写。</p>
<pre class="highlight"><code class="">class A {
    String info = &quot;Hello&quot;;
}

class B extends A {
    String info = &quot;World&quot;;
    public void print(){
        System.out.println(super.info); // 调用父类属性
        System.out.println(this.info);  // 调用本类属性
    }
}

public class Demo {
    public static void main(String[] args) {
        B b = new B();
        b.print();
    }
}
</code></pre>
<p>由于在开发中，类的属性必须封装，而封装后，属性覆写就没有意义。因为父类定义的私有属性，子类不可见，因此不会互相影响。</p>
<blockquote>
<p><strong>问题：super和this的区别</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>No.</th>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>功能</td>
<td>调用本类中的操作</td>
<td>子类调用父类中的操作</td>
</tr>
<tr>
<td>2</td>
<td>形式</td>
<td>先从本类查找目标操作,再从父类中查找</td>
<td>只查找父类</td>
</tr>
<tr>
<td>3</td>
<td>特殊</td>
<td>表示本类的当前对象</td>
<td>super不能单独使用</td>
</tr>
</tbody>
</table>
<p>在开发中，对于本类或父类的操作，最好加上this.或super.，这样便于代码调试。</p>
<h3 id="继承综合实战数组操作"><a class="markdownIt-Anchor" href="#继承综合实战数组操作"></a> 继承综合实战：数组操作</h3>
<blockquote>
<p>要求：定义Array类，在类中可以进行整型数组的操作：由外部传入数组的数据，可以进行数据的保存和输出，并且在这个类上派生出两个子类：<br>
（1）排序类：通过此类取得的数据可以进行排序；<br>
（2）反转类：通过此类取得的数据采用倒序的方式输出。<br>
开发时，先不考虑子类，先开发父类。</p>
</blockquote>
<h4 id="根据要求定义父类array实现其操作"><a class="markdownIt-Anchor" href="#根据要求定义父类array实现其操作"></a> 根据要求定义父类Array，实现其操作。</h4>
<blockquote>
<p>思路：开辟好数组后，根据索引，一一存放数据。</p>
</blockquote>
<pre class="highlight"><code class="">class Array {
    private int data[]; // 数组
    private int foot; // 脚标
    // 开辟数组空间
    public Array(int len) {
        if (len &gt; 0) { 
            this.data = new int[len];
        } else { // 数组默认长度为1
            this.data = new int[1];
        }
    }
    // 为数组添加数据
    public boolean add(int num) {
        if (this.foot &lt; this.a[this.foot++] = num; // 保存数据
            return true;
        }
        return false;
    }
    // 取得数组内容
    public int[] getData() {
        return this.data;
    }
}

public class Demo {
    public static void main(String[] args) {
        Array array = new Array(3);
        System.out.println(array.add(10)); // true
        System.out.println(array.add(20)); // true
        System.out.println(array.add(30)); // true
        // 超出数组长度，false
        System.out.println(array.add(40));
        int[] temp = array.getData();
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.println(temp[x]); // 10 20 30
        }
    }
}
</code></pre>
<p>####定义子类。</p>
<blockquote>
<p>思路：将Array类getData()返回的结果进行排序输出即可，因此要覆写父类的方法。</p>
</blockquote>
<pre class="highlight"><code class="">// 定义一个排序数组的子类
class SortArray extends Array {
    // Array中没有无参构造方法，
    // 需要明确调用父类的有参构造方法
    public SortArray(int len) {
        super(len);
    }
    // Array的getData()无法排序，进行方法覆写
    public int[] getData() {
        // 调用类库中的方法排序
        java.util.Arrays.sort(super.getData());
        return super.getData();
    }
}

public class Demo {
    public static void main(String[] args) {
        SortArray array = new SortArray(3);
        System.out.println(array.add(20)); // true
        System.out.println(array.add(30)); // true
        System.out.println(array.add(10)); // true
        // 超出数组长度，false
        System.out.println(array.add(40));
        int[] temp = array.getData();
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.println(temp[x]); // 10 20 30
        }
    }
}
</code></pre>
<p>####定义反转子类，也要保持客户端操作不变，因此要覆写父类的方法。</p>
<pre class="highlight"><code class="">// 定义一个反转子类
class ReverseArray extends Array {
    public ReverseArray(int len) {
        super(len);
    }

    public int[] getData() {
        int center = super.getData().length / 2;
        int head = 0;
        int tail = super.getData().length - 1;
        for (int x = 0; x &lt; center; x++) {
            int temp = super.getData()[head];
            super.getData()[head] = super.getData()[tail];
            super.getData()[tail] = temp;
            head++;
            tail--;
        }
        return super.getData();
    }
}

public class Demo {
    public static void main(String[] args) {
        ReverseArray array = new ReverseArray(3);
        System.out.println(array.add(20)); // true
        System.out.println(array.add(10)); // true
        System.out.println(array.add(30)); // true
        // 超出数组长度，false
        System.out.println(array.add(40));
        int[] temp = array.getData();
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.println(temp[x]); // 10 20 30
        }
    }
}
</code></pre>
<blockquote>
<p><strong>总结</strong>：<br>
子类扩充方法时，尽量根据需求覆写父类方法，而不是直接定义新方法。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot小例子进阶]]></title>
      <url>/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/SpringBoot%E5%B0%8F%E4%BE%8B%E5%AD%90%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>本部分代码是基于<code>SpringBoot基础应用</code>博文的。</p>
<blockquote>
<p>代码结构如下：</p>
</blockquote>
<pre class="highlight"><code class="">demo   // 项目名
|- .idea
|- .mvn
|- src  // 代码存放区
   |- main 
      |- java
         |- com.example.demo          // java包
         	|- aspect                 // 拦截器
         	   |- HttpAspect.java     
         	|- controller             // 控制器
         	   |- PersonController   
         	|- domain                 // 实体类
         	   |- Person   
         	   |- Result              // 定义异常的响应信息的格式
         	|- enums
         	   |- ResultEnum          // 定义异常的code和信息
         	|- exception              // 自定义异常
         	   |- PersonException     
         	|- handle                 // 捕获异常
         	   |- ExceptionHandle 
         	|- repository             // jpa操作
         	   |- PersonRepository
         	|- service                // 处理业务逻辑
         	   |- PersonService  
            |- DemoApplication.java   // 项目启动类
      |- resources
         |- static     // 用于存放css,js等样式文件
         |- templates  // 用于存放html文件
         application.properties  // 项目配置文件
   |- test //测试代码存放区
|- target
.gitignore
mvnw
mvnw.cmd
demo.iml
pom.xml // 项目对象模型,添加项目依赖等配置
</code></pre>
<h2 id="实现表单验证"><a class="markdownIt-Anchor" href="#实现表单验证"></a> 实现表单验证</h2>
<blockquote>
<p>要求： age小于18的数据无法入库</p>
</blockquote>
<h3 id="修改person类"><a class="markdownIt-Anchor" href="#修改person类"></a> 修改Person类</h3>
<pre class="highlight"><code class="">package com.example.demo.domain;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.validation.constraints.Min;

@Entity
public class Person {
    @Id
    @GeneratedValue
    private Integer id;
    private String name;

    // @Min 使得该属性必须大于18,当数值小于18时,有提示信息
    @Min(value = 18, message = &quot;年龄小于18无法添加&quot;)
    private Integer age;

    public Person() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
</code></pre>
<h3 id="修改personcontroller类addperson"><a class="markdownIt-Anchor" href="#修改personcontroller类addperson"></a> 修改PersonController类addPerson()</h3>
<pre class="highlight"><code class="">     /**
     * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据
     * @param person 要添加的person对象
     * @param bindingResult 获取绑定结果信息
     * @return 返回Person类信息
     */
    @PostMapping(value = &quot;/person&quot;)
    public Person addPerson(@Valid Person person, BindingResult bindingResult) {
    	// 当输入数据不符合要求时,后台输出错误信息
        if (bindingResult.hasErrors()) {
            System.out.println(bindingResult.getFieldError().getDefaultMessage());
            return null;
        }
        return  personRepository.save(person);
    }
</code></pre>
<p><code>@Valid</code>用于对传入的数据进行校验。</p>
<h2 id="使用aop处理请求"><a class="markdownIt-Anchor" href="#使用aop处理请求"></a> 使用AOP处理请求</h2>
<blockquote>
<p>什么是AOP<br>
(1)AOP(面向切面, Aspect Oriented Programming)是一种编程范式,是一种程序设计思想。思想是将通用逻辑从业务逻辑中分离出来<br>
<img src="/article/框架/Spring Boot/SpringBoot小例子进阶/AOP%E6%80%9D%E6%83%B3.png" alt="无法加载" title="AOP"><br>
将纵向的分析变为横向分析,从而将通用逻辑从业务逻辑中分离出来。<br>
(2)除了AOP还有OOP(面向对象,Object Oriented Programming),POP(面向过程,Proceduer Oriented Programming)</p>
</blockquote>
<h3 id="aop统一处理请求日志"><a class="markdownIt-Anchor" href="#aop统一处理请求日志"></a> AOP统一处理请求日志</h3>
<blockquote>
<p>要求：记录每一个http请求</p>
</blockquote>
<h4 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h4>
<pre class="highlight"><code class="">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="创建httpaspect类"><a class="markdownIt-Anchor" href="#创建httpaspect类"></a> 创建HttpAspect类</h4>
<p><code>@Aspect</code>实现切面注入;<code>@Component</code>将该类注册到SpringBoot容器中</p>
<pre class="highlight"><code class="">package com.example.demo.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;

// 切面注入
@Aspect
@Component
public class HttpAspect {
	// 日志对象
    private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect
            .class);

	// 指明哪些方法需要执行AOP
    @Pointcut(&quot;execution(public * com.example.demo.controller.PersonController&quot; +
            &quot;.*(..))&quot;)
    public void log() {}

    /**
     * 该方法功能是将请求中的信息输出至日志中
     * @Before 在使用PersonController中方法前先执行该注解下的方法
     * @param joinpoint 目标类连接点对象
     */
    @Before(&quot;log()&quot;)
    public void doBefore(JoinPoint joinpoint) {
        ServletRequestAttributes attributes = (ServletRequestAttributes)
                RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        // 获取url
        LOGGER.info(&quot;url = {}&quot;, request.getRequestURL());
        // 获取请求方式
        LOGGER.info(&quot;method = {}&quot;, request.getMethod());
        // 获取请求方的ip
        LOGGER.info(&quot;ip = {}&quot;, request.getRemoteAddr());
        // 获取被调用的方法名
        LOGGER.info(&quot;class_method = {}&quot;,
                joinpoint.getSignature().getDeclaringTypeName() +
                        &quot;.&quot; + joinpoint.getSignature().getName() + &quot;()&quot;);
        // 获取请求参数
        LOGGER.info(&quot;args = {}&quot;, joinpoint.getArgs());

    }

    /** 该方法功能是将响应中的信息输出至日志中
     * @AfterReturning 使得该类可以接收HttpResponse中对象信息
     * @param object 返回的对象信息
     */
    @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;)
    public void doAfterReturning(Object object) {
        LOGGER.info(&quot;response = {}&quot;, object.toString());
    }
}
</code></pre>
<h2 id="统一异常处理"><a class="markdownIt-Anchor" href="#统一异常处理"></a> 统一异常处理</h2>
<blockquote>
<p>要求:获取Person对象的age并判断<br>
age &lt; 12 : 返回&quot;正在上小学&quot;<br>
age &gt; 12 &amp;&amp; age &lt; 15: 返回&quot;正在上初中&quot;</p>
</blockquote>
<h3 id="定义异常响应信息格式"><a class="markdownIt-Anchor" href="#定义异常响应信息格式"></a> 定义异常响应信息格式</h3>
<pre class="highlight"><code class="">package com.example.demo.domain;


public class Result&lt;T&gt; {

    private Integer code; // 错误码
    private String msg;   // 提示信息
    private T data;       // 具体内容

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
</code></pre>
<h3 id="自定义异常类"><a class="markdownIt-Anchor" href="#自定义异常类"></a> 自定义异常类</h3>
<pre class="highlight"><code class="">package com.example.demo.exception;

import com.example.demo.enums.ResultEnum;

public class PersonException extends RuntimeException {
    private Integer code;

    public PersonException(ResultEnum resultEnum) {
        super(resultEnum.getMsg());
        this.code = resultEnum.getCode();
    }
    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}
</code></pre>
<h3 id="规范响应code和msg"><a class="markdownIt-Anchor" href="#规范响应code和msg"></a> 规范响应code和msg</h3>
<pre class="highlight"><code class="">package com.example.demo.enums;

public enum ResultEnum {
    UNKNOW_ERROR(-1, &quot;未知错误&quot;),
    SUCCESS(200, &quot;添加成功&quot;),
    PRIMARY_SCHOOL(403, &quot;在上小学&quot;),
    MIDDLE_SCHOOL(404, &quot;在上初中&quot;),
    ;
    private Integer code;
    private String msg;

    ResultEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>
<h3 id="进行异常捕获"><a class="markdownIt-Anchor" href="#进行异常捕获"></a> 进行异常捕获</h3>
<pre class="highlight"><code class="">package com.example.demo.handle;

import com.example.demo.domain.Result;
import com.example.demo.exception.PersonException;
import com.example.demo.util.ResultUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@ControllerAdvice
public class ExceptionHandle {
    private final static Logger LOGGER = LoggerFactory.getLogger
            (ExceptionHandle.class);
    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public Result handle(Exception e){
        if (e instanceof PersonException) {
            PersonException personException = (PersonException) e;
            return ResultUtil.error(personException.getCode(),
                    personException.getMessage());
        } else {
            LOGGER.error(&quot;[系统异常] {}&quot;, e);
            return ResultUtil.error(-1, &quot;未知错误&quot;);
        }
    }
}
</code></pre>
<h3 id="进行逻辑判断从而判断异常"><a class="markdownIt-Anchor" href="#进行逻辑判断从而判断异常"></a> 进行逻辑判断,从而判断异常</h3>
<pre class="highlight"><code class="">package com.example.demo.service;

import com.example.demo.domain.Person;
import com.example.demo.enums.ResultEnum;
import com.example.demo.exception.PersonException;
import com.example.demo.repository.PersonRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PersonService {
    @Autowired
    private PersonRepository personRepository;

    public void getAge(Integer id) throws Exception{
        Person person = personRepository.findOne(id);
        Integer age = person.getAge();
        if (age &lt; 10) {
            throw new PersonException(ResultEnum.PRIMARY_SCHOOL);
        } else if (age &gt; 10 &amp;&amp; age &lt; 16) {
            throw new PersonException(ResultEnum.MIDDLE_SCHOOL);
        }
    }
}
</code></pre>
<h2 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h2>
<p>对Service进行测试</p>
<pre class="highlight"><code class="">package com.example.demo;

import com.example.demo.domain.Person;
import com.example.demo.service.PersonService;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class PersonServiceTest {
    @Autowired
    private PersonService personService;
    @Test
    public void findOneTest() {
        Person person = personService.findOne(9);
        // 断言
        Assert.assertEquals(new Integer(19), person.getAge());
    }
}
</code></pre>
<p>对API进行测试</p>
<pre class="highlight"><code class="">package com.example.demo.controller;

import com.example.demo.domain.Person;
import com.example.demo.repository.PersonRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet
        .AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class PersonControllerTest {
    @Autowired
    private MockMvc mockMvc;
    @Test
    public void personList() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person&quot;)).
                // 对状态码进行断言
                andExpect(MockMvcResultMatchers.status().isOk()).
                // 对响应文本进行断言
                andExpect(MockMvcResultMatchers.content().string(&quot;&quot;));
    }

}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(十)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%8D%81)/</url>
      <content type="html"><![CDATA[<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2>
<blockquote>
<p>链表是引用的加强应用.<br>
知识点前提：依赖于引用传递；this表示当前对象。</p>
</blockquote>
<h3 id="链表基本概念"><a class="markdownIt-Anchor" href="#链表基本概念"></a> 链表基本概念</h3>
<p>1.链表是一种简单的数据结构，功能是<strong>依靠引用关系实现多个数据的保存。</strong><br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-1.png" alt="无法加载" title="数据保存"><br>
根据上图编写代码：</p>
<blockquote>
<p>要求：定义一个Node类，保存String类型数据，同时拥有下一个节点的引用。</p>
</blockquote>
<pre class="highlight"><code class="">// 每个链表由多个节点组成
class Node { // 定义节点类
    private String data; // 要保存的数据
    private Node next;   // 要保存的下一个节点

    // 每个Node对象都必须保存相应的数据
    public Node(String data) { // 有数据才有Node
        this.data = data;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node getNext() {
        return this.next;
    }

    public String getData() {
        return this.data;
    }
}

</code></pre>
<p><code>Node</code>类专门负责保存节点关系，需要其他类负责Node之间的关系匹配。<br>
<strong>范例</strong>：使用循环取出数据</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Node root = new Node(&quot;火车头&quot;);
        Node n1 = new Node(&quot;车厢A&quot;);
        Node n2 = new Node(&quot;车厢B&quot;);
        root.setNext(n1);
        n1.setNext(n2);
        // 2. 取出数据
        Node currentNode = root; //从根节点开始读取数据
        while (currentNode != null) { // 当前节点存在数据
            System.out.println(currentNode.getData());
            // 将下一节点设置为当前节点
            currentNode = currentNode.getNext();
        }
    }
}
</code></pre>
<p>利用循环取出数据不够便捷，应使用递归。<br>
<strong>范例</strong>：使用递归取出数据</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 1. 设置数据
        Node root = new Node(&quot;火车头&quot;);
        Node n1 = new Node(&quot;车厢A&quot;);
        Node n2 = new Node(&quot;车厢B&quot;);
        root.setNext(n1);
        n1.setNext(n2);
        print(root);
    }
    public static void print(Node current){
        if (current == null){ // 节点不存在
            return ; // 结束方法调用
        }
        System.out.println(current.getData());
        print(current.getNext()); // 递归调用
    }
}
</code></pre>
<p><strong>因为循环次数未知，所以使用while循环。节点操作中，递归比while循环更直观。</strong></p>
<blockquote>
<p><strong>问题：为什么要设置Node类</strong><br>
答：数据本身不具有先后关系，因此需要使用Node类封装份数据，同时利用Node类指向下一节点。</p>
</blockquote>
<h3 id="链表基本实现"><a class="markdownIt-Anchor" href="#链表基本实现"></a> 链表基本实现</h3>
<p>通过分析发现：</p>
<blockquote>
<p>(1)用户操作过程中，Node类应该是不可见的，即用户无需关注Node类的结构<br>
(2)Node之间的关系不应该由用户定义，而应该由一个专门的类处理。</p>
</blockquote>
<p><strong>范例</strong>：定义Link类，隐藏Node类<br>
程序要描述的步骤如下：<br>
<strong>第一步：</strong><br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-2.png" alt="无法加载" title="数据保存"><br>
<strong>第二步：</strong><br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-3.png" alt="无法加载" title="数据保存"><br>
<strong>第三步：</strong><br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-4.png" alt="无法加载" title="数据保存"><br>
<strong>第四步：</strong><br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-5.png" alt="无法加载" title="数据保存"></p>
<pre class="highlight"><code class="">// 处理Node对象间关系
class Link {
    private Node root; // 根节点

    // 设置数据
    public void add(String data) {
        // 为了设置数据的先后关系，将data包装在Node对象中
        Node newNode = new Node(data);
        if (this.root == null) { // 保存数据时，根节点不存在
            // 该判断执行一次，因为链表只有一个根节点
            this.root = newNode; // 将新节点设置为根节点
        } else { // 根节点存在
            // 新节点应交给Node决定
            // 从root之后设置合适的位置
            this.root.addNode(newNode);
        }
    }

    // 输出数据
    public void print() {
        if (this.root != null) {
            this.root.printNode();
        }
    }
}
</code></pre>
<p><strong>范例</strong>:根据Link类，修改Node类</p>
<pre class="highlight"><code class="">class Node { 
    private String data; 
    private Node next;  

    public Node(String data) { 
        this.data = data;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node getNext() {
        return this.next;
    }

    public String getData() {
        return this.data;
    }

    // 添加节点
    // 第一次Link调用: this = link.root
    // 第二次Node调用：this = link.root.next
    // 第三次Node调用：this = link.root.next.next
    public void addNode(Node newNode) {
        if (this.next == null) { // 当前节点的next为空
            this.next = newNode; // 保存为新节点
        } else { 
            // 当前节点的next的next继续保存
            this.next.addNode(newNode);
        }
    }
    // 第一次Link调用: this = link.root
    // 第二次Node调用：this = link.root.next
    // 第三次Node调用：this = link.root.next.next
    public void printNode() {
        System.out.println(this.data); // 输出当前节点数据
        if (this.next != null) { // 当前节点有next
            this.next.printNode(); // 输出next节点信息
        }
    }
}
</code></pre>
<p><strong>范例</strong>：测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Link link = new Link(); // 负责数据操作
        // 增加数据
        link.add(&quot;火车头&quot;);
        link.add(&quot;车厢A&quot;);
        link.add(&quot;车厢B&quot;);
        // 输出数据
        link.print();
    }
}
</code></pre>
<p>由上述代码可知链表操作的基本特点：</p>
<blockquote>
<p>（1）对于客户端而言Node是不可见的，只能利用Link中的方法<br>
（2）Link类的功能是控制Node对象的产生和根节点的使用；<br>
（3）Node类的功能是保存数据以及配置引用关系。</p>
</blockquote>
<h3 id="可用链表基本结构"><a class="markdownIt-Anchor" href="#可用链表基本结构"></a> 可用链表基本结构</h3>
<p>1.可用链表指的是能实现数据的增删改查的链表。<br>
2.可用链表开发要求：Node类负责节点数据的保存以及节点关系的匹配，因此Node类不能被单独使用，即外部不能绕过Link去使用Node<br>
<strong>范例</strong>：修改Node结构，使得Node类只能被Link类使用</p>
<blockquote>
<p>思路：将Node类变为private定义的内部类。</p>
</blockquote>
<pre class="highlight"><code class="">class Link { // 链表类，外部可见
    // Node定义在内部让其只为Link服务
    private class Node { 
        private String data; // 保存数据
        private Node next; // 引用关系

        public Node(String data) { 
            this.data = data;
        }
    }

    // ====================以上为内部类=====================
    private Node root; // 根节点
}
</code></pre>
<p>上述代码即为可用链表的基本结构，后续为其增加功能代码。</p>
<h3 id="增加数据功能"><a class="markdownIt-Anchor" href="#增加数据功能"></a> 增加数据功能</h3>
<blockquote>
<p>思路：数据的增加应由Link负责节点对象的产生，以及根节点的维护。节点间的关系匹配，由Node类处理。</p>
</blockquote>
<p><strong>范例</strong>：Node类中添加<code>addNode()</code>，Link类中添加<code>add()</code></p>
<pre class="highlight"><code class="">// 设置关系
public void addNode(Node newNode) {
    if (this.next == null) {
        this.next = newNode;
    } else {
        this.next.addNode(newNode);
    }
}

public void add(String data) {
    if (data == null) { // 输入数据为空
        return;
    }
    Node newNode = new Node(data); // 要保存的数据
    if (this.root == null) { // 根节点不存在
        this.root = newNode; // 设为根节点
    } else { //  根节点存在，交由Node处理
        this.root.addNode(newNode);
    }
}
</code></pre>
<p>范例：测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Link link = new Link();
        link.add(&quot;火车头&quot;);
        link.add(&quot;车厢A&quot;);
        link.add(&quot;车厢B&quot;);
    }
}

</code></pre>
<h3 id="获取链表长度"><a class="markdownIt-Anchor" href="#获取链表长度"></a> 获取链表长度</h3>
<blockquote>
<p>思路：每个链表对象都只有一个root，可以在Link类中设置count属性，随后每次添加数据后，count自增。</p>
</blockquote>
<p>范例：修改Link类<br>
（1）增加count属性:<code>private int count = 0; // 节点的个数</code><br>
（2）在add()添加统计节点个数的操作</p>
<pre class="highlight"><code class="">public void add(String data) {
   if (data == null) { 
       return;
   }
   Node newNode = new Node(data); 
   if (this.root == null) { 
       this.root = newNode; 
   } else { // 
       this.root.addNode(newNode);
   }
   this.count++; // 每次增加节点，count+1
}
</code></pre>
<p>（3）添加获取链表长度的方法size()</p>
<pre class="highlight"><code class="">public int size() {
    return this.count;
}
</code></pre>
<p>（4）判断链表是否为空，有两种方式，一是判断root是否为null，二是判断count是否为0，在此采用第二种方式，在Link类中添加isEmpty()</p>
<pre class="highlight"><code class="">public boolean isEmpty() {
    return this.count == 0;
}
</code></pre>
<h3 id="内容查询"><a class="markdownIt-Anchor" href="#内容查询"></a> 内容查询</h3>
<blockquote>
<p>思路：判断链表中是否存在某数据，以String为例，仅需遍历链表中的数据，与要查询的数据记性匹配（使用equals(String str)），如果匹配成功返回true，反之返回false。<br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-6.png" alt="无法加载" title="内容查询"><br>
根据上图编写代码：<br>
（1）Link中添加contains()</p>
</blockquote>
<pre class="highlight"><code class="">public boolean contains(String data) {
    if (data == null || root == null) {
        return false;
    }
    return this.root.containsNode(data);
}
</code></pre>
<p>Link从root节点开始查询数据是否存在，数据不存在，Node开始查询非根节点。<br>
（2）Node中添加containsNode()</p>
<pre class="highlight"><code class="">public boolean containsNode(String data) {
    if (data.equals(this.data)) { // 当前数据等于要目标数据
        return true; // 结束查询
    } else { // 当前数据不等于目标数据
        if (this.next != null) { // 有后续节点
            return this.next.containsNode(data);
        } else { 
            return false;
        }
    }
}
</code></pre>
<p>（3）测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Link link = new Link();
        link.add(&quot;火车头&quot;);
        link.add(&quot;车厢A&quot;);
        link.add(&quot;车厢B&quot;);
        System.out.println(link.contains(&quot;火车头&quot;));
    }
}
</code></pre>
<blockquote>
<p>案例中使用的是String类型数据，所以判断数据使用equals(String str)。如果判断的是自定义类型数据，就需要定义一个对象比较的方法，方法名暂定为compare()。</p>
</blockquote>
<h3 id="根据索引取得数据"><a class="markdownIt-Anchor" href="#根据索引取得数据"></a> 根据索引取得数据</h3>
<blockquote>
<p>链表中保存有多个对象。数组也可以保存多个对象。链表和数组相比优势在于没有长度限制。因此链表相当于一个动态对象数组，具备像数组那样根据索引取得元素的功能。<br>
由于是动态对象数组，所以元素的索引也是动态生成的。<br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-7.png" alt="无法加载" title="内容查询"><br>
根据上图，编写代码：<br>
（1）Link中增加foot属性，表示Node的索引:<code>private int foot = 0; // 索引</code><br>
每次查询前，应该重置为0.链表查询数据前应先判断要查询的索引小于索引总数。</p>
</blockquote>
<pre class="highlight"><code class="">public String get(int index) {
    if (index &gt; this.count) { // 超出查询范围
        return null;
    }
    this.foot = 0;
    return this.root.getNode(index); // 查询交给Node类
}
</code></pre>
<p>（2）Node定义getNode()，内部类和外部类间可以方便地进行私有属性的访问。</p>
<pre class="highlight"><code class="">public String getNode(int index) {
    // 当前foot内容与要查询的索引比较
    // foot自增，目的是下次查询方便
    if (Link.this.foot++ == index) {
        return this.data;
    } else {
        return this.next.getNode(index);
    }
}
</code></pre>
<h3 id="修改链表数据"><a class="markdownIt-Anchor" href="#修改链表数据"></a> 修改链表数据</h3>
<blockquote>
<p>修改和查询思路差不多，不同的是查询是当满足索引值时，返回数据；修改是满足索引时，对数据重新赋值。</p>
</blockquote>
<p>（1）Link添加<code>set(int index, String data)</code></p>
<pre class="highlight"><code class="">public void set(int index, String data) {
    if (index &gt; this.count) {
        return;
    }
    this.foot = 0; // 重置foot,作为索引
    this.root.setNode(index, data); // Node进行修改数据
}
</code></pre>
<p>（2）Node添加<code>setNode(int index, String data)</code></p>
<pre class="highlight"><code class="">public void setNode(int index, String data) {
    if (Link.this.foot++ == index) {
        this.data = data;
    } else {
        this.next.setNode(index, data);
    }
}
</code></pre>
<h3 id="删除链表数据"><a class="markdownIt-Anchor" href="#删除链表数据"></a> 删除链表数据</h3>
<blockquote>
<p>删除链表数据应分为两种情况：<br>
（1）要删除的是根节点，root.next()变为root，在Link中处理，因为由Link来维护root；<br>
（2）要删除的是非根节点，当前节点的上一节点.next()=当前节点.next()，即空出了当前节点。非根节点应交由Node处理。</p>
</blockquote>
<p>1.Node添加removeNode(Node previous, String data)</p>
<pre class="highlight"><code class="">public void removeNode(Node previous, String data) {
    // 参数中传递上一个节点和要删除的数据
    if (data.equals(this.data)) {
        previous.next = this.next;
    } else {
        this.next.removeNode(this, data);
    }
}
</code></pre>
<ol start="2">
<li>Link添加remove(String data)</li>
</ol>
<pre class="highlight"><code class="">public void remove(String data) {
    if (this.contains(data)) { // 判断数据是否存在
        if (data.equals(this.root.data)) { // 判断数据是否是root数据
            this.root = this.root.next;
        } else {
            // root是Node对象，此处直接访问内部类私有操作
            this.root.next.removeNode(this.root, data);
        }
this.count -- ; // 删除后数据个数减少
    }
}
</code></pre>
<h3 id="对象数组转换"><a class="markdownIt-Anchor" href="#对象数组转换"></a> 对象数组转换</h3>
<blockquote>
<p>开发中，类中不应该有输出语句。想输出数据应将数据返回到调用处。链表属于动态数组，因此可以将链表以对象数组的形式返回。<br>
<img src="/article/Java/Java Base/Java基础知识(十)/15-8.png" alt="无法加载" title="对象数组转换"><br>
由上图可知，Link的<code>toArray()</code>要返回一个对象数组，且该数组也要由Node操作。因此该数组应定义为Link的属性。<br>
（1）Link添加一个数组属性，便于Node和Link访问。添加toArray()</p>
</blockquote>
<pre class="highlight"><code class="">private String[] retArray; // 返回的数组

public String[] toArray() {
    if (this.root == null) {
        return null;
    }
    this.foot = 0; // 需要脚标控制
    this.retArray = new String[this.count]; // 根据保存内容开辟数组
    this.root.toArrayNode();
    return this.retArray;
}
</code></pre>
<p>（2）Node添加toArrayNode()进行数组数据保存</p>
<pre class="highlight"><code class="">public void toArrayNode() {
    Link.this.retArray[Link.this.foot++] = this.data;
    if (this.next != null) {
        this.next.toArrayNode();
    }
}
</code></pre>
<p><strong>链表数据变为对象数组取出是重要功能！</strong></p>
<h3 id="链表使用"><a class="markdownIt-Anchor" href="#链表使用"></a> 链表使用</h3>
<blockquote>
<p>上述链表只能操作String数据。下面要使用链表操作自定义类，由于链表具有contains()，因此类中需定义对象比较的方法。</p>
</blockquote>
<p>（1）定义Book类（setter/getter暂时省略）</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String getInfo() {
        return &quot;书名：&quot; + this.title + &quot;,价格&quot; + this.price;
    }

    public boolean compare(Book book) {
        if (book == null) {
            return false;
        }
        if (this == book) {
            return true;
        }
        if (this.title.equals(book.title)
                &amp;&amp; this.price == book.price) {
            return true;
        } else {
            return false;
        }
    }
}
</code></pre>
<p>（2）修改链表</p>
<pre class="highlight"><code class="">class Link { 
    private class Node { // 节点类
        private Book data; // 保存数据
        private Node next; // 引用关系

        public Node(Book data) { 
            this.data = data;
        }

        // 设置关系
        public void addNode(Node newNode) {
            if (this.next == null) {
                this.next = newNode;
            } else {
                this.next.addNode(newNode);
            }
        }

        // 数据查询
        public boolean containsNode(Book data) {
            if (data.equals(this.data)) { // 当前数据等于要目标数据
                return true; // 结束查询
            } else { // 当前数据不等于目标数据
                if (this.next != null) { // 有后续节点
                    return this.next.containsNode(data);
                } else { // 没有后续节点
                    return false;
                }
            }
        }


        public Book getNode(int index) {
            // 当前foot内容与要查询的索引比较
            // foot自增，目的是下次查询方便
            if (Link.this.foot++ == index) {
                return this.data;
            } else {
                return this.next.getNode(index);
            }
        }

        // 修改节点信息
        public void setNode(int index, Book data) {
            if (Link.this.foot++ == index) {
                this.data = data;
            } else {
                this.next.setNode(index, data);
            }
        }

        // 删除非根节点
        public void removeNode(Node previous, Book data) {
            // 参数中传递上一个节点和要删除的数据
            if (data.equals(this.data)) {
                previous.next = this.next;
            } else {
                this.next.removeNode(this, data);
            }
        }

        public void toArrayNode() {
            Link.this.retArray[Link.this.foot++] = this.data;
            if (this.next != null) {
                this.next.toArrayNode();
            }
        }
    }


    // ====================以上为内部类=====================
    private Node root; // 根节点
    private int count = 0; // 节点的个数
    private int foot = 0; // 索引
    private Book[] retArray; // 返回的数组

    public void add(Book data) {
        if (data == null) { // 输入数据为空
            return;
        }
        Node newNode = new Node(data); // 要保存的数据
        if (this.root == null) { // 根节点不存在
            this.root = newNode; // 设为根节点
        } else { //  根节点存在，交由Node处理
            this.root.addNode(newNode);
        }
        this.count++; // 每次增加节点，count+1
    }

    // 获取链表长度
    public int size() {
        return this.count;
    }

    // 判断是否为空链表
    public boolean isEmpty() {
        return this.count == 0;
    }


    // 判断数据是否存在
    public boolean contains(Book data) {
        if (data == null || root == null) {
            return false;
        }
        return this.root.containsNode(data);
    }

    // 根据索引获取信息
    public Book get(int index) {
        if (index &gt; this.count) { // 超出查询范围
            return null;
        }
        this.foot = 0;
        return this.root.getNode(index); // 查询交给Node类
    }

    // 设置信息
    public void set(int index, Book data) {
        if (index &gt; this.count) {
            return;
        }
        this.foot = 0; // 重置foot,作为索引
        this.root.setNode(index, data); // Node进行修改数据
    }


    // 判断删除节点是否为root
    public void remove(Book data) {
        if (this.contains(data)) { // 判断数据是否存在
            if (data.equals(this.root.data)) { // 判断数据是否是root数据
                this.root = this.root.next;
            } else {
                // root是Node对象，此处直接访问内部类私有操作
                this.root.next.removeNode(this.root, data);
            }
            this.count--; // 删除后数据个数减少
        }
    }

    public Book[] toArray() {
        if (this.root == null) {
            return null;
        }
        this.foot = 0; // 需要脚标控制
        this.retArray = new Book[this.count]; // 根据保存内容开辟数组
        this.root.toArrayNode();
        return this.retArray;
    }
}
</code></pre>
<p>（3）测试</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Link all = new Link();
        all.add(new Book(&quot;Java开发&quot;, 69.8));
        all.add(new Book(&quot;JSP&quot;, 78.8));
        all.add(new Book(&quot;C++开发&quot;, 19.8));
        System.out.println(&quot;保存书的个数：&quot; + all.size());
        System.out.println(all.contains(new Book(&quot;Java开发&quot;, 69.8)));
        all.remove(new Book(&quot;C++开发&quot;, 19.8));
        Book[] books = all.toArray();
        for (int x = 0; x &lt; books.length; x++) {
            System.out.println(books[x].getInfo());
        }
    }
}
</code></pre>
<p>链表的最佳应用就是横向替换对象数组。</p>
<h3 id="在映射中使用链表"><a class="markdownIt-Anchor" href="#在映射中使用链表"></a> 在映射中使用链表</h3>
<blockquote>
<p>链表属于动态对象数组。之前进行数据表映射时，都会出现对象数组的概念，现在就用链表来进行对象保存。本节以一对多为例，即用前文中的省份-城市表为例：</p>
</blockquote>
<p>（1）对于使用链表的类，要添加对象比较的方法</p>
<pre class="highlight"><code class="">class Province {
    private int pid;
    private String pname;
    private Link cities = new Link();

    public Link getCities() {
        return this.cities;
    }

    //getter/setter,无参构造方法略
    public Province(int pid, String pname) {
        this.pid = pid;
        this.pname = pname;
    }

    public boolean compare(Province province) {
        if (province == null) {
            return false;
        }
        if (this == province) {
            return true;
        }
        if (this.pid == province.pid &amp;&amp; this.pname.equals(province.pname)) {
            return true;
        } else {
            return false;
        }
    }

    public String getInfo() {
        return &quot;省份ID：&quot; + this.pid + &quot;,省份名称：&quot; + this.pname;
    }
}


class City {
    private int cid;
    private String cname;
    private Province province;

    public void setProvince(Province province) {
        this.province = province;
    }

    public Province getProvince() {
        return this.province;
    }

    //getter/setter,无参构造方法略
    public City(int cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public String getInfo() {
        return &quot;城市ID：&quot; + this.cid + &quot;,城市名称：&quot; + this.cname;
    }

    public boolean compare(City city) {
        if (city == null) {
            return false;
        }
        if (this == city) {
            return true;
        }
        if (this.cid == city.cid &amp;&amp; this.cname.equals(city.cname)
                &amp;&amp; this.province.compare(city.province)) {
            return true;
        } else {
            return false;
        }
    }
}
</code></pre>
<p>此时只需将链表中的Book改为City即可。<br>
在此时发现问题：每定义一个新的类，链表就需要重新进行修改。方法解决了代码重复问题。但是该问题不属于代码重复，属于数据类型不同意，该问题需要依靠面向对象的特性的来结局。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<blockquote>
<p>（1）本章所讲的只是最基础的单向链表；<br>
（2）链表中应有如下方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:left">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">public void add(数据类型 变量)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">向链表中添加数据</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">public int size()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">取得链表中数据个数</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">public boolean isEmpty()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">判断是否为空链表</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">public boolean contains(数据类型 变量)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">判断数据是否存在</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">public 数据类型 get(int index)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">根据索引取得数据</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">public void set(int index,数据类型 变量)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">修改数据</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left">public void remove(数据类型 变量)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">删除指定数据</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:left">public 数据类型 [] toArray()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">将链表以对象数组的形式转换</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(九)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B9%9D)/</url>
      <content type="html"><![CDATA[<h2 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h2>
<blockquote>
<p>代码块是<code>{}</code>定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：<strong>普通代码块，构造块，静态块和同步代码块</strong>。</p>
</blockquote>
<h3 id="普通代码块"><a class="markdownIt-Anchor" href="#普通代码块"></a> 普通代码块</h3>
<p>1.写在方法中的代码块，称为<strong>普通代码块</strong>。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        { // 普通代码块
            int num = 10; // 局部变量
            System.out.println(&quot;num = &quot; + num); // 10
        }
        int num = 100; // 全局变量
        System.out.println(&quot;num = &quot; + num); // 100
    }
}
</code></pre>
<p><strong>普通代码块的功能</strong>是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。</p>
<h3 id="构造块"><a class="markdownIt-Anchor" href="#构造块"></a> 构造块</h3>
<p>1.写在类中的代码块，称为<strong>构造块</strong>。</p>
<pre class="highlight"><code class="">class Book {
    public Book(){ // 构造方法
        System.out.println(&quot;A. Book类的构造方法&quot;);
    }
    { // 构造块
        System.out.println(&quot;B. Book类的构造块&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        new Book();
        // B. Book类的构造块
        // A. Book类的构造方法
    }
}
</code></pre>
<p>输出结果显示：<strong>构造块的调用优先于构造方法。</strong></p>
<h3 id="静态块"><a class="markdownIt-Anchor" href="#静态块"></a> 静态块</h3>
<p>static定义的代码块，称为<strong>静态块</strong>。静态块的使用，分为两种情况：<br>
1.在非主类中使用</p>
<pre class="highlight"><code class="">class Book {
    public Book(){ // 构造方法
        System.out.println(&quot;A. Book类的构造方法&quot;);
    }
    { // 构造块
        System.out.println(&quot;B. Book类的构造块&quot;);
    }
    static {
        System.out.println(&quot;C. Book类的静态块&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        new Book(); // C B A
        new Book(); // B A
    }
}
</code></pre>
<p>结果显示：**静态块优先于构造块。**且不论实例化多少个对象，<strong>静态块只执行一次</strong>。static主要功能是为类中的static属性初始化。</p>
<pre class="highlight"><code class="">class Book {
    public static String msg;
    static {
        msg = &quot;Hello&quot;.substring(0,2);
        System.out.println(&quot;C. Book类的静态块&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        System.out.println(Book.msg);
    }
}
</code></pre>
<p>2.在主类中定义</p>
<pre class="highlight"><code class="">public class Demo {
    static {
        System.out.println(&quot;**************&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;Hello World !&quot;);
        // **************
        // Hello World !
    }
}
</code></pre>
<p>结果显示：静态块优先于<code>main()</code>方法执行。在编写测试时，可以使用静态块。</p>
<h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2>
<blockquote>
<p>从开发角度来说，尽量不要使用内部类</p>
</blockquote>
<h3 id="内部类基本概念"><a class="markdownIt-Anchor" href="#内部类基本概念"></a> 内部类基本概念</h3>
<p>1.<strong>内部类</strong>是指在一个类的内部定义其他的类。<br>
<strong>范例</strong>：内部类</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    class Inner { // 内部类
        public void print() {
            System.out.println(msg);
        }
    }

    public void fun() {
        // 实例化内部类对象，调用print()方法
        new Inner().print();
    }
}

public class Demo {
    public static void main(String[] args) {
        // 实例化外部类对象
        Outer out = new Outer();
        out.fun(); // 调用外部类方法，Hello World
    }
}
</code></pre>
<p>上述代码牺牲了程序的结构，实现了一个重要功能。<br>
2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。<br>
<strong>范例</strong>：取出内部类</p>
<pre class="highlight"><code class="">class Outer { 
    private String msg = &quot;Hello World&quot;;

    public void fun() {
        new Inner().print();
    }
}

class Inner { 
    public void print() {
        System.out.println(msg);
    }
}

public class Demo {
    public static void main(String[] args) {
        Outer out = new Outer();
        out.fun(); // 报错，msg属于Outer，Inner无法调用
    }
}
</code></pre>
<p>（1）要想使得<code>Inner</code>调用<code>msg</code>，就需在<code>Outer</code>中写一个<code>getMsg()</code></p>
<pre class="highlight"><code class="">public String getMsg(){
    return this.msg;
}
</code></pre>
<p>（2）<code>Inner</code>要调用<code>Outer</code>的<code>getMsg()</code>方法，必须实例化一个<code>Outer</code>对象</p>
<pre class="highlight"><code class="">class Outer { 
    private String msg = &quot;Hello World&quot;;

    public String getMsg(){
        return this.msg;
    }

    public void fun() {
        new Inner().print();
    }
}

class Inner {
    public void print() {
        System.out.println(new Outer().getMsg());
    }
}

public class Demo {
    public static void main(String[] args) {
        Outer out = new Outer();
        out.fun();
    }
}
</code></pre>
<p>上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。</p>
<pre class="highlight"><code class="">class Outer { 
    private String msg = &quot;Hello World&quot;;

    public String getMsg() {
        return this.msg;
    }

    public void fun() {
        new Inner(this).print();
    }
}

class Inner {
    private Outer out;

    public Inner(Outer out) {
        this.out = out;
    }

    public void print() {
        System.out.println(this.out.getMsg());
    }
}

public class Demo {
    public static void main(String[] args) {
        Outer out = new Outer();
        out.fun();
    }
}
</code></pre>
<p>由此可得内部类的特点：</p>
<blockquote>
<p>内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。</p>
</blockquote>
<p><strong>范例</strong>：访问内部类私有属性</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    class Inner { // 内部类
        private  String info = &quot;世界你好&quot;;
        public void print() {
            System.out.println(msg);
        }
    }

    public void fun() {
        // 实例化内部类对象
        Inner in = new Inner();
        // 使用内部类对象访问内部类私有属性
        System.out.println(in.info);
    }
}

public class Demo {
    public static void main(String[] args) {
        Outer out = new Outer();
        out.fun();
    }
}
</code></pre>
<p>3.观察代码</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    class Inner { // 内部类
        private  String info = &quot;世界你好&quot;;
        public void print() {
            System.out.println(this.msg); // 报错，找不到msg
        }
    }

    public void fun() {
        new Inner().print();
    }
}
</code></pre>
<p><strong>报错原因</strong>：<code>this.msg</code>指向的是<code>Inner</code>类，而<code>Inner</code>类中没有<code>msg</code>属性。因此要访问<code>Outer</code>的<code>msg</code>属性，需要使用<code>Outer.this.msg</code>.</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    class Inner { // 内部类
        public void print() {
            // 外部类.this = 外部类的当前对象
            System.out.println(Outer.this.msg); 
        }
    }

    public void fun() {
        new Inner().print();
    }
}
</code></pre>
<p>4.内部类的class文件名: <code>Outer$Inner.class</code><br>
直接实例化内部类对象语法：<code>外部类.内部类 对象名 = new 外部类().new 内部类();</code><br>
<strong>范例</strong>：实例化内部类对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Outer.Inner in = new Outer().new Inner();
        in.print();
    }
}
</code></pre>
<p>上述代码说明：</p>
<blockquote>
<p>要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。</p>
</blockquote>
<p>5.内部类只想被外部类使用，不能被外部调用，应使用<code>private</code>定义</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    private class Inner { // 内部类
        public void print() {
            // 外部类.this = 外部类的当前对象
            System.out.println(Outer.this.msg);
       }
    }
}
</code></pre>
<h3 id="static定义内部类"><a class="markdownIt-Anchor" href="#static定义内部类"></a> static定义内部类</h3>
<p>使用static定义的属性或方法不受实例化对象控制，因此使用<strong>static定义的内部类也不受外部类实例化对象控制。</strong><br>
1.static定义的内部类只能访问外部类中static定义的属性或方法</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    static class Inner { // 内部类
        public void print() {
            System.out.println(msg); // 报错，无法引用非静态变量msg
        }
    }
}
</code></pre>
<p>2.static定义的内部类，相当于外部类<br>
取得static定义的内部类对象语法：<code>外部类.内部类 对象 = new 外部类.内部类();</code>由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于<strong>内部类成了一个外部类。</strong></p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private static String msg = &quot;Hello World&quot;;

    static class Inner { // 内部类
        public void print() {
            System.out.println(msg);
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        Outer.Inner in = new Outer.Inner();
        in.print();
    }
}
</code></pre>
<h3 id="方法中定义内部类"><a class="markdownIt-Anchor" href="#方法中定义内部类"></a> 方法中定义内部类</h3>
<p>1.内部类可定义在外部类中的任意位置。<strong>在方法中定义内部类</strong>是最常见的形式。</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    public void fun() {
        class Inner { // 定义在方法中的内部类
            public void print() {
                System.out.println(msg);
            }
        }
        new Inner().print();
    }
}

public class Demo {
    public static void main(String[] args) {
        new Outer().fun();
    }
}
</code></pre>
<p>2.方法可以接收参数，也可以定义变量<br>
<strong>范例</strong>：访问方法中定义的参数或变量</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    public void fun(int num) { // 方法参数
        double score = 99.9; // 方法变量
        class Inner { // 定义在方法中的内部类
            public void print() {
                System.out.println(&quot;属性：&quot; + msg);
                System.out.println(&quot;方法参数：&quot; + num);
                System.out.println(&quot;方法变量：&quot; + score);
            }
        }
        new Inner().print();
    }
}

public class Demo {
    public static void main(String[] args) {
        new Outer().fun(100);
    }
}
</code></pre>
<p><strong>方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后</strong>！在JDK1.8之前的版本严格要求：方法中的内部类只能访问<code>final</code>标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式：</p>
<pre class="highlight"><code class="">class Outer { // 外部类
    private String msg = &quot;Hello World&quot;;

    public void fun(final int num) { // 方法参数
       final double score = 99.9; // 方法变量
        class Inner { // 定义在方法中的内部类
            public void print() {
                System.out.println(&quot;属性：&quot; + msg);
                System.out.println(&quot;方法参数：&quot; + num);
                System.out.println(&quot;方法变量：&quot; + score);
            }
        }
        new Inner().print();
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(八)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AB)/</url>
      <content type="html"><![CDATA[<h2 id="对象比较"><a class="markdownIt-Anchor" href="#对象比较"></a> 对象比较</h2>
<p>1.数字比较用<code>==</code>，字符串比较用<code>equals(String str)</code>。</p>
<blockquote>
<p>要进行对象比较，必须对对象中所有属性的值进行比较。</p>
</blockquote>
<p><strong>范例</strong>：对象比较的基本方式</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    //省略无参构造方法和setter方法
    public String getTitle() {
        return this.title;
    }

    public double getPrice() {
        return this.price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book(&quot;Java开发&quot;, 79.5);
        Book bkB = new Book(&quot;JSP&quot;, 45.6);
        if (bkA.getTitle().equals(bkB.getTitle())
                &amp;&amp; bkA.getPrice() == bkB.getPrice()) {
            System.out.println(&quot;bkA和bkB是同一个对象！&quot;);
        } else {
            System.out.println(&quot;bkA和bkB是不同对象！&quot;);
        }
    }
}
</code></pre>
<p>上述程序存在问题：主方法相当于客户端，客户端的程序逻辑应该越简单越好。所以对象比较应该由对象自己完成，即<strong>对象所对应的类应该提供对象比较的方法。</strong></p>
<blockquote>
<p>附：类的属性使用private封装，那么在类的外部就不能通过对象直接调用属性</p>
</blockquote>
<pre class="highlight"><code class="">class Info{
    private String msg = &quot;Hello&quot;;
    public void print(){
        System.out.println(&quot;msg = &quot; + this.msg);
    }
}
public class Demo {
    public static void main(String[] args) {
        Info x = new Info();
        x.msg = &quot;sss&quot;; // 报错，无法访问private属性
        x.print();
    }
}
</code></pre>
<blockquote>
<p>附：将一个对象作为参数传回类的方法中，相当于取消封装，使得对象可以直接访问属性。</p>
</blockquote>
<pre class="highlight"><code class="">class Info {
    private String msg = &quot;Hello&quot;;

    public void print() {
        System.out.println(&quot;msg = &quot; + this.msg);
    }

    public void fun(Info temp) {
        // 在类的内部直接利用对象访问私有属性
        temp.msg = &quot;修改内容&quot;;
    }
}

public class Demo {
    public static void main(String[] args) {
        Info x = new Info();
        x.fun(x);
        x.print(); // msg = 修改内容
    }
}
</code></pre>
<blockquote>
<p>附：<strong>一个类接收本类对象</strong>形式的代码在对象比较时很常见。</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    //省略无参构造方法和setter方法
    public String getTitle() {
        return this.title;
    }

    public double getPrice() {
        return this.price;
    }

    // 类接收自身对象，对象可以直接访问属性，不需要getter方法
    // compare()有两个功能：一带回了要比较的信息；二方便属性访问
    public boolean compare(Book book) {
        if (book == null) { // 要比较的对象为空
            return false; // 没必要比较
        }
        if (this == book) { // 内存地址相同
            return true; //避免具体比较，节约时间
        }
        // 执行“bkA.equals(bkB)”时，有两个对象：
        // 一个为当前对象this(调用方法的对象，即bkA）
        // 一个为传递对象book(引用传递，即bkB）
        if (this.title.equals(book.title)
                &amp;&amp; this.price == book.price) {
            return true;
        } else {
            return false;
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book(&quot;Java开发&quot;, 79.5);
        Book bkB = new Book(&quot;JSP&quot;, 45.6);
        if (bkA.compare(bkB)) {
            System.out.println(&quot;bkA和bkB是同一个对象！&quot;);
        } else {
            System.out.println(&quot;bkA和bkB是不同对象！&quot;);
        }
    }
}
</code></pre>
<blockquote>
<p>总结<br>
（1）对象比较的方法必须定义在类中；<br>
（2）对象比较时一定要判断是否为<code>null</code>，内存地址是否相同，属性是否相同。</p>
</blockquote>
<h2 id="关键字static"><a class="markdownIt-Anchor" href="#关键字static"></a> 关键字static</h2>
<h3 id="static-定义属性"><a class="markdownIt-Anchor" href="#static-定义属性"></a> static 定义属性</h3>
<blockquote>
<p>问题引出：</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;
    // 为操作方便，暂不封装
    String pub = &quot;清华大学出版社&quot;;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String getInfo(){
        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book(&quot;Java开发&quot;, 79.5);
        Book bkB = new Book(&quot;JSP&quot;, 45.6);
        System.out.println(bkA.getInfo()); // 清华大学出版社
        System.out.println(bkB.getInfo()); // 清华大学出版社
        bkB.pub = &quot;北京大学出版社&quot;;
        System.out.println(bkA.getInfo()); // 清华大学出版社
        System.out.println(bkB.getInfo()); // 北京大学出版社
    }
}
</code></pre>
<blockquote>
<p>对上述代码进行内存分析：<br>
<img src="/article/Java/Java Base/Java基础知识(八)/12-1.png" alt="无法加载" title="内存分析"><br>
通过内存分析，发现属性重复：每个对象各自占有相同的属性值。假如有1000个该对象，要修改所有对象的pub属性，就需要分别进行修改。因此如果将pub属性定为普通属性，那每个堆内存都保存有各自的pub值。</p>
</blockquote>
<p>1.但所有对象的pub值都一样，应将其定为一个共享的属性，即所有对象都指向同一块pub属性。可以利用<code>static</code>定义共享属性。</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;
    // 为操作方便，暂不封装
    static String pub = &quot;清华大学出版社&quot;;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String getInfo(){
        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book(&quot;Java开发&quot;, 79.5);
        Book bkB = new Book(&quot;JSP&quot;, 45.6);
        System.out.println(bkA.getInfo()); // 清华大学出版社
        System.out.println(bkB.getInfo()); // 清华大学出版社
        bkB.pub = &quot;北京大学出版社&quot;;
        System.out.println(bkA.getInfo()); // 北京大学出版社
        System.out.println(bkB.getInfo()); // 北京大学出版社
    }
}
</code></pre>
<p>使用<code>static</code>定义属性后，只要有一个对象修改属性值，那么所有对象的该属性值都会改变，内存分析如下：<br>
<img src="/article/Java/Java Base/Java基础知识(八)/12-2.png" alt="无法加载" title="内存分析"><br>
2. <code>static</code>定义的属性与普通属性区别在于<strong>保存数据的内存区域不同。</strong><br>
<code>static</code>定义的是公共属性，任由某个对象直接修改属性值是不合理的，应该由所有对象的代表进行属性访问，即用类访问。<strong>因此<code>static</code>定义的属性，可直接用类名调用：</strong><code>Book.pub = &quot;北京大学出版社&quot;;</code><br>
3. <code>static</code>属性与普通属性的区别在于：普通属性必须由实例化的对象调用，而在没有实例化对象的情况下，static属性依然可以被调用。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 没有实例化对象的情况下，输出pub的内容
        System.out.println(Book.pub);
    }
}
</code></pre>
<p>由结果可知：<strong><code>static</code>虽然定义在类中，但不受对象控制，是独立于类存在的。</strong><br>
4. 何时使用static定义属性<br>
编写类时，<code>static</code>不是首选修饰符，<strong>当需要描述共享信息时，才使用static，方便集体修改，不用重复开辟内存空间。</strong></p>
<h3 id="static-定义方法"><a class="markdownIt-Anchor" href="#static-定义方法"></a> static 定义方法</h3>
<p>1.<code>static</code>定义的方法也可以直接被类名调用</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;
    // 为操作方便，暂不封装
    private static String pub = &quot;清华大学出版社&quot;;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public static void setPub(String p){
        pub = p;
    }
    public String getInfo(){
        return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub;
    }
}

public class Demo {
    public static void main(String[] args) {
        // 没有实例化对象的情况下，调用方法
        Book.setPub(&quot;北京大学出版社&quot;);
        Book bkA = new Book(&quot;Java开发&quot;, 79.5);
        System.out.println(bkA.getInfo()); // 北京大学出版社
    }
}
</code></pre>
<p>上述代码存在问题：类中有两种方法，static方法和普通方法，两种方法间的访问受到限制。<br>
（1）static方法不能直接使用非static属性或方法，只能调用static属性或方法。</p>
<pre class="highlight"><code class="">public static void setPub(String p){
   pub = p;
   title = &quot;sss&quot;; // 报错，无法引用非静态变量
   getInfo(); // 报错，无法引用非静态方法
   System.out.println(this); // 报错，无法引用非静态变量
}
</code></pre>
<p>（2）普通方法可以使用static属性或方法</p>
<pre class="highlight"><code class="">public String getInfo(){
    setPub(&quot;&quot;); // 不报错
    return &quot;,出版社：&quot; + this.pub; // 不报错
}
</code></pre>
<p>出现上述限制的原因：</p>
<blockquote>
<p>|- 普通属性和方法必须在对象实例化后分配了堆内存空间，才可以使用；<br>
|- static定义的方法和属性，不受实例化对象控制，可在没有实例化对象情况下访问。</p>
</blockquote>
<p>2.一个方法定义在主类中，并由主方法直接调用，该方法定义格式如下：</p>
<pre class="highlight"><code class="">public static 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) {
    方法体; 
    [return [返回值] ;] // []中内容可写可不写
}
</code></pre>
<p>一个方法定义在类中，由对象直接调用，其语法格式如下：</p>
<pre class="highlight"><code class="">public 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) {
    方法体; 
    [return [返回值] ;] // []中内容可写可不写
}
</code></pre>
<p>观察代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        fun();
    }

    public static void fun() {
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<p>没有static定义的fun()必须通过对象调用，主方法要使用fun()必须实例化对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        // 产生对象，再利用对象调用非static方法
        new Demo().fun();
    }

    public void fun() {
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<ol start="3">
<li>定义类中方法时，<code>static</code>不是首选修饰符，因为每个对象可以利用自己的属性实现方法的不同调用。</li>
</ol>
<pre class="highlight"><code class="">class Flag {
    private boolean flag;

    public Flag(boolean flag) {
        this.flag = flag;
    }

    public void fun() {
        if (this.flag) {
            System.out.println(&quot;可以操作&quot;);
        } else {
            System.out.println(&quot;不可以操作&quot;);
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        Flag fA = new Flag(true);
        Flag fB = new Flag(false);
        fA.fun();
        fB.fun();
    }
}
</code></pre>
<p>当一个类中没有属性，只有方法时，建议将所有方法定义为static方法。这样就不用每次调用时都需要有实例化对象。</p>
<pre class="highlight"><code class="">class MyMath {
    public static int add(int x, int y) {
        return x + y;
    }
}

public class Demo {
    public static void main(String[] args) {
        System.out.println(MyMath.add(10, 20));
    }
}
</code></pre>
<h3 id="主方法"><a class="markdownIt-Anchor" href="#主方法"></a> 主方法</h3>
<p>1.主方法的组成：</p>
<table>
<thead>
<tr>
<th style="text-align:center">组成</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">主方法是程序的开始，所以主方法必须是可见、public（公共的）的</td>
</tr>
<tr>
<td style="text-align:center">static</td>
<td style="text-align:center">证明此方法可直接由类名调用</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">主方法是程序的开始，因此不能回头，执行完为止，所以不能有返回值</td>
</tr>
<tr>
<td style="text-align:center">main</td>
<td style="text-align:center">系统规定好的方法名，不能修改</td>
</tr>
<tr>
<td style="text-align:center">String [] args</td>
<td style="text-align:center">指的是程序运行时传递的参数</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：对主方法传入参数</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        for (int x = 0; x &lt; args.length ; x++) {
            System.out.println(args[x]); // 未输出参数，为空
        }
    }
}
</code></pre>
<p>多个参数时，必须使用空格分割。<code>cmd执行的是java Demo 1 3 4 6</code><br>
输出为：<code>1 3 4 6</code><br>
如果参数本身带有空格，需用<code>&quot;&quot;</code>描述<br>
cmd执行的是<code>java Demo &quot;Hello world&quot; &quot;Hello Java&quot;</code></p>
<h3 id="static应用案例"><a class="markdownIt-Anchor" href="#static应用案例"></a> static应用案例</h3>
<blockquote>
<p>已知：<br>
（1）多个对象，都使用同一个static属性；<br>
（2）static定义方法可以避免实例化对象调用方法的限制。</p>
</blockquote>
<p>1.实现对实例化对象个数的统计</p>
<blockquote>
<p>要求：每实例化一个对象，就输出&quot;这是第x个实例化对象&quot;<br>
思路：每次实例化对象，就会调用构造方法，因此可在构造方法中增加一个统计数据的操作，每当新对象产生，该属性值就自增加一。</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private static int num = 0;

    public Book() {
        num++;
        System.out.println(&quot;这是第&quot; + num + &quot;个实例化对象&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        new Book();
        new Book();
        new Book();
    }
}
</code></pre>
<p>2.实现属性的自动设置</p>
<blockquote>
<p>要求：类中有一个无参构造方法，一个有参构造方法，有参构造方法的功能是传递title值。不论调用的哪个构造方法，均可为title赋值，且属性值尽量不重复。</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private String title;
    private static int num = 0;

    public Book() {
        this(&quot;Title:No.&quot; + num++);
    }
    public Book(String title){
        this.title = title;
    }
    public String getTitle(){
        return  this.title;
    }
}

public class Demo {
    public static void main(String[] args) {
        System.out.println(new Book(&quot;Java开发&quot;).getTitle()); // Java开发
        System.out.println(new Book().getTitle()); // Title:No.0
        System.out.println(new Book().getTitle()); // Title:No.1
    }
}
</code></pre>
<blockquote>
<p>总结<br>
（1）类定义属性或方法首时选不是static属性或方法；<br>
（2）static属性或方法可直接用类名调用；<br>
（3）static属性保存在全局数据区。<br>
（4）内存区有四种: 栈内存（对象的地址），堆内存（普通属性），全局数据区（static属性），全局代码区（所有的方法）</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(七)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%83)/</url>
      <content type="html"><![CDATA[<h2 id="引用传递分析实例"><a class="markdownIt-Anchor" href="#引用传递分析实例"></a> 引用传递分析实例</h2>
<h3 id="引用传递"><a class="markdownIt-Anchor" href="#引用传递"></a> 引用传递</h3>
<p>1.引用传递核心意义：同一块堆内存可以被不同栈内存所指向，不同栈内存可以对同一块堆内存进行修改。<br>
<strong>范例</strong>：引用传递</p>
<pre class="highlight"><code class="">public class Message {
    private int num = 10;

    public Message(int num) {
        this.num = num;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }
}

public class TMessage {
    public static void main(String[] args) {
        Message msg = new Message(30);
        System.out.println(msg.getNum()); // 30
        fun(msg); // 引用传递
        System.out.println(msg.getNum()); // 100
    }

    public static void fun(Message temp) {
        temp.setNum(100);
    }
}
</code></pre>
<p>对上述代码进行内存分析：<br>
<img src="/article/Java/Java Base/Java基础知识(七)/10-1.png" alt="无法加载" title="内存分析"><br>
2.引用</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String msg  = &quot;Hello&quot;;
        fun(msg);
        System.out.println(msg); // Hello
    }
    public static void fun(String temp) {
        temp = &quot;World&quot;;
    }
}
</code></pre>
<p>出现上述结果原因：String对象的内容一旦声明不可改变，对象内容的改变依靠的是引用地址的改变。内存分析如下：<br>
<img src="/article/Java/Java Base/Java基础知识(七)/10-2.png" alt="无法加载" title="内存分析"><br>
3.引用传递</p>
<pre class="highlight"><code class="">public class Message {
    private String info = &quot;nihao&quot;;

    public Message(String info) {
        this.info = info;
    }

    public String getInfo() {
        return info;
    }

    public void setInfo(String info) {
        this.info = info;
    }
}

public class TMessage {
    public static void main(String[] args) {
        Message msg = new Message(&quot;Hello&quot;);
        System.out.println(msg.getInfo()); // Hello
        fun(msg);
        System.out.println(msg.getInfo()); // World
    }

    public static void fun(Message temp) {
        temp.setInfo(&quot;World&quot;);
    }
}
</code></pre>
<p>内存分析如下：<br>
<img src="/article/Java/Java Base/Java基础知识(七)/10-3.png" alt="无法加载" title="内存分析"><br>
<strong>上述内存分析，是按照int型数据的特点进行的。实</strong>际info是String对象，应该按照如下方式进行分析：<br>
<img src="/article/Java/Java Base/Java基础知识(七)/10-4.png" alt="无法加载" title="内存分析"><br>
<strong>结论</strong>：虽然<code>String</code>是一个类，属于引用数据类型，但由于其内容不可改的特点，我们常将其当作基本数据类型。即每个String变量只能保存一个数据。</p>
<h3 id="引用传递实例"><a class="markdownIt-Anchor" href="#引用传递实例"></a> 引用传递实例</h3>
<blockquote>
<p>要求：通过面向对象的方式描述每个人有车或没车。</p>
</blockquote>
<p><strong>实现步骤</strong>：<br>
1.创建数据库：应设计两张表:<code>汽车表</code>和<code>人员表</code>;<br>
2.根据数据表，定义两个类：</p>
<blockquote>
<p>（编写简单java类时，可按照数据表的设计来写，规则如下：<br>
类名 = 表名；<br>
属性名(类型) = 表字段(类型);<br>
一个实例化对象 = 一行记录；<br>
多个实例化对象 = 多行记录<br>
引用关系 = 外键描述）</p>
</blockquote>
<pre class="highlight"><code class="">public class Member {
    private int mId;
    private String name;
}

public class Car {
    private String pName;
}
</code></pre>
<p>3.利用<code>引用</code>来描述两个类的外键，从而使得两个类有联系</p>
<pre class="highlight"><code class="">public class Member {
    private int mId;
    private String name;
    // 有Car类实例化对象表示有车
    // Car为null表示没车
    private Car car;

    public Member(int mId, String name) {
        this.mId = mId;
        this.name = name;
    }

    public String getInfo() {
        return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name;
    }
}

public class Car {
    private Member member; // 车属于一个人
    private String pName;

    public Car(String pName) {
        this.pName = pName;
    }

    public String getInfo() {
        return &quot;车名：&quot; + this.pName;
    }
}
</code></pre>
<p>4.当两个类的对象产生，为这两个对象设置彼此的关系：</p>
<pre class="highlight"><code class="">public class Member {
    private int mId;
    private String name;
    // 有Car类实例化对象表示有车
    // Car为null表示没车
    private Car car;

    public Member(int mId, String name) {
        this.mId = mId;
        this.name = name;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    public String getInfo() {
        return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name;
    }
}

public class Car {
    private Member member; // 车属于一个人
    private String pName;

    public Car(String pName) {
        this.pName = pName;
    }

    public String getInfo() {
        return &quot;车名：&quot; + this.pName;
    }

    public Member getMember() {
        return member;
    }

    public void setMember(Member member) {
        this.member = member;
    }
}
</code></pre>
<p><strong>5.测试</strong><br>
测试分为两步：</p>
<blockquote>
<p>（1）根据定义的结构关系设置数据<br>
（2）根据定义的结构关系取出数据</p>
</blockquote>
<pre class="highlight"><code class="">public class TCar {
    public static void main(String[] args) {
        // 1. 设置数据
        Member m = new Member(1,&quot;张三&quot;);
        Car c = new Car(&quot;宝马&quot;);
        // 设置车与人的关系：张三有辆宝马
        m.setCar(c);
        c.setMember(m);
        // 2. 取出数据
        // 通过人找到车
        System.out.println(m.getCar().getInfo());
        // 通过车找到人
        System.out.println(c.getMember().getInfo());
    }
}
</code></pre>
<p>6.进一步设计：每个人都有孩子，孩子还可能有车</p>
<blockquote>
<p>思路：<br>
（1）设计一个孩子类，如有孙子，在设计孙子类，以此类推。该方案过于冗余，不合适；<br>
（2）在Member类中设计属性child，类型为Member：</p>
</blockquote>
<pre class="highlight"><code class="">private Member child; // 孩子
public Member getChild() {
    return child;
}

public void setChild(Member child) {
    this.child = child;
}
</code></pre>
<p><strong>测试</strong>：</p>
<pre class="highlight"><code class="">public class TCar {
    public static void main(String[] args) {
        // 1. 设置数据
        Member m = new Member(1,&quot;张三&quot;);
        Member child =  new Member(1,&quot;张四&quot;);
        Car c = new Car(&quot;宝马&quot;);
        Car cc  =new Car(&quot;法拉利&quot;);
        // 设置车与人的关系：张三有辆宝马
        m.setCar(c);
        c.setMember(m);
        // 设置车与人的关系：张四有辆法拉利
        child.setCar(cc);
        c.setMember(child);
        // 设置人与人的关系：张四是张三的儿子
        m.setChild(child);
        // 2. 取出数据
        // 通过人找到车
        System.out.println(m.getCar().getInfo());
        // 通过车找到人
        System.out.println(c.getMember().getInfo());
        // 通过人找到孩子
        System.out.println(m.getChild().getInfo());
        // 通过人找到孩子的车
        System.out.println(m.getChild().getCar().getInfo());
    }
}
</code></pre>
<p>7.利用引用描述电脑：电脑由主机、键盘、内存、CPU、显卡等组成，下面用伪代码描述：</p>
<pre class="highlight"><code class="">class 键盘{}
class 鼠标{}
class CPU{}
class 硬盘{}
class 内存{}
class 显示器{}
class 主机{}
class 主板{}
class 主机{
    private CPU 对象[];
    private 硬盘 对象[];
    private 主板 对象;
    private 内存 对象[];
}
class 电脑{
    private 主机 对象;
    private 显示器 对象;
    private 键盘 对象;
    private 鼠标 对象;
}
</code></pre>
<p>上述设计思路称为<code>合成设计模式</code>。<strong>引用</strong>是实现两个不同类之间互相关联的主要手段。</p>
<h3 id="数据表与简单java类映射"><a class="markdownIt-Anchor" href="#数据表与简单java类映射"></a> 数据表与简单Java类映射</h3>
<blockquote>
<p><strong>要求</strong>：通过程序描述部门和雇员关系<br>
<strong>属性</strong>：<br>
·dept：deptno,dname,loc;<br>
·emp：empno, ename,job,sal,comm,deptno,mgr<br>
<strong>关系</strong>：<br>
·一个部门有多个雇员；<br>
·一个雇员有一个或零个领导。</p>
</blockquote>
<p>第一步： 根据数据表创建简单java类</p>
<pre class="highlight"><code class="">/**
 * 部门类
 */
public class Dept {
    private int depNo; // 编号
    private String dName; // 名字
    private String address; // 地址
    // setter,getter,无参构造方法略

    public Dept(int depNo, String dName, String address) {
        this.depNo = depNo;
        this.dName = dName;
        this.address = address;
    }

    public String getInfo() {
        return &quot;部门编号：&quot; + this.depNo +
                &quot;,部门名称：&quot; + this.dName +
                &quot;,地址：&quot; + this.address;
    }
}

/**
 * 员工类
 */
public class Emp {
    private int eNo; // 编号
    private String eName; // 姓名
    private String job; // 职位
    private double sal; // 工资
    private double comm; // 佣金

    // setter,getter,无参构造方法略
    public Emp(int eNo, String eName, String job, double sal, double comm) {
        this.eNo = eNo;
        this.eName = eName;
        this.job = job;
        this.sal = sal;
        this.comm = comm;
    }
    
    public String getInfo() {
        return &quot;编  号&quot; + this.eNo + &quot;\n&quot; +
                &quot;姓 名&quot; + this.eName + &quot;\n&quot; +
                &quot;职 位&quot; + this.job + &quot;\n&quot; +
                &quot;工 资&quot; + this.sal + &quot;\n&quot; +
                &quot;佣 金&quot; + this.comm;
    }
}
</code></pre>
<p>第二步：设置外键关系<br>
· 一个雇员属于一个部门，应在雇员类中保存部门信息</p>
<pre class="highlight"><code class="">private Dept dept; // 对应的部门信息

public Dept getDept() {
    return dept;
}

public void setDept(Dept dept) {
    this.dept = dept;
}
</code></pre>
<p>· 一个部门有的多个雇员，可用数组在部门类中保存雇员信息：</p>
<pre class="highlight"><code class="">private Emp emps[]; // 多个雇员信息

public Emp[] getEmps() {
    return emps;
}

public void setEmps(Emp[] emps) {
    this.emps = emps;
}
</code></pre>
<p>· 一个雇员有一个领导（定义在Emp类中）</p>
<pre class="highlight"><code class="">private Emp mgr; // 领导信息

public Emp getMgr() {
    return mgr;
}

public void setMgr(Emp mgr) {
    this.mgr = mgr;
}
</code></pre>
<p>第三步：测试<br>
（1）设置数据：</p>
<pre class="highlight"><code class="">public class Demo {
   public static void main(String[] args) {
       // 1. 产生对象
       Dept dept = new Dept(10, &quot;财务部&quot;, &quot;北京&quot;); // 部门信息
       //  员工信息
       Emp eA = new Emp(1111, &quot;张三&quot;, &quot;保安&quot;, 800.0, 0.0);
       Emp eB = new Emp(1101, &quot;李四&quot;, &quot;秘书&quot;, 2800.0, 500.0);
       Emp eC = new Emp(1001, &quot;王五&quot;, &quot;经历&quot;, 6800.0, 1500.0);
       // 2. 设置员工与领导关系
       eA.setMgr(eB);
       eB.setMgr(eC);
       // 3. 设置员工和部门关系
       eA.setDept(dept);
       eB.setDept(dept);
       eC.setDept(dept);
       dept.setEmps(new Emp[]{eA, eB, eC});
   }
}
</code></pre>
<p>（2）：根据给定的结构取出数据，要求如下：</p>
<blockquote>
<p>|-根据一个雇员查询他所对应的领导信息和部门信息；<br>
|-根据一个部门查询所有雇员以及其所对应的领导信息；</p>
</blockquote>
<pre class="highlight"><code class="">// 第二步：取出数据
// 1. 通过员工找到领导信息和部门信息
System.out.println(eA.getInfo()); // 获取员工信息
System.out.println(&quot;\t|-&quot; + eA.getMgr().getInfo()); // 获取领导信息
System.out.println(&quot;\t|-&quot; + eA.getDept().getInfo()); // 获取部门信息
// 2. 根据部门找到所有员工及其领导信息
System.out.println(&quot;---------------------------------------------&quot;);
System.out.println(dept.getInfo());
for (int x = 0; x &lt; dept.getEmps().length; x++) {
    System.out.println(&quot;\t|-&quot; + dept.getEmps()[x].getInfo()); // 获取员工信息
    if (dept.getEmps()[x].getMgr() != null) {
        System.out.println(&quot;\t\t|-&quot; + dept.getEmps()[x].getMgr().getInfo()); // 获取领导信息
    }
}
</code></pre>
<p>上述代码都是依靠代码链取出数据。</p>
<h3 id="一对多映射"><a class="markdownIt-Anchor" href="#一对多映射"></a> 一对多映射</h3>
<blockquote>
<p>要求：通过程序描述省份和城市的关系<br>
1.通过一个城市找到它对应的省份信息；<br>
2.通过一个省份找到所有城市的信息。</p>
</blockquote>
<pre class="highlight"><code class="">class Province {
    private int pId;
    private String pName;
    private City cities[];
    // getter,setter,无参构造方法略

    public Province(int pId, String pName) {
        this.pId = pId;
        this.pName = pName;
    }

    public City[] getCities() {
        return cities;
    }

    public void setCities(City[] cities) {
        this.cities = cities;
    }

    public String getInfo() {
        return &quot;省份ID：&quot; + this.pId + &quot;，省名：&quot; + this.pName;
    }
}

class City {
    private int cId;
    private String cName;
    private Province province;

    // getter,setter,无参构造方法略
    public City(int cId, String cName) {
        this.cId = cId;
        this.cName = cName;
    }

    public Province getProvince() {
        return province;
    }

    public void setProvince(Province province) {
        this.province = province;
    }

    public String getInfo() {
        return &quot;城市ID：&quot; + this.cId + &quot;，市名：&quot; + this.cName;
    }
}

public class Demo {
    public static void main(String[] args) {
        Province province = new Province(350, &quot;福建省&quot;);
        City cA = new City(1, &quot;福州&quot;);
        City cB = new City(2, &quot;厦门&quot;);
        City cC = new City(3, &quot;泉州&quot;);
        cA.setProvince(province);
        cB.setProvince(province);
        cC.setProvince(province);
        province.setCities(new City[]{cA, cB, cC});
        System.out.println(cA.getInfo());
        System.out.println(&quot;\t|-&quot; + cA.getProvince().getInfo());
        System.out.println(&quot;==================================&quot;);
        System.out.println(province.getInfo());
        for (int x = 0; x &lt; province.getCities().length; x++) {
            System.out.println(&quot;\t|-&quot; + province.getCities()[x].getInfo());
        }
    }
}
</code></pre>
<p>上述代码存在不足：<strong>每次添加城市，就要修改数组的引用关系</strong></p>
<h3 id="双向一对多映射"><a class="markdownIt-Anchor" href="#双向一对多映射"></a> 双向一对多映射</h3>
<blockquote>
<p>要求：通过程序描述类型-子类型-商品的关系<br>
（1）通过一个类型找到它对应的子类型；<br>
（2）过一个类型找到它所对应的商品；<br>
（3）通过一个子类型找到所有对应的商品。</p>
</blockquote>
<pre class="highlight"><code class=""> class Type {
    private int tId;
    private String tName;
    private SonType sonTypes[];
    private Product products[];

    // getter,setter,无参构造方法略
    public Type(int tId, String tName) {
        this.tId = tId;
        this.tName = tName;
    }

    public SonType[] getSontypes() {
        return this.sonTypes;
    }

    public void setSontypes(SonType[] sontypes) {
        this.sonTypes = sontypes;
    }

    public Product[] getProducts() {
        return products;
    }

    public void setProducts(Product[] products) {
        this.products = products;
    }

    public String getInfo() {
        return &quot;类型编号：&quot; + this.tId + &quot;,类型名称：&quot; + this.tName;
    }
}

class SonType {
    private int sId;
    private String sName;
    private Type type;
    private Product products[];
    // getter,setter,无参构造方法略

    public SonType(int sId, String sName) {
        this.sId = sId;
        this.sName = sName;
    }

    public int getsId() {
        return sId;
    }

    public void setsId(int sId) {
        this.sId = sId;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public Product[] getProducts() {
        return products;
    }

    public void setProducts(Product[] products) {
        this.products = products;
    }

    public String getInfo() {
        return &quot;子类型编号：&quot; + this.sId + &quot;,子类型名称：&quot; + this.sName;
    }
}

class Product {
    private int pId;
    private String name;
    private double price;
    private Type type;
    private SonType sonType;
    // getter,setter,无参构造方法略

    public Product(int pId, String name, double price) {
        this.pId = pId;
        this.name = name;
        this.price = price;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public SonType getSonType() {
        return sonType;
    }

    public void setSonType(SonType sonType) {
        this.sonType = sonType;
    }

    public String getInfo() {
        return &quot;商品编号：&quot; + this.pId + &quot;,商品名称：&quot; + this.name + &quot;,价格：&quot; + this.price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Type type = new Type(1, &quot;家电类&quot;);
        SonType stA = new SonType(11, &quot;小型家电&quot;);
        SonType stB = new SonType(12, &quot;大型家电&quot;);
        Product pA = new Product(111, &quot;剃须刀&quot;, 99.0);
        Product pB = new Product(112, &quot;热水壶&quot;, 29.0);
        Product pC = new Product(121, &quot;电冰箱&quot;, 1199.0);
        Product pD = new Product(122, &quot;电热水器&quot;, 399.0);

        stA.setType(type);
        stB.setType(type);
        pA.setType(type);
        pB.setType(type);
        pC.setType(type);
        pD.setType(type);
        type.setSontypes(new SonType[]{stA, stB});
        type.setProducts(new Product[]{pA, pB, pC, pD});

        pA.setSonType(stA);
        pB.setSonType(stA);
        pC.setSonType(stB);
        pD.setSonType(stB);
        stA.setProducts(new Product[]{pA, pB});
        stB.setProducts(new Product[]{pC, pD});



        System.out.println(type.getInfo());
        for (int x = 0; x &lt; type.getSontypes().length; x++) {
            System.out.println(&quot;\t|- &quot; + type.getSontypes()[x].getInfo());
        }
        System.out.println(&quot;--------------------------------------&quot;);
        System.out.println(type.getInfo());
        for (int x = 0; x &lt; type.getProducts().length; x++) {
            System.out.println(&quot;\t|- &quot; + type.getProducts()[x].getInfo());
            System.out.println(&quot;\t\t|- &quot; + type.getProducts()[x].getSonType().getInfo());
        }
        System.out.println(&quot;--------------------------------------&quot;);
        System.out.println(stA.getInfo());
        for (int x = 0; x &lt; stA.getProducts().length; x++) {
            System.out.println(&quot;\t|- &quot; + stA.getProducts()[x].getInfo());
        }
    }
}
</code></pre>
<h3 id="多对多映射"><a class="markdownIt-Anchor" href="#多对多映射"></a> 多对多映射</h3>
<blockquote>
<p>要求：通过程序描述管理员-角色-组-权限的关系；<br>
（1）根据一个管理员找到它对应的角色，以及每个角色包含的所有权限组的信息，以及每个权限组所包含的权限的内容；<br>
（2）根据一个权限组找到所有具备此权限组的角色以及每个角色所拥有的管理员信息；<br>
<code>角色_权限组</code>表是关系表，保存的是两个外键的关联关系，不需要为其生成映射类。只有实体表才需要生成映射类，多对多的中间转换表只需通过类属性的关系引用即可。</p>
</blockquote>
<pre class="highlight"><code class="">class Admin {
    private String aid;
    private String password;
    private Role role;

    public void setRole(Role role) {
        this.role = role;
    }

    public Role getRole() {
        return this.role;
    }

    public Admin(String aid, String password) {
        this.aid = aid;
        this.password = password;
    }

    public String getInfo() {
        return &quot;管理员编号:&quot; + this.aid + &quot;，管理员密码：&quot; + this.password;
    }
}

class Role {
    private int rid;
    private String title;
    private Admin admins[];
    private Group groups[];

    public void setAdmins(Admin admins[]) {
        this.admins = admins;
    }

    public Admin[] getAdmins() {
        return this.admins;
    }

    public void setGroups(Group groups[]) {
        this.groups = groups;
    }

    public Group[] getGroups() {
        return this.groups;
    }

    public Role(int rid, String title) {
        this.rid = rid;
        this.title = title;
    }

    public String getInfo() {
        return &quot;角色编号：&quot; + this.rid + &quot;，角色名称&quot; + this.title;
    }
}

class Group {
    private int gid;
    private String title;
    private Role roles[];
    private Action actions[];

    public void setActions(Action actions[]) {
        this.actions = actions;
    }

    public Action[] getActions() {
        return this.actions;
    }

    public void setRoles(Role roles[]) {
        this.roles = roles;
    }

    public Role[] getRoles() {
        return this.roles;
    }

    public Group(int gid, String title) {
        this.gid = gid;
        this.title = title;
    }

    public String getInfo() {
        return &quot;权限组编号：&quot; + this.gid + &quot;，权限组名称：&quot; + this.title;
    }
}

class Action {
    private int aid;
    private String title;
    private String url;
    private Group group;

    public void setGroup(Group group) {
        this.group = group;
    }

    public Group getGroup() {
        return this.group;
    }

    public Action(int aid, String title, String url) {
        this.aid = aid;
        this.title = title;
        this.url = url;
    }

    public String getInfo() {
        return &quot;权限编号：&quot; + this.aid + &quot;权限名称：&quot; + this.title + &quot;,权限路径：&quot; + this.url;
    }
}

public class Demo {
    public static void main(String[] args) {
        Admin a1 = new Admin(&quot;admin&quot;, &quot;123456&quot;);
        Admin a2 = new Admin(&quot;root&quot;, &quot;654321&quot;);
        Admin a3 = new Admin(&quot;guest&quot;, &quot;654321&quot;);
        Role r1 = new Role(1, &quot;系统管理员&quot;);
        Role r2 = new Role(1, &quot;信息管理员&quot;);
        Group g1 = new Group(10, &quot;信息管理&quot;);
        Group g2 = new Group(11, &quot;用户管理&quot;);
        Group g3 = new Group(12, &quot;数据管理&quot;);
        Group g4 = new Group(13, &quot;接口管理&quot;);
        Group g5 = new Group(14, &quot;备份管理&quot;);
        Action ac1 = new Action(1001, &quot;新闻发布&quot;, &quot;-&quot;);
        Action ac2 = new Action(1002, &quot;新闻列表&quot;, &quot;-&quot;);
        Action ac3 = new Action(1003, &quot;新闻审核&quot;, &quot;-&quot;);
        Action ac4 = new Action(1004, &quot;增加用户&quot;, &quot;-&quot;);
        Action ac5 = new Action(1005, &quot;用户列表&quot;, &quot;-&quot;);
        Action ac6 = new Action(1006, &quot;登陆日志&quot;, &quot;-&quot;);
        Action ac7 = new Action(1007, &quot;雇员数据&quot;, &quot;-&quot;);
        Action ac8 = new Action(1008, &quot;部门数据&quot;, &quot;-&quot;);
        Action ac9 = new Action(1009, &quot;公司数据&quot;, &quot;-&quot;);
        Action ac10 = new Action(1010, &quot;服务传输&quot;, &quot;-&quot;);
        Action ac11 = new Action(1011, &quot;短信平台&quot;, &quot;-&quot;);
        Action ac12 = new Action(1012, &quot;全部备份&quot;, &quot;-&quot;);
        Action ac13 = new Action(1013, &quot;局部备份&quot;, &quot;-&quot;);

        a1.setRole(r1);
        a2.setRole(r2);
        a3.setRole(r2);
        r1.setAdmins(new Admin[]{a1});
        r2.setAdmins(new Admin[]{a2, a3});

        r1.setGroups(new Group[]{g1, g2, g3, g4, g5});
        r2.setGroups(new Group[]{g1, g2});
        g1.setRoles(new Role[]{r1, r2});
        g2.setRoles(new Role[]{r1, r2});
        g3.setRoles(new Role[]{r1});
        g4.setRoles(new Role[]{r1});
        g5.setRoles(new Role[]{r1});

        g1.setActions(new Action[]{ac1, ac2, ac3});
        g2.setActions(new Action[]{ac4, ac5, ac6});
        g3.setActions(new Action[]{ac7, ac8, ac9});
        g4.setActions(new Action[]{ac10, ac11});
        g5.setActions(new Action[]{ac12, ac13});

        ac1.setGroup(g1);
        ac2.setGroup(g1);
        ac3.setGroup(g1);
        ac4.setGroup(g2);
        ac5.setGroup(g2);
        ac6.setGroup(g2);
        ac7.setGroup(g3);
        ac8.setGroup(g3);
        ac9.setGroup(g3);
        ac10.setGroup(g4);
        ac11.setGroup(g4);
        ac12.setGroup(g5);
        ac13.setGroup(g5);

        System.out.println(a1.getInfo());
        System.out.println(a1.getRole().getInfo());
        for (int x = 0; x &lt; a1.getRole().getGroups().length; x++) {
            System.out.println(&quot;\t|-&quot; + a1.getRole().getGroups()[x].getInfo());
            for (int y = 0; y &lt; a1.getRole().getGroups()[x].getActions().length; y++) {
                System.out.println(&quot;\t\t|-&quot; + a1.getRole().getGroups()[x].getActions()[y].getInfo());
            }
        }
        System.out.println(&quot;-------------------------------------------------&quot;);
        System.out.println(g2.getInfo());
        for (int x = 0; x &lt; g2.getRoles().length; x++) {
            System.out.println(g2.getRoles()[x].getInfo());
            for (int y = 0; y &lt; g2.getRoles()[x].getAdmins().length; y++) {
                System.out.println(&quot;\t\t|-&quot; + g2.getRoles()[x].getAdmins()[y].getInfo());
            }
            System.out.println();
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Centos7上部署Docker私有仓库]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Centos7%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。</p>
<h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2>
<h3 id="系统要求"><a class="markdownIt-Anchor" href="#系统要求"></a> 系统要求</h3>
<table>
<thead>
<tr>
<th style="text-align:center">要求</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系统</td>
<td style="text-align:center">Centos 7</td>
</tr>
<tr>
<td style="text-align:center">内核</td>
<td style="text-align:center">4.13.5-1.el7.elrepo.x86_64</td>
</tr>
<tr>
<td style="text-align:center">仓库地址</td>
<td style="text-align:center">10.0.0.128:5000</td>
</tr>
<tr>
<td style="text-align:center">docker</td>
<td style="text-align:center">1.12.6</td>
</tr>
</tbody>
</table>
<h3 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h3>
<pre class="highlight"><code class="">$ systemctl stop firewalld.service
$ systemctl disable firewalld.service
$ vim /etc/sysconfig/selinux
  SELINUX=disabled
</code></pre>
<h2 id="搭建docker私有仓库"><a class="markdownIt-Anchor" href="#搭建docker私有仓库"></a> 搭建Docker私有仓库</h2>
<h3 id="搭建仓库"><a class="markdownIt-Anchor" href="#搭建仓库"></a> 搭建仓库</h3>
<pre class="highlight"><code class="">$ docker pull registry  // 拉取官方镜像
$ docker run -d -p 5000:5000 --restart=always --name myHub registry   // 运行官方镜像
$ curl localhost:5000/v2/_catalog  // 查看私有镜像仓库,此时为空
{&quot;repositories&quot;:[]}
</code></pre>
<h3 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h3>
<pre class="highlight"><code class="">$ vim /etc/sysconfig/docker
  OPTIONS='--insecure-registry 10.0.0.128:5000'
$ systemctl restart docker
</code></pre>
<h3 id="上传镜像到私有仓库"><a class="markdownIt-Anchor" href="#上传镜像到私有仓库"></a> 上传镜像到私有仓库</h3>
<pre class="highlight"><code class="">$ docker tag mysql 10.0.0.128:5000/mysql:0.1  // docker tage image_name registry_ip:port/images_name:tag
$ docker push 10.0.0.128:5000/mysql:0.1  // 上传镜像
$ curl localhost:5000/v2/_catalog   // 查看仓库镜像                             
{&quot;repositories&quot;:[&quot;mysql&quot;]}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(六)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AD)/</url>
      <content type="html"><![CDATA[<h2 id="关键字this"><a class="markdownIt-Anchor" href="#关键字this"></a> 关键字this</h2>
<h3 id="this调用属性"><a class="markdownIt-Anchor" href="#this调用属性"></a> this调用属性</h3>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String t, double p) {
        title = t;
        price = p;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book book = new Book(&quot;Java开发&quot;, 66.6);
        System.out.println(book.getInfo());
    }
}
</code></pre>
<p>上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。<strong>构造方法的功能是为类的属性初始化，参数名最好与属性名一致。</strong></p>
<pre class="highlight"><code class="">public Book(String title, double price) {
    title = title;
    price = price;
}
</code></pre>
<p>修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的<code>{}</code>的变量名，即数据传到构造方法后，并未传到属性中。<strong>为了明确要访问的变量是类的属性，应在变量名前加<code>this</code>。</strong></p>
<pre class="highlight"><code class="">public Book(String title, double price) {
    this.title = title;
    this.price = price;
}
</code></pre>
<p><strong>在开发中，只要访问类中属性，前面必须加<code>this</code>。</strong></p>
<h3 id="this调用方法"><a class="markdownIt-Anchor" href="#this调用方法"></a> this调用方法</h3>
<p>1.<code>this</code>指的是当前对象，一个类除了属性还有方法，因此可以利用<code>this</code>调用方法。</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public void print() {
        System.out.println(&quot;*********&quot;);
    }

    // setter和getter方法略
    public String getInfo() {
        this.print();
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>在类中调用普通方法，加不加<code>this</code>都一样。但为了代码的严谨性，最好加<code>this</code>。<br>
2.this调用构造方法<br>
多个构造方法间互相调用: <code>this(参数1, 参数2…);</code><br>
<strong>范例</strong>：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息<code>一个新的Book类对象产生</code></p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
        this.title = title;
    }

    public Book(String title, double price) {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码中存在重复，要消除重复代码：</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() {
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        this(); // 调用本类中的无参构造
        this.title = title;
    }

    public Book(String title, double price) {
        this(title); // 调用本类中的单参构造方法
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码中存在限制：</p>
<blockquote>
<p>（1）利用<code>this</code>调用构造方法的语句只能放在构造方法首行；<br>
（2）普通方法无法调用构造方法；<br>
（3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。</p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book() { // 报错，构造递归调用
        this(&quot;Book&quot;,1.1);
        System.out.println(&quot;一个新的Book类对象产生&quot;);
    }

    public Book(String title) {
        this(); // 调用本类中的无参构造
        this.title = title;
    }

    public Book(String title, double price) {
        this(title); // 调用本类中的单参构造方法
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}
</code></pre>
<p>上述代码会出现”构造方法递归调用”错误，说明<strong>构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。</strong><br>
3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法;</p>
<blockquote>
<p>（1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”；<br>
（2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”；<br>
（3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”；<br>
（4）四参构造</p>
</blockquote>
<p><strong>实现方式1：不使用this</strong></p>
<pre class="highlight"><code class="">class Emp {
    private int empNo;
    private String eName;
    private double sal;
    private String dept;

    public Emp() {
        this.empNo = 0;
        this.eName = &quot;无名氏&quot;;
        this.sal = 0.0;
        this.dept = &quot;未定&quot;;
    }

    public Emp(int empNo) {
        this.empNo = empNo;
        this.eName = &quot;临时工&quot;;
        this.sal = 800.0;
        this.dept = &quot;后勤部&quot;;
    }

    public Emp(int empNo, String eName) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = 2000.0;
        this.dept = &quot;技术部&quot;;
    }

    public Emp(int empNo, String eName, double sal, String dept) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = sal;
        this.dept = dept;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +
                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +
                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +
                &quot;部   门：&quot; + this.dept;
    }
}
</code></pre>
<p><strong>实现方式2：使用this</strong></p>
<pre class="highlight"><code class="">class Emp {
    private int empNo;
    private String eName;
    private double sal;
    private String dept;

    public Emp() {
        this(0,&quot;无名氏&quot;,0.0,&quot;&quot;);
    }

    public Emp(int empNo) {
        this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;);

    }

    public Emp(int empNo, String eName) {
        this(empNo,eName,2000.0,&quot;技术部&quot;);
    }

    public Emp(int empNo, String eName, double sal, String dept) {
        this.empNo = empNo;
        this.eName = eName;
        this.sal = sal;
        this.dept = dept;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;雇员编号：&quot; + this.empNo + &quot;\n&quot; +
                &quot;姓   名：&quot; + this.eName + &quot;\n&quot; +
                &quot;工   资：&quot; + this.sal + &quot;\n&quot; +
                &quot;部   门：&quot; + this.dept;
    }
}
</code></pre>
<p><strong>通过构造方法互相调用解决了代码重复问题。</strong></p>
<h3 id="当前对象"><a class="markdownIt-Anchor" href="#当前对象"></a> 当前对象</h3>
<p><strong>当前对象指的是当前正在调用类中属性或方法的对象</strong></p>
<pre class="highlight"><code class="">class Book {
    public void print() {
        // 哪个对象调用了print(),this就与该对象指向同一块内存地址
        // this就是当前调用方法的对象
        System.out.println(&quot;this = &quot; + this);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        System.out.println(&quot;bkA = &quot; + bkA);  
        // bkA = com.java.demo.Book@1540e19d
        bkA.print(); 
        // this = com.java.demo.Book@1540e19d
        System.out.println( &quot;===============&quot;);
        Book bkB = new Book(); 
        // bkB = com.java.demo.Book@677327b6
        System.out.println(&quot;bkB = &quot; + bkB); 
        // this = com.java.demo.Book@677327b6
        bkB.print();
    }
}
</code></pre>
<pre class="highlight"><code class="">class A{
    private B b;
    public A(){ // 2.执行A类构造方法
        // 3. 实例化B类对象b，调用B类构造方法
        this.b = new B(this); //此时this是temp
        this.b.get(); // 5. 通过b调用B类的get()
    }
    public void print(){ //8. 执行该方法
        System.out.println(&quot;Hello World !&quot;);
    }
}
class B{
    private A a;
    public B(A a){ // A a = temp
        this.a = a; // 4. 执行B类构造方法
    }
    public void get(){ // 6. 执行该方法
        this.a.print(); // 7. 调用A类的print()
    }
}
public class Demo {
    public static void main(String[] args) {
        // 1.实例化A类对象，调用A类的无参构造方法
        A temp = new A(); // Hello World !
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(五)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%94)/</url>
      <content type="html"><![CDATA[<h2 id="string类的特点及使用"><a class="markdownIt-Anchor" href="#string类的特点及使用"></a> String类的特点及使用</h2>
<blockquote>
<p>JDK_API文档由下面几部分组成：<br>
（1）类的定义以及相关的继承结构<br>
（2）类的简短说明<br>
（3）类的成员组成<br>
（4）类所提供的构造方法<br>
（5）类所提供的普通方法<br>
（6）类的成员，构造方法，普通方法的详细说明<br>
<code>deprecated</code>标记表示不再建议使用。</p>
</blockquote>
<h3 id="string对象的两种实例化方式"><a class="markdownIt-Anchor" href="#string对象的两种实例化方式"></a> String对象的两种实例化方式</h3>
<p>1.<code>String</code>是字符串类,下面将类的角度与内存关系分析其作用：<br>
（1）直接赋值<code>String value_name = &quot;字符串&quot;</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World !&quot;; // 直接赋值
        System.out.println(str);
    }
}
</code></pre>
<p>（2）构造方法<code>public String (String str);</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = new String(&quot;Hello World !&quot;);
        System.out.println(str);
    }
}
</code></pre>
<h3 id="字符串比较"><a class="markdownIt-Anchor" href="#字符串比较"></a> 字符串比较</h3>
<p>1.判断两个int数据是否相等：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int x = 10;
        int y = 10;
        System.out.println(x == y); // true
    }
}
</code></pre>
<p>使用<code>==</code>判断String对象是否相等：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = new String(&quot;Hello&quot;);
        String strC = strB;
        System.out.println(strA == strB); // false
        System.out.println(strA == strC); // false
        System.out.println(strB == strC); // true
    }
}
</code></pre>
<p>对上述代码进行内存分析：<br>
<img src="/article/Java/Java Base/Java基础知识(五)/8-1.png" alt="无法加载" title="内存分析"><br>
由内存分析可知，String对象使用<code>==</code>比较时，比较的是对象的<strong>栈内存地址的值</strong>。<br>
2.要比较字符串的内容，应使用String类中的方法<code>public boolean equals（String str）</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = new String(&quot;Hello&quot;);
        String strC = strB;
        System.out.println(strA.equals(strB)); // true
        System.out.println(strA.equals(strC)); // true
    }
}
</code></pre>
<p>开发中，字符串比较应用<code>equals(String str)</code>.<br>
3.<strong>章节例题：<code>==</code>与<code>equals(String str)</code>的区别</strong><br>
<code>==</code>是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值;<br>
<code>equals(String str)</code>是String类的方法，用于比较字符串内容。</p>
<h3 id="string常量是匿名对象"><a class="markdownIt-Anchor" href="#string常量是匿名对象"></a> String常量是匿名对象</h3>
<p>1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但<strong>不属于基本数据类型，而是将字符串作为String类的匿名对象。</strong><br>
<strong>范例</strong>：验证字符串是匿名对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        System.out.println(&quot;Hello&quot;.equals(str));
    }
}
</code></pre>
<p>2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化.</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String input = null; // 假设该内容是用户输入的
        if (input.equals(&quot;hello&quot;)){
            System.out.println(&quot;Hello World !&quot;);
            // 报错，NullPointerException
        }
    }
}
</code></pre>
<p>为预防用户输入错误导致input为null，而后调用<code>equals()</code>，出现空指针异常，应使用如下代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String input = null; // 假设该内容是用户输入的
        if (&quot;hello&quot;.equals(input)){
            System.out.println(&quot;Hello World !&quot;);
        }
    }
}
</code></pre>
<p>使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将<strong>指定字符串放在equals()前</strong>。</p>
<h3 id="两种实例化方式的区别"><a class="markdownIt-Anchor" href="#两种实例化方式的区别"></a> 两种实例化方式的区别</h3>
<p>1.<strong>直接赋值</strong><br>
直接赋值就是给字符串匿名对象设置对象名。<br>
此时内存中会开辟堆内存，并且有一块栈内存指向堆内存：<br>
<img src="/article/Java/Java Base/Java基础知识(五)/8-2.png" alt="无法加载" title="内存分析"><br>
观察下列代码：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;hello&quot;;
        String strB = &quot;hello&quot;;
        String strC = &quot;hello&quot;;
        String strD = &quot;world&quot;;
        System.out.println(strA == strB); // true
        System.out.println(strA == strC); // true
        System.out.println(strB == strC); // true
        System.out.println(strA == strD); // false
    }
}
</code></pre>
<p>由上述结果可知，strA，strB，strC都指向同一块堆内存：<br>
<img src="/article/Java/Java Base/Java基础知识(五)/8-3.png" alt="无法加载" title="内存分析"><br>
<strong>共享设计模式</strong>：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。<br>
2.<strong>构造方法实例化</strong><br>
使用构造方法定义String对象，就需要每次开辟新的堆内存。<br>
<img src="/article/Java/Java Base/Java基础知识(五)/8-4.png" alt="无法加载" title="内存分析"><br>
由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = new String(&quot;hello&quot;);
        String strB = &quot;hello&quot;;
        System.out.println(strA == strB); // false
    }
}
</code></pre>
<p>除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用<code>public String intern()</code>手工入池。</p>
<p>3.<strong>章节小题：String对象两种定义方式的区别</strong><br>
· 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用；<br>
· 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。</p>
<h3 id="字符串内容不可改变"><a class="markdownIt-Anchor" href="#字符串内容不可改变"></a> 字符串内容不可改变</h3>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        str += &quot; World&quot;;
        str += &quot; !!!&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>对上述代码进行内存分析：<br>
<img src="/article/Java/Java Base/Java基础知识(五)/8-5.png" alt="无法加载" title="内存分析"><br>
分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。</p>
<h3 id="string类常用方法字符与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字符与字符串"></a> String类常用方法(字符与字符串)</h3>
<p>很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法：</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String (char[] value)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将字符数组变为String类对象</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String (char[] value ,int offset,int count)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分字符数组变为String对象</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public char charAt (int index)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">返回指定索引对应的字符信息</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public char[] toCharArray()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串以字符数组的形式返回</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：取出指定索引的字符</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        char c = str.charAt(0);
        System.out.println(c); // H
    }
}
</code></pre>
<p><strong>范例</strong>：将字符串转大写</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello&quot;;
        char [] data = str.toCharArray(); // 字符串转为字符数组
        for (int x = 0; x &lt; data.length ; x++) {
            data[x] -= 32; // 小写编码 - 32 = 大写编码
        }
        // 将字符数组变为字符串
        System.out.println(new String(data)); // HELLO
        // 将部分字符数组变为String对象
        System.out.println(new String(data, 1, 2)); // EL
    }
}
</code></pre>
<p><strong>范例</strong>：判断一个字符换是否为纯数字<br>
<em>思路</em>：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;3146017052&quot;;
        if (isNumber(str)) {
            System.out.println(&quot;字符串全部由数字组成&quot;);
        } else {
            System.out.println(&quot;字符串不是全部由数字组成&quot;);
        }
    }

    // 定义判断字符串是否由数字组成的方法
    public static boolean isNumber(String temp) {
        // 首先将字符串变为字符数组
        char[] data = temp.toCharArray();
        // 一一比较字符
        for (int x = 0; x &lt; data.length; x++) {
            if (data[x] &gt; '9' || data[x] &lt; '0') {
                return false;
            }
        }
        // 全部为数字则返回true
        return true;
    }
}
</code></pre>
<p><strong>建议</strong>：返回值为<code>boolean</code>的方法命名为<code>isXxx</code>。</p>
<h3 id="string类常用方法字节与字符串"><a class="markdownIt-Anchor" href="#string类常用方法字节与字符串"></a> String类常用方法(字节与字符串)</h3>
<p>字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String (byte[] bytes)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将字节数组变为字符串</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String (byte[] bytes ,int offset,int length)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分字节数组变为字符串</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public byte[] getBytes (String charsetName) throws UnsupportedEncodingException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行编码转换</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public byte[] getBytes()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串变为字节数组</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：字符串与字节数组的转换</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        byte [] data = str.getBytes(); // 将字符串转为字节数组
        for (int x = 0; x &lt; data.length ; x++) {
            data[x] -= 32; // 将小写字母转为大写字母
        }
        System.out.println(new String(data)); // HELLOWORLD
        System.out.println(new String(data,5,5)); // WORLD
    }
}
</code></pre>
<h3 id="string类常用方法字符串比较"><a class="markdownIt-Anchor" href="#string类常用方法字符串比较"></a> String类常用方法(字符串比较)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public boolean equals(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行内容判断，区分大小写</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public boolean equalsIgnoreCase(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">进行内容判断，不区分大小写</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public int compareTo (String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断两个字符串的大小（按照字符编码）,返回值为0,1,-1</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：equals()判断</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.equals(strB)); // false,说明区分大小写
    }
}
</code></pre>
<p><strong>范例</strong>：equalsIgnoreCase()判断</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.equals(strB)); // false,说明区分大小写
        System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写
    }
}
</code></pre>
<p><strong>范例</strong>：compareTo()</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;Hello&quot;;
        String strB = &quot;hello&quot;;
        System.out.println(strA.compareTo(strB)); // -32
        if (strA.compareTo(strB) &gt; 0){
            System.out.println(&quot;大于&quot;);
        } else if (strA.compareTo(strB) == 0){
            System.out.println(&quot;两个字符串相等&quot;);
        } else {
            System.out.println(&quot;小于&quot;);
        }
    }
}
</code></pre>
<p>只有String对象才能进行大小判断。</p>
<h3 id="string类常用方法字符串查找"><a class="markdownIt-Anchor" href="#string类常用方法字符串查找"></a> String类常用方法(字符串查找)</h3>
<p>要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法：</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public boolean contains (String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断指定内容是否存在</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public int indexOf(String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public int indexOf(String s,int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public int lastindexOf(String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">public int lastindexOf(String s, int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">public boolean startsWith (String prefix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定字符串开头</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">public boolean startsWith (String prefix，int toffset)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定位置开始判断是否是以指定字符串开头</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">public boolean endsWith(String suffix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定字符串结尾</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：查找字符串位置</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 返回满足条件的单词的首字母索引
        System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引
        // 从索引5开始查满足条件单词的索引
        System.out.println(str.indexOf(&quot;l&quot;,5)); // 8
        // 从后向前查
        System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8
    }
}
</code></pre>
<p>在某些程序中，需要查找指定字符串是否存在，早期方法如下：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        if (str.indexOf(&quot;world&quot;) != -1){
            System.out.println(&quot;该字符串存在&quot;);
        } else {
            System.out.println(&quot;该字符串不存在&quot;);
        }
    }
}
</code></pre>
<p>JDK1.5出现<code>contains()</code>，使用如下：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        if (str.contains(&quot;world&quot;)) {
            System.out.println(&quot;该字符串存在&quot;);
        } else {
            System.out.println(&quot;该字符串不存在&quot;);
        }
    }
}
</code></pre>
<p><strong>范例</strong>：开头或结尾判断内容</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 从开头开始查
        System.out.println(str.startsWith(&quot;he&quot;));
        // 从索引2开始查找
        System.out.println(str.startsWith(&quot;ll&quot;,2));
        // 从结尾开始查找
        System.out.println(str.endsWith(&quot;ld&quot;));
    }
}
</code></pre>
<h3 id="string类常用方法字符串替换"><a class="markdownIt-Anchor" href="#string类常用方法字符串替换"></a> String类常用方法(字符串替换)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String replaceAll(String regex，String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">全部替换</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String replaceFirst(String regex，String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换首个满足条件的内容</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 替换所有
        String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d
        // 只替换第一个
        String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld
        System.out.println(resultA);
        System.out.println(resultB);
    }
}
</code></pre>
<h3 id="string类常用方法字符串截取"><a class="markdownIt-Anchor" href="#string类常用方法字符串截取"></a> String类常用方法(字符串截取)</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String substring(int beginIndex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">从指定索引截取到结尾</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String substring(int beginIndex,int endIndex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">截取指定范围内的内容</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;helloworld&quot;;
        // 从索引5开始截取直到结尾
        String resultA = str.substring(5); 
        // 截取索引5到8之间
        String resultB = str.substring(5,8); 
        System.out.println(resultA); // world
        System.out.println(resultB); // wor
    }
}
</code></pre>
<h3 id="string类常用方法字符串拆分"><a class="markdownIt-Anchor" href="#string类常用方法字符串拆分"></a> String类常用方法(字符串拆分)</h3>
<table>
<thead>
<tr>
<th>No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String[] split (String regex)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">按照指定的字符串进行全部拆分</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String[] split (String regex，int limit)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">按照指定的字符串进行部分拆分，最后一个数组长度由limit决定</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：全部拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world&quot;;
        // 按照空格拆分单词
        String result[] = str.split(&quot; &quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：hello
            // world
        }
    }
}
</code></pre>
<p>在拆分的时候，只写一个空字符串（<code>&quot;&quot;</code>不是<code>null</code>），表示按照每一个字符进行拆分。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world&quot;;
        // 按照空字符串拆分
        String result[] = str.split(&quot;&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：h e l l o w o r l d
        }
    }
}
</code></pre>
<p><strong>范例</strong>：部分拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hello world nihao mldn&quot;;
        // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆
        String result[] = str.split(&quot; &quot;,3);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot;
        }
    }
}
</code></pre>
<p><strong>范例</strong>：IP地址拆分</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;192.168.1.1&quot;;
        String result[] = str.split(&quot;\\.&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            System.out.println(result[x]);
            // 结果为：192 168 1 1
        }
    }
}
</code></pre>
<p>上述代码中，只用<code>.</code>无法拆分，当遇到这种拆分时，需要使用<code>\\.</code>进行转义后拆分。<br>
<strong>范例</strong>：拆分“张三:20|李四:25|王五:23”</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;张三:20|李四:25|王五:23&quot;;
        String result[] = str.split(&quot;\\|&quot;);
        for (int x = 0; x &lt; result.length; x++) {
            String temp[] = result[x].split(&quot;:&quot;);
            System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]);
        }
    }
}
</code></pre>
<h3 id="string类其他方法"><a class="markdownIt-Anchor" href="#string类其他方法"></a> String类其他方法</h3>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">public String concat (String str)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">字符串连接</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">public String toLowerCase ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">把字符串转为小写</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">public String toUpperCase ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">把字符串转为大写</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">public String trim ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">去掉字符串中左右两边的空格，中间空格保留</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">public int length()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">取得字符串长度</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">public String intern ()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">数据入池操作</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center"></td>
<td style="text-align:center">public boolean isEmpty ()</td>
<td style="text-align:center">普通方法</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：字符串连接</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String strA = &quot;hello&quot;;
        String strB = strA + &quot; world&quot;;
        String strC = &quot;hello&quot; + &quot;world&quot;;
        String strD = &quot;hello world&quot;;
        String strE = strA.concat(&quot; world&quot;);
        System.out.println(strB == strC); // false
        System.out.println(strB == strD); // false
        System.out.println(strB == strE); // false
        System.out.println(strC == strD); // false
        System.out.println(strC == strE); // false
        System.out.println(strD == strE); // false
    }
}
</code></pre>
<p><strong>范例</strong>：字符串进行大小写转换</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;*Hello*&quot;;
        // 只转换小写字母
        System.out.println(str.toUpperCase()); // *HELLO*
        // 只转换大写字母
        System.out.println(str.toLowerCase()); // *hello*
    }
}
</code></pre>
<p><strong>范例</strong>：去掉空格</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot; Hello World &quot;;
        System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】
        System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】
    }
}
</code></pre>
<p>用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了<code>trim()</code>。<br>
<strong>范例</strong>：取得字符串长度</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World&quot;;
        System.out.println(str.length()); // 11
    }
}
</code></pre>
<p>某些情况要求用户输入的数据长度有限制，可以利用此方法判断。<br>
<strong>范例</strong>：判断是否是空字符串</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;&quot;;
        System.out.println(str.isEmpty()); // true
        System.out.println(&quot;&quot;.equals(str)); // true
    }
}
</code></pre>
<p><strong>范例</strong>：实现首字母大写，其余字母小写</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        String str = &quot;hElLo&quot;;
        System.out.println(initcap(str)); // Hello
    }

    public static String initcap(String temp) {
        // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写
        return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase();
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(四)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%9B)/</url>
      <content type="html"><![CDATA[<h2 id="数组的定义及使用"><a class="markdownIt-Anchor" href="#数组的定义及使用"></a> 数组的定义及使用</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>1.<strong>数组</strong>是一组变量的集合。数组属于引用数据类型。<br>
2.数组的定义语法<br>
（1）声明并开辟数组： <code>数组类型 数组名[] = new 数据类型[数组长度]</code><br>
（2）分步完成：</p>
<pre class="highlight"><code class="">// 声明数组
数组类型 数组名[] = null;
// 开辟数组
数组名 = new 数据类型 [数组长度]
</code></pre>
<p>3.数组开辟空间用，可利用<code>数组名[下标|索引]</code>访问，<strong>下标从0开始</strong>。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现<strong>数组越界异常（ArrayIndexOutOfBoundsException）。</strong><br>
4.数组是顺序结构且长度固定，可使用循环语句输出，可用<code>数组名.length</code>获取数组长度。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[3]; // 声明并开辟一个长度为3的数组
        datas[0] = 1; // 为数组赋值，如不赋值，默认值为0
        datas[1] = 2;
        datas[2] = 3;
        // for循环输出数组内容，datas.length获取数组长度
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p>5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。<br>
<img src="/article/Java/Java Base/Java基础知识(四)/7-1.png" alt="无法加载" title="数组内存分析"><br>
<strong>范例</strong>：分步完成</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = null; // 声明数组
        datas = new int[3]; // 开辟一个长度为3的数组
        datas[0] = 1;
        datas[1] = 2;
        datas[2] = 3;
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p><img src="/article/Java/Java Base/Java基础知识(四)/7-2.png" alt="无法加载" title="数组内存分析"><br>
6.数组可以进行引用传递。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[3];
        datas[0] = 1;
        datas[1] = 2;
        datas[2] = 3;
        int temp[] = datas; // 引用传递
        temp[0] = 99;
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]); // 99 2 3
        }
    }
}
</code></pre>
<p><img src="/article/Java/Java Base/Java基础知识(四)/7-3.png" alt="无法加载" title="数组内存分析"><br>
以上都是<code>动态初始化数组</code>，即先开辟数组，再为数组赋值。<br>
7.静态初始化数组：<br>
在定义数组的同时为其赋值，语法：<br>
（1）<code>数组类型 数组名[] = {v1, v2 ,…,vn};</code><br>
（2）<code>数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn};</code><br>
<strong>范例</strong>：静态初始化数组</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[]{1, 2, 3}; // 静态初始化数组
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }
}
</code></pre>
<p>数组支持顺序数据访问，最大缺点是<strong>长度不能改变</strong>，因此在开发中不直接使用数组，但会使用数组的概念。</p>
<h3 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h3>
<p>1.<strong>一维数组就是一行数据：</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据</td>
<td style="text-align:center">0</td>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
</tr>
</tbody>
</table>
<p>在一维数组中要查询一个数据，只要确定其索引即可。<br>
<strong>二维数组，是一个数据表：</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">12</td>
<td style="text-align:center">123</td>
<td style="text-align:center">231</td>
<td style="text-align:center">233</td>
</tr>
</tbody>
</table>
<p>二维数组中要查询一个数据，需要定位列和行。二维数组中第一个<code>[]</code>确定行，第二个<code>[]</code>确定列。<br>
2. 二维数组定义语法：</p>
<pre class="highlight"><code class="">// 动态初始化：
数据类型 数组名称[][]=new 数据类型[行数][列数];
// 静态初始化：
数据类型 数组名称[][]=new 数据类型[][]{数组元素} ;
</code></pre>
<p>由此可以发现，二维数组就是将多个一维数组变为一个数组。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[][] = new int[][]{
        	{1, 2, 3}, 
        	{4, 5, 6}, 
        	{7, 8, 9}
        }; 
        // 外层循环控制数组的行
        for (int x = 0; x &lt; datas.length; x++) {
            // 内层循环控制数组的列
            for (int y = 0; y &lt; datas[x].length ; y++) {
                System.out.print(datas[x][y] + &quot;\t&quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="数组与方法的引用"><a class="markdownIt-Anchor" href="#数组与方法的引用"></a> 数组与方法的引用</h3>
<p>1.方法的参数可以是数组：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int datas[] = new int[]{1, 2, 3};
        change(datas);
        for (int x = 0; x &lt; datas.length; x++) {
            System.out.println(datas[x]);
        }
    }

    public static void change(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            temp[x] *= 2; // 数组元素乘2保存
        }
    }
}
</code></pre>
<p><strong>内存分析：</strong><br>
<img src="/article/Java/Java Base/Java基础知识(四)/7-4.png" alt="无法加载" title="数组内存分析"><br>
<code>change()</code>执行完毕后，<code>temp</code>不再指向<code>datas</code>的堆内存，但<code>change()</code>对<code>datas</code>数据的修改被保存下来。<br>
2.<strong>数组排序（冒泡排序）</strong>：<br>
数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。</p>
<pre class="highlight"><code class="">public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};
        for (int x = 0; x &lt; datas.length; x++) {
            for (int y = 0; y &lt; datas.length - 1; y++) {
                if (datas[y] &gt; datas[x]) {
                    int t = datas[y];
                    datas[y] = datas[x];
                    datas[x] = t;
                }
            }
            // 为更好地理解冒泡排序，输出每轮排序的结果
            System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;);
            print(datas);
            System.out.println();
        }
        print(datas);
    }
    // 数组输出的方法
    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot; &quot;);
        }
    }
}
</code></pre>
<p><strong>建议</strong>：<code>main()</code>是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。</p>
<pre class="highlight"><code class="">public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8};
        sort(datas);
        print(datas);
    }

    // 数组冒泡排序方法
    public static void sort(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            for (int y = 0; y &lt; temp.length - 1; y++) {
                if (temp[y] &gt; temp[x]) {
                    int t = temp[y];
                    temp[y] = temp[x];
                    temp[x] = t;
                }
            }
        }
    }

    // 数组输出的方法
    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot; &quot;);
        }
    }
}
</code></pre>
<p>3.<strong>数组转置</strong><br>
转置的概念（一维数组）：·</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th style="text-align:right">1，2，3，4，5，6，7，8</th>
</tr>
</thead>
<tbody>
<tr>
<td>转置后</td>
<td style="text-align:right">8，7，6，5，4，3，2，1</td>
</tr>
</tbody>
</table>
<p><strong>转置操作的两个思路：</strong><br>
（1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用：</p>
<pre class="highlight"><code class=""> public class ArrayDemo {
    public static void main(String[] args) {
        int datas[] = new int[]{1,2,3,4,5,6,7,8};
        datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾
    }
    // 数组逆序输出方法一
    public static int [] reverseOne(int temp[]) {
        // 定义新数组，长度与原始数组一致
        int temps[] = new int[temp.length];
        int foot = temp.length - 1; // 控制原始数组的索引
        for (int x = 0; x &lt; temps.length ; x++) {
            temps[x] = temp[foot]; // 新数组按照原始数组倒序排列
            foot --;
        }
        return temps;
    }
}
</code></pre>
<p>上述代码实现转置，但产生了垃圾，不合理。<br>
（2）利用算法，直接在数组上完成转置：<br>
不论数组个数是奇数还是偶数,<code>转换次数 = 数组长度 / 2</code>;</p>
<pre class="highlight"><code class="">// 数组逆序输出方法
public static void reverse(int temp[]) {
    int len = temp.length / 2;
    int head = 0;
    int tail = temp.length - 1;
    for (int x = 0; x &lt; len; x++) {
        int t = temp[head];
        temp[head] = temp[tail];
        temp[tail] = t;
        head++;
        tail--;
    }
}
</code></pre>
<p>4.<strong>行列数相等的二维数组转置：</strong></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int data[][] = new int[][]{
        	{1, 2, 3}, 
        	{4, 5, 6}, 
        	{7, 8, 9}
        };
        reverse(data);
        print(data);
    }

    // 专门实现数组的倒置操作
    public static void reverse(int arr[][]) {
        for (int x = 0; x &lt; arr.length; x++) {
            for (int y = x; y &lt; arr.length; y++) {
                if (x != y) { //行和列相同，进行交换
                    int temp = arr[x][y];
                    arr[x][y] = arr[y][x];
                    arr[y][x] = temp;
                }
            }
        }
    }

    // 专门输出的方法
    public static void print(int temp[][]) {
        for (int x = 0; x &lt; temp.length; x++) {
            for (int y = 0; y &lt; temp[x].length; y++) {
                System.out.print(temp[x][y] + &quot;、&quot;);
            }
            System.out.println();
        }
        System.out.println();
    }

}
</code></pre>
<p><strong>转置过程</strong>：</p>
<pre class="highlight"><code class="">1[0][0]  2[0][1]  3[0][2]
4[1][0]  5[1][1]  6[1][2]
7[2][0]  8[2][1]  9[2][2]
第一次转换（x=0，y=x=0，循环3次）
 ·y的第一次循环（x==y）
  1[0][0]  2[0][1]  3[0][2]
  4[1][0]  5[1][1]  6[1][2]
  7[2][0]  8[2][1]  9[2][2]
 ·y的第二次循环（x=0，y=1，进行交换）
  1[0][0]  4[1][0]  3[0][2]
  2[0][1]  5[1][1]  6[1][2]
  7[2][0]  8[2][1]  9[2][2]
 ·y的第三次循环（x=0，y=2，进行交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  6[1][2]
  3[0][2]  8[2][1]  9[2][2]
第二次转换（x=1，y=x=1，循环2次）
 ·y的第一次循环（x=1，y=1，不交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  6[1][2]
  3[0][2]  8[2][1]  9[2][2]
 ·y的第二次循环（x=1，y=2，进行交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  8[2][1]
  3[0][2]  6[1][2]  9[2][2]
第三次转换（x=2，y=x=2，循环11次）
 ·y的第二次循环（x=2，y=2，不交换）
  1[0][0]  4[1][0]  7[2][0]
  2[0][1]  5[1][1]  8[2][1]
  3[0][2]  6[1][2]  9[2][2]
</code></pre>
<p>行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。<br>
5.方法返回数组：</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int data[] = init(); // 接收数组
        print(data);
        System.out.println(init().length);
    }

    public static int[] init() {
        return new int[]{1, 2, 3}; // 方法返回数组
    }

    public static void print(int temp[]) {
        for (int x = 0; x &lt; temp.length; x++) {
            System.out.print(temp[x] + &quot;、&quot;);
        }
        System.out.println();
    }
}
</code></pre>
<h3 id="操作数组的方法"><a class="markdownIt-Anchor" href="#操作数组的方法"></a> 操作数组的方法</h3>
<p>1.Java对数组提供类库支持，下面介绍两个类库中的方法：<br>
（1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。<br>
语法：<code>System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)</code>。<br>
范例：数组拷贝<br>
·数组A：1，2，3，4，5，6，7，8；<br>
·数组B：11，22，33，44，55，66，77，88；<br>
·拷贝后的数组B:11，22，5，6，7，66，77，88</p>
<pre class="highlight"><code class=""> public class Demo {
    public static void main(String[] args) {
        int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8};
        int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88};
        System.arraycopy(dataA, 4, dataB, 2, 3);
        ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法
    }
}
</code></pre>
<p>（2）数组排序：<br>
语法：<code>java.util.Arrays.sort(数组名)</code></p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5};
        java.util.Arrays.sort(dataA);
        ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法
    }
}
</code></pre>
<h3 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h3>
<p>1.<strong>对象数组</strong>是将多个对象交由数组处理。<br>
2.对象数组的定义与一般数组一致：<br>
<strong>范例</strong>： 动态初始化对象数组</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book books[] = new Book[3];
        books[0] = new Book(&quot;Java开发&quot;, 66.6);
        books[1] = new Book(&quot;JSP&quot;, 6.6);
        books[2] = new Book(&quot;C++&quot;, 16.6);
        for (int x = 0; x &lt; books.length; x++) {
            System.out.println(books[x].getInfo()); 
//未实例化对象时，输出值全为null
        }
    }  
}
</code></pre>
<p><strong>范例</strong>：静态初始化对象数组：</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    // setter和getter方法略
    public String getInfo() {
        return &quot;书名：&quot; + title + &quot;，价格：&quot; + price;
    }
}

public class Demo {
    public static void main(String[] args) {
        Book books[] = new Book[]{
                new Book(&quot;Java开发&quot;, 66.6),
                new Book(&quot;JSP&quot;, 6.6),
                new Book(&quot;C++&quot;, 16.6)
        };
        for (int x = 0; x &lt; books.length; x++) {
            //未实例化对象时，输出值全为null
            System.out.println(books[x].getInfo()); 
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(三)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="方法的定义与使用"><a class="markdownIt-Anchor" href="#方法的定义与使用"></a> 方法的定义与使用</h2>
<h3 id="方法的基本概念"><a class="markdownIt-Anchor" href="#方法的基本概念"></a> 方法的基本概念</h3>
<ol>
<li><strong>方法</strong>就是<code>将一段可重复使用的代码封装</code>。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是<code>定义在主类中，由主方法直接调用</code>的方法。此类方法的语法：</li>
</ol>
<pre class="highlight"><code class="">public static 返回值类型 method_name(v_type v1, v_type v2,...) {
    方法体; // 方法要进行的若干操作
    [return [返回值] ;] // []中内容可写可不写
}
</code></pre>
<p><strong>返回值类型:</strong></p>
<table>
<thead>
<tr>
<th>数据类型(基本数据类型、引用数据类型)</th>
<th style="text-align:right">无返回值(void)</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容</td>
<td style="text-align:right">不需要return语句，但可用return结束方法调用</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>方法名的命名规则：<code>第一个单词小写，随后每个单词首字母大写</code>。<br>
<strong>范例</strong>：定义无参无返回值方法</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        print(); // 直接调用
    }
    public static void print(){
        System.out.println(&quot;无参无返回值方法&quot;);
    }
}
</code></pre>
<p><strong>范例</strong>：定义含参无返回值方法</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        compare(10.2); // 调用时必须写入参数
        compare(-10.2);
    }

    public static void compare(double x){
        String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>有了参数后，方法就可以根据不同的参数内容进行数据的处理。<br>
<strong>范例</strong>：定义含参数有返回值方法</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        //定义变量接收返回值，而后输出
        int result = add(10, 20);
        System.out.println(result);
        // 直接输出返回值
        System.out.println(add(10, 20));
    }

    public static int add(int x, int y) {
        return x + y;
    }
}
</code></pre>
<ol start="3">
<li>一个方法使用<code>void</code>定义，该方法无法使用return返回值，但可以使用return结束调用。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        print(1100); // x = 1100
        print(3); // 结束调用,不输出x
    }

    public static void print(int x) {
        if (x == 3) {
            System.out.println(&quot;结束调用,不输出x&quot;);
            return;
        }
        System.out.println(&quot;x = &quot; + x);
    }
}
</code></pre>
<p><strong>只有返回值类型为void时，才可使用return结束方法的调用。</strong></p>
<h3 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h3>
<ol>
<li>假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为<code>方法重载（overloading）</code>。</li>
<li>方法重载要求<code>方法名一致，参数类型或个数不同</code>。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 根据参数的个数或类型，调用不同方法
        add(10,20);
        add(10.2,20.2);
        add(10,20,30);
    }
    // 方法名相同，参数的类型或个数不同
    public static void add(int x, int y) {
        System.out.println(&quot;两个整数相加：&quot; + (x + y));
    }

    public static void add(double x, double y) {
        System.out.println(&quot;两个小数相加：&quot; + (x + y));
    }

    public static void add(int x, int y, int z) {
        System.out.println(&quot;三个整数相加：&quot; + (x + y + z));
    }
}
</code></pre>
<p><code>System.out.println()</code>可以输出不同类型数据，可知此方法是一个被重载后的方法。</p>
<ol start="3">
<li>方法重载的说明：<br>
（1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致；<br>
（2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
    }
    // 报错,已在类中定义了方法 add(int,int)
    // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同
    public static int add(int x, int y) {
        return x + y;
    }

    public static double add(int x, int y) {
        return x + y;
    }
}
</code></pre>
<h3 id="递归调用"><a class="markdownIt-Anchor" href="#递归调用"></a> 递归调用</h3>
<ol>
<li>递归调用是指<code>方法调用自身</code>。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。<br>
<strong>范例</strong>：递归实现1~100的累加操作</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        System.out.println(sum(100));
    }
    public static int sum(int num){
        if (num == 1) { // 结束递归调用
            return 1;
        }
        // 递归调用
        return num + sum(num - 1); 
    }
}
</code></pre>
<p><strong>代码的执行步骤：</strong></p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center">内容</th>
<th style="text-align:right">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">主方法调用sum(100)</td>
<td style="text-align:right">100+sum(99)</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">递归调用sum(99)</td>
<td style="text-align:right">100 + 99 + sum（98)</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">递归调用sum(98)</td>
<td style="text-align:right">100 + 99 + 98+ sum(97)</td>
</tr>
<tr>
<td>…</td>
<td style="text-align:center">依此类推</td>
<td style="text-align:right">…</td>
</tr>
<tr>
<td>最后一次</td>
<td style="text-align:center">递归调用sum(1)</td>
<td style="text-align:right">sum=100+99+98+…+2+1,结束递归</td>
</tr>
</tbody>
</table>
<h2 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h2>
<h3 id="面向对象简介"><a class="markdownIt-Anchor" href="#面向对象简介"></a> 面向对象简介</h3>
<blockquote>
<p>面向过程：指的是针对某一个问题单独提出解决方案和代码开发。<br>
面向对象：以组件化的形式进行代码设计，优点是代码可重用。<br>
面向对象语言的特征：<br>
（1）<code>封装性</code>：保护内部结构安全性。<br>
（2）<code>继承性</code>：在已有的程序结构上扩充新的功能。<br>
（3）<code>多态性</code>：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果<br>
面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。</p>
</blockquote>
<h3 id="类与对象-2"><a class="markdownIt-Anchor" href="#类与对象-2"></a> 类与对象</h3>
<p>1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。<br>
2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含<code>特征(属性)</code>外，还包括许多<code>行为(方法)</code>。根据这个类产生的对象都具有相同的行为。<br>
3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。<br>
4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。</p>
<h3 id="类与对象的定义及使用"><a class="markdownIt-Anchor" href="#类与对象的定义及使用"></a> 类与对象的定义及使用</h3>
<p>1.定义类使用<code>class class_name {}</code>语句完成。类的组成：<br>
(1)<code>field</code>（属性，成员，变量）：一堆变量的集合；<br>
(2)<code>method</code>（方法，行为）：由对象调用。<br>
<strong>范例</strong>：定义类</p>
<pre class="highlight"><code class="">package com.java.entity;
public class Book {
   // 定义属性
   public String title;
   public double price;
   // 定义方法
   public void getInfo(){
       System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
   }
}
</code></pre>
<p>2.要使用类，必须要有对象，对象定义的语法有如下两种：<br>
(1)声明并实例化对象：<code>class_name object_name = new class_name()</code>；<br>
(2)分步完成： 第一步-声明对象：<code>class_name object_name = null</code>;<br>
第二部-实例化对象：<code>object_name =new class_name()</code>;<br>
引用数据类型与基本数据类型最大区别是<strong>需要内存的开辟及使用</strong>，所以关键字<code>new</code>的主要功能就是开辟内存空间。<br>
3.当一个对象实例化后，利用如下方式操作类：<br>
(1)<code>object_name.field</code>：操作类中的属性；<br>
(2)<code>object_name.method()</code>：调用类中的方法。<br>
<strong>范例</strong>：使用类</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book book = new Book(); // 声明并实例化对象
        book.title = &quot;Java开发&quot;; // 定义属性
        book.price = 66.6;
        book.getInfo(); // 调用方法
    }
}
</code></pre>
<p>4.堆内存和栈内存的概念：</p>
<table>
<thead>
<tr>
<th>堆内存</th>
<th style="text-align:right">栈内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>保存对象的属性内容，使用关键字new开辟</td>
<td style="text-align:right">栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字</td>
</tr>
</tbody>
</table>
<p><img src="/article/Java/Java Base/Java基础知识(三)/6-1.png" alt="无法加载" title="内存分析"><br>
<strong>范例</strong>：分步使用实例化对象</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book book = null; // 声明对象
        book = new Book(); // 实例化对象
        book.title = &quot;Java开发&quot;;
        book.price = 66.6;
        book.getInfo();
    }
}
</code></pre>
<p><strong>内存分析</strong>：使用关键字<strong>new</strong>开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为<strong>默认值</strong>。<br>
<img src="/article/Java/Java Base/Java基础知识(三)/6-2.png" alt="无法加载" title="内存分析"><br>
使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）”</p>
<h3 id="对象引用分析"><a class="markdownIt-Anchor" href="#对象引用分析"></a> 对象引用分析</h3>
<p>1.在引用分析中，每次使用<code>new</code>关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么<strong>两个对象占据的是不同的堆内存，因此不会互相影响。</strong><br>
<strong>范例</strong>：声明两个对象</p>
<pre class="highlight"><code class="">public class Demo {
   public static void main(String[] args) {
       Book bkA = new Book();
       Book bkB = new Book();
       bkA.title = &quot;Java开发&quot;;
       bkA.price = 66.6;
       bkA.getInfo();
       bkB.title = &quot;C++开发&quot;;
       bkB.price = 22.6;
       bkB.getInfo();
   }
}
</code></pre>
<p><img src="/article/Java/Java Base/Java基础知识(三)/6-3.png" alt="无法加载" title="内存分析"><br>
2. <strong>范例</strong>：对象引用传递</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        Book bkB = null;
        bkA.title = &quot;Java开发&quot;;
        bkA.price = 66.6;
        bkA.getInfo(); // 66.6
        bkB = bkA; // 引用传递
        bkB.price = 90.5;
        bkA.getInfo(); // 90.5
        bkB.getInfo(); // 90.5
    }
}
</code></pre>
<p><img src="/article/Java/Java Base/Java基础知识(三)/6-4.png" alt="无法加载" title="内存分析"><br>
由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。<strong>在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。</strong><br>
3. <strong>范例</strong>：引用传递</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        Book bkB = new Book();
        bkA.title = &quot;Java开发&quot;;
        bkA.price = 66.6;
        bkB.title = &quot;C++开发&quot;;
        bkB.price = 90.5;
        bkB = bkA; // 引用传递
        bkB.price = 100;
        bkA.getInfo(); // 100
        bkB.getInfo(); // 100
    }
}
</code></pre>
<p><img src="/article/Java/Java Base/Java基础知识(三)/6-5.png" alt="无法加载" title="内存分析"><br>
通过内存分析可知，<strong>在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。</strong></p>
<h3 id="封装性"><a class="markdownIt-Anchor" href="#封装性"></a> 封装性</h3>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.title = &quot;Java开发&quot;;
        bkA.price = -66.6;
        bkA.getInfo();
    }
}

</code></pre>
<p>上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为<strong>对象可以在类的外部直接访问属性。</strong><br>
1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。</p>
<pre class="highlight"><code class="">public class Book {
    private String title;
    private double price;
    public void getInfo(){
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性
    }
}
</code></pre>
<p>此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：<strong>类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter()</strong>.<br>
2. 以Book类中的title属性为例，定义setter()/getter()：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">setter()</th>
<th style="text-align:center">getter()</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用</td>
<td style="text-align:center">设置属性值</td>
<td style="text-align:center">取得属性值</td>
</tr>
<tr>
<td>语法</td>
<td style="text-align:center">public void setTitle(String t)</td>
<td style="text-align:center">public void getTitle()</td>
</tr>
<tr>
<td>是否含参</td>
<td style="text-align:center">有参</td>
<td style="text-align:center">无参</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="">package com.java.entity;
public class Book {
    private String title;
    private double price;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public void getInfo(){
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}
</code></pre>
<p>如果要添加如价格不能为负数的功能，应在setter()中添加：</p>
<pre class="highlight"><code class="">public void setPrice(double price) {
    if (price &gt; 0.0){
        this.price = price; 
    }
}
</code></pre>
<p>对于数据的验证，开发中应有其他辅助代码完成，<strong>setter()只是简单地设置数据，getter()只用于返回数据。</strong></p>
<h3 id="构造方法与匿名对象"><a class="markdownIt-Anchor" href="#构造方法与匿名对象"></a> 构造方法与匿名对象</h3>
<blockquote>
<p>定义对象的语法：类名称 对象名称 = new 类名称();<br>
①类名称：定义对象的类型；<br>
②对象名称：标识符，要使用对象，需要有一个对象名；<br>
③new：用于开辟堆内存空间，实例化对象；<br>
④类名称()：一个方法名和类名称一样的方法，这就是构造方法。<br>
通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为<strong>Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。</strong><br>
1.构造方法的定义原则：<strong>方法名称与类名称相同，没有返回值。</strong></p>
</blockquote>
<pre class="highlight"><code class="">class Book {
    public Book() { // 系统自动生成的构造方法
    }
}
</code></pre>
<p>2.构造方法在对象使用new实例化时调用。<br>
<strong>范例</strong>：证明构造方法被调用</p>
<pre class="highlight"><code class="">public class Book {
   public Book() {
       System.out.println(&quot;构造方法被调用&quot;);
   }
}

public class Demo {
   public static void main(String[] args) {
       Book book = null ; // 声明对象
       book = new Book(); // 实例化对象时调用构造方法
       //结果：构造方法被调用
   }
}
</code></pre>
<p>构造方法与普通方法的最大区别：<strong>构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。</strong><br>
3.<strong>范例</strong>：自定义构造方法</p>
<pre class="highlight"><code class="">class Book {
    private String title;
    private double price;
    // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法
    public Book(String t, double p) {
        title = t;
        price = p;
    }

    public void getInfo() {
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book book = new Book(&quot;Java开发&quot;, 66.6);
        book.getInfo();
    }
}
</code></pre>
<p>由上述代码可知构造方法的作用：<code>在类对象实例化时设置属性的初始值，即构造方法用于属性初始化</code>。<br>
4.构造方法也属于方法，因此可以进行重载。<br>
<strong>范例</strong>：构造方法重载</p>
<pre class="highlight"><code class="">class Book {
    public Book() {
        System.out.println(&quot;系统自动生成的构造方法&quot;);
    }
    // 进行方法重载的构造方法
    public Book(String t, double p) {
        System.out.println(&quot;方法重载后的构造方法&quot;);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bookA = new Book(); // 系统自动生成的构造方法
        Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法
    }
}
</code></pre>
<p>重载方法时要求：<strong>按照参数个数，对方法进行升序或者降序排列。</strong><br>
5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：<code>类的加载，内存的分配，默认值的设置，构造方法</code>。</p>
<pre class="highlight"><code class="">class Book {
    private String title = &quot;Java开发&quot;; // 设置默认值
    private double price;

    public Book() {
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        if (price &gt; 0.0){
            this.price = price;
        }
    }

    public void getInfo() {
        System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price);
    }
}

public class Demo {
    public static void main(String[] args) {
        Book bkA = new Book();
        bkA.getInfo(); // 书名：Java开发,价格：0.0
    }
}
</code></pre>
<p>本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。<strong>真实的对象信息都保存在堆内存中。</strong><br>
6.匿名对象：<code>没有栈内存指向的对象，即没有标识符的对象</code>。</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        new Book(&quot;Java开发&quot;,6.6).getInfo();
    }
}
</code></pre>
<p>由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。<br>
<strong>何时使用匿名对象</strong>：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。</p>
<h3 id="简单java类实践"><a class="markdownIt-Anchor" href="#简单java类实践"></a> 简单Java类实践</h3>
<p><strong>题目要求</strong>：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。<br>
<strong>提示</strong>：这种类被称为<code>简单java类</code>，因为这种类不包含过于复杂的程序逻辑。</p>
<blockquote>
<p>对于简单Java类而言，它的要求如下：<br>
·类名必须有意义；<br>
·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法；<br>
·类中可以有多个构造方法，但必须保留无参构造方法；<br>
·类中不允许出现输出语句，信息输出必须交给调用处。<br>
·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。</p>
</blockquote>
<p><strong>第一步：定义类</strong></p>
<pre class="highlight"><code class="">public class Emp {
    private int eId; // 编号
    private String eName; // 姓名
    private String job; // 职位
    private double sal; // 工资
    private double comm; // 佣金
    // 定义构造方法
    public Emp() {
    }
    
    public Emp(int eId, String eName, String job, double sal, double comm) {
        this.eId = eId;
        this.eName = eName;
        this.job = job;
        this.sal = sal;
        this.comm = comm;
    }
    // 定义setter和getter方法
    public int geteId() {
        return eId;
    }

    public void seteId(int eId) {
        this.eId = eId;
    }

    public String geteName() {
        return eName;
    }

    public void seteName(String eName) {
        this.eName = eName;
    }

    public String getJob() {
        return job;
    }

    public void setJob(String job) {
        this.job = job;
    }

    public double getSal() {
        return sal;
    }

    public void setSal(double sal) {
        this.sal = sal;
    }

    public double getComm() {
        return comm;
    }

    public void setComm(double comm) {
        this.comm = comm;
    }
    // 定义普通方法
    public String getInfo() {
        return &quot;编  号&quot; + this.eId + &quot;\n&quot; +
                &quot;姓 名&quot; + this.eName + &quot;\n&quot; +
                &quot;职 位&quot; + this.job + &quot;\n&quot; +
                &quot;工 资&quot; + this.sal + &quot;\n&quot; +
                &quot;佣 金&quot; + this.comm;
    }
}
</code></pre>
<p><strong>第二步：测试</strong></p>
<pre class="highlight"><code class="">public class TEmp {
    public static void main(String[] args) {
        Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0);
        System.out.println(e.getInfo()); // 获取全部信息
        System.out.println(e.geteId()); // 通过getter()获取单一信息
    }
}
</code></pre>
<p>类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kubernetes安装及使用]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Kubernetes%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2>
<p><strong>系统要求</strong>: CentOS 7<br>
<strong>软件版本</strong>: 1.5.2</p>
<h2 id="配置目标"><a class="markdownIt-Anchor" href="#配置目标"></a> 配置目标:</h2>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">master端</th>
<th style="text-align:right">node端</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td style="text-align:center">10.0.0.100</td>
<td style="text-align:right">10.0.0.101</td>
</tr>
<tr>
<td>etcd</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>flannel</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kube-scheduler</td>
<td style="text-align:center">✔</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>kubelet</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>kube-proxy</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>docker</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
</tr>
</tbody>
</table>
<h2 id="共同配置即master和node都需要进行的操作"><a class="markdownIt-Anchor" href="#共同配置即master和node都需要进行的操作"></a> 共同配置（即master和node都需要进行的操作）</h2>
<p>(1)修改/etc/hosts文件，添加master和node节点IP</p>
<pre class="highlight"><code class="">$ echo &quot;10.0.0.100 centos-master
  10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts
$ cat /etc/hosts
  10.0.0.100 centos-master
  10.0.0.101 centos-minion
</code></pre>
<p>(2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services</p>
<pre class="highlight"><code class=""># 关闭fierwalld
$ systemctl stop firewalld
$ systemctl disable firewalld

# 安装iptables，启动该服务并设置开机自启动
$ yum install iptables
$ systemctl start iptables
$ systemctl enable iptables

# 关闭iptables-services
$ systemctl disable iptables-services 
$ systemctl stop iptables-services 

# 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot;
# 解决方法：修改SElinux配置
$ vi /etc/selinux/config
  # SELINUX=enforcing    #注释掉
  # SELINUXTYPE=targeted #注释掉
    SELINUX=disabled #增加
  :wq! #保存退出
$ setenforce 0 #使配置立即生效
</code></pre>
<p>(3)安装</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Hub Mysql官方镜像实现首次启动后初始化库表]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Docker%20Hub%20mysql%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%AE%9E%E7%8E%B0%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%93%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>在Docker Hub中查看MySQL官方镜像的Dockerfile:</p>
<pre class="highlight"><code class="">
COPY docker-entrypoint.sh /usr/local/bin/

RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat

ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]
</code></pre>
<p>镜像启动时，会运行<code>entrypoint.sh</code>脚本，该脚本的shell命令中:</p>
<pre class="highlight"><code class="">echo
    for f in /docker-entrypoint-initdb.d/*; do
		case &quot;$f&quot; in
			*.sh)     echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;;
			*.sql)    echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;;
			*.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;;
			*)        echo &quot;$0: ignoring $f&quot; ;;
		esac
		echo
done
</code></pre>
<p>上述shell命令会遍历<code>/docker-entrypoint-initdb.d/</code>文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。</p>
<h2 id="实现首次启动后初始化库表"><a class="markdownIt-Anchor" href="#实现首次启动后初始化库表"></a> 实现首次启动后初始化库表</h2>
<h3 id="创建mysql_data文件夹将datasql放入"><a class="markdownIt-Anchor" href="#创建mysql_data文件夹将datasql放入"></a> 创建mysql_data文件夹，将data.sql放入：</h3>
<pre class="highlight"><code class="data.sql">-- 创建数据库 
DROP database IF EXISTS `docker_database`;
create database `docker_database` default character set utf8 collate utf8_general_ci; 
-- 切换到test_data数据库
use docker_database; 
-- 建表 
DROP TABLE IF EXISTS `person`; 

CREATE TABLE `person` ( 
	`id` bigint(20) NOT NULL, 
	`name` varchar(255) DEFAULT NULL, 
	`age` bigint(20) NOT NULL,
	PRIMARY KEY (`id`) 
) ENGINE=InnoDB DEFAULT CHARSET=latin1; 
-- 插入数据 
INSERT INTO `user` (`id`,`name`,`age` ) 
VALUES 
   (0,'Tom',18);
</code></pre>
<h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3>
<pre><code>$ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456  mysql 
</code></pre>
<h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3>
<pre><code>$ docker exec -it sql /bin/bash
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u root -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);
Query OK, 1 row affected (0.06 sec)
mysql&gt; select * from person;                                
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
|  1 | Jane |   17 |
+----+------+------+
2 rows in set (0.00 sec)
</code></pre>
<p>重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。</p>
<h2 id="指定sql文件运行顺序"><a class="markdownIt-Anchor" href="#指定sql文件运行顺序"></a> 指定sql文件运行顺序</h2>
<p><code>entrypoint.sh</code>脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法：</p>
<ol>
<li>将文件按照预期顺序，进行命名，比如1_xx,2_xx;</li>
<li>将必须有前后顺序的sql文件合并在一个sql文件中;</li>
<li>将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。<br>
假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh</li>
</ol>
<pre class="highlight"><code class="data.sh">#!/bin/bash
mysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOF
source /usr/local/work/database.sql;
source /usr/local/work/table.sql;
source /usr/local/work/data.sql; 
</code></pre>
<p>启动容器：</p>
<pre><code>$ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql
</code></pre>
<p>数据结果应与上述一致。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker实现mysql容器启动后自动建库]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E5%AE%9E%E7%8E%B0mysql%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BB%BA%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>通过Dockerfile创建一个mysql镜像,该镜像具有如下功能：</p>
<blockquote>
<p>mysql容器启动时，会自动执行指定的sql文件;<br>
每次启动该容器，数据都进行初始化，删除所有的修改。</p>
</blockquote>
<h2 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h2>
<h3 id="创建dockerfile"><a class="markdownIt-Anchor" href="#创建dockerfile"></a> 创建Dockerfile</h3>
<pre><code>$ vim Dockerfile
</code></pre>
<pre class="highlight"><code class=""># 指定基础镜像，选用docker官方最新mysql镜像
FROM docker.io/mysql:latest

# 环境变量设置，设置mysql登陆时不需密码
ENV MYSQL_ALLOW_EMPTY_PASSWORD yes

# 复制文件到容器中，要复制的文件有：启动脚本和sql文件
COPY setup.sh /mysql/setup.sh
COPY data.sql /mysql/data.sql
COPY privileges.sql /mysql/privileges.sql

# 容器启动命令启动脚本
CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;]
</code></pre>
<h3 id="创建privilegessql用于修改mysql权限"><a class="markdownIt-Anchor" href="#创建privilegessql用于修改mysql权限"></a> 创建privileges.sql用于修改mysql权限</h3>
<pre><code>$vim privileges.sql
</code></pre>
<pre class="highlight"><code class="">use mysql; 

select host, user from user; 

-- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456：
-- 如果用户docker不存在，则创建用户docker
grant all on docker_database.* to docker@'%' identified by '123456' with grant option; 

-- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： 
flush privileges;
</code></pre>
<h3 id="创建datasql导入数据"><a class="markdownIt-Anchor" href="#创建datasql导入数据"></a> 创建data.sql导入数据</h3>
<pre><code>$ vim data.sql
</code></pre>
<pre class="highlight"><code class="">-- 创建数据库 
DROP database IF EXISTS `docker_database`;
create database `docker_database` default character set utf8 collate utf8_general_ci; 
-- 切换到test_data数据库
use docker_database; 
-- 建表 
DROP TABLE IF EXISTS `person`; 

CREATE TABLE `person` ( 
	`id` bigint(20) NOT NULL, 
	`name` varchar(255) DEFAULT NULL, 
	`age` bigint(20) NOT NULL,
	PRIMARY KEY (`id`) 
) ENGINE=InnoDB DEFAULT CHARSET=latin1; 
-- 插入数据 
INSERT INTO `user` (`id`,`name`,`age` ) 
VALUES 
   (0,'Tom',18);
</code></pre>
<h3 id="创建容器启动脚本setupsh"><a class="markdownIt-Anchor" href="#创建容器启动脚本setupsh"></a> 创建容器启动脚本<code>setup.sh</code></h3>
<pre><code>$ vim setup.sh
</code></pre>
<pre class="highlight"><code class=""># !/bin/bash 
set -e 

# 查看mysql服务的状态，方便调试
echo `service mysql status` 

echo '1.启动mysql' 
# 启动mysql 
service mysql start 
# 使进程休眠
sleep 3 
echo `service mysql status` 

echo '2.开始导入数据' 
#导入sql文件
mysql &lt; /mysql/data.sql 
echo '3.导入数据完毕....' 

sleep 3 
echo `service mysql status` 

# 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 
echo '4.开始修改密码....' 
# 导入修改mysql权限设置的文件
mysql &lt; /mysql/privileges.sql 
echo '5.修改密码完毕....' 

#sleep 3 
echo `service mysql status` 
echo 'mysql容器启动完毕,且数据导入成功' 
</code></pre>
<h3 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h3>
<p>创建镜像并命名为mysql:9.29</p>
<pre><code>$ docker build -t mysql:9.29 .
</code></pre>
<h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2>
<h3 id="启动mysql929镜像生成容器"><a class="markdownIt-Anchor" href="#启动mysql929镜像生成容器"></a> 启动mysql:9.29镜像，生成容器</h3>
<pre><code>$ docker run --name sql -d -p 23306:3306 mysql:9.29
6da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41
</code></pre>
<h3 id="查看容器日志"><a class="markdownIt-Anchor" href="#查看容器日志"></a> 查看容器日志</h3>
<pre><code>$ docker log sql
</code></pre>
<pre class="highlight"><code class="">1.启动mysql....
2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=45790
2017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903.
2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.
2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode.
2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode.
..
MySQL Community Server 5.7.19 is started.
MySQL Community Server 5.7.19 is running.
2.开始导入数据....
3.导入数据完毕....
MySQL Community Server 5.7.19 is running.
4.开始修改密码....
host	user
localhost	mysql.session
localhost	mysql.sys
localhost	root
5.修改密码完毕....
MySQL Community Server 5.7.19 is running.
mysql容器启动完毕,且数据导入成功
</code></pre>
<p>容器启动过程与setup.sh中编写的步骤完全一致。</p>
<h3 id="进入容器进行验证"><a class="markdownIt-Anchor" href="#进入容器进行验证"></a> 进入容器进行验证</h3>
<pre><code>$ docker exec -it sql /bin/bash 
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="验证重启mysql容器数据库初始化"><a class="markdownIt-Anchor" href="#验证重启mysql容器数据库初始化"></a> 验证重启mysql容器，数据库初始化</h3>
<p>插入数据</p>
<pre><code>mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17);
Query OK, 1 row affected (0.06 sec)
</code></pre>
<pre class="highlight"><code class="">mysql&gt; select * from person;                                
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
|  1 | Jane |   17 |
+----+------+------+
2 rows in set (0.00 sec)
</code></pre>
<p>重新启动容器</p>
<pre><code>$ docker stop sql
$ docker start sql
$ docker exec -it sql /bin/bash 
</code></pre>
<pre class="highlight"><code class="">root@6da21b87a0a5:/# mysql -u docker -p 
Enter password:
mysql&gt; use docker_database;
mysql&gt; show tables;
+---------------------------+
| Tables_in_docker_database |
+---------------------------+
| person                    |
+---------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from person;
+----+------+------+
| id | name | age  |
+----+------+------+
|  0 | Tom  |   18 |
+----+------+------+
1 row in set (0.00 sec)
</code></pre>
<p>重启容器后，数据初始化。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用TestNG进行单元测试]]></title>
      <url>/article/%E6%B5%8B%E8%AF%95/Test/%E5%88%A9%E7%94%A8TestNG%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="testng简介"><a class="markdownIt-Anchor" href="#testng简介"></a> TestNG简介</h2>
<p>TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。</p>
<h2 id="annotation"><a class="markdownIt-Anchor" href="#annotation"></a> Annotation</h2>
<table>
<thead>
<tr>
<th>Annotation</th>
<th style="text-align:right">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@BeforeSuite</code></td>
<td style="text-align:right">被注释的方法将在所有测试运行前运行</td>
</tr>
<tr>
<td><code>@AfterSuite</code></td>
<td style="text-align:right">被注释的方法将在所有测试运行后运行</td>
</tr>
<tr>
<td><code>@BeforeTest</code></td>
<td style="text-align:right">被注释的方法将在测试运行前运行</td>
</tr>
<tr>
<td><code>@AfterTest</code></td>
<td style="text-align:right">被注释的方法将在测试运行后运行</td>
</tr>
<tr>
<td><code>@BeforeGroups</code></td>
<td style="text-align:right">被注释的方法将在gourp中方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterGroups</code></td>
<td style="text-align:right">被注释的方法将在gourp中方法运行后运行</td>
</tr>
<tr>
<td><code>@BeforeClass</code></td>
<td style="text-align:right">被注释的方法将在当前类的第一个方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterClass</code></td>
<td style="text-align:right">被注释的方法将在当前类的所有方法运行后运行</td>
</tr>
<tr>
<td><code>@BeforeMethod</code></td>
<td style="text-align:right">被注释的方法将在每一个方法运行前运行</td>
</tr>
<tr>
<td><code>@AfterMethod</code></td>
<td style="text-align:right">被注释的方法将在每一个方法运行后运行</td>
</tr>
<tr>
<td><code>@DataProvider</code></td>
<td style="text-align:right">被注释的方法用于为其他方法提供数据</td>
</tr>
<tr>
<td><code>@Factory</code></td>
<td style="text-align:right">被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[]</td>
</tr>
<tr>
<td><code>@Par##ameters</code></td>
<td style="text-align:right">传递参数给测试方法</td>
</tr>
</tbody>
</table>
<h3 id="使用testng进行单元测试"><a class="markdownIt-Anchor" href="#使用testng进行单元测试"></a> 使用TestNG进行单元测试</h3>
<pre class="highlight"><code class="">@Test()  // Test中所有方法变为测试方法
public class Test {

	@Test(enable = false)  // 该注释后，test1()测试时被忽略，相当于普通方法
	public void test1(){}
    
    @BeforeTest()          // 该注释后，test3(),test4()执行前，test2()先执行
	public void test2(){}

    @
	public void test3(){}

	public void test4(){}
}
</code></pre>
<h3 id="测试中的一些小问题"><a class="markdownIt-Anchor" href="#测试中的一些小问题"></a> 测试中的一些小问题</h3>
<p>1、匿名JSON节点验证：</p>
<pre class="highlight"><code class="">[
	{
		&quot;name&quot;:&quot;Tom&quot;,
		&quot;age&quot;:12
	},
	{
		&quot;name&quot;:&quot;Jane&quot;,
		&quot;age&quot;:18
	}
]
</code></pre>
<p>对于上述JSON的验证代码如下：</p>
<pre class="highlight"><code class="">public void method_name() {
    given().
            header(&quot;Authorization&quot;, &quot;token &quot; + Config.getToken()).
    when().
            get(url).
    then().
            statusCode(200).
            body(&quot;[0].name&quot;, equalTo(&quot;正常&quot;)).
            body(&quot;[0].age&quot;, greaterThanOrEqualTo(0));
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TestNG </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git使用(Linux)]]></title>
      <url>/article/%E5%B7%A5%E5%85%B7/Tool/Git%E4%BD%BF%E7%94%A8(Linux)/</url>
      <content type="html"><![CDATA[<h2 id="环境安装"><a class="markdownIt-Anchor" href="#环境安装"></a> 环境安装</h2>
<p>安装git</p>
<pre class="highlight"><code class="">sudo apt-get install git
</code></pre>
<p>配置git用户名</p>
<pre class="highlight"><code class="">git config –global user.name &quot;user_name&quot;
</code></pre>
<p>配置用户邮箱地址</p>
<pre class="highlight"><code class="">git config –global user.email &quot;user_mail&quot;
</code></pre>
<h2 id="创建本地仓库"><a class="markdownIt-Anchor" href="#创建本地仓库"></a> 创建本地仓库</h2>
<p>创建空目录</p>
<pre class="highlight"><code class="">mkdir folder_name
</code></pre>
<p>进入空目录</p>
<pre class="highlight"><code class="">cd folder_name
</code></pre>
<p>显示当前目录</p>
<pre class="highlight"><code class="">pwd
</code></pre>
<p>把当前目录变为Git仓库</p>
<pre class="highlight"><code class="">git init
</code></pre>
<p>把文件添加到Git仓库</p>
<pre class="highlight"><code class="">git add file
</code></pre>
<p>把文件提交到Git仓库</p>
<pre class="highlight"><code class="">git commit -m &quot;commit_message&quot;
</code></pre>
<h2 id="版本库操作"><a class="markdownIt-Anchor" href="#版本库操作"></a> 版本库操作</h2>
<p>查看修改内容</p>
<pre class="highlight"><code class="">git diff file_name
</code></pre>
<p>查看工作区状态</p>
<pre class="highlight"><code class="">git status
</code></pre>
<p>查看历史记录</p>
<pre class="highlight"><code class="">git log
</code></pre>
<p>查看精简历史记录</p>
<pre class="highlight"><code class="">git log --pretty=oneline
</code></pre>
<p>回退到上一个版本</p>
<pre class="highlight"><code class="">git reset --hard HEAD^
</code></pre>
<p>回到某个指定版本</p>
<pre class="highlight"><code class="">git reset –-hard commit-id(git log查看)
</code></pre>
<p>查看命令记录</p>
<pre class="highlight"><code class="">git reflog
</code></pre>
<p>撤销全部工作区修改</p>
<pre class="highlight"><code class="">git checkout --file
</code></pre>
<p>将暂存区修改撤销放回工作区</p>
<pre class="highlight"><code class="">git reset HEAD 文件
</code></pre>
<p>linux删除文件</p>
<pre class="highlight"><code class="">rm file
</code></pre>
<p>git库删除文件</p>
<pre class="highlight"><code class="">git rm file
</code></pre>
<p>下载他人项目</p>
<pre class="highlight"><code class="">git clone https://github.com/xxx/xxx.git new_git_name
</code></pre>
<h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2>
<p>创建并切换到分支</p>
<pre class="highlight"><code class="">git checkout -b dev_name
</code></pre>
<p>查看当前分支</p>
<pre class="highlight"><code class="">git branch (*表示当前分支)
</code></pre>
<p>切换分支</p>
<pre class="highlight"><code class="">git checkout dev_name
</code></pre>
<p>合并指定分支到当前分支(fast forward 模式)</p>
<pre class="highlight"><code class="">git merge dev_name
</code></pre>
<p>删除分支</p>
<pre class="highlight"><code class="">git branch -d dev_name
</code></pre>
<p>合并分支时冲突,修改文件后,再提交<br>
查看分支合并图</p>
<pre class="highlight"><code class="">git log --graph --pretty=oneline --addrev-commit
</code></pre>
<p>合并分支（普通模式）</p>
<pre class="highlight"><code class="">git merge -- no-ff -m &quot;commit_message&quot; dev
</code></pre>
<h2 id="多人合作"><a class="markdownIt-Anchor" href="#多人合作"></a> 多人合作</h2>
<p>查看远程库信息</p>
<pre class="highlight"><code class="">git remote -v
</code></pre>
<p>推送主分支</p>
<pre class="highlight"><code class="">git push origin master
</code></pre>
<p>推送其他分支</p>
<pre class="highlight"><code class="">git push origin dev_name
</code></pre>
<p>创建本地分支</p>
<pre class="highlight"><code class="">git checkout -b dev_name origin/dev_name
</code></pre>
<p>指定本地分支与远程分支的链接</p>
<pre class="highlight"><code class="">git branch --set-upstream-to=origin/dev_name
</code></pre>
<p>获取远程库内容</p>
<pre class="highlight"><code class="">git pull  
</code></pre>
<p>解决冲突后commit，再上传</p>
<pre class="highlight"><code class="">git push origin dev_name
</code></pre>
<h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2>
<p>创建标签</p>
<pre class="highlight"><code class="">git tag tag_name
</code></pre>
<p>给指定提交打标签</p>
<pre class="highlight"><code class="">git tag tag_name commit-id
</code></pre>
<p>创建带说明的标签</p>
<pre class="highlight"><code class="">git tag -a tag_name -m &quot;message&quot; commit-id
</code></pre>
<p>查看标签说明</p>
<pre class="highlight"><code class="">git show tag_name
</code></pre>
<p>删除标签</p>
<pre class="highlight"><code class="">git tag -d tag_name
</code></pre>
<p>推送标签</p>
<pre class="highlight"><code class="">git push origin tag_name
</code></pre>
<p>一次性推送所有标签</p>
<pre class="highlight"><code class="">git push origin --tags
</code></pre>
<p>删除标签（本地）</p>
<pre class="highlight"><code class="">git tag -d tag_name
</code></pre>
<p>删除远程标签</p>
<pre class="highlight"><code class="">git push origin :refs/tags/tag_name
</code></pre>
<h2 id="自定义git"><a class="markdownIt-Anchor" href="#自定义git"></a> 自定义Git</h2>
<p>使git显示不同颜色</p>
<pre class="highlight"><code class="">git config --global color.ui true
</code></pre>
<p>忽略某些文件时，需要编写.gitignore	<br>
强制添加被忽略文件</p>
<pre class="highlight"><code class="">git add -f file
</code></pre>
<p>检查某个文件符合被忽略要求</p>
<pre class="highlight"><code class="">git check-ignore -v file
</code></pre>
<p>配置命令别名</p>
<pre class="highlight"><code class="">git config --global alias.别名 命令
</code></pre>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的安装说明]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h2 id="安装及部署docker"><a class="markdownIt-Anchor" href="#安装及部署docker"></a> 安装及部署Docker</h2>
<h3 id="系统和资源说明"><a class="markdownIt-Anchor" href="#系统和资源说明"></a> 系统和资源说明</h3>
<p>Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。<br>
资源需求：Docker1.12.6</p>
<h3 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h3>
<p>(1)安装</p>
<pre><code>$ yum install docker
</code></pre>
<p>(2)设置开机启动Docker Daemon进程</p>
<pre><code>$ systemctl start docker.service   // 启动docker
$ systemctl enable docker.service  // 设置Docker开机自启动
$ systemctl disable firewalld      // 关闭防火墙
$ yum -y install iptables-services // 安装iptable服务
$ systemctl start iptables.service   // 启动iptable
$ systemctl enable iptables.service  // 设置iptable开机自启动
</code></pre>
<p>(3)安装成功的Docker</p>
<pre><code>$ docker version
</code></pre>
<img src="/article/容器/Docker/Docker的安装说明/success.png" alt="Docker安装成功">  
<p>(4)建立docker用户组，将使用docker的用户加入docker用户组。</p>
<pre><code>$ groupadd docker
$ usermod -aG docker $USER
</code></pre>
<h3 id="docker的代理配置"><a class="markdownIt-Anchor" href="#docker的代理配置"></a> Docker的代理配置</h3>
<pre><code>$ vim /usr/lib/systemd/system/docker.service
[Service]
Environment=”HTTP_PROXY=http://192.168.13.19:7777”
Environment=”HTTPS_PROXY=http://192.168.13.19:7777”
Type=notify
</code></pre>
<h3 id="docker配置加速器"><a class="markdownIt-Anchor" href="#docker配置加速器"></a> Docker配置加速器</h3>
<p>国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了<a href="https://cr.console.aliyun.com">阿里云加速器</a> 注册用户并且申请加速器后，会获得　<a href="https://xxx.mirror.aliyuncs.com">https://xxx.mirror.aliyuncs.com</a> 这样的地址。<br>
<img src="/article/容器/Docker/Docker的安装说明/dockerhub.png" alt="Docker加速器"></p>
<pre><code>$ vim /usr/lib/systemd/system/docker.service
  ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com
$ systemctl daemon-reload  //　重新加载配置
$ systemctl restart docker //　重启docker
</code></pre>
<h3 id="docker配置文件说明"><a class="markdownIt-Anchor" href="#docker配置文件说明"></a> Docker配置文件说明</h3>
<pre><code>$ vim /etc/sysconfig/docker
OPTIONS='
 --selinux-enabled  //　是否开启selinux，默认开启
 --insecure registry ip:port // 添加私人仓库地址
 --bip=ip // 表示网桥docker0的CIDR地址
'
</code></pre>
<h2 id="docker的常用命令"><a class="markdownIt-Anchor" href="#docker的常用命令"></a> Docker的常用命令</h2>
<h3 id="docker信息查看"><a class="markdownIt-Anchor" href="#docker信息查看"></a> Docker信息查看</h3>
<p>(1)查看docker进程状态</p>
<pre><code>$ systemctl status docker
</code></pre>
<p>(2)查看docker的具体信息</p>
<pre><code>$ docker info
</code></pre>
<p>(3)查看docker的版本信息</p>
<pre><code>$ docker version
</code></pre>
<h3 id="docker的镜像操作"><a class="markdownIt-Anchor" href="#docker的镜像操作"></a> Docker的镜像操作</h3>
<p>(1)查找镜像</p>
<pre><code>$ docker search image_name
</code></pre>
<p>(2)拉取镜像</p>
<pre><code>$ docker pull image_name:tag
</code></pre>
<p>(3)列出本地镜像</p>
<pre><code>$ docker images
</code></pre>
<p>列表参数说明</p>
<blockquote>
<p>Repository：镜像的仓库源<br>
Tag：镜像的标签<br>
Image ID： 镜像ID<br>
Created： 镜像的创建时间<br>
Size： 镜像大小</p>
</blockquote>
<p>(4)设置镜像标签</p>
<pre><code>$ docker tag image_id tag
</code></pre>
<p>(5)利用镜像创建容器</p>
<pre><code>$ docker run image_name:tag command
</code></pre>
<p>(6)提交镜像</p>
<pre><code>$ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name
</code></pre>
<h3 id="docker的容器操作"><a class="markdownIt-Anchor" href="#docker的容器操作"></a> Docker的容器操作</h3>
<p>(1)启动容器</p>
<pre><code>$ docker run option host_port:contaniner_port image_name:tag command
</code></pre>
<blockquote>
<p>例如：docker run -it -d -p 5000:5000 java java -version<br>
-d：后台运行容器<br>
-p:将容器端口映射到宿主机端口<br>
-it:进行交互式操作<br>
command: 执行java -version命令</p>
</blockquote>
<p>(2)查看容器</p>
<pre><code>$ docker ps // 查看正在运行的容器
</code></pre>
<p>(3)容器生命周期命令</p>
<pre><code>$ docker create image:tag  // 创建容器但不启动
$ docker start container_name   // 启动容器
$ docker stop contaniner_name   // 停止容器
$ docker restart container_name // 重启容器
$ docker pause contaniner_name  // 暂停容器内所有进程
$ docker unpause contaniner_name // 恢复容器内所有进程
$ docker rm contaniner  // 删除容器
$ docker rm ${docker ps -a -q} // 删除所有停止的容器</code></pre>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的简单说明]]></title>
      <url>/article/%E5%AE%B9%E5%99%A8/Docker/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h2 id="docker简介"><a class="markdownIt-Anchor" href="#docker简介"></a> Docker简介</h2>
<h3 id="docker的概念"><a class="markdownIt-Anchor" href="#docker的概念"></a> Docker的概念</h3>
<p><code>Docker</code>最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。<code>Docker</code>被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将<code>应用软件及其依赖软件</code>（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。</p>
<h3 id="dcoker的技术依赖"><a class="markdownIt-Anchor" href="#dcoker的技术依赖"></a> Dcoker的技术依赖</h3>
<p>Docker使用<code>Go</code>语言进行开发实现，基于Linux内核的<code>cgroup</code>、<code>namespace</code>以及AUFS类的<code>UnionFS</code>等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于<code>LXC</code>、0.7后去除LXC，使用自行开发的<code>libcontainer</code>。从1.11开始，则使用<code>runC</code>和<code>containerd</code>。</p>
<blockquote>
<p>（1）<code>cgroup</code>是将任意进程进行分组化管理的Linux内核功能。重要概念是<code>子系统</code>，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。<br>
（2）<code>LXC</code>（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于<code>namespace</code>的隔离机制和<code>cgroup</code>限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。<br>
（3）<code>AUFS</code>是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。<br>
（4）<code>App打包</code>：Docker额外提供的Feature,标准统一的打包部署运行方案。</p>
</blockquote>
<h3 id="docker的优势"><a class="markdownIt-Anchor" href="#docker的优势"></a> Docker的优势</h3>
<p>Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：<code>传统虚拟机技术</code>是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而<code>容器</code>内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。</p>
<blockquote>
<p><strong>（1）更高效的利用系统资源</strong><br>
由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。<br>
<strong>（2）更快速的启动</strong><br>
Docker容器应用由于<code>直接运行于宿主内核</code>，无需启动完整的操作系统，因此可以做到<code>秒级</code>，甚至<code>毫秒级</code>的启动，大大节约了开发、测试、部署的时间。<br>
<strong>（3）一致的运行环境</strong><br>
Docker镜像提供了<code>除内核外完整的运行时环境</code>，确保了应用运行环境的一致性。<br>
<strong>（4）持续交付和部署</strong><br>
Docker可以通过<code>定制应用镜像</code>实现持续集成、持续交付、部署。开发人员可以通过<code>Dockerfile</code>来创建镜像，并结合<code>持续集成（Continuous integration）系统</code>进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合<code>持续部署（Continuous Delivery/Deployment）系统</code>进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。<br>
<strong>（5）更轻松的迁移</strong><br>
由于Docker确保了运行环境的一致性，使得应用迁移更加容易。<br>
<strong>（6）更轻松的维护和扩展</strong><br>
Docker使用的<code>分层存储以及镜像技术</code>，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易.</p>
</blockquote>
<h2 id="docker相关的基础概念"><a class="markdownIt-Anchor" href="#docker相关的基础概念"></a> Docker相关的基础概念</h2>
<h3 id="docker-image"><a class="markdownIt-Anchor" href="#docker-image"></a> Docker Image</h3>
<p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。<code>Docker镜像（Image）</code>就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的<code>程序、库、资源、配置等文件</code>外，还包含一些为运行时准备的<code>配置参数</code>（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。</p>
<h3 id="分层存储"><a class="markdownIt-Anchor" href="#分层存储"></a> 分层存储</h3>
<blockquote>
<p>因为传统镜像包含操作系统<code>完整的root文件系统</code>，其体积往往庞大。因此在Docker设计时，就充分利用<code>Union FS</code>技术，将其设计为<code>分层存储</code>的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。</p>
</blockquote>
<p>镜像构建时，会<code>一层层构建</code>，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，<code>任何额外的东西应在该层构建结束前清理结束</code>。<br>
分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。</p>
<h3 id="docker-container"><a class="markdownIt-Anchor" href="#docker-container"></a> Docker Container</h3>
<p><code>镜像（Image）</code>是静态定义，<code>容器（Container）</code>是镜像运行时的实体。容器可以被创建、启动、停止等。<br>
容器的实质是<code>进程</code>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。<br>
容器也是<code>分层存储</code>的，每个容器运行时<code>以镜像为基础层</code>，在其上创建一个当前容器的<code>存储层</code>，我们可以称这个为容器运行时读写而准备的存储层为<code>容器存储层</code>。<br>
容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。</p>
<blockquote>
<p>按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。</p>
</blockquote>
<h3 id="docker-registry"><a class="markdownIt-Anchor" href="#docker-registry"></a> Docker Registry</h3>
<p>镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即<code>Docker Registry</code>。<br>
一个<code>Docker Registry</code>包含多个<code>仓库（Repository）</code>；每个仓库包含多个标签<code>Tag</code>；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>来获取指定版本的镜像，如果不给出标签，就将以<code>latest</code>为默认标签。<br>
<code>Docker Registry公开服务</code>是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的<code>Docker Hub</code>。<br>
除了公开服务外，用户还可以在本地搭建<code>私有的Docker Registry</code>。Docker官方提供<code>Docker Registry</code>镜像，可以直接使用作为私有Registry服务。</p>
]]></content>
      
        <categories>
            
            <category> 容器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(二)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<blockquote>
<p>常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。</p>
</blockquote>
<h3 id="基本运算符"><a class="markdownIt-Anchor" href="#基本运算符"></a> 基本运算符</h3>
<ol>
<li><code>=</code>为赋值运算符。</li>
<li>四则运算符基本组成：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。<strong>不要使用运算符编写过于复杂的计算。</strong></li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        double numB = 20;
        int numC = 3;
        System.out.println(&quot;加法计算：&quot; + (numA + numB));
        System.out.println(&quot;减法计算：&quot; + (numA - numB));
        System.out.println(&quot;乘法计算：&quot; + (numA * numB));
        System.out.println(&quot;除法计算：&quot; + (numA / numB));
        System.out.println(&quot;求模计算：&quot; + (numA % numC));
    }
}
</code></pre>
<ol start="3">
<li>简化运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>:</li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        numA += 2; // 等同于 numA = numA + 2
        System.out.println(&quot;加法计算&quot; + (numA)); // 12
    }
}
</code></pre>
<ol start="4">
<li><code>++</code>（自增），<code>--</code>（自减）：位置不同，功能也不同：<br>
·<code>++变量</code>，<code>--变量</code>：先对变量加/减1，再使用自增或自减后的变量进行计算;<br>
·<code>变量++</code>，<code>变量--</code>：先使用变量进行计算，再进行变量加/减1。</li>
</ol>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        int numB = 20;
        // ++变量，先numA + 1
        // 然后(numA + 1) + numB内容
        // 最后对numB加1
        int result = (++numA) + (numB++);
        System.out.println(&quot;numA=&quot; + numA); // 11
        System.out.println(&quot;numB=&quot; + numB); // 21
        System.out.println(&quot;result=&quot; + result); // 31
    }
}
</code></pre>
<h3 id="三目运算符"><a class="markdownIt-Anchor" href="#三目运算符"></a> 三目运算符</h3>
<p>三目运算符根据布尔表达式的结果进行赋值：</p>
<pre><code>value_type value_name = 布尔表达式 ? true_value : false_value;
</code></pre>
<p>利用三目运算符可以减少判断代码:</p>
<pre class="highlight"><code class="">public class Demo {
    public static void main(String[] args) {
        int numA = 10;
        int numB = 20;
        int max = 0;
        /** 使用三目运算符
         *  当numA大于numB,返回true,max = numA
         *  当numA小于numB,返回false,max = numB
         */
        max = numA&gt;numB ? numA : numB;
        // 不使用三目运算符
        // if (numA &gt; numB) {
        //    max = numA;
        //} else {
        //    max = numB;
        //}
        System.out.println(max);
    }
}
</code></pre>
<h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3>
<ol>
<li>逻辑运算符：与<code>&amp;，&amp;&amp;</code>、或<code>|，||</code>、非<code>!</code></li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        boolean flag = true;
        System.out.println(!flag); // false
    }
}
</code></pre>
<ol start="2">
<li>布尔表达式的连接，只能使用<code>与</code>和<code>或</code>操作</li>
</ol>
<blockquote>
<p><code>与</code>：所有条件都为true时，结果为true;有一个为false，结果就是false.</p>
</blockquote>
<p><strong>范例</strong>：普通与<code>&amp;</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 除数不能为0
        if ((1 == 2) &amp; (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // 报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>：程序报错，因为<code>&amp;</code>会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。<br>
<strong>范例</strong>：短路与<code>&amp;&amp;</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 除数不能为0
        if ((1 == 2) &amp;&amp; (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // false,不报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>:程序不报错，因为<code>&amp;&amp;</code>只要有一个条件为false后，后续判断就不再进行，从而提高了效率。</p>
<blockquote>
<p>或操作：一个条件为true，结果为true。</p>
</blockquote>
<p><strong>范例</strong>：普通或<code>|</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        if ((1 &lt; 2 ) | (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // 报错
        }
    }
}
</code></pre>
<p><strong>结果</strong>：使用<code>|</code>，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。<br>
<strong>范例</strong>：短路或<code>||</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        if ((1 &lt; 2 ) || (10 / 0 == 0)){
            System.out.println(&quot;Hello&quot;); // true,不报错
        }
    }
}
</code></pre>
<blockquote>
<p>因此使用逻辑运算时就使用<code>&amp;&amp;</code>和<code>||</code>。</p>
</blockquote>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<ol>
<li>数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。</li>
<li>位运算主要是进行二进制数据操作，位运算符：<code>&amp;</code>、<code>|</code>、<code>&gt;&gt;</code>(移位)、<code>&lt;&lt;</code>、<code>^</code>(反码)、<code>~</code>。<br>
<strong>范例</strong>：位与<code>&amp;</code></li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 9;
        int numB = 11;
        System.out.println(numA &amp; numB); // 9
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>  1001 → 9
&amp; 1011 → 11
  1001 →  9
</code></pre>
<p><strong>范例</strong>：位或<code>|</code></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 9;
        int numB = 11;
        System.out.println(numA | numB); // 11
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>  1001 → 9
| 1011 → 11
  1011 → 11
</code></pre>
<p><strong>范例</strong>：移位（最快方式计算2的3次方）</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int num = 2;
        num = num &lt;&lt; 2; // 向左移位
        System.out.println(num); // 8,相当于2的3次方
    }
}
</code></pre>
<p><strong>运算过程</strong>：</p>
<pre><code>    0010 → 2
2&lt;&lt; 1000 → 8
</code></pre>
<blockquote>
<p><strong>章节小问题：请解释<code>&amp;</code>与<code>&amp;&amp;</code>的区别，以及<code>|</code>与<code>||</code>的区别:</strong><br>
1. 在逻辑运算中：<br>
  |- <code>&amp;</code>和<code>|</code>会对所有条件进行判断后，返回结果<br>
  |- <code>&amp;&amp;</code>只要一个条件返回false，就不进行后续判断，结果为false<br>
  |- <code>||</code>只要一个条件为true，就不进行后续判断，结果为true<br>
2. 在位运算中：<br>
  |- <code>&amp;</code>为位与元算，<code>|</code>为位或元算<br>
  |- <code>&amp;&amp;</code>和<code>||</code>不能用于位运算</p>
</blockquote>
<h2 id="java程序逻辑控制"><a class="markdownIt-Anchor" href="#java程序逻辑控制"></a> Java程序逻辑控制</h2>
<p>程序逻辑结构主要分为三种：顺序结构、分支结构、循环结构。顺序结构执行顺序是从前到后，但有时是以代码所在的{}为界限。</p>
<h3 id="分支结构"><a class="markdownIt-Anchor" href="#分支结构"></a> 分支结构</h3>
<ol>
<li>分支结构即判断结构，有两种语法：if和switch.</li>
<li>if语句:<br>
if语句的格式:</li>
</ol>
<table>
<thead>
<tr>
<th>if</th>
<th style="text-align:center">if…else</th>
<th style="text-align:right">if…else if…else</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>范例</strong>：if判断</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        double score = 90.0;
        if (score &lt; 60.0) {
            System.out.println(&quot;不及格&quot;);
        } else if (score &lt; 90) {
            System.out.println(&quot;良&quot;);
        } else {
            System.out.println(&quot;优秀&quot;);
        }
    }
}
</code></pre>
<ol start="3">
<li>switch语句:<br>
switch判断<strong>不能使用布尔表达式</strong>，JDK1.5之前只能进行<code>整数或字符</code>判断，JDK1.5增加了<code>枚举</code>判断，JDK1.7增加了<code>String</code>判断，语法：</li>
</ol>
<pre class="highlight"><code class="">switch (数字/字符/枚举/字符串){
    case 内容 : 内容满足时执行的代码 ; break;
    case 内容 : 内容满足时执行的代码 ; break;
    ...
    default {
        内容都不满足case时执行;
        break;
    }
}
</code></pre>
<p><strong>范例</strong>：使用switch</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int num = 2;
        switch (num) {
            case 1:
                System.out.println(&quot;数字1&quot;);
                break;
            case 2:
                System.out.println(&quot;数字2&quot;);
                break;
            default:
                System.out.println(&quot;大于2的数字&quot;);
                break;
        }
    }
}
</code></pre>
<p>switch默认从第一个符合条件的case语句开始执行，直到整个switch执行完毕或遇到break关键字，才停止执行。<strong>程序区分大小写</strong>。</p>
<h3 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h3>
<ol>
<li>当某段代码需要重复执行时，可使用循环语句实现，循环有两种：for循环和while循环。</li>
<li>while循环：</li>
</ol>
<table>
<thead>
<tr>
<th>while循环</th>
<th style="text-align:right">do…while循环</th>
</tr>
</thead>
<tbody>
<tr>
<td>while（布尔语句）｛｝</td>
<td style="text-align:right">do｛｝while（布尔语句);</td>
</tr>
</tbody>
</table>
<p><strong>范例</strong>：实现1到100的累加（<strong>while循环先判断再执行</strong>）：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
   public static void main(String[] args) {
       int sum = 0;
       int current = 1; // 循环的初始化条件
       while (current &lt;= 100) { // 循环结束条件
           sum += current; // 累加
           current++; // 修改循环的初始化条件
       }
       System.out.println(sum); // 5050
   }
}
</code></pre>
<p><strong>范例</strong>：实现1到100的累加（<strong>do…while循环是先执行再判断）</strong></p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int sum = 0;
        int current = 1;
        do {
            sum += current;
            current++;
        } while (current &lt;= 100);
        System.out.println(sum);
    }
}
</code></pre>
<p>do…while循环先执行再判断，即不论循环条件是否满足，都至少执行一次，<strong>因此开发中不建议使用do…while。</strong></p>
<ol start="3">
<li>for循环：</li>
</ol>
<pre class="highlight"><code class="">for (循环初始化条件; 循环结束条件; 循环条件变更) {
    循环语句;
}
</code></pre>
<p>即使三个条件都不写，但是<strong>两个&quot;;&quot;必须保留。</strong><br>
<strong>范例</strong>：实现1~100的累加</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int sum = 0;
        for (int i = 0; i &lt;= 100; i++) {
            sum += i;
        }
        System.out.println(sum);
    }
}
</code></pre>
<ol start="4">
<li>开发原则:<br>
（1）循环次数未知，循环结束条件已知时使用<code>while</code>循环；<br>
（2）循环次数已知，使用<code>for</code>循环。</li>
<li>循环嵌套</li>
</ol>
<pre class="highlight"><code class="">public class 九九乘法表 {
    public static void main(String[] args) {
        for (int x = 1; x &lt;= 9; x++) {
            for (int y = 1; y &lt;= x; y++) {
                System.out.print(x + &quot;*&quot; + y + &quot;=&quot; + (x * y) + &quot;\t&quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h3>
<p>循环控制有两个语句：<code>continue</code>（退出本次循环）和<code>break</code>（结束整个循环）。该语句要和判断语句一起使用。<br>
<strong>范例</strong>：continue使用</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
   public static void main(String[] args) {
       for (int x = 0; x &lt; 5; x++) {
           if (x == 3) {
               continue; // 跳出本次循环，不进行后续的输出操作
           }
           System.out.print(x + &quot;,&quot;); // 0,1,2,4,
       }
   }
}
</code></pre>
<p><strong>范例</strong>：break</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        for (int x = 0; x &lt; 5; x++) {
            if (x == 3) {
                break; // 结束整体循环
            }
            System.out.print(x + &quot;,&quot;); // 0,1,2,
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/article/%E8%AF%AD%E8%A8%80/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。</p>
</blockquote>
<h2 id="markdown语法"><a class="markdownIt-Anchor" href="#markdown语法"></a> Markdown语法</h2>
<h3 id="区块元素"><a class="markdownIt-Anchor" href="#区块元素"></a> 区块元素</h3>
<h4 id="段落与换行"><a class="markdownIt-Anchor" href="#段落与换行"></a> 段落与换行</h4>
<p>一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是<strong>无法使用空格或制表符来缩进的</strong>，因为其默认一个空格就是一个空行。</p>
<h4 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h4>
<p>Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个<code>#</code>，对应1到6级标题。</p>
<pre><code># 这是H1
## 这是H2
...
###### 这是H6
</code></pre>
<h4 id="区块引用blockquotes"><a class="markdownIt-Anchor" href="#区块引用blockquotes"></a> 区块引用Blockquotes</h4>
<p>Markdown标记区块引用方式如下：</p>
<pre><code>&gt; 文本内容。
&gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt;
</code></pre>
<p>在引用的区域中，也可以使用其他的Markdown语法。</p>
<h4 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h4>
<p>Markdown支持有序列表和无序列表。无序列表使用<code>星号</code>、<code>减号</code>或<code>加号</code>作为列表标记:</p>
<pre><code>* red
- green
+ blue
</code></pre>
<p>有序列表则使用数字接着一个英文句号：</p>
<pre><code>1. red
2. green
3. blue
</code></pre>
<p>如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即：</p>
<pre class="highlight"><code class="">	* blue

	*red
</code></pre>
<p>会被转换为：</p>
<pre class="highlight"><code class="bash">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>如果要在列表项目中放入引用，就需要缩进</p>
<pre><code>* red
	&gt; this is color
</code></pre>
<p>如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。</p>
<h4 id="代码区域"><a class="markdownIt-Anchor" href="#代码区域"></a> 代码区域</h4>
<p>要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。</p>
<h4 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h4>
<p>你可以在一行使用三个以上的<code>星号</code>、<code>减号</code>、<code>下划线</code>来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。</p>
<pre><code>星号：  * * *
减号：  - - -
下划线：_ _ _ 
</code></pre>
<h3 id="区段元素"><a class="markdownIt-Anchor" href="#区段元素"></a> 区段元素</h3>
<h4 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h4>
<p>Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。</p>
<pre><code>[example](https://www.baidu.com &quot;Title&quot;)
</code></pre>
<h4 id="强调"><a class="markdownIt-Anchor" href="#强调"></a> 强调</h4>
<p>Markdown使用星号和下划线标记强调，被<code>*</code>或<code>_</code>包围的字词会被转为用<code>&lt;em&gt;</code>标签包围，而用两个<code>*</code>或<code>_</code>包起来，则变为<code>&lt;strong&gt;</code></p>
<pre><code>*强调*
_强调_
**强调**
__强调__
</code></pre>
<p>如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠：</p>
<pre><code>\*文字\*
</code></pre>
<h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4>
<p>如果要标记一小段行内代码，可以使用反引号把它包起来，例如：</p>
<pre><code>`printf()`
</code></pre>
<p>如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段:</p>
<pre><code>`` (`) `` 将变为  &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt;
</code></pre>
<h4 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h4>
<p>插入图片有两种方式：行内式和参考式</p>
<pre><code>![替代图片的文字](/path/to/img.jpg &quot;文字&quot;)
</code></pre>
<h2 id="结束"><a class="markdownIt-Anchor" href="#结束"></a> 结束</h2>
<p>感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot小例子]]></title>
      <url>/article/%E6%A1%86%E6%9E%B6/Spring%20Boot/SpringBoot%E5%B0%8F%E4%BE%8B%E5%AD%90/</url>
      <content type="html"><![CDATA[<h2 id="第一个spring-boot应用"><a class="markdownIt-Anchor" href="#第一个spring-boot应用"></a> 第一个Spring Boot应用</h2>
<h3 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h3>
<p>1.打开 IDEA, 选择 <code>Create New Project</code><br>
2.左侧菜单选择<code>Spring Initializr</code>, Next即可<br>
3.<code>Project Metadata</code>默认即可，Next<br>
4.<code>Dependencies</code>选择Web中的<code>Web</code>即可,Next<br>
5.<code>Project Name</code>默认即可,finsh</p>
<h3 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h3>
<pre class="highlight"><code class="">demo   // 项目名
|- .idea
|- .mvn
|- src  // 代码存放区
   |- main 
      |- java
         |- com.example.demo // java包
            |- DemoApplication.java  // 项目启动类
      |- resources
         |- static     // 用于存放css,js等样式文件
         |- templates  // 用于存放html文件
         application.properties  // 项目配置文件
   |- test //测试代码存放区
|- target
.gitignore
mvnw
mvnw.cmd
demo.iml
pom.xml // 项目对象模型,添加项目依赖等配置
</code></pre>
<h3 id="demoapplicationjava"><a class="markdownIt-Anchor" href="#demoapplicationjava"></a> DemoApplication.java</h3>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(PersonApplication.class, args);
	}
}

</code></pre>
<p><code>@SpringBootApplication</code>标注它是一个SpringBoot应用,main方法使说明它是主程序,在应用启动时首先被执行。<br>
右键<code>run</code>,然后在浏览器中输入<code>localhost:8080</code>即可访问页面,因为当前未定义页面,因此显示<code>Error Page</code></p>
<h3 id="第一个页面"><a class="markdownIt-Anchor" href="#第一个页面"></a> 第一个页面</h3>
<p>在<code>com.example.demo</code>文件下创建<code>HelloController.java</code></p>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController 
public class HelloController {
	// 设置请求路径为 /hello,请求方式为get
    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String say() {
        return &quot;Hello World!&quot;;
    }
}
</code></pre>
<p><code>RestController</code>注解该类是一个控制器。当用户访问指定路径时,将调用say()返回&quot;Hello World&quot;。<br>
右键<code>run</code>,然后在浏览器中输入<code>localhost:8080/hello</code>即可访问页面,此时可在页面看到<code>Hello World!</code></p>
<h3 id="项目属性配置"><a class="markdownIt-Anchor" href="#项目属性配置"></a> 项目属性配置</h3>
<blockquote>
<p>建议将项目中application.properties改为application.yml,便于配置</p>
</blockquote>
<pre class="highlight"><code class="">server:
  port: 8080           # 端口号
  context-path: /demo  # 主路径配置
age: 18                # 自定义属性
content: &quot;age: ${age}&quot; # 配置文件中调用属性
</code></pre>
<p>获取配置文件中的属性值</p>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController 
public class HelloController {
    @Value(&quot;${content}&quot;)
	private String content;

    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String say() {
        return content;
    }
}
</code></pre>
<p>右键<code>run</code>,然后在浏览器中输入<code>localhost:8080/demo/hello</code>即可访问页面,此时可在页面看到<code>age: 18</code></p>
<h4 id="当有一系列属性值时"><a class="markdownIt-Anchor" href="#当有一系列属性值时"></a> 当有一系列属性值时</h4>
<p>可将其定义为某个属性的子属性</p>
<pre class="highlight"><code class="">server:
  port: 8080
person:
  name: Tom
  age: 40
</code></pre>
<p>定义一个PersonProperties类</p>
<pre class="highlight"><code class="">package com.temp.person;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component // 将类实例化到Spring容器中
@ConfigurationProperties(prefix = &quot;person&quot;)  // 获取前缀为person的配置
public class PersonProperties {
    private String name;
    private Integer age;
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

}
</code></pre>
<p>获取配置文件中的值:</p>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.web.bind.annotation.RequestMapping; 
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController 
public class HelloController {
    @Autowired
    private PersonProperties personProperties;  // 定义对象,从而间接获取属性值

    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String say() {
        return personProperties.getName;
    }
}
</code></pre>
<p>右键<code>run</code>,然后在浏览器中输入<code>localhost:8080/demo/hello</code>即可访问页面,此时可在页面看到<code>Tom</code>。<strong>对于配置文件中属性的读取建议采用该方式</strong>。</p>
<h4 id="多种配置文件"><a class="markdownIt-Anchor" href="#多种配置文件"></a> 多种配置文件</h4>
<p>假设现在有两种配置文件application-dev.yml和application-prod.yml</p>
<pre class="highlight"><code class="">[application-dev.yml]
demo:
  name: you 
  age: 20

[application-prod.yml]
demo:
  name: you 
  age: 20
</code></pre>
<p>只需在application.yml中</p>
<pre class="highlight"><code class="">spring:
  profiles:
  # 选择要调用的配置文件
    active: dev
</code></pre>
<p>当要使用某种时,active设为那个文件的值即可。</p>
<h3 id="controller的基本使用"><a class="markdownIt-Anchor" href="#controller的基本使用"></a> Controller的基本使用</h3>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Controller</td>
<td>处理http请求</td>
</tr>
<tr>
<td>@RestController</td>
<td>Spring4之后新加的注解，原先返回json需要@ResponseBody配合@Controller</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>配置url映射</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>获取url中的数据</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>获取请求参数的值</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>组合注解</td>
</tr>
</tbody>
</table>
<h4 id="访问路径和访问方式"><a class="markdownIt-Anchor" href="#访问路径和访问方式"></a> 访问路径和访问方式</h4>
<p>1.<code>@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</code>设置访问路径为&quot;hello&quot;,请求方式为get，可以简写为<code>@GetMapping(value = &quot;/hello&quot;)</code><br>
2.可将路径设为集合,使得访问的路径不同,但请求的资源相同:<code>@RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;})</code><br>
3.可以为整个类设置访问路径,如下：</p>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController 
@GetMapping(value = &quot;/demo&quot;)
public class HelloController {
    @GetMapping(value = {&quot;/hello&quot;, &quot;hi&quot;})
    public String say() {
        return &quot;Hello World!&quot;;
    }
}
</code></pre>
<p>在浏览器输入地址<code>http://localhost:8080/demo/hello</code>和<code>http://localhost:8080/demo/hi</code>均能看到页面显示<code>Hello World!</code>.</p>
<h4 id="获取路径参数"><a class="markdownIt-Anchor" href="#获取路径参数"></a> 获取路径参数</h4>
<p>1.<code>@PathVariable</code> 获取路径参数</p>
<pre class="highlight"><code class="">@GetMapping(value = &quot;/hello/{id}&quot;)
public Integer say(@PathVariable(&quot;id&quot;) Integer id) {
   return id;
}
</code></pre>
<p>在浏览器输入地址<code>http://localhost:8080/hello/100</code>此时页面显示<code>100</code><br>
2.<code>@RequestParam</code> 获取请求参数</p>
<pre class="highlight"><code class="">@GetMapping(value = &quot;/hello&quot;)
// 获取路径中参数id的值,id可不存在，默认为0
public Integer say(@RequestParam(value = &quot;id&quot;,required = false,defaultValue =&quot;0&quot;) Integer id) {
    return id;
}
</code></pre>
<p>在浏览器输入地址<code>http://localhost:8080/hello/100?id=100</code>此时页面显示<code>100</code></p>
<h3 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h3>
<blockquote>
<p>Java客户端使用Spring-Data-Jpa组件。<br>
JPA（Java Persistence API）定义了一系列对象持久化的标准,目前实现这一规范的产品有Hibernate、TopLink等。</p>
</blockquote>
<h4 id="restful-api设计"><a class="markdownIt-Anchor" href="#restful-api设计"></a> RESTful API设计</h4>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>请求路径</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>/person</td>
<td>获取数据列表</td>
</tr>
<tr>
<td>POST</td>
<td>/person</td>
<td>添加数据</td>
</tr>
<tr>
<td>Get</td>
<td>/person/id</td>
<td>根据id获取数据</td>
</tr>
<tr>
<td>PUT</td>
<td>/person/id</td>
<td>根据id修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>/person/id</td>
<td>根据id删除数据</td>
</tr>
</tbody>
</table>
<h4 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h4>
<p>在<code>pom.xml</code>添加jpa依赖和MySQL组件</p>
<pre class="highlight"><code class="">	&lt;dependency&gt;
		&lt;groupId&gt;mysql&lt;/groupId&gt;
		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
		&lt;scope&gt;runtime&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
</code></pre>
<h4 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h4>
<p>在<code>application.yml</code>中添加数据库配置</p>
<pre class="highlight"><code class="">spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver  # 驱动
    url: jdbc:mysql://127.0.0.1:3306/dbperson # 数据库url
    username: root
    password:
  jpa:
    hibernate:
      ddl-auto: udate
    show-sql: true
</code></pre>
<h4 id="创建数据表"><a class="markdownIt-Anchor" href="#创建数据表"></a> 创建数据表</h4>
<p>在Spring Boot中可通过创建实体类，自动生成数据表</p>
<pre class="highlight"><code class="">package com.example.demo;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity  // 注册实体,Spring Boot会自动将其变为数据表
public class Person {
    @Id  // 设为数据表中id属性
    @GeneratedValue   // 设置为自增
    private Integer id;  
    private String name;
    private Integer age;

    public Person() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p>Spring Boot会将上述代码中类的属性变为数据表的字段。</p>
<h4 id="创建personrepository接口"><a class="markdownIt-Anchor" href="#创建personrepository接口"></a> 创建PersonRepository接口</h4>
<p>该接口继承JpaRepositoy,实现sql语句</p>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; {

	// 自定义方法,实现通过年龄找数据
    List&lt;Person&gt; findByAge(Integer age);
}
</code></pre>
<h4 id="创建personcontroller实现访问时根据访问方式和路径实现数据操作"><a class="markdownIt-Anchor" href="#创建personcontroller实现访问时根据访问方式和路径实现数据操作"></a> 创建PersonController,实现访问时根据访问方式和路径实现数据操作</h4>
<pre class="highlight"><code class="">package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.transaction.Transactional;
import java.util.List;

@RestController
public class PersonController {
    @Autowired
    private PersonRepository personRepository;

    /**
     * 通过get方式访问localhost:8080/person可获取全部数据
     * @return 数据类集
     */
    @GetMapping(value = &quot;/person&quot;)
    public List&lt;Person&gt; personList(){
        return personRepository.findAll();
    }

    /**
     * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据
     * @param name 数据表的name字段
     * @param age  数据表的age字段
     * @return 返回Person对象
     */
    @PostMapping(value = &quot;/person&quot;)
    public Person addPerson(@RequestParam(&quot;name&quot;) String name,
                            @RequestParam(&quot;age&quot;) Integer age) {
        Person person = new Person();
        person.setName(name);
        person.setAge(age);
        return  personRepository.save(person);
    }

    /**
     * 通过get方式访问localhost:8080/person/1可获取id为1的数据
     * @param id 要查询的数据id
     * @return Person对象
     */
    @GetMapping(value = &quot;/person/{id}&quot;)
    public Person findPersonById(@PathVariable(&quot;id&quot;) Integer id) {
        return personRepository.findOne(id);
    }

    /**
     * 通过put方式访问localhost:8080/person/1?name=Jane&amp;age=10可将id为1的数据修改
     * @param id 要修改的数据id
     * @return Person对象
     */
    @PutMapping(value = &quot;/person/{id}&quot;)
    public Person updatePersonByid(@PathVariable(&quot;id&quot;) Integer id,
                                   @RequestParam(&quot;name&quot;) String name,
                                   @RequestParam(&quot;age&quot;) Integer age) {
        Person person = personRepository.findOne(id);
        person.setName(name);
        person.setAge(age);
        return  personRepository.save(person);
    }

    /**
     * 通过delete方式访问localhost:8080/person/1可将id为1的数据删除
     * @param id 要删除数据的id
     */
    @DeleteMapping(value = &quot;/person/{id}&quot;)
    public void deletePersonById(@PathVariable(&quot;id&quot;) Integer id) {
        personRepository.delete(id);
    }

    /**
     * 通过get方式访问localhost:8080/person/age/10可查找age为10的数据
     * @param age 要查找的年龄
     */
    @GetMapping(value = &quot;/person/age/{age}&quot;)
    public List&lt;Person&gt; personListByAge(@PathVariable(&quot;age&quot;) Integer age) {
        return personRepository.findByAge(age);
    }

    /**
     * 实现事务管理,批量增加数据,一个数据失败，全部数据不得入库
     * @Transactional 用于标注事务管理
     */
    @PostMapping(value = &quot;/person/two&quot;)
    @Transactional
    public void addTwoPerson() {
        Person personA = new Person();
        personA.setName(&quot;Tony&quot;);
        personA.setAge(13);
        personRepository.save(personA);

        Person personB = new Person();
        personB.setName(&quot;Maria&quot;);
        personB.setAge(18);
        personRepository.save(personB);
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go基础知识]]></title>
      <url>/article/Go/Go%20Base/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2>
<p>Go语言是一门编译型语言，是一个开源的编程语言，能让构造简单、而且高效的软件变得容易。Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p>
<h3 id="go语言环境安装"><a class="markdownIt-Anchor" href="#go语言环境安装"></a> Go语言环境安装</h3>
<p>Go语言安装包下载地址为<a href="https://golang.org/dl/">Golang</a>。Windows使用mis后缀的安装包即可。默认情况msi文件会安装在c:\Go目录下。Go语言的开发工具可以使用<a href="http://sourceforge.net/projects/liteide/files/">LitelDE</a>，是一款开源、跨平台的轻量级Go语言集成开发环境.。也可以在Eclipse或IDEA中安装Go语言插件。</p>
<h3 id="第一个go程序"><a class="markdownIt-Anchor" href="#第一个go程序"></a> 第一个Go程序</h3>
<pre class="highlight"><code class="">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello World!&quot;)
}
</code></pre>
<p>Go的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go提供的工具都通过<code>go</code>命令调用。其中<code>go run</code>就是编译go的源文件，链接库文件，并运行生成的可执行文件。</p>
<pre class="highlight"><code class="">$ go run helloworld.go
</code></pre>
<p>Go语言支持Unicode，可以处理任何语言的文本，包括中文。<br>
如果要编译上述程序，保存编译结果以备将来使用，可以使用<code>build</code>子命令：</p>
<pre class="highlight"><code class="">$ go build helloworld.go
</code></pre>
<p>这个命令生成一个名为helloworld的可执行的二进制文件（注：Windows系统下生成的是<code>helloworld.exe</code>），之后可以随时运行它，不需要任何处理（注：因为是静态编译，所以不必担心系统库更新时的冲突）。</p>
<p>Go语言的代码通过包（package）组织，包类似与其他语言中的库（libraries）或者模块（modules）。一个包由单个目录下的一个或多个go源代码文件组成，目录定义包的作用。每个源文件都以package声明语句为开始。上述例子就是<code>package main</code>，紧跟着导入（import）的包，之后是程序代码。</p>
<p><code>fmt包</code>含有格式化输出、接收输入的函数，<code>Println</code>是其中一个基础函数。</p>
<p><code>main包</code>比较特殊，定义了一个独立可执行的程序，而不是一个库。main包中的main函数是整个程序执行时的入口。import声明告诉编译器需要哪些包，缺少必要的包或者导入不需要的包，程序都无法编译通过。</p>
<p>组成程序的函数、变量、常量、类型的声明语句分别由关键字<code>func</code>、<code>var</code>、<code>const</code>、<code>type</code>定义。一个函数的声明由<code>func</code>关键字、函数名、参数列表、返回值列表（mian函数不含返回值）以及包含在大括号里的函数体组成。<strong>Go语言不需在语句末尾添加分号，除非一行有多条语句。</strong></p>
<h2 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h2>
<h3 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h3>
<p>Go语言的<code>函数名、变量名、常量名、类型名、语句标号和包名</code>等所有命名的规则是：</p>
<blockquote>
<p>（1）由字母、下划线、或数字组成，以字母或下划线开头，区分大小写。<br>
（2）不能使用关键字。Go语言有25个关键字：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">break</th>
<th style="text-align:center">default</th>
<th style="text-align:center">func</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">select</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">defer</td>
<td style="text-align:center">go</td>
<td style="text-align:center">map</td>
<td style="text-align:center">struct</td>
</tr>
<tr>
<td style="text-align:center">chan</td>
<td style="text-align:center">else</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">package</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">fallthrough</td>
<td style="text-align:center">if</td>
<td style="text-align:center">range</td>
<td style="text-align:center">type</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">import</td>
<td style="text-align:center">return</td>
<td style="text-align:center">var</td>
</tr>
</tbody>
</table>
<blockquote>
<p>（3）Go语言还有30多个预定义的名字，如int和true等，对应内建的常量、类型和函数。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">内建常量</th>
<th style="text-align:center">true  false iota nil</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内建类型</td>
<td style="text-align:center">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32  float64 complex128 complex64 bool  byte  rune  string  error</td>
</tr>
<tr>
<td style="text-align:center">内建函数</td>
<td style="text-align:center">make  len  cap  new  append   copy  close  delete  complex  real imag  panic  revover</td>
</tr>
</tbody>
</table>
<p>内部预定义的名字不是关键字，因为可以在定义中重新使用它们。在一些特殊场景重新定义它们时要避免过度而引起的语义混乱。<br>
（4）命名长度没有限制，但应尽量短小。如果作用域较大，生命周期长，应见名知意。<br>
（5）Go语言推荐使用驼峰式命名，而对于<code>ASCII</code>和<code>HTML</code>这样的缩略词则不变，即<code>escapeHTML</code>，而不是<code>escapeHtml</code>。<br>
（6）如果一个标识符是在函数内部定义的，那么它只在函数内部有效。如果在函数外部定义，则当前包中所有的文件都可以访问该标识符。名字开头字母的大小写决定了标识符在包外的可见性：如果开头是大写字母，那么它是公开，可被外部包访问，如fmt包的Printf函数就可以在fmt包外访问。包的名字一般总是小写。</p>
<h3 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h3>
<p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型声明语句：<code>var、const、type和func</code>，分别对应<code>变量、常量、类型和函数实体对象</code>的声明。</p>
<p>（1）一个Go程序对应一个或多个go源文件。每个源文件以包的声明语句开始，说明该文件属于哪个包。之后是<code>import</code>语句，然后是包一级的类型、变量、常量、函数声明语句。<br>
<strong>范例</strong>：声明常量、函数、变量</p>
<pre class="highlight"><code class="">package main  // 包声明

import &quot;fmt&quot;  // 导入依赖包

const  boilingF = 212.0   // 定义常量

/**
进行摄氏度和华氏度的转换
 */
func main() {   // 定义函数
	var f = boilingF   // 定义变量
	var c = (f - 32) * 5 / 9
	fmt.Printf(&quot;boiling point = %g°F or %g°C\n&quot;, f, c)
}
</code></pre>
<p>上述代码中，<code>bilingF</code>是包级别的声明,作用范围为包内的所有文件。f和c是在函数内部声明的，作用范围仅在函数内部。</p>
<p>（2）一个函数的声明由<code>函数名、参数、可选的返回值和函数体</code>组成。如果没有返回值，就可不定义返回值。函数的执行从第一个语句，依次执行直到遇到return语句或执行完毕。<br>
<strong>如果要多次进行摄氏度与华氏度的转换，可以将其定义为函数。</strong></p>
<pre class="highlight"><code class="">package main

import &quot;fmt&quot;

func main() {
	const freezingF, boilingF = 32.0, 212.0
	fmt.Printf(&quot;%g°F = %g°C\n&quot;, freezingF, fToC(freezingF))
	fmt.Printf(&quot;%g°F = %g°C\n&quot;, boilingF, fToC(boilingF))
}

/** 华氏度转为摄氏度
 * f: 华氏度值
 * return: 返回float64类型数据
 */
func fToC(f float64) float64  {
	return (f - 32) * 5 / 9
}
</code></pre>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p>变量声明的一般语法：<code>var 变量名 类型 = 表达式</code></p>
<blockquote>
<p>类型或表达式可省略其一。如果省略类型，则根据表达式推断变量的类型;如果省略表达式，则变量的值为默认值：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数值类型</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">布尔型</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">字符串型</td>
<td style="text-align:center">空字符串</td>
</tr>
<tr>
<td style="text-align:center">接口或引用类型(包括slice、指针、map、chan和函数)</td>
<td style="text-align:center">nil</td>
</tr>
<tr>
<td style="text-align:center">数组或结构体等聚合类型</td>
<td style="text-align:center">每个元素或字段对应该类型的初始值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Go的零值初始化机制可以保证每个变量都被初始化，因此Go中不存在未初始化的变量。这个特性可以简化很多代码，在不增加额外工作的情况下，确保边界条件下的合理行为。</p>
</blockquote>
<p>可以在声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量，如果忽略每个变量的类型，就可以声明多个不同类型变量（类型由初始表达式推导）</p>
<pre class="highlight"><code class="">var i, j, k int  // int, int, int
var b, f, s = true, 2.3, &quot;four&quot;  // bool, float64, string
</code></pre>
<p>变量也可以通过调用函数，由函数的返回值进行初始化：</p>
<pre class="highlight"><code class="">var f, err = os.Open(name)
</code></pre>
<h4 id="简短变量声明"><a class="markdownIt-Anchor" href="#简短变量声明"></a> 简短变量声明</h4>
<p>简短变量声明，变量的类型根据表达式自动推导，语法<code>变量名 := 表达式</code></p>
<blockquote>
<p>因为其简洁灵活的特点，简短变量声明常用于大部分的局部变量；var声明常用于需要显示变量类型的地方或者变量稍后会被重新赋值的而初始值无关紧要的地方。</p>
</blockquote>
<pre class="highlight"><code class="">i := 100
var boilong float64 = 100
var name []string
</code></pre>
<p>简短变量声明也同var一样可以声明一组变量，表达式可以是函数。<br>
（1）简短变量声明左边的变量如果是已经被声明过的，那么此时该语句对该变量的作用只是赋值（简短变量声明一句中至少有一个变量是新地！）</p>
<pre class="highlight"><code class="">in, err := os.Open(infile)
out, err := os.Open(outfile)  // 此时&quot;:=&quot; 对于err只是进行赋值
out, err := os.Create(outfile) // 报错,没有新的变量
</code></pre>
<p>解决上述错误的方法是将第二个简短变量声明改为普通的多重赋值语句。</p>
<blockquote>
<p>简短变量声明只对已经在同级作用范围声明的变量起到赋值作用，如果是作用域外的声明，则会在当前作用域重新声明一个新的变量。</p>
</blockquote>
<h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识(一)]]></title>
      <url>/article/Java/Java%20Base/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="java基础知识"><a class="markdownIt-Anchor" href="#java基础知识"></a> Java基础知识</h2>
<blockquote>
<p>Java是一门<strong>面向对象</strong>语言，支持多线程编程;通过使用更为简单的<strong>引用</strong>来进行内存关系的匹配，而不是复杂的指针;Java提供<strong>垃圾自动回收机制</strong>，能更好地处理垃圾空间;可以实现多平台的移植。</p>
</blockquote>
<h3 id="第一个java程序"><a class="markdownIt-Anchor" href="#第一个java程序"></a> 第一个Java程序</h3>
<ol>
<li>运行Java程序的步骤<br>
<code>javac xx.java</code>:对Java程序进行编译，生成字节码文件<code>xx.class</code>。<br>
<code>java xx</code>：对Java程序进行解释。</li>
<li>Java程序的核心单元—<strong>类</strong><br>
类的声明方式有两种:<br>
<code>public class class_name {}</code>：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。<br>
<code>class class_name {}</code>：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。</li>
<li>第一个Java程序：Hello World</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;    		// 包名
public class HelloWorld {		// 类
	public static void main(String[] args) {    // 主方法
		System.out.println(&quot;Hello World&quot;);    // 方法体
	}
}
</code></pre>
<p>Java程序都是从<strong>主方法</strong>开始执行的.<code>System.out.println()</code>将内容输出后换行。</p>
<h3 id="classpath环境属性"><a class="markdownIt-Anchor" href="#classpath环境属性"></a> CLASSPATH环境属性</h3>
<p>PATH和CLASSPTH的<strong>区别</strong>：<code>PATH</code>是操作系统路径，定义了所有可执行程序的路径；<code>CLASSPATH</code>是Java解释类文件时的加载路径，当<code>java</code>命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。<br>
配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。</p>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p><code>// 注释内容</code>：    单行注释<br>
<code>/* 注释内容 */</code>： 多行注释<br>
<code>/** 注释内容 */</code>：文档注释</p>
<h3 id="标识符与关键字"><a class="markdownIt-Anchor" href="#标识符与关键字"></a> 标识符与关键字</h3>
<ol>
<li>标识符<br>
标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下：
<blockquote>
<p>（1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字；<br>
（2）标识符应尽量有意义，可见名知意。<br>
（3）Java标识符可以是中文，但不建议使用中文命名标识符。</p>
</blockquote>
</li>
<li>关键字<br>
Java中有两个未使用的关键字<code>goto</code>和<code>const</code>；JDK1.4之后增加了<code>assert</code>关键字；JDK1.5之后增加了<code>enum</code>关键字。</li>
</ol>
<h2 id="java数据类型"><a class="markdownIt-Anchor" href="#java数据类型"></a> Java数据类型</h2>
<ol>
<li>Java数据类型分为两大类：<code>基础数据类型</code>和<code>引用数据类型</code><br>
<strong>两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。</strong></li>
</ol>
<blockquote>
<p>基本数据类型：<br>
    |-数值型：<br>
        |-整型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>； →默认值：<code>0</code>；<br>
        |-浮点型：<code>float</code>、<code>double</code>；        →默认值：<code>0.0</code><br>
        |-字符型：<code>char</code>；                      →默认值：<code>‘\u0000’</code><br>
        |-布尔型：<code>boolean</code>；       			 →默认值：<code>false</code><br>
    |-引用数据类型：数组、类、接口等。 		 →默认值：<code>null</code></p>
</blockquote>
<ol start="2">
<li>数据类型的选择原则</li>
</ol>
<blockquote>
<p>（1）整数用<code>int</code>，小数用<code>double</code>；<br>
（2）描述日期时间或内存大小，用<code>long</code>；<br>
（3）实现内容传递或编码转换用<code>byte</code>；<br>
（4）逻辑控制用<code>boolean</code>；<br>
（5）避免中文乱码用<code>char</code>。</p>
</blockquote>
<h3 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h3>
<ol>
<li>数字常量属于<code>int</code>型数据，如数字30。<br>
常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 一个变量名在同一块代码中只允许声明一次
        // 变量赋值语法：value_type value_name = value ;
        int num = 10; 
        num = num * 2;
        System.out.println(num);
    }
}
</code></pre>
<ol start="2">
<li>每个数据类型都有其对应的存储范围</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int max = Integer.MAX_VALUE;  // int型数据的最大值
        int min = Integer.MIN_VALUE;  // int型数据的最小值
        System.out.println(max);      // 2147483647
        System.out.println(max + 1);  // -2147483648
        System.out.println(min);      // -2147483648
        System.out.println(min - 1);  // 2147483647
        System.out.println(min - 2);  // 2147483646
    }
}
</code></pre>
<p>当数据超过<code>int</code>型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为<code>数据溢出</code>，解决方法是<strong>扩大数据范围</strong>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int max = Integer.MAX_VALUE;
        int min = Integer.MIN_VALUE;
        // int变量 + long变量 = long变量,扩大了数据的范围
        System.out.println(max + 1L); // 2147483648
        System.out.println(min - (long)1); // -2147483649
        System.out.println((long)min - 2); // -2147483650
    }
}
</code></pre>
<ol start="3">
<li>数据类型的转换规律</li>
</ol>
<blockquote>
<p>范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型；<br>
范围大的数据类型只能通过强制转换变为范围小的数据类型。<br>
常量进行强制转换，可通过使用常量标记（如<code>L，l</code>可将<code>int</code>型常量变为<code>long</code>型）或使用<code>(数据类型)常量</code>。范例–强制转换：</p>
</blockquote>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 1000是int型，使用long型变量接收，发生自动转换
        long num = 1000;
	    // long型变为int型，强制转换
        int x = (int) num; 
        System.out.println(x); // 1000
    }
}
</code></pre>
<p>当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生<strong>数据溢出</strong>。</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 2147483650L是long型数据，超出int型的范围
        long num = 2147483650L ;
        int x = (int) num; 
        System.out.println(x); // -2147483646，数据溢出
    }
}
</code></pre>
<p><code>byte</code>型数据的取值范围为<code>-128~127</code>，当整数数值在这个范围内时，会自动转型；超出<code>byte</code>范围时会发生数据溢出。<br>
4. 注意点<br>
变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        // 未给变量赋值
		int num;  
		// 报错,未初始化变量,无法使用该变量
        System.out.println(num); 
    }
}
</code></pre>
<h3 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h3>
<ol>
<li>Java中浮点数属于<code>double</code>型（<code>double</code>型是保存范围最广的类型）。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        double num = 10.2; // 10.2是小数，属于double型
        // double型 * int型 = double型
        System.out.println(num * 2); // 20.4
    }
}
</code></pre>
<p>所以使用<code>float</code>数据须将<code>double强制转换为float型</code>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        float fA = 10.2F;         // 强制转型方式一
        float fB = (float) 10.2; // 强制转型方式二
        System.out.println(fA);  // 10.2
        System.out.println(fB);  // 10.2
        System.out.println(fA * fB); // 104.03999,该bug无法解决
    }
}
</code></pre>
<p>开发过程中要考虑到<code>整型数据不保留小数位</code>：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        int y = 9;
        System.out.println(y / x); // 1
    }
}
</code></pre>
<p>因为<code>int型/int型=int型</code>，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int x = 5;
        int y = 9;
        System.out.println(y / (double) x); // 1.8
    }
}
</code></pre>
<h3 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> 字符型</h3>
<ol>
<li>byte<br>
<code>byte</code>是字节，1字符=2字节。Java使用十六进制<code>UNICODE</code>编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。</li>
<li>字符使用单引号<code>'</code>声明，一对单引号只能保存一位字符。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = 'A';
        int num = c; // char型可以自动转换为int型
        System.out.println(c);
        System.out.println(num); // 65,是A的ASCII码值
    }
}
</code></pre>
<ol start="3">
<li>编码：<code>'A'</code>(65)~<code>'Z'</code>(90); <code>'a'</code>（97）~<code>'z'</code>（122）; <code>'0'</code>（48）~<code>'9'</code>(57),可利用A和a的编码差为32，实现字母大小写转换：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = 'A';
        int num = c;     // char型变为int型才能进行四则运算
        num = num + 32;  // 大写与小写编码值差为32
        c = (char) num;  // int型只能强制转换为char型
        System.out.println(c); // a
    }
}
</code></pre>
<ol start="4">
<li>传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        char c = '游';
        int num = c;
        System.out.println(num); // 28216
    }
}
</code></pre>
<p>由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。</p>
<h3 id="布尔型"><a class="markdownIt-Anchor" href="#布尔型"></a> 布尔型</h3>
<p>布尔型返回逻辑结果，只保存两种数据：<code>true</code>和<code>false</code>，主要用于逻辑控制：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        boolean flag = false;
        //  if (布尔值){满足条件时的操作}
        if (!flag) {
            System.out.println(&quot;Hello World !&quot;);
        }
    }
}
</code></pre>
<h3 id="string型"><a class="markdownIt-Anchor" href="#string型"></a> String型</h3>
<ol>
<li>String型<br>
<code>String</code>属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号<code>&quot;&quot;</code>声明。</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello World !&quot;; // str为字符串变量
        System.out.println(str);
        // &quot;Hello World !&quot;为字符串常量
        System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre>
<ol start="2">
<li><code>+</code>可实现字符串连接</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello&quot;;
        str = str + &quot; World !&quot;;
        System.out.println(str);
    }
}
</code></pre>
<p>当四则运算与字符串连接同时存在时：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 100;
        double numB = 99.9;
        String str = &quot;加法计算：&quot; + numA + numB;
        System.out.println(str); // 加法计算：10099.9
    }
}
</code></pre>
<p>出现上述结果是因为小范围数据会自动转型为大范围数据，即<code>String型+任意数据类型=String型</code>，然后进行字符串连接，可使用()来实现正确的运算：</p>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        int numA = 100;
        double numB = 99.9;
        String str = &quot;加法计算：&quot; + (numA + numB);
        System.out.println(str); // 加法计算：199.9
    }
}
</code></pre>
<ol start="3">
<li>Java支持转义字符，<br>
例如：换行<code>\n</code>、制表符<code>\t</code>、反斜杠<code>\\</code>、双引号<code>\&quot;</code>、单引号<code>\'</code>：</li>
</ol>
<pre class="highlight"><code class="">package com.java.demo;
public class Demo {
    public static void main(String[] args) {
        String str = &quot;Hello \&quot;World\&quot; \nHello MLDN&quot;;
        System.out.println(str);
        /**
         * Hello &quot;World&quot;
         * Hello MLDN
         */
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gitee+Hexo搭建个人博客]]></title>
      <url>/article/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Tool/Gitee+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><a href="https://gitee.com">Gitee</a>: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。<br>
Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。</p>
<h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2>
<h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装Node.js</h3>
<p>Windows用户访问<a href="https://nodejs.org/en">Node.js</a>下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。</p>
<pre><code>$ npm config set registry http://registry.npm.taobao.org/
</code></pre>
<h3 id="hexo安装"><a class="markdownIt-Anchor" href="#hexo安装"></a> Hexo安装</h3>
<pre><code>$ npm install -g hexo-cli
</code></pre>
<p>Hexo的基本使用请查看hello-world文中所写。</p>
<h3 id="本地运行hexo"><a class="markdownIt-Anchor" href="#本地运行hexo"></a> 本地运行Hexo</h3>
<p>在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件：</p>
<pre><code>$ hexo init
</code></pre>
<p>初始化后，文件夹的目录如下：</p>
<pre><code>.
├── .deploy       #需要部署的文件
├── node_modules  #Hexo插件
├── public        #生成的静态网页文件
├── scaffolds     #模板
├── source        #博客正文和其他源文件等都应该放在这里
|   ├── _drafts   #草稿
|   └── _posts    #文章
├── themes        #主题
├── _config.yml   #全局配置文件
└── package.json
</code></pre>
<p>之后在本地执行如下命令后，即可访问 <a href="http://localhost:4000">http://localhost:4000</a> 访问Hexo页面</p>
<pre><code>$ hexo s
</code></pre>
<h3 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> Git安装</h3>
<p><a href="https://git-scm.com/downloads">Git安装包地址</a>,根据操作系统选择安装包下载后安装即可。</p>
<h3 id="注册码云账号并创建一个项目"><a class="markdownIt-Anchor" href="#注册码云账号并创建一个项目"></a> 注册码云账号，并创建一个项目</h3>
<p><img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/new project.png" alt="创建新项目"><br><br>
<img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/new project2.png" alt="创建新项目"><br></p>
<h3 id="获取项目地址"><a class="markdownIt-Anchor" href="#获取项目地址"></a> 获取项目地址</h3>
<p><img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/get.png" alt="获取项目地址"><br></p>
<h2 id="发布博客"><a class="markdownIt-Anchor" href="#发布博客"></a> 发布博客</h2>
<h3 id="修改hexo配置文件_configyml"><a class="markdownIt-Anchor" href="#修改hexo配置文件_configyml"></a> 修改Hexo配置文件_config.yml</h3>
<pre><code>deploy:
	type: git
	repo: 码云的项目地址
	branch: master
</code></pre>
<h3 id="部署博客"><a class="markdownIt-Anchor" href="#部署博客"></a> 部署博客</h3>
<pre><code>$ npm install hexo-deployer-git --save 
$ hexo g --d  #一键部署
</code></pre>
<p>此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。</p>
<h3 id="开启page功能"><a class="markdownIt-Anchor" href="#开启page功能"></a> 开启Page功能</h3>
<p><img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/open.png" alt="开启Page功能"><br><br>
<img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/start.png" alt="开启Page功能"><br><br>
<img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/success.png" alt="博客部署成功"></p>
<h3 id="访问博客"><a class="markdownIt-Anchor" href="#访问博客"></a> 访问博客</h3>
<p>在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下：<br>
<img src="/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/blog.png" alt="我的博客"></p>
<h2 id="博客使用"><a class="markdownIt-Anchor" href="#博客使用"></a> 博客使用</h2>
<p>在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为<code>file_name.md</code><br>
<code>file_name.md</code>的文件开头如下:</p>
<pre class="highlight"><code class="">---
title: file_name
tag: 标签名
categories: 分类
comment: 是否允许评论(true or false)
description: 描述
---
文档正文编写，请参照markdown语法。
</code></pre>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>如果搭建过程中，还有什么问题，请在下方留言。谢谢您的阅读！</p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/article/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<pre class="highlight"><code class="bash">$ hexo new <span class="string">"My New Post"</span>
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<pre class="highlight"><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<pre class="highlight"><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<pre class="highlight"><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[About]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>一个被现实从网络架构逼到了编程开发的小菜鸟x.x</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
