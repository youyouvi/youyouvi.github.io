{"meta":{"title":"Cogitate","subtitle":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","description":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","author":"子语","url":"https://youyouvi.github.io"},"pages":[{"title":"Links","date":"2017-09-25T01:46:53.317Z","updated":"2017-09-25T01:46:53.317Z","comments":true,"path":"links/index.html","permalink":"https://youyouvi.github.io/links/index.html","excerpt":"","text":""},{"title":"Timeline","date":"2017-09-24T15:48:28.689Z","updated":"2017-09-24T15:48:28.689Z","comments":true,"path":"timeline/index.html","permalink":"https://youyouvi.github.io/timeline/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-24T15:49:20.806Z","updated":"2017-09-24T15:49:20.806Z","comments":true,"path":"tags/index.html","permalink":"https://youyouvi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker的安装说明","slug":"Docker的安装说明","date":"2017-09-24T10:43:23.794Z","updated":"2017-09-24T15:53:19.292Z","comments":true,"path":"2017/09/24/Docker的安装说明/","link":"","permalink":"https://youyouvi.github.io/2017/09/24/Docker的安装说明/","excerpt":"","text":"安装及部署Docker 系统和资源说明 Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。 资源需求：Docker1.12.6 安装步骤 (1)安装 $ yum install docker (2)设置开机启动Docker Daemon进程 $ systemctl start docker.service // 启动docker $ systemctl enable docker.service // 设置Docker开机自启动 $ systemctl disable firewalld // 关闭防火墙 $ yum -y install iptables-services // 安装iptable服务 $ systemctl start iptables.service // 启动iptable $ systemctl enable iptables.service // 设置iptable开机自启动 (3)安装成功的Docker $ docker version (4)建立docker用户组，将使用docker的用户加入docker用户组。 $ groupadd docker $ usermod -aG docker $USER Docker的代理配置 $ vim /usr/lib/systemd/system/docker.service [Service] Environment=”HTTP_PROXY=http://192.168.13.19:7777” Environment=”HTTPS_PROXY=http://192.168.13.19:7777” Type=notify Docker配置加速器 国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了阿里云加速器 注册用户并且申请加速器后，会获得 https://xxx.mirror.aliyuncs.com 这样的地址。 $ vim /usr/lib/systemd/system/docker.service ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com $ systemctl daemon-reload // 重新加载配置 $ systemctl restart docker // 重启docker Docker配置文件说明 $ vim /etc/sysconfig/docker OPTIONS=' --selinux-enabled // 是否开启selinux，默认开启 --insecure registry ip:port // 添加私人仓库地址 --bip=ip // 表示网桥docker0的CIDR地址 ' Docker的常用命令 Docker信息查看 (1)查看docker进程状态 $ systemctl status docker (2)查看docker的具体信息 $ docker info (3)查看docker的版本信息 $ docker version Docker的镜像操作 (1)查找镜像 $ docker search image_name (2)拉取镜像 $ docker pull image_name:tag (3)列出本地镜像 $ docker images 列表参数说明 Repository：镜像的仓库源 Tag：镜像的标签 Image ID： 镜像ID Created： 镜像的创建时间 Size： 镜像大小 (4)设置镜像标签 $ docker tag image_id tag (5)利用镜像创建容器 $ docker run image_name:tag command (6)提交镜像 $ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name Docker的容器操作 (1)启动容器 $ docker run option host_port:contaniner_port image_name:tag command 例如：docker run -it -d -p 5000:5000 java java -version -d：后台运行容器 -p:将容器端口映射到宿主机端口 -it:进行交互式操作 command: 执行java -version命令 (2)查看容器 $ docker ps // 查看正在运行的容器 (3)容器生命周期命令 $ docker create image:tag // 创建容器但不启动 $ docker start container_name // 启动容器 $ docker stop contaniner_name // 停止容器 $ docker restart container_name // 重启容器 $ docker pause contaniner_name // 暂停容器内所有进程 $ docker unpause contaniner_name // 恢复容器内所有进程 $ docker rm contaniner // 删除容器 $ docker rm ${docker ps -a -q} // 删除所有停止的容器","categories":[{"name":"容器","slug":"容器","permalink":"https://youyouvi.github.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://youyouvi.github.io/tags/Docker/"}]},{"title":"Docker的简单说明","slug":"Docker的简单说明","date":"2017-09-24T09:36:05.889Z","updated":"2017-09-24T10:42:47.666Z","comments":true,"path":"2017/09/24/Docker的简单说明/","link":"","permalink":"https://youyouvi.github.io/2017/09/24/Docker的简单说明/","excerpt":"","text":"Docker简介 Docker的概念 Docker最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。Docker被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将应用软件及其依赖软件（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。 Dcoker的技术依赖 Docker使用Go语言进行开发实现，基于Linux内核的cgroup、namespace以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于LXC、0.7后去除LXC，使用自行开发的libcontainer。从1.11开始，则使用runC和containerd。 （1）cgroup是将任意进程进行分组化管理的Linux内核功能。重要概念是子系统，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。 （2）LXC（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于namespace的隔离机制和cgroup限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。 （3）AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。 （4）App打包：Docker额外提供的Feature,标准统一的打包部署运行方案。 Docker的优势 Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而容器内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。 （1）更高效的利用系统资源 由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。 （2）更快速的启动 Docker容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动，大大节约了开发、测试、部署的时间。 （3）一致的运行环境 Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致性。 （4）持续交付和部署 Docker可以通过定制应用镜像实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来创建镜像，并结合持续集成（Continuous integration）系统进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。 （5）更轻松的迁移 由于Docker确保了运行环境的一致性，使得应用迁移更加容易。 （6）更轻松的维护和扩展 Docker使用的分层存储以及镜像技术，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易. Docker相关的基础概念 Docker Image 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。Docker镜像（Image）就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含一些为运行时准备的配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。 分层存储 因为传统镜像包含操作系统完整的root文件系统，其体积往往庞大。因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，任何额外的东西应在该层构建结束前清理结束。 分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。 Docker Container 镜像（Image）是静态定义，容器（Container）是镜像运行时的实体。容器可以被创建、启动、停止等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。 容器也是分层存储的，每个容器运行时以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。 按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。 Docker Registry 镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即Docker Registry。 一个Docker Registry包含多个仓库（Repository）；每个仓库包含多个标签Tag；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;来获取指定版本的镜像，如果不给出标签，就将以latest为默认标签。 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的Docker Hub。 除了公开服务外，用户还可以在本地搭建私有的Docker Registry。Docker官方提供Docker Registry镜像，可以直接使用作为私有Registry服务。","categories":[{"name":"容器","slug":"容器","permalink":"https://youyouvi.github.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://youyouvi.github.io/tags/Docker/"}]},{"title":"Java基础知识(二)","slug":"Java基础知识(二)","date":"2017-09-24T03:29:54.604Z","updated":"2017-09-24T07:04:15.670Z","comments":true,"path":"2017/09/24/Java基础知识(二)/","link":"","permalink":"https://youyouvi.github.io/2017/09/24/Java基础知识(二)/","excerpt":"","text":"运算符 常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。 基本运算符 =为赋值运算符。 四则运算符基本组成：+、-、*、/、%。不要使用运算符编写过于复杂的计算。 public class Demo { public static void main(String[] args) { int numA = 10; double numB = 20; int numC = 3; System.out.println(&quot;加法计算：&quot; + (numA + numB)); System.out.println(&quot;减法计算：&quot; + (numA - numB)); System.out.println(&quot;乘法计算：&quot; + (numA * numB)); System.out.println(&quot;除法计算：&quot; + (numA / numB)); System.out.println(&quot;求模计算：&quot; + (numA % numC)); } } 简化运算符：+=、-=、*=、/=、%=: public class Demo { public static void main(String[] args) { int numA = 10; numA += 2; // 等同于 numA = numA + 2 System.out.println(&quot;加法计算&quot; + (numA)); // 12 } } ++（自增），--（自减）：位置不同，功能也不同： ·++变量，--变量：先对变量加/减1，再使用自增或自减后的变量进行计算; ·变量++，变量--：先使用变量进行计算，再进行变量加/减1。 public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; // ++变量，先numA + 1 // 然后(numA + 1) + numB内容 // 最后对numB加1 int result = (++numA) + (numB++); System.out.println(&quot;numA=&quot; + numA); // 11 System.out.println(&quot;numB=&quot; + numB); // 21 System.out.println(&quot;result=&quot; + result); // 31 } } 三目运算符 三目运算符根据布尔表达式的结果进行赋值： value_type value_name = 布尔表达式 ? true_value : false_value; 利用三目运算符可以减少判断代码: public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; int max = 0; /** 使用三目运算符 * 当numA大于numB,返回true,max = numA * 当numA小于numB,返回false,max = numB */ max = numA&gt;numB ? numA : numB; // 不使用三目运算符 // if (numA &gt; numB) { // max = numA; //} else { // max = numB; //} System.out.println(max); } } 逻辑运算符 逻辑运算符：与&amp;，&amp;&amp;、或|，||、非! package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = true; System.out.println(!flag); // false } } 布尔表达式的连接，只能使用与和或操作 与：所有条件都为true时，结果为true;有一个为false，结果就是false. 范例：普通与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：程序报错，因为&amp;会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。 范例：短路与&amp;&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp;&amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // false,不报错 } } } 结果:程序不报错，因为&amp;&amp;只要有一个条件为false后，后续判断就不再进行，从而提高了效率。 或操作：一个条件为true，结果为true。 范例：普通或| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) | (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：使用|，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。 范例：短路或|| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) || (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // true,不报错 } } } 因此使用逻辑运算时就使用&amp;&amp;和||。 位运算符 数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。 位运算主要是进行二进制数据操作，位运算符：&amp;、|、&gt;&gt;(移位)、&lt;&lt;、^(反码)、~。 范例：位与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA &amp; numB); // 9 } } 运算过程： 1001 → 9 &amp; 1011 → 11 1001 → 9 范例：位或| package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA | numB); // 11 } } 运算过程： 1001 → 9 | 1011 → 11 1011 → 11 范例：移位（最快方式计算2的3次方） package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; num = num &lt;&lt; 2; // 向左移位 System.out.println(num); // 8,相当于2的3次方 } } 运算过程： 0010 → 2 2&lt;&lt; 1000 → 8 章节小问题：请解释&amp;与&amp;&amp;的区别，以及|与||的区别: 1. 在逻辑运算中： |- &amp;和|会对所有条件进行判断后，返回结果 |- &amp;&amp;只要一个条件返回false，就不进行后续判断，结果为false |- ||只要一个条件为true，就不进行后续判断，结果为true 2. 在位运算中： |- &amp;为位与元算，|为位或元算 |- &amp;&amp;和||不能用于位运算","categories":[{"name":"语言","slug":"语言","permalink":"https://youyouvi.github.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://youyouvi.github.io/tags/Java/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2017-09-23T09:19:24.606Z","updated":"2017-09-24T07:15:05.283Z","comments":true,"path":"2017/09/23/Markdown语法/","link":"","permalink":"https://youyouvi.github.io/2017/09/23/Markdown语法/","excerpt":"","text":"Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。 Markdown语法 区块元素 段落与换行 一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是无法使用空格或制表符来缩进的，因为其默认一个空格就是一个空行。 标题 Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个#，对应1到6级标题。 # 这是H1 ## 这是H2 ... ###### 这是H6 区块引用Blockquotes Markdown标记区块引用方式如下： &gt; 文本内容。 &gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt; 在引用的区域中，也可以使用其他的Markdown语法。 列表 Markdown支持有序列表和无序列表。无序列表使用星号、减号或加号作为列表标记: * red - green + blue 有序列表则使用数字接着一个英文句号： 1. red 2. green 3. blue 如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即： * blue *red 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 如果要在列表项目中放入引用，就需要缩进 * red &gt; this is color 如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。 代码区域 要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。 分隔线 你可以在一行使用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。 星号： * * * 减号： - - - 下划线：_ _ _ 区段元素 链接 Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。 [example](https://www.baidu.com &quot;Title&quot;) 强调 Markdown使用星号和下划线标记强调，被*或_包围的字词会被转为用&lt;em&gt;标签包围，而用两个*或_包起来，则变为&lt;strong&gt; *强调* _强调_ **强调** __强调__ 如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠： \\*文字\\* 代码 如果要标记一小段行内代码，可以使用反引号把它包起来，例如： `printf()` 如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段: `` (`) `` 将变为 &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt; 图片 插入图片有两种方式：行内式和参考式 ![替代图片的文字](/path/to/img.jpg &quot;文字&quot;) 结束 感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。","categories":[{"name":"语言","slug":"语言","permalink":"https://youyouvi.github.io/categories/语言/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://youyouvi.github.io/tags/Markdown/"}]},{"title":"SpringBoot使用","slug":"SpringBoot使用","date":"2017-09-23T08:58:23.811Z","updated":"2017-09-23T13:08:37.516Z","comments":true,"path":"2017/09/23/SpringBoot使用/","link":"","permalink":"https://youyouvi.github.io/2017/09/23/SpringBoot使用/","excerpt":"","text":"","categories":[{"name":"框架","slug":"框架","permalink":"https://youyouvi.github.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://youyouvi.github.io/tags/Java/"}]},{"title":"Go基础知识","slug":"Go基础知识","date":"2017-09-23T08:57:17.832Z","updated":"2017-09-23T13:08:33.805Z","comments":true,"path":"2017/09/23/Go基础知识/","link":"","permalink":"https://youyouvi.github.io/2017/09/23/Go基础知识/","excerpt":"","text":"","categories":[{"name":"语言","slug":"语言","permalink":"https://youyouvi.github.io/categories/语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://youyouvi.github.io/tags/Go/"}]},{"title":"Java基础知识(一)","slug":"Java基础知识(一)","date":"2017-09-23T08:57:00.370Z","updated":"2017-09-24T07:11:43.493Z","comments":true,"path":"2017/09/23/Java基础知识(一)/","link":"","permalink":"https://youyouvi.github.io/2017/09/23/Java基础知识(一)/","excerpt":"","text":"Java基础知识 Java是一门面向对象语言，支持多线程编程;通过使用更为简单的引用来进行内存关系的匹配，而不是复杂的指针;Java提供垃圾自动回收机制，能更好地处理垃圾空间;可以实现多平台的移植。 第一个Java程序 运行Java程序的步骤 javac xx.java:对Java程序进行编译，生成字节码文件xx.class。 java xx：对Java程序进行解释。 Java程序的核心单元—类 类的声明方式有两种: public class class_name {}：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。 class class_name {}：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。 第一个Java程序：Hello World package com.java.demo; // 包名 public class HelloWorld { // 类 public static void main(String[] args) { // 主方法 System.out.println(&quot;Hello World&quot;); // 方法体 } } Java程序都是从主方法开始执行的.System.out.println()将内容输出后换行。 CLASSPATH环境属性 PATH和CLASSPTH的区别：PATH是操作系统路径，定义了所有可执行程序的路径；CLASSPATH是Java解释类文件时的加载路径，当java命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。 配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。 注释 // 注释内容： 单行注释 /* 注释内容 */： 多行注释 /** 注释内容 */：文档注释 标识符与关键字 标识符 标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下： （1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字； （2）标识符应尽量有意义，可见名知意。 （3）Java标识符可以是中文，但不建议使用中文命名标识符。 关键字 Java中有两个未使用的关键字goto和const；JDK1.4之后增加了assert关键字；JDK1.5之后增加了enum关键字。 Java数据类型 Java数据类型分为两大类：基础数据类型和引用数据类型 两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。 基本数据类型： |-数值型： |-整型：byte、short、int、long； →默认值：0； |-浮点型：float、double； →默认值：0.0 |-字符型：char； →默认值：‘\\u0000’ |-布尔型：boolean； →默认值：false |-引用数据类型：数组、类、接口等。 →默认值：null 数据类型的选择原则 （1）整数用int，小数用double； （2）描述日期时间或内存大小，用long； （3）实现内容传递或编码转换用byte； （4）逻辑控制用boolean； （5）避免中文乱码用char。 整型 数字常量属于int型数据，如数字30。 常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量： package com.java.demo; public class Demo { public static void main(String[] args) { // 一个变量名在同一块代码中只允许声明一次 // 变量赋值语法：value_type value_name = value ; int num = 10; num = num * 2; System.out.println(num); } } 每个数据类型都有其对应的存储范围 package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; // int型数据的最大值 int min = Integer.MIN_VALUE; // int型数据的最小值 System.out.println(max); // 2147483647 System.out.println(max + 1); // -2147483648 System.out.println(min); // -2147483648 System.out.println(min - 1); // 2147483647 System.out.println(min - 2); // 2147483646 } } 当数据超过int型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为数据溢出，解决方法是扩大数据范围： package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; // int变量 + long变量 = long变量,扩大了数据的范围 System.out.println(max + 1L); // 2147483648 System.out.println(min - (long)1); // -2147483649 System.out.println((long)min - 2); // -2147483650 } } 数据类型的转换规律 范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型； 范围大的数据类型只能通过强制转换变为范围小的数据类型。 常量进行强制转换，可通过使用常量标记（如L，l可将int型常量变为long型）或使用(数据类型)常量。范例–强制转换： package com.java.demo; public class Demo { public static void main(String[] args) { // 1000是int型，使用long型变量接收，发生自动转换 long num = 1000; // long型变为int型，强制转换 int x = (int) num; System.out.println(x); // 1000 } } 当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生数据溢出。 package com.java.demo; public class Demo { public static void main(String[] args) { // 2147483650L是long型数据，超出int型的范围 long num = 2147483650L ; int x = (int) num; System.out.println(x); // -2147483646，数据溢出 } } byte型数据的取值范围为-128~127，当整数数值在这个范围内时，会自动转型；超出byte范围时会发生数据溢出。 4. 注意点 变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。 package com.java.demo; public class Demo { public static void main(String[] args) { // 未给变量赋值 int num; // 报错,未初始化变量,无法使用该变量 System.out.println(num); } } 浮点型 Java中浮点数属于double型（double型是保存范围最广的类型）。 package com.java.demo; public class Demo { public static void main(String[] args) { double num = 10.2; // 10.2是小数，属于double型 // double型 * int型 = double型 System.out.println(num * 2); // 20.4 } } 所以使用float数据须将double强制转换为float型： package com.java.demo; public class Demo { public static void main(String[] args) { float fA = 10.2F; // 强制转型方式一 float fB = (float) 10.2; // 强制转型方式二 System.out.println(fA); // 10.2 System.out.println(fB); // 10.2 System.out.println(fA * fB); // 104.03999,该bug无法解决 } } 开发过程中要考虑到整型数据不保留小数位： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / x); // 1 } } 因为int型/int型=int型，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / (double) x); // 1.8 } } 字符型 byte byte是字节，1字符=2字节。Java使用十六进制UNICODE编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。 字符使用单引号'声明，一对单引号只能保存一位字符。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型可以自动转换为int型 System.out.println(c); System.out.println(num); // 65,是A的ASCII码值 } } 编码：'A'(65)~'Z'(90); 'a'（97）~'z'（122）; '0'（48）~'9'(57),可利用A和a的编码差为32，实现字母大小写转换： package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型变为int型才能进行四则运算 num = num + 32; // 大写与小写编码值差为32 c = (char) num; // int型只能强制转换为char型 System.out.println(c); // a } } 传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = '游'; int num = c; System.out.println(num); // 28216 } } 由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。 布尔型 布尔型返回逻辑结果，只保存两种数据：true和false，主要用于逻辑控制： package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = false; // if (布尔值){满足条件时的操作} if (!flag) { System.out.println(&quot;Hello World !&quot;); } } } String型 String型 String属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号&quot;&quot;声明。 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // str为字符串变量 System.out.println(str); // &quot;Hello World !&quot;为字符串常量 System.out.println(&quot;Hello World !&quot;); } } +可实现字符串连接 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str = str + &quot; World !&quot;; System.out.println(str); } } 当四则运算与字符串连接同时存在时： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + numA + numB; System.out.println(str); // 加法计算：10099.9 } } 出现上述结果是因为小范围数据会自动转型为大范围数据，即String型+任意数据类型=String型，然后进行字符串连接，可使用()来实现正确的运算： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + (numA + numB); System.out.println(str); // 加法计算：199.9 } } Java支持转义字符， 例如：换行\\n、制表符\\t、反斜杠\\\\、双引号\\&quot;、单引号\\'： package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello \\&quot;World\\&quot; \\nHello MLDN&quot;; System.out.println(str); /** * Hello &quot;World&quot; * Hello MLDN */ } }","categories":[{"name":"语言","slug":"语言","permalink":"https://youyouvi.github.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://youyouvi.github.io/tags/Java/"}]},{"title":"Gitee+Hexo搭建个人博客","slug":"Gitee+Hexo搭建个人博客","date":"2017-09-22T13:48:40.242Z","updated":"2017-09-24T11:51:21.555Z","comments":true,"path":"2017/09/22/Gitee+Hexo搭建个人博客/","link":"","permalink":"https://youyouvi.github.io/2017/09/22/Gitee+Hexo搭建个人博客/","excerpt":"","text":"Gitee: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。 Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。 环境搭建 安装Node.js Windows用户访问Node.js下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。 $ npm config set registry http://registry.npm.taobao.org/ Hexo安装 $ npm install -g hexo-cli Hexo的基本使用请查看hello-world文中所写。 本地运行Hexo 在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件： $ hexo init 初始化后，文件夹的目录如下： . ├── .deploy #需要部署的文件 ├── node_modules #Hexo插件 ├── public #生成的静态网页文件 ├── scaffolds #模板 ├── source #博客正文和其他源文件等都应该放在这里 | ├── _drafts #草稿 | └── _posts #文章 ├── themes #主题 ├── _config.yml #全局配置文件 └── package.json 之后在本地执行如下命令后，即可访问 http://localhost:4000 访问Hexo页面 $ hexo s Git安装 Git安装包地址,根据操作系统选择安装包下载后安装即可。 注册码云账号，并创建一个项目 获取项目地址 发布博客 修改Hexo配置文件_config.yml deploy: type: git repo: 码云的项目地址 branch: master 部署博客 $ npm install hexo-deployer-git --save $ hexo g --d #一键部署 此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。 开启Page功能 访问博客 在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下： 结尾 如果搭建过程中，还有什么问题，请在下方留言。谢谢您的观赏！","categories":[{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"https://youyouvi.github.io/categories/Hexo搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://youyouvi.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-22T08:28:42.118Z","updated":"2017-09-23T07:11:13.725Z","comments":true,"path":"2017/09/22/hello-world/","link":"","permalink":"https://youyouvi.github.io/2017/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"https://youyouvi.github.io/categories/Hexo搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://youyouvi.github.io/tags/Hexo/"}]}]}