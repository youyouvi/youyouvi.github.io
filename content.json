{"meta":{"title":"Ember","subtitle":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","description":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","author":"子语","url":"http://yov.oschina.io"},"pages":[{"title":"About","date":"2017-09-26T12:54:07.654Z","updated":"2017-09-26T12:54:07.654Z","comments":true,"path":"about/index.html","permalink":"http://yov.oschina.io/about/index.html","excerpt":"","text":"一个被现实从网络架构逼到了编程开发的小菜鸟x.x"},{"title":"Gallery","date":"2017-09-25T03:23:43.087Z","updated":"2017-09-25T03:23:43.087Z","comments":true,"path":"gallery/index.html","permalink":"http://yov.oschina.io/gallery/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-09-25T01:46:53.317Z","updated":"2017-09-25T01:46:53.317Z","comments":true,"path":"links/index.html","permalink":"http://yov.oschina.io/links/index.html","excerpt":"","text":""},{"title":"Timeline","date":"2017-09-24T15:48:28.689Z","updated":"2017-09-24T15:48:28.689Z","comments":true,"path":"timeline/index.html","permalink":"http://yov.oschina.io/timeline/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-24T15:49:20.806Z","updated":"2017-09-24T15:49:20.806Z","comments":true,"path":"tags/index.html","permalink":"http://yov.oschina.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础知识(十三)","slug":"Java Base/Java基础知识(十三)","date":"2017-10-28T12:06:18.603Z","updated":"2017-10-28T12:25:13.479Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十三)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十三)/","excerpt":"","text":"接口 接口的基本定义 1、接口是只由抽象方法和全局变量组成的类,使用interface关键字定义。 interface A { // 定义接口 public static final String MSG = &quot;Hello&quot;; // 全局常量 public abstract void print(); // 抽象方法 } 由于接口中存在抽象方法，因此接口对象不能直接实例化，其使用原则如下： （1）接口必须要有子类，子类可以使用implements关键字实现多接口； （2）接口的子类（非抽象类时），必须对接口的抽象方法进行覆写； （3）接口的对象可以利用子类对象通过向上转型实现实例化。 interface A { // 定义接口 public static final String MSG = &quot;Hello&quot;; // 全局常量 public abstract void print(); // 抽象方法 } interface B { public abstract void get(); } class X implements A, B { // X 实现A和B两个接口 public void print() { System.out.println(&quot;A.抽象方法&quot;); } public void get() { System.out.println(&quot;B.抽象方法&quot;); } } public class Demo { public static void main(String[] args) { X x = new X(); // 实例化子类对象 A a = x; // 向上转型 B b = x; // 向上转型 a.print(); b.get(); } } X是A和B的子类，因此X的对象可以变为A或者B接口的对象。 public class Demo { public static void main(String[] args) { A a = new X(); B b = (B) a; b.get(); // B.抽象方法 System.out.println(a instanceof A); // true System.out.println(b instanceof B); // true } } 从结构上来说，A和B接口没有直接关系，但是两个接口拥有共同的子类X，最终实例化的是X，这个子类向上转型为B类对象，因此代码可以执行。 2、子类同时继承类和接口时，语法:class X extends A implements B {} 接口的组成只有抽象方法和全局变量，因此可以不写abstract和public static final,并且方法是否使用public定义都是一样的，因为接口只能使用public权限。 |interface A{ public static final String MSG = &quot;Hello&quot;; //全局常量 public abstract void print(); //抽象方法 } |interface A{ String MSG = &quot;Hello&quot;; //全局常量 void print(); //抽象方法 } 上述代码是等价的。在接口中，默认访问权限为public，而不是default。但开发时，定义接口中的方法时要写上public。 3、一个抽象类只能继承一个抽象类，但一个接口可以使用extends关键字同时继承多个接口，接口不能继承抽象类。 interface A { public void funA(); } interface B { public void funB(); } interface C extends A, B { public void funC(); } class X implements C { public void funA() { } public void funB() { } public void funC() { } } 从继承上来说，抽象类的限制比接口多： （1）一个抽象类只能继承一个抽象父类，而接口没有该限制； （2）一个子类只能继承一个抽象类，但可以实现多接口。 因此Java中接口的功能是解决单继承限制。 4、从概念而言，接口只能由抽象方法和全局变量组成。但接口中可以定义普通内部类、抽象内部类、内部接口。这些内部接口不受接口的概念限制。 interface A { public void funA(); abstract class B { // 定义抽象内部类 public abstract void funB(); } } class X implements A { // X实现A接口 public void funA() { } class Y extends B { // 抽象内部类的子类 public void funB() { } } } 上述代码形式，几乎不会用到。 5、在接口中使用static定义一个内部接口，相当于外部接口。 interface A { public void funA(); static interface B { // 相当于外部接口 public void funB(); } } class X implements A.B { // X实现B接口 public void funB() { } } 总结： 接口在实际开发中的三大作用： （1）定义不同层之间的操作标准； （2）表示一种操作的能力； （3）表示将服务器端的远程方法视图暴露给客户端。 定义标准 根据上图编写代码：电脑利用USB接口标准和其他设备关联。 范例：定义USB标准 // 标准可以连接不同层的操作类 interface USB { // 接口就是标准 public void start(); public void stop(); } 范例：定义电脑 class Computer{ public void plugin(USB usb){ // 插入USB设备 usb.start(); usb.stop(); } } 不论是什么设备，只要实现了USB标准，就可以在电脑上使用。 范例：定义U盘 class Flash implements USB { public void start() { System.out.println(&quot;U盘开始使用&quot;); } public void stop() { System.out.println(&quot;U盘停止使用&quot;); } } 范例：定义打印机 class Print implements USB { public void start() { System.out.println(&quot;打印机开始使用&quot;); } public void stop() { System.out.println(&quot;打印机停止使用&quot;); } } 范例：测试 public class Demo { public static void main(String[] args) { Computer com = new Computer(); com.plugin(new Flash()); com.plugin(new Print()); } } Java中，标准就是被定义为接口。 工厂设计模式 interface Fruit { public void eat(); } class Apple implements Fruit { public void eat() { System.out.println(&quot;吃苹果&quot;); } } 上述代码通过主方法可以取得Fruit对象，但存在如下问题： 附：要确定代码是否合理，标准如下： （1）客户端调用简单，不用关注具体实现； （2）客户端之外的代码修改，不影响用户的使用，即用户不用关注代码的变更。 由上述标准可知该程序的问题是一个接口不一定只有子类，现在添加一个Fruit子类： class Orange implements Fruit { public void eat() { System.out.println(&quot;吃橘子&quot;); } } 客户端要使用这个新子类，需要修改代码： public class Demo { public static void main(String[] args) { Fruit f = new Orange (); f.eat(); // 吃橘子 } } 在上述代码，我们最关注的是如何获得Fruit对象,之后进行方法调用。至于该对象是怎么实例的,不是客户端的工作。 1、上述程序中，客户端每次更换对象，就需要修改主方法的代码，这不符合标准。该问题的关键在于new的使用，这种问题是因为耦合度太高（两者联系程度太高）。耦合度太高，代码不便于维护。 解决思路：参考Java虚拟机的设定-程序→JVM→适应不同的操作系统。 范例：增加一个过渡 class Factory { // 工厂设计模式 public static Fruit getInstance(String className) { if (&quot;apple&quot;.equals(className)) { return new Apple(); } else if (&quot;orange&quot;.equals(className)) { return new Orange(); } else { return null; } } } public class Demo { public static void main(String[] args) { Fruit f = Factory.getInstance(&quot;apple&quot;); f.eat(); // 吃苹果 } } 此时，所有子类对于客户端是不可见的，因为Fruit对象的实例化是通过Factory对象获取的，日后扩充Fruit子类时，只需修改Factory即可，不用修改客户端代码。 上图描述的是工厂设计模式，客户端可见的只有接口和Factory。 代理设计模式 代理设计模式的核心在于有一个主题操作接口（可能有很多接口），核心操作类只完成核心功能，而代理主题负责完成所有与核心操作有关的辅助性操作。 1、以去餐馆吃饭为例,外人只看到吃饭,看不到厨师和顾客。皇帝完成核心业务,厨师完成辅助业务。 package com.java.demo; interface Subject { // 核心业务 public void eat(); } class RealSubject implements Subject { // 实际进行核心业务的对象 public void eat() { System.out.println(&quot;顾客在吃饭&quot;); } } class ProxySubject implements Subject { // 执行代理操作的对象 private Subject subject; // 接收进行核心业务的对象 public ProxySubject(Subject subject) { this.subject = subject; } public void prepared() { System.out.println(&quot;为吃做准备&quot;); } public void eat() { this.prepared(); this.subject.eat(); this.destory(); } public void destory() { System.out.println(&quot;为吃收尾&quot;); } } public class Demo { public static void main(String[] args) { Subject sub = new ProxySubject(new RealSubject()); sub.eat(); // 调用代理操作 } } 接口与抽象类的区别 No. 区别 抽象类 接口 1 关键字 abstract class interface 2 组成 构造方法、普通方法、抽象方法、static方法、变量、常量 抽象方法，全局常量 3 子类使用 class 子类 extends 抽象类 class 子类implements 接口,接口… 4 关系 抽象类可以实现多接口 接口不能继承抽象类，却可以继承多个接口 5 权限 可以使用任意权限 只能使用public权限 6 限制 单继承局限 没有单继承局限 7 子类 抽象类和接口都必须有子类，子类必须要覆写全部抽象方法 抽象类和接口都必须有子类，子类必须要覆写全部抽象方法 8 实例化对象 依靠子类对象的向上转型进行对象的实例化 依靠子类对象的向上转型进行对象的实例化 经过比较发现，抽象类存在单继承限制，因此当抽象类和接口都可以使用时，优先考虑接口。 （1）当进行公共操作时，要定义接口； （2）有了接口就需要使用子类完善方法 （3）自定义的接口，不能直接实例化接口子类，应使用工厂设计模式。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十二)","slug":"Java Base/Java基础知识(十二)","date":"2017-10-23T12:21:57.951Z","updated":"2017-10-24T07:25:08.911Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十二)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十二)/","excerpt":"","text":"辅助概念 关键字final Java中，final被称为终结器，可以用于定义类、方法、属性，具有如下特点： 1、final定义的类不能有子类 final class A{} class B extends A{} //报错，无法继承A类 开发系统类或者进行一些架构代码开发时使用到final定义类。 2、final定义的方法不能被方法覆写 父类中某些方法具备某种隐藏的特性，或子类必须使用该方法时，使用final定义，意思是子类不要破坏父类中该方法的结构。 class A{ public final void fun(){} } class B extends A{ public void fun(){} // 报错，无法覆写方法 } 3、final定义的变量就成了常量。常量必须在定义时设置好值，且不能修改。 class A { final double GOOD = 100.0; public void fun() { GOOD = 200; // 无法修改常量GOOD的值 } } 用final定义变量，就可以使用变量名来描述一些数据。开发中常量名均为大写，变量名首个单词小写，之后的单词首字母大写。 4、全局常量：public static final 声明的变量就是全局常量: public static final String MSG = &quot;MLDN&quot;; static数据存在公共数据区，因此MSG是一个公共常量。 总结： （1）final定义的类和方法不能继承，不能覆写； （2）public static final 定义的是全局常量，常量名全部大写。 对象多态性 多态性依赖于方法覆写。 class A { public void print() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void print() { System.out.println(&quot;覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); // 覆写的方法 } } 1、多态性分为两种： （1）方法的多态性 |- 方法重载：同一个方法名，根据传入的参数类型或个数的不同，执行不同方法体； |- 方法覆写：同一个方法，根据对象所属的子类不同，执行不同方法体。 （2）对象的多态性：指发生在具有继承关系的类中，父类与子类的转换。 |- 向上转型（自动完成）：父类 父类对象 = 子类实例化; |- 向下转型（强制完成）：子类 子类对象 = （父类）父类实例化; 范例：向上转型 public class Demo { public static void main(String[] args) { A a = new B(); a.print(); // 覆写的方法 } } 范例：向下转型 public class Demo { public static void main(String[] args) { B b = (B) new A(); // 向下转型 b.print(); // 覆写的方法 } } 2、向上转型：由于子类对象都可以自动向上转型，所以可应用于参数的统一。 class A { public void print() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void print() { System.out.println(&quot;B覆写的方法&quot;); } } class C extends A { public void print() { System.out.println(&quot;C覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { A a1 = new B(); // 向上转型 A a2 = new C(); // 向上转型 a1.print(); // B覆写的方法 a2.print(); // C覆写的方法 } } a1,a2参数统一后，还可以调用子类覆写的方法，即同一个方法针对不同子类可以有不同实现。 3、向下转型：父类发生向上转型后，不能调用子类中自定义的方法。因此当父类要调用子类自定义方法时，需要进行向下转型，将父类对象变为子类对象。 class A { } class B extends A { public void fun() { System.out.println(&quot;自定义方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 a.fun(); // 报错，无法调用B自定义方法 } } 向下转型后，可以调用子类自定义的方法： class A { } class B extends A { public void fun() { System.out.println(&quot;自定义方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 B b = (B) a; // 向下转型 b.fun(); } } 问题：上述代码中不适用向下转型,直接实例化子类对象就可以直接调用fun(),为什么还要转型？ 答：数据的操作分为两步：设置数据（最需要进行参数统一）和取出数据。 public class Demo { public static void main(String[] args) { fun(new B()); // 向上转型 } public static void fun(A a){ // 统一参数 B b = (B) a; // 向下转型 b.fun(); // 调用子类自定义方法 } } 5、个性化操作在开发中尽量少出现，因为对象的强制转型容易带来安全隐患。 class A { public void print() { System.out.println(&quot;A.print()&quot;); } } class B extends A { public void print() { System.out.println(&quot;B.print()&quot;); } } public class Demo { public static void main(String[] args) { A a = new A(); B b = (B) a; b.print(); } } 上述代码会报错,Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at ExDemo.main(ExDemo.java:15)，表示类转换异常，指的是两个没有关系的类对象强制进行向下转型时发生的异常，因此向下转型存在风险。 为保证转型的安全性，Java提供关键字instanceof,其返回结果为boolean:对象 instanceof 类 如果某个对象是某个类的实例，则会返回true，反之返回false。 class A { public void print() { System.out.println(&quot;A.print()&quot;); } } class B extends A { public void print() { System.out.println(&quot;B.print()&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); System.out.println(a instanceof A); // true System.out.println(a instanceof B); // true if (a instanceof B) { B b = (B) a; b.print(); // B.print() } } } 向下转型前应先进行对象的向上转型，建立关系后才能进行向下转型。 总结： （1）大多数情况只使用向上转型，使得参数统一，便于程序设计；子类尽量覆写方法，而不是自定义方法； （2）极少情况使用向下转型调用子类的自定义方法，或者不转型。 抽象类 基本概念 1、抽象类是含有抽象方法的类。抽象方法没有方法体，必须用abstract定义。 abstract class A { // 抽象类 public void fun(){方法体;} // 普通方法 public abstract void print(); // 抽象方法 } public class Demo { public static void main(String[] args) { A a = new A(); // 报错，A是抽象类，无法实例化 } } 结果显示，无法直接实例化抽象类对象.普通类的对象实例化后,该对象可以调用类中的属性和方法.而抽象类中存在抽象方法,抽象方法没有方法体无法调用，因此无法产生实例化对象. 2、抽象类使用原则： （1）抽象类必须有子类； （2）抽象类的子类（非抽象类时）必须覆写抽象类中所有的抽象方法（强制子类进行方法覆写） （3）抽象类对象的实例化依靠子类完成，采用向上转型方式。 范例：使用抽象类 abstract class A { // 抽象类 public void fun() { // 普通方法 System.out.println(&quot;普通方法&quot;); } public abstract void print(); // 抽象方法 } class B extends A { // 强制要求对抽象方法进行覆写，否则会报错 public void print() { System.out.println(&quot;覆写后的抽象方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 a.fun(); a.print(); } } 由上述代码，可知： （1）抽象类的子类明确要求方法覆写，而普通类没有； （2）抽象类只比普通类多了抽象方法，其他部分相同； （3）抽象类对象必须经过向上转型才能实例化； （4）虽然子类可以继承任何类，但开发中，普通类最好继承抽象类。 使用限制 1、抽象类由于存在属性，因此会有构造方法来初始化属性。子类对象实例化时依然先执行父类构造方法，再调用子类构造方法。 2、抽象类不能使用final定义，因为抽象类必须有子类。 3、抽象外部类不允许使用static定义，而抽象内部类可以使用static声明。使用static定义的抽象内部类相当于抽象外部类，继承时使用外部类.内部类的形式表示类名。 abstract class A { // 抽象类 static abstract class B { public abstract void print(); } } class X extends A.B { public void print() { System.out.println(&quot;*****&quot;); } } public class Demo { public static void main(String[] args) { A.B ab = new X(); // 向上转型 ab.print(); } } 4、static定义的方法可以没有实例化对象的情况下直接调用，即使是抽象类中的static方法。 abstract class A { // 抽象类 public static void print() { System.out.println(&quot;static方法&quot;); } } public class Demo { public static void main(String[] args) { A.print(); // static方法 A a = new A() ; // 报错 } } 5、有时抽象类只需要一个特定的子类操作，因此可以将该子类定义为该抽象类的内部类。 abstract class A { // 抽象类 public abstract void print(); private static class B extends A { // 内部抽象类子类 public void print() { System.out.println(&quot;Hello&quot;); } } public static A getInstance() { // 获取B的实例化对象 return new B(); } } public class Demo { public static void main(String[] args) { // 客户端得到抽象类对象时，B对其不可见 A a = A.getInstance(); a.print(); } } 上述设计在系统类库中较为常见，目的是：为用户隐藏不需要知道的子类。 6、观察下述代码： abstract class A { // 抽象类 // 1. 先调用父类构造 public A() { this.print(); } public abstract void print(); } class B extends A { private int num = 100; // 3.调用子类构造，并初始化num = 30.运行结束，未输出初始化后的num public B(int num) { this.num = num; } // 2. 父类构造调用子类的print，此时num = 0,打印输出。 public void print() { System.out.println(&quot;num = &quot; + num); } } public class Demo { public static void main(String[] args) { new B(30); // 4. 结果为0 } } 在构造方法执行完之前，属性的内容均为其对应的数据类型的默认值。子类在执行构造方法前必先执行父类的构造方法，因为此时子类构造方法还没执行，就调用print()输出了num的值，所以num为0. 模板设计模式 要求：设计三个类，通过类描述如下行为： （1）机器人：充电、工作； （2）人：吃饭、工作、睡觉； （3）猪：吃饭、睡觉 思路：定义一个抽象类，具有吃饭、睡觉、工作的抽象方法。根据子类的不同，具体实现抽象方法。 abstract class Action { public static final int EAT = 1; public static final int SLEEP = 5; public static final int WORK = 7; public void command(int flag) { switch (flag) { case EAT: this.eat(); break; case SLEEP: this.sleep(); break; case WORK: this.work(); break; case EAT + WORK: this.eat(); this.work(); break; } } // 不确定方法中的具体行为，定义为抽象类 public abstract void eat(); public abstract void sleep(); public abstract void work(); } 定义子类： class Robot extends Action { public void eat() { System.out.println(&quot;机器人正在补充能量&quot;); } public void sleep() { } public void work() { System.out.println(&quot;机器人正在工作&quot;); } } class Human extends Action { public void eat() { System.out.println(&quot;人正在吃饭&quot;); } public void sleep() { System.out.println(&quot;人正在睡觉&quot;); } public void work() { System.out.println(&quot;人正在工作&quot;); } } class Pig extends Action { public void eat() { System.out.println(&quot;猪正在吃饭&quot;); } public void sleep() { System.out.println(&quot;猪正在睡觉&quot;); } public void work() { } } 范例：测试程序 public class Demo { public static void main(String[] args) { fun(new Robot()); fun(new Human()); fun(new Pig()); } public static void fun(Action act) { act.command(Action.EAT); act.command(Action.SLEEP); act.command(Action.WORK); } } 结果显示：子类要实现操作，必须按照Action类的标准。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"使用IDEA将SpringBoot打包成war","slug":"Spring Boot/使用IDEA将SpringBoot打包成war包","date":"2017-10-22T12:33:06.711Z","updated":"2017-10-22T12:48:32.912Z","comments":true,"path":"article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/","excerpt":"","text":"修改pom.xml 将package格式改为war &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; 排除内置tomcat &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 打包过程跳过测试 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; 打包 打开IDE右侧边栏的Maven Projects demo |- Lifecycle |- clean |- validate |- compile |- test |- package |- verify |- install |- site |- deploy |- Plugins |- Dependencies 双击package即可开始打包，打包后,会在项目文件target中。 发布war包 删除tomcat下webapps中的文件,将文件war包文件复制放入。点击tomcat中bin文件夹下的startup.bat，此时便可进行访问localhost查看SpringBoot。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.8.RELEASE) 20:45:57 CST 2017]; root of context hierarchy 2017-10-22 20:46:01.008 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello],methods=[GET]}&quot; onto public java.lang.String com.demo.DemoApplication.hello() 2017-10-22 20:46:01.016 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2017-10-22 20:46:01.030 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView 2017-10-22 20:46:01.635 INFO 5972 --- [ost-startStop-1] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup 2017-10-22 20:46:01.687 INFO 5972 --- [ost-startStop-1] com.demo.DemoApplication : Started DemoApplication in 5.963 seconds (JVM running for 11.781) 2017-10-22 20:46:02.385 WARN 5972 --- [ost-startStop-1] o.a.c.util.SessionIdGeneratorBase : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [682] milliseconds. application archive E:\\apache-tomcat-8.0.45\\webapps\\ROOT.war has finished in 10,051 ms 22-Oct-2017 20:46:02.430 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8888&quot;] 22-Oct-2017 20:46:02.454 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;] 22-Oct-2017 20:46:02.468 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 10192 ms 在上述信息中，告诉了我们可以访问的端口为8888.","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Java基础知识(十一)","slug":"Java Base/Java基础知识(十一)","date":"2017-10-22T07:53:56.490Z","updated":"2017-10-22T08:29:57.020Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十一)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十一)/","excerpt":"","text":"继承性 继承性的作用是解决代码重用问题。 继承问题的引出 范例:定义两个类Person和Student class Person{ private String name; private int age; public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age; } public String getName(){ return this.name; } public int getAge(){ return this.age; } } class Student{ private String name; private int age; private String school; public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age; } public void setSchool(String school){ this.school = school; } public String getName(){ return this.name; } public int getAge(){ return this.age; } public String getSchool(){ return this.school; } } 由代码可见Studen和Person存在代码重复。在自然关系上，Student是Person的一种，只是Student描述的更细致，范围更小。 实现继承 继承使用关键字extends实现，语法如下：class 子类 extends 父类{} 子类也被称为派生类，父类也被称为基类、超类或super类。 范例：实现继承 class Person { // 父类 private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student extends Person { // 继承Person类 } public class Demo { public static void main(String[] args) { Student stu = new Student(); stu.setName(&quot;张三&quot;); stu.setAge(18); System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;,年龄：&quot; + stu.getAge()); } } Student继承了Person，可以使用Person类中的方法。 范例：在Student中添加属性和方法 class Student extends Person { // 继承Person类 private String school; public String getSchool() { return school; } public void setSchool(String school) { this.school = school; } } 由上述代码，可知继承性的优点： （1）子类可以直接使用父类的属性和方法，进行代码重用； （2）子类可以扩充属于自己的操作。 继承的限制 Java中继承存在如下限制： 1、Java不允许多重继承，但允许多层继承。 C++允许多继承，即一个子类可以同时继承多个父类。但该操作在Java中是不允许的。多继承是为了使子类可以同时拥有多个父类的操作。Java中使用多层继承替代，语法如下： class A{} class B extends A{} class C extends B{} 相当于C是B的子类，是A的孙子类。多层继承没有层数限制，但最好不超过三层。 2、子类继承父类时，会继承父类全部操作。对于私有操作属于隐式继承，对于非私有操作属于显式继承。 class A { private String msg; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } class B extends A { } public class Demo { public static void main(String[] args) { B b = new B(); b.setMsg(&quot;Hello&quot;); System.out.println(b.getMsg()); // Hello } } 上述代码显示B类中也存在属性msg,因为如果msg不存在，setMsg()设置的内容就不能保存，即getMsg()无法输出内容。 class B extends A { public void fun() { System.out.println(msg); // 报错，无法访问 } } 但是在B类中无法直接访问msg，因为msg是A类的私有属性，只能间接访问。 3、在实例化子类对象之前，会先调用父类构造方法（默认是无参构造方法），以保证父类对象先实例化，而后在实例化子类对象。 class A { public A() { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B() { System.out.println(&quot;B 构造方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); // A 构造方法 // B 构造方法 } } 由结果可知，在实例化子类对象前，会先实例化父类对象。对于子类构造方法来说相当于隐藏一个”super()”. class B extends A { public B() { super(); // 父类有无参构造方法时，加不加都一样 System.out.println(&quot;B 构造方法&quot;); } } 何时要在子类构造方法中添加super()：如果父类中没有无参构造方法，就必须使用super调用父类的有参构造方法。 class A { public A(String title) { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B() { // 子类默认调用无参构造，但A中没有无参构造 System.out.println(&quot;B 构造方法&quot;); } } 上述代码执行后，不会调用A中的有参构造，因此需要在B类中的构造方法添加super(): class A { public A(String title) { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B(String title) { super(title); System.out.println(&quot;B 构造方法&quot;); } } super()必须放在子类构造方法的第一行。而this()也应该放在构造方法的首行。 问题：子类构造方法未添加super()，系统默认使用super()调用父类的无参构造方法。如果在子类构造方法中添加this()，那么子类是不是无法调用父类构造方法？ class B extends A { public B() { // 报错，构造递归调用 this(); System.out.println(&quot;B 构造方法&quot;); } } 由结果可知，super()和this()不能同时存在。不论子类怎么修改，子类构造方法执行前都必须先执行父类的构造方法。 方法覆写 继承性的特点是子类可以对父类已有的功能进行扩展。子类在定义属性或方法时有可能与父类重名，该操作就称为覆写。 1、方法覆写：子类定义一个与父类方法的方法名、参数类型及个数、返回值都相同的方法。 class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // A中的方法 } } 此时B中没有fun()，所以调用的是从A继承的fun(). 范例：方法覆写 class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void fun(){ // 方法覆写 System.out.println(&quot;覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // 覆写的方法 } } 当方法覆写后，此时会调用子类中覆写的方法。 2、覆写结果的分析要素： （1）实例化的是那个类； （2）该对象调用的方法是否被覆写，如果未覆写将调用父类中的方法。 class B extends A { public String fun(){ System.out.println(&quot;覆写的方法&quot;); // 报错，B中fun()无法覆盖A中fun()，返回类型不兼容 return &quot;Hello&quot;; } } 进行方法覆写时，不能改变方法中的返回值和参数个数。 3、方法覆写的使用原则：父类方法不能满足子类需求，但又必须使用该方法名时，要进行方法覆写。 方法覆写时还要考虑到权限问题，被子类覆写的方法不能拥有比父类更高的访问控制权限。 访问控制权限：public&gt;default&gt;private，private的访问权限最严格。即如果父类方法使用public方法，子类覆写此方法时，只能使用public。父类使用的是default，子类覆写时，只能用default或public. 范例：正确覆写 class A { void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void fun(){ System.out.println(&quot;覆写的方法&quot;); } } 错误覆写： class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { void fun(){ System.out.println(&quot;覆写的方法&quot;); // 报错，正在尝试分配更低权限。 } } 上述代码中子类使用default，比public权限更严格，不符合方法覆写原则。 问题：父类方法使用private声明，子类使用public声明该方法，是覆写吗？ 答：从概念上，private声明权限高于public，因此从权限上而言符合覆写的要求。观察下述代码： class A { public void fun() { print(); } private void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // Hello } } 从上述代码来看，子类并没有覆写print()，因为使用private定义的方法对于子类而言是不可见，因此子类定义的print()虽然符合覆写的要求，但是实际只是相当于定义了一个全新的方法，而不是方法覆写。而正确的覆写结果应该如下： class A { public void fun() { print(); } public void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // World } } 5、默认情况下，子类对象调用是一定是覆写后的方法。 class A { public void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ print(); // 等同于this.print() System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); // 报错，方法递归调用，死循环 } } 上述代码中，B类会优先调用B中print()，因此发生了递归调用。如果B中没有print()，则会调用父类中的。 范例：调用父类中方法super.方法名() class B extends A { public void print(){ super.print(); System.out.println(&quot;World&quot;); } } super.方法名()与this.方法名()的区别： （1）this.方法名()会优先查找本类中是否有目标方法，如果有则直接调用，没有就继续在父类中查找。 （2）super.方法名()会直接在父类中查找目标方法，不会在子类中查找。 问题：请说明重载（overloading）和覆写（override）的区别 No. 区别 重载 覆写 1 英文单词 Overloading Overrid 2 发生范围 发生在一个类中 发生在继承关系中 3 定义 方法名相同，参数类型及个数不相同 方法名称、参数类型及个数，方法返回值都相同 4 权限 没有权限限制 被覆写的方法不能拥有比父类更严格的权限 在方法重载时，返回值可以不同，但为了程序设计的统一性，应尽量保证返回值类型一致。 属性覆写 1、子类定义了与父类完全相同的属性名时，称为属性覆写。 class A { String info = &quot;Hello&quot;; } class B extends A { String info = &quot;World&quot;; public void print(){ System.out.println(super.info); // 调用父类属性 System.out.println(this.info); // 调用本类属性 } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); } } 由于在开发中，类的属性必须封装，而封装后，属性覆写就没有意义。因为父类定义的私有属性，子类不可见，因此不会互相影响。 问题：super和this的区别 No. 区别 this super 1 功能 调用本类中的操作 子类调用父类中的操作 2 形式 先从本类查找目标操作,再从父类中查找 只查找父类 3 特殊 表示本类的当前对象 super不能单独使用 在开发中，对于本类或父类的操作，最好加上this.或super.，这样便于代码调试。 继承综合实战：数组操作 要求：定义Array类，在类中可以进行整型数组的操作：由外部传入数组的数据，可以进行数据的保存和输出，并且在这个类上派生出两个子类： （1）排序类：通过此类取得的数据可以进行排序； （2）反转类：通过此类取得的数据采用倒序的方式输出。 开发时，先不考虑子类，先开发父类。 根据要求定义父类Array，实现其操作。 思路：开辟好数组后，根据索引，一一存放数据。 class Array { private int data[]; // 数组 private int foot; // 脚标 // 开辟数组空间 public Array(int len) { if (len &gt; 0) { this.data = new int[len]; } else { // 数组默认长度为1 this.data = new int[1]; } } // 为数组添加数据 public boolean add(int num) { if (this.foot &lt; this.a[this.foot++] = num; // 保存数据 return true; } return false; } // 取得数组内容 public int[] getData() { return this.data; } } public class Demo { public static void main(String[] args) { Array array = new Array(3); System.out.println(array.add(10)); // true System.out.println(array.add(20)); // true System.out.println(array.add(30)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } ####定义子类。 思路：将Array类getData()返回的结果进行排序输出即可，因此要覆写父类的方法。 // 定义一个排序数组的子类 class SortArray extends Array { // Array中没有无参构造方法， // 需要明确调用父类的有参构造方法 public SortArray(int len) { super(len); } // Array的getData()无法排序，进行方法覆写 public int[] getData() { // 调用类库中的方法排序 java.util.Arrays.sort(super.getData()); return super.getData(); } } public class Demo { public static void main(String[] args) { SortArray array = new SortArray(3); System.out.println(array.add(20)); // true System.out.println(array.add(30)); // true System.out.println(array.add(10)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } ####定义反转子类，也要保持客户端操作不变，因此要覆写父类的方法。 // 定义一个反转子类 class ReverseArray extends Array { public ReverseArray(int len) { super(len); } public int[] getData() { int center = super.getData().length / 2; int head = 0; int tail = super.getData().length - 1; for (int x = 0; x &lt; center; x++) { int temp = super.getData()[head]; super.getData()[head] = super.getData()[tail]; super.getData()[tail] = temp; head++; tail--; } return super.getData(); } } public class Demo { public static void main(String[] args) { ReverseArray array = new ReverseArray(3); System.out.println(array.add(20)); // true System.out.println(array.add(10)); // true System.out.println(array.add(30)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } 总结： 子类扩充方法时，尽量根据需求覆写父类方法，而不是直接定义新方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"SpringBoot小例子进阶","slug":"Spring Boot/SpringBoot小例子进阶","date":"2017-10-21T05:42:31.770Z","updated":"2017-10-21T13:10:31.827Z","comments":true,"path":"article/框架/Spring Boot/SpringBoot小例子进阶/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子进阶/","excerpt":"","text":"本部分代码是基于SpringBoot基础应用博文的。 代码结构如下： demo // 项目名 |- .idea |- .mvn |- src // 代码存放区 |- main |- java |- com.example.demo // java包 |- aspect // 拦截器 |- HttpAspect.java |- controller // 控制器 |- PersonController |- domain // 实体类 |- Person |- Result // 定义异常的响应信息的格式 |- enums |- ResultEnum // 定义异常的code和信息 |- exception // 自定义异常 |- PersonException |- handle // 捕获异常 |- ExceptionHandle |- repository // jpa操作 |- PersonRepository |- service // 处理业务逻辑 |- PersonService |- DemoApplication.java // 项目启动类 |- resources |- static // 用于存放css,js等样式文件 |- templates // 用于存放html文件 application.properties // 项目配置文件 |- test //测试代码存放区 |- target .gitignore mvnw mvnw.cmd demo.iml pom.xml // 项目对象模型,添加项目依赖等配置 实现表单验证 要求： age小于18的数据无法入库 修改Person类 package com.example.demo.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.validation.constraints.Min; @Entity public class Person { @Id @GeneratedValue private Integer id; private String name; // @Min 使得该属性必须大于18,当数值小于18时,有提示信息 @Min(value = 18, message = &quot;年龄小于18无法添加&quot;) private Integer age; public Person() { } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 修改PersonController类addPerson() /** * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据 * @param person 要添加的person对象 * @param bindingResult 获取绑定结果信息 * @return 返回Person类信息 */ @PostMapping(value = &quot;/person&quot;) public Person addPerson(@Valid Person person, BindingResult bindingResult) { // 当输入数据不符合要求时,后台输出错误信息 if (bindingResult.hasErrors()) { System.out.println(bindingResult.getFieldError().getDefaultMessage()); return null; } return personRepository.save(person); } @Valid用于对传入的数据进行校验。 使用AOP处理请求 什么是AOP (1)AOP(面向切面, Aspect Oriented Programming)是一种编程范式,是一种程序设计思想。思想是将通用逻辑从业务逻辑中分离出来 将纵向的分析变为横向分析,从而将通用逻辑从业务逻辑中分离出来。 (2)除了AOP还有OOP(面向对象,Object Oriented Programming),POP(面向过程,Proceduer Oriented Programming) AOP统一处理请求日志 要求：记录每一个http请求 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 创建HttpAspect类 @Aspect实现切面注入;@Component将该类注册到SpringBoot容器中 package com.example.demo.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; // 切面注入 @Aspect @Component public class HttpAspect { // 日志对象 private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect .class); // 指明哪些方法需要执行AOP @Pointcut(&quot;execution(public * com.example.demo.controller.PersonController&quot; + &quot;.*(..))&quot;) public void log() {} /** * 该方法功能是将请求中的信息输出至日志中 * @Before 在使用PersonController中方法前先执行该注解下的方法 * @param joinpoint 目标类连接点对象 */ @Before(&quot;log()&quot;) public void doBefore(JoinPoint joinpoint) { ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 获取url LOGGER.info(&quot;url = {}&quot;, request.getRequestURL()); // 获取请求方式 LOGGER.info(&quot;method = {}&quot;, request.getMethod()); // 获取请求方的ip LOGGER.info(&quot;ip = {}&quot;, request.getRemoteAddr()); // 获取被调用的方法名 LOGGER.info(&quot;class_method = {}&quot;, joinpoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinpoint.getSignature().getName() + &quot;()&quot;); // 获取请求参数 LOGGER.info(&quot;args = {}&quot;, joinpoint.getArgs()); } /** 该方法功能是将响应中的信息输出至日志中 * @AfterReturning 使得该类可以接收HttpResponse中对象信息 * @param object 返回的对象信息 */ @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;) public void doAfterReturning(Object object) { LOGGER.info(&quot;response = {}&quot;, object.toString()); } } 统一异常处理 要求:获取Person对象的age并判断 age &lt; 12 : 返回&quot;正在上小学&quot; age &gt; 12 &amp;&amp; age &lt; 15: 返回&quot;正在上初中&quot; 定义异常响应信息格式 package com.example.demo.domain; public class Result&lt;T&gt; { private Integer code; // 错误码 private String msg; // 提示信息 private T data; // 具体内容 public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public T getData() { return data; } public void setData(T data) { this.data = data; } } 自定义异常类 package com.example.demo.exception; import com.example.demo.enums.ResultEnum; public class PersonException extends RuntimeException { private Integer code; public PersonException(ResultEnum resultEnum) { super(resultEnum.getMsg()); this.code = resultEnum.getCode(); } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } } 规范响应code和msg package com.example.demo.enums; public enum ResultEnum { UNKNOW_ERROR(-1, &quot;未知错误&quot;), SUCCESS(200, &quot;添加成功&quot;), PRIMARY_SCHOOL(403, &quot;在上小学&quot;), MIDDLE_SCHOOL(404, &quot;在上初中&quot;), ; private Integer code; private String msg; ResultEnum(Integer code, String msg) { this.code = code; this.msg = msg; } public Integer getCode() { return code; } public String getMsg() { return msg; } } 进行异常捕获 package com.example.demo.handle; import com.example.demo.domain.Result; import com.example.demo.exception.PersonException; import com.example.demo.util.ResultUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class ExceptionHandle { private final static Logger LOGGER = LoggerFactory.getLogger (ExceptionHandle.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Result handle(Exception e){ if (e instanceof PersonException) { PersonException personException = (PersonException) e; return ResultUtil.error(personException.getCode(), personException.getMessage()); } else { LOGGER.error(&quot;[系统异常] {}&quot;, e); return ResultUtil.error(-1, &quot;未知错误&quot;); } } } 进行逻辑判断,从而判断异常 package com.example.demo.service; import com.example.demo.domain.Person; import com.example.demo.enums.ResultEnum; import com.example.demo.exception.PersonException; import com.example.demo.repository.PersonRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PersonService { @Autowired private PersonRepository personRepository; public void getAge(Integer id) throws Exception{ Person person = personRepository.findOne(id); Integer age = person.getAge(); if (age &lt; 10) { throw new PersonException(ResultEnum.PRIMARY_SCHOOL); } else if (age &gt; 10 &amp;&amp; age &lt; 16) { throw new PersonException(ResultEnum.MIDDLE_SCHOOL); } } } 单元测试 对Service进行测试 package com.example.demo; import com.example.demo.domain.Person; import com.example.demo.service.PersonService; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class PersonServiceTest { @Autowired private PersonService personService; @Test public void findOneTest() { Person person = personService.findOne(9); // 断言 Assert.assertEquals(new Integer(19), person.getAge()); } } 对API进行测试 package com.example.demo.controller; import com.example.demo.domain.Person; import com.example.demo.repository.PersonRepository; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet .AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class PersonControllerTest { @Autowired private MockMvc mockMvc; @Test public void personList() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person&quot;)). // 对状态码进行断言 andExpect(MockMvcResultMatchers.status().isOk()). // 对响应文本进行断言 andExpect(MockMvcResultMatchers.content().string(&quot;&quot;)); } }","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Java基础知识(十)","slug":"Java Base/Java基础知识(十)","date":"2017-10-18T02:24:29.526Z","updated":"2017-10-21T05:59:07.647Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十)/","excerpt":"","text":"链表 链表是引用的加强应用. 知识点前提：依赖于引用传递；this表示当前对象。 链表基本概念 1.链表是一种简单的数据结构，功能是依靠引用关系实现多个数据的保存。 根据上图编写代码： 要求：定义一个Node类，保存String类型数据，同时拥有下一个节点的引用。 // 每个链表由多个节点组成 class Node { // 定义节点类 private String data; // 要保存的数据 private Node next; // 要保存的下一个节点 // 每个Node对象都必须保存相应的数据 public Node(String data) { // 有数据才有Node this.data = data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } public String getData() { return this.data; } } Node类专门负责保存节点关系，需要其他类负责Node之间的关系匹配。 范例：使用循环取出数据 public class Demo { public static void main(String[] args) { // 1. 设置数据 Node root = new Node(&quot;火车头&quot;); Node n1 = new Node(&quot;车厢A&quot;); Node n2 = new Node(&quot;车厢B&quot;); root.setNext(n1); n1.setNext(n2); // 2. 取出数据 Node currentNode = root; //从根节点开始读取数据 while (currentNode != null) { // 当前节点存在数据 System.out.println(currentNode.getData()); // 将下一节点设置为当前节点 currentNode = currentNode.getNext(); } } } 利用循环取出数据不够便捷，应使用递归。 范例：使用递归取出数据 public class Demo { public static void main(String[] args) { // 1. 设置数据 Node root = new Node(&quot;火车头&quot;); Node n1 = new Node(&quot;车厢A&quot;); Node n2 = new Node(&quot;车厢B&quot;); root.setNext(n1); n1.setNext(n2); print(root); } public static void print(Node current){ if (current == null){ // 节点不存在 return ; // 结束方法调用 } System.out.println(current.getData()); print(current.getNext()); // 递归调用 } } 因为循环次数未知，所以使用while循环。节点操作中，递归比while循环更直观。 问题：为什么要设置Node类 答：数据本身不具有先后关系，因此需要使用Node类封装份数据，同时利用Node类指向下一节点。 链表基本实现 通过分析发现： (1)用户操作过程中，Node类应该是不可见的，即用户无需关注Node类的结构 (2)Node之间的关系不应该由用户定义，而应该由一个专门的类处理。 范例：定义Link类，隐藏Node类 程序要描述的步骤如下： 第一步： 第二步： 第三步： 第四步： // 处理Node对象间关系 class Link { private Node root; // 根节点 // 设置数据 public void add(String data) { // 为了设置数据的先后关系，将data包装在Node对象中 Node newNode = new Node(data); if (this.root == null) { // 保存数据时，根节点不存在 // 该判断执行一次，因为链表只有一个根节点 this.root = newNode; // 将新节点设置为根节点 } else { // 根节点存在 // 新节点应交给Node决定 // 从root之后设置合适的位置 this.root.addNode(newNode); } } // 输出数据 public void print() { if (this.root != null) { this.root.printNode(); } } } 范例:根据Link类，修改Node类 class Node { private String data; private Node next; public Node(String data) { this.data = data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } public String getData() { return this.data; } // 添加节点 // 第一次Link调用: this = link.root // 第二次Node调用：this = link.root.next // 第三次Node调用：this = link.root.next.next public void addNode(Node newNode) { if (this.next == null) { // 当前节点的next为空 this.next = newNode; // 保存为新节点 } else { // 当前节点的next的next继续保存 this.next.addNode(newNode); } } // 第一次Link调用: this = link.root // 第二次Node调用：this = link.root.next // 第三次Node调用：this = link.root.next.next public void printNode() { System.out.println(this.data); // 输出当前节点数据 if (this.next != null) { // 当前节点有next this.next.printNode(); // 输出next节点信息 } } } 范例：测试 public class Demo { public static void main(String[] args) { Link link = new Link(); // 负责数据操作 // 增加数据 link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); // 输出数据 link.print(); } } 由上述代码可知链表操作的基本特点： （1）对于客户端而言Node是不可见的，只能利用Link中的方法 （2）Link类的功能是控制Node对象的产生和根节点的使用； （3）Node类的功能是保存数据以及配置引用关系。 可用链表基本结构 1.可用链表指的是能实现数据的增删改查的链表。 2.可用链表开发要求：Node类负责节点数据的保存以及节点关系的匹配，因此Node类不能被单独使用，即外部不能绕过Link去使用Node 范例：修改Node结构，使得Node类只能被Link类使用 思路：将Node类变为private定义的内部类。 class Link { // 链表类，外部可见 // Node定义在内部让其只为Link服务 private class Node { private String data; // 保存数据 private Node next; // 引用关系 public Node(String data) { this.data = data; } } // ====================以上为内部类===================== private Node root; // 根节点 } 上述代码即为可用链表的基本结构，后续为其增加功能代码。 增加数据功能 思路：数据的增加应由Link负责节点对象的产生，以及根节点的维护。节点间的关系匹配，由Node类处理。 范例：Node类中添加addNode()，Link类中添加add() // 设置关系 public void addNode(Node newNode) { if (this.next == null) { this.next = newNode; } else { this.next.addNode(newNode); } } public void add(String data) { if (data == null) { // 输入数据为空 return; } Node newNode = new Node(data); // 要保存的数据 if (this.root == null) { // 根节点不存在 this.root = newNode; // 设为根节点 } else { // 根节点存在，交由Node处理 this.root.addNode(newNode); } } 范例：测试 public class Demo { public static void main(String[] args) { Link link = new Link(); link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); } } 获取链表长度 思路：每个链表对象都只有一个root，可以在Link类中设置count属性，随后每次添加数据后，count自增。 范例：修改Link类 （1）增加count属性:private int count = 0; // 节点的个数 （2）在add()添加统计节点个数的操作 public void add(String data) { if (data == null) { return; } Node newNode = new Node(data); if (this.root == null) { this.root = newNode; } else { // this.root.addNode(newNode); } this.count++; // 每次增加节点，count+1 } （3）添加获取链表长度的方法size() public int size() { return this.count; } （4）判断链表是否为空，有两种方式，一是判断root是否为null，二是判断count是否为0，在此采用第二种方式，在Link类中添加isEmpty() public boolean isEmpty() { return this.count == 0; } 内容查询 思路：判断链表中是否存在某数据，以String为例，仅需遍历链表中的数据，与要查询的数据记性匹配（使用equals(String str)），如果匹配成功返回true，反之返回false。 根据上图编写代码： （1）Link中添加contains() public boolean contains(String data) { if (data == null || root == null) { return false; } return this.root.containsNode(data); } Link从root节点开始查询数据是否存在，数据不存在，Node开始查询非根节点。 （2）Node中添加containsNode() public boolean containsNode(String data) { if (data.equals(this.data)) { // 当前数据等于要目标数据 return true; // 结束查询 } else { // 当前数据不等于目标数据 if (this.next != null) { // 有后续节点 return this.next.containsNode(data); } else { return false; } } } （3）测试 public class Demo { public static void main(String[] args) { Link link = new Link(); link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); System.out.println(link.contains(&quot;火车头&quot;)); } } 案例中使用的是String类型数据，所以判断数据使用equals(String str)。如果判断的是自定义类型数据，就需要定义一个对象比较的方法，方法名暂定为compare()。 根据索引取得数据 链表中保存有多个对象。数组也可以保存多个对象。链表和数组相比优势在于没有长度限制。因此链表相当于一个动态对象数组，具备像数组那样根据索引取得元素的功能。 由于是动态对象数组，所以元素的索引也是动态生成的。 根据上图，编写代码： （1）Link中增加foot属性，表示Node的索引:private int foot = 0; // 索引 每次查询前，应该重置为0.链表查询数据前应先判断要查询的索引小于索引总数。 public String get(int index) { if (index &gt; this.count) { // 超出查询范围 return null; } this.foot = 0; return this.root.getNode(index); // 查询交给Node类 } （2）Node定义getNode()，内部类和外部类间可以方便地进行私有属性的访问。 public String getNode(int index) { // 当前foot内容与要查询的索引比较 // foot自增，目的是下次查询方便 if (Link.this.foot++ == index) { return this.data; } else { return this.next.getNode(index); } } 修改链表数据 修改和查询思路差不多，不同的是查询是当满足索引值时，返回数据；修改是满足索引时，对数据重新赋值。 （1）Link添加set(int index, String data) public void set(int index, String data) { if (index &gt; this.count) { return; } this.foot = 0; // 重置foot,作为索引 this.root.setNode(index, data); // Node进行修改数据 } （2）Node添加setNode(int index, String data) public void setNode(int index, String data) { if (Link.this.foot++ == index) { this.data = data; } else { this.next.setNode(index, data); } } 删除链表数据 删除链表数据应分为两种情况： （1）要删除的是根节点，root.next()变为root，在Link中处理，因为由Link来维护root； （2）要删除的是非根节点，当前节点的上一节点.next()=当前节点.next()，即空出了当前节点。非根节点应交由Node处理。 1.Node添加removeNode(Node previous, String data) public void removeNode(Node previous, String data) { // 参数中传递上一个节点和要删除的数据 if (data.equals(this.data)) { previous.next = this.next; } else { this.next.removeNode(this, data); } } Link添加remove(String data) public void remove(String data) { if (this.contains(data)) { // 判断数据是否存在 if (data.equals(this.root.data)) { // 判断数据是否是root数据 this.root = this.root.next; } else { // root是Node对象，此处直接访问内部类私有操作 this.root.next.removeNode(this.root, data); } this.count -- ; // 删除后数据个数减少 } } 对象数组转换 开发中，类中不应该有输出语句。想输出数据应将数据返回到调用处。链表属于动态数组，因此可以将链表以对象数组的形式返回。 由上图可知，Link的toArray()要返回一个对象数组，且该数组也要由Node操作。因此该数组应定义为Link的属性。 （1）Link添加一个数组属性，便于Node和Link访问。添加toArray() private String[] retArray; // 返回的数组 public String[] toArray() { if (this.root == null) { return null; } this.foot = 0; // 需要脚标控制 this.retArray = new String[this.count]; // 根据保存内容开辟数组 this.root.toArrayNode(); return this.retArray; } （2）Node添加toArrayNode()进行数组数据保存 public void toArrayNode() { Link.this.retArray[Link.this.foot++] = this.data; if (this.next != null) { this.next.toArrayNode(); } } 链表数据变为对象数组取出是重要功能！ 链表使用 上述链表只能操作String数据。下面要使用链表操作自定义类，由于链表具有contains()，因此类中需定义对象比较的方法。 （1）定义Book类（setter/getter暂时省略） class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo() { return &quot;书名：&quot; + this.title + &quot;,价格&quot; + this.price; } public boolean compare(Book book) { if (book == null) { return false; } if (this == book) { return true; } if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } else { return false; } } } （2）修改链表 class Link { private class Node { // 节点类 private Book data; // 保存数据 private Node next; // 引用关系 public Node(Book data) { this.data = data; } // 设置关系 public void addNode(Node newNode) { if (this.next == null) { this.next = newNode; } else { this.next.addNode(newNode); } } // 数据查询 public boolean containsNode(Book data) { if (data.equals(this.data)) { // 当前数据等于要目标数据 return true; // 结束查询 } else { // 当前数据不等于目标数据 if (this.next != null) { // 有后续节点 return this.next.containsNode(data); } else { // 没有后续节点 return false; } } } public Book getNode(int index) { // 当前foot内容与要查询的索引比较 // foot自增，目的是下次查询方便 if (Link.this.foot++ == index) { return this.data; } else { return this.next.getNode(index); } } // 修改节点信息 public void setNode(int index, Book data) { if (Link.this.foot++ == index) { this.data = data; } else { this.next.setNode(index, data); } } // 删除非根节点 public void removeNode(Node previous, Book data) { // 参数中传递上一个节点和要删除的数据 if (data.equals(this.data)) { previous.next = this.next; } else { this.next.removeNode(this, data); } } public void toArrayNode() { Link.this.retArray[Link.this.foot++] = this.data; if (this.next != null) { this.next.toArrayNode(); } } } // ====================以上为内部类===================== private Node root; // 根节点 private int count = 0; // 节点的个数 private int foot = 0; // 索引 private Book[] retArray; // 返回的数组 public void add(Book data) { if (data == null) { // 输入数据为空 return; } Node newNode = new Node(data); // 要保存的数据 if (this.root == null) { // 根节点不存在 this.root = newNode; // 设为根节点 } else { // 根节点存在，交由Node处理 this.root.addNode(newNode); } this.count++; // 每次增加节点，count+1 } // 获取链表长度 public int size() { return this.count; } // 判断是否为空链表 public boolean isEmpty() { return this.count == 0; } // 判断数据是否存在 public boolean contains(Book data) { if (data == null || root == null) { return false; } return this.root.containsNode(data); } // 根据索引获取信息 public Book get(int index) { if (index &gt; this.count) { // 超出查询范围 return null; } this.foot = 0; return this.root.getNode(index); // 查询交给Node类 } // 设置信息 public void set(int index, Book data) { if (index &gt; this.count) { return; } this.foot = 0; // 重置foot,作为索引 this.root.setNode(index, data); // Node进行修改数据 } // 判断删除节点是否为root public void remove(Book data) { if (this.contains(data)) { // 判断数据是否存在 if (data.equals(this.root.data)) { // 判断数据是否是root数据 this.root = this.root.next; } else { // root是Node对象，此处直接访问内部类私有操作 this.root.next.removeNode(this.root, data); } this.count--; // 删除后数据个数减少 } } public Book[] toArray() { if (this.root == null) { return null; } this.foot = 0; // 需要脚标控制 this.retArray = new Book[this.count]; // 根据保存内容开辟数组 this.root.toArrayNode(); return this.retArray; } } （3）测试 public class Demo { public static void main(String[] args) { Link all = new Link(); all.add(new Book(&quot;Java开发&quot;, 69.8)); all.add(new Book(&quot;JSP&quot;, 78.8)); all.add(new Book(&quot;C++开发&quot;, 19.8)); System.out.println(&quot;保存书的个数：&quot; + all.size()); System.out.println(all.contains(new Book(&quot;Java开发&quot;, 69.8))); all.remove(new Book(&quot;C++开发&quot;, 19.8)); Book[] books = all.toArray(); for (int x = 0; x &lt; books.length; x++) { System.out.println(books[x].getInfo()); } } } 链表的最佳应用就是横向替换对象数组。 在映射中使用链表 链表属于动态对象数组。之前进行数据表映射时，都会出现对象数组的概念，现在就用链表来进行对象保存。本节以一对多为例，即用前文中的省份-城市表为例： （1）对于使用链表的类，要添加对象比较的方法 class Province { private int pid; private String pname; private Link cities = new Link(); public Link getCities() { return this.cities; } //getter/setter,无参构造方法略 public Province(int pid, String pname) { this.pid = pid; this.pname = pname; } public boolean compare(Province province) { if (province == null) { return false; } if (this == province) { return true; } if (this.pid == province.pid &amp;&amp; this.pname.equals(province.pname)) { return true; } else { return false; } } public String getInfo() { return &quot;省份ID：&quot; + this.pid + &quot;,省份名称：&quot; + this.pname; } } class City { private int cid; private String cname; private Province province; public void setProvince(Province province) { this.province = province; } public Province getProvince() { return this.province; } //getter/setter,无参构造方法略 public City(int cid, String cname) { this.cid = cid; this.cname = cname; } public String getInfo() { return &quot;城市ID：&quot; + this.cid + &quot;,城市名称：&quot; + this.cname; } public boolean compare(City city) { if (city == null) { return false; } if (this == city) { return true; } if (this.cid == city.cid &amp;&amp; this.cname.equals(city.cname) &amp;&amp; this.province.compare(city.province)) { return true; } else { return false; } } } 此时只需将链表中的Book改为City即可。 在此时发现问题：每定义一个新的类，链表就需要重新进行修改。方法解决了代码重复问题。但是该问题不属于代码重复，属于数据类型不同意，该问题需要依靠面向对象的特性的来结局。 总结 （1）本章所讲的只是最基础的单向链表； （2）链表中应有如下方法： No. 方法名称 类型 作用 1 public void add(数据类型 变量) 普通 向链表中添加数据 2 public int size() 普通 取得链表中数据个数 3 public boolean isEmpty() 普通 判断是否为空链表 4 public boolean contains(数据类型 变量) 普通 判断数据是否存在 5 public 数据类型 get(int index) 普通 根据索引取得数据 6 public void set(int index,数据类型 变量) 普通 修改数据 7 public void remove(数据类型 变量) 普通 删除指定数据 8 public 数据类型 [] toArray() 普通 将链表以对象数组的形式转换","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(九)","slug":"Java Base/Java基础知识(九)","date":"2017-10-15T01:28:21.489Z","updated":"2017-10-21T05:58:17.385Z","comments":true,"path":"article/Java/Java Base/Java基础知识(九)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(九)/","excerpt":"","text":"代码块 代码块是{}定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：普通代码块，构造块，静态块和同步代码块。 普通代码块 1.写在方法中的代码块，称为普通代码块。 public class Demo { public static void main(String[] args) { { // 普通代码块 int num = 10; // 局部变量 System.out.println(&quot;num = &quot; + num); // 10 } int num = 100; // 全局变量 System.out.println(&quot;num = &quot; + num); // 100 } } 普通代码块的功能是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。 构造块 1.写在类中的代码块，称为构造块。 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // B. Book类的构造块 // A. Book类的构造方法 } } 输出结果显示：构造块的调用优先于构造方法。 静态块 static定义的代码块，称为静态块。静态块的使用，分为两种情况： 1.在非主类中使用 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } static { System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // C B A new Book(); // B A } } 结果显示：**静态块优先于构造块。**且不论实例化多少个对象，静态块只执行一次。static主要功能是为类中的static属性初始化。 class Book { public static String msg; static { msg = &quot;Hello&quot;.substring(0,2); System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { System.out.println(Book.msg); } } 2.在主类中定义 public class Demo { static { System.out.println(&quot;**************&quot;); } public static void main(String[] args) { System.out.println(&quot;Hello World !&quot;); // ************** // Hello World ! } } 结果显示：静态块优先于main()方法执行。在编写测试时，可以使用静态块。 内部类 从开发角度来说，尽量不要使用内部类 内部类基本概念 1.内部类是指在一个类的内部定义其他的类。 范例：内部类 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象，调用print()方法 new Inner().print(); } } public class Demo { public static void main(String[] args) { // 实例化外部类对象 Outer out = new Outer(); out.fun(); // 调用外部类方法，Hello World } } 上述代码牺牲了程序的结构，实现了一个重要功能。 2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。 范例：取出内部类 class Outer { private String msg = &quot;Hello World&quot;; public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(msg); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); // 报错，msg属于Outer，Inner无法调用 } } （1）要想使得Inner调用msg，就需在Outer中写一个getMsg() public String getMsg(){ return this.msg; } （2）Inner要调用Outer的getMsg()方法，必须实例化一个Outer对象 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg(){ return this.msg; } public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(new Outer().getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg() { return this.msg; } public void fun() { new Inner(this).print(); } } class Inner { private Outer out; public Inner(Outer out) { this.out = out; } public void print() { System.out.println(this.out.getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 由此可得内部类的特点： 内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。 范例：访问内部类私有属性 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象 Inner in = new Inner(); // 使用内部类对象访问内部类私有属性 System.out.println(in.info); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 3.观察代码 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(this.msg); // 报错，找不到msg } } public void fun() { new Inner().print(); } } 报错原因：this.msg指向的是Inner类，而Inner类中没有msg属性。因此要访问Outer的msg属性，需要使用Outer.this.msg. class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } public void fun() { new Inner().print(); } } 4.内部类的class文件名: Outer$Inner.class 直接实例化内部类对象语法：外部类.内部类 对象名 = new 外部类().new 内部类(); 范例：实例化内部类对象 public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.print(); } } 上述代码说明： 要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。 5.内部类只想被外部类使用，不能被外部调用，应使用private定义 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; private class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } } static定义内部类 使用static定义的属性或方法不受实例化对象控制，因此使用static定义的内部类也不受外部类实例化对象控制。 1.static定义的内部类只能访问外部类中static定义的属性或方法 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); // 报错，无法引用非静态变量msg } } } 2.static定义的内部类，相当于外部类 取得static定义的内部类对象语法：外部类.内部类 对象 = new 外部类.内部类();由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于内部类成了一个外部类。 class Outer { // 外部类 private static String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); } } } public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer.Inner(); in.print(); } } 方法中定义内部类 1.内部类可定义在外部类中的任意位置。在方法中定义内部类是最常见的形式。 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun() { class Inner { // 定义在方法中的内部类 public void print() { System.out.println(msg); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(); } } 2.方法可以接收参数，也可以定义变量 范例：访问方法中定义的参数或变量 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(int num) { // 方法参数 double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(100); } } 方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后！在JDK1.8之前的版本严格要求：方法中的内部类只能访问final标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式： class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(final int num) { // 方法参数 final double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(八)","slug":"Java Base/Java基础知识(八)","date":"2017-10-14T02:34:53.423Z","updated":"2017-10-21T05:58:52.668Z","comments":true,"path":"article/Java/Java Base/Java基础知识(八)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(八)/","excerpt":"","text":"对象比较 1.数字比较用==，字符串比较用equals(String str)。 要进行对象比较，必须对对象中所有属性的值进行比较。 范例：对象比较的基本方式 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.getTitle().equals(bkB.getTitle()) &amp;&amp; bkA.getPrice() == bkB.getPrice()) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 上述程序存在问题：主方法相当于客户端，客户端的程序逻辑应该越简单越好。所以对象比较应该由对象自己完成，即对象所对应的类应该提供对象比较的方法。 附：类的属性使用private封装，那么在类的外部就不能通过对象直接调用属性 class Info{ private String msg = &quot;Hello&quot;; public void print(){ System.out.println(&quot;msg = &quot; + this.msg); } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.msg = &quot;sss&quot;; // 报错，无法访问private属性 x.print(); } } 附：将一个对象作为参数传回类的方法中，相当于取消封装，使得对象可以直接访问属性。 class Info { private String msg = &quot;Hello&quot;; public void print() { System.out.println(&quot;msg = &quot; + this.msg); } public void fun(Info temp) { // 在类的内部直接利用对象访问私有属性 temp.msg = &quot;修改内容&quot;; } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.fun(x); x.print(); // msg = 修改内容 } } 附：一个类接收本类对象形式的代码在对象比较时很常见。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } // 类接收自身对象，对象可以直接访问属性，不需要getter方法 // compare()有两个功能：一带回了要比较的信息；二方便属性访问 public boolean compare(Book book) { if (book == null) { // 要比较的对象为空 return false; // 没必要比较 } if (this == book) { // 内存地址相同 return true; //避免具体比较，节约时间 } // 执行“bkA.equals(bkB)”时，有两个对象： // 一个为当前对象this(调用方法的对象，即bkA） // 一个为传递对象book(引用传递，即bkB） if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } else { return false; } } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.compare(bkB)) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 总结 （1）对象比较的方法必须定义在类中； （2）对象比较时一定要判断是否为null，内存地址是否相同，属性是否相同。 关键字static static 定义属性 问题引出： class Book { private String title; private double price; // 为操作方便，暂不封装 String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 对上述代码进行内存分析： 通过内存分析，发现属性重复：每个对象各自占有相同的属性值。假如有1000个该对象，要修改所有对象的pub属性，就需要分别进行修改。因此如果将pub属性定为普通属性，那每个堆内存都保存有各自的pub值。 1.但所有对象的pub值都一样，应将其定为一个共享的属性，即所有对象都指向同一块pub属性。可以利用static定义共享属性。 class Book { private String title; private double price; // 为操作方便，暂不封装 static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 北京大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 使用static定义属性后，只要有一个对象修改属性值，那么所有对象的该属性值都会改变，内存分析如下： 2. static定义的属性与普通属性区别在于保存数据的内存区域不同。 static定义的是公共属性，任由某个对象直接修改属性值是不合理的，应该由所有对象的代表进行属性访问，即用类访问。因此static定义的属性，可直接用类名调用：Book.pub = &quot;北京大学出版社&quot;; 3. static属性与普通属性的区别在于：普通属性必须由实例化的对象调用，而在没有实例化对象的情况下，static属性依然可以被调用。 public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，输出pub的内容 System.out.println(Book.pub); } } 由结果可知：static虽然定义在类中，但不受对象控制，是独立于类存在的。 4. 何时使用static定义属性 编写类时，static不是首选修饰符，当需要描述共享信息时，才使用static，方便集体修改，不用重复开辟内存空间。 static 定义方法 1.static定义的方法也可以直接被类名调用 class Book { private String title; private double price; // 为操作方便，暂不封装 private static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public static void setPub(String p){ pub = p; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，调用方法 Book.setPub(&quot;北京大学出版社&quot;); Book bkA = new Book(&quot;Java开发&quot;, 79.5); System.out.println(bkA.getInfo()); // 北京大学出版社 } } 上述代码存在问题：类中有两种方法，static方法和普通方法，两种方法间的访问受到限制。 （1）static方法不能直接使用非static属性或方法，只能调用static属性或方法。 public static void setPub(String p){ pub = p; title = &quot;sss&quot;; // 报错，无法引用非静态变量 getInfo(); // 报错，无法引用非静态方法 System.out.println(this); // 报错，无法引用非静态变量 } （2）普通方法可以使用static属性或方法 public String getInfo(){ setPub(&quot;&quot;); // 不报错 return &quot;,出版社：&quot; + this.pub; // 不报错 } 出现上述限制的原因： |- 普通属性和方法必须在对象实例化后分配了堆内存空间，才可以使用； |- static定义的方法和属性，不受实例化对象控制，可在没有实例化对象情况下访问。 2.一个方法定义在主类中，并由主方法直接调用，该方法定义格式如下： public static 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 一个方法定义在类中，由对象直接调用，其语法格式如下： public 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 观察代码： public class Demo { public static void main(String[] args) { fun(); } public static void fun() { System.out.println(&quot;Hello World !&quot;); } } 没有static定义的fun()必须通过对象调用，主方法要使用fun()必须实例化对象 public class Demo { public static void main(String[] args) { // 产生对象，再利用对象调用非static方法 new Demo().fun(); } public void fun() { System.out.println(&quot;Hello World !&quot;); } } 定义类中方法时，static不是首选修饰符，因为每个对象可以利用自己的属性实现方法的不同调用。 class Flag { private boolean flag; public Flag(boolean flag) { this.flag = flag; } public void fun() { if (this.flag) { System.out.println(&quot;可以操作&quot;); } else { System.out.println(&quot;不可以操作&quot;); } } } public class Demo { public static void main(String[] args) { Flag fA = new Flag(true); Flag fB = new Flag(false); fA.fun(); fB.fun(); } } 当一个类中没有属性，只有方法时，建议将所有方法定义为static方法。这样就不用每次调用时都需要有实例化对象。 class MyMath { public static int add(int x, int y) { return x + y; } } public class Demo { public static void main(String[] args) { System.out.println(MyMath.add(10, 20)); } } 主方法 1.主方法的组成： 组成 作用 public 主方法是程序的开始，所以主方法必须是可见、public（公共的）的 static 证明此方法可直接由类名调用 void 主方法是程序的开始，因此不能回头，执行完为止，所以不能有返回值 main 系统规定好的方法名，不能修改 String [] args 指的是程序运行时传递的参数 范例：对主方法传入参数 public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; args.length ; x++) { System.out.println(args[x]); // 未输出参数，为空 } } } 多个参数时，必须使用空格分割。cmd执行的是java Demo 1 3 4 6 输出为：1 3 4 6 如果参数本身带有空格，需用&quot;&quot;描述 cmd执行的是java Demo &quot;Hello world&quot; &quot;Hello Java&quot; static应用案例 已知： （1）多个对象，都使用同一个static属性； （2）static定义方法可以避免实例化对象调用方法的限制。 1.实现对实例化对象个数的统计 要求：每实例化一个对象，就输出&quot;这是第x个实例化对象&quot; 思路：每次实例化对象，就会调用构造方法，因此可在构造方法中增加一个统计数据的操作，每当新对象产生，该属性值就自增加一。 class Book { private static int num = 0; public Book() { num++; System.out.println(&quot;这是第&quot; + num + &quot;个实例化对象&quot;); } } public class Demo { public static void main(String[] args) { new Book(); new Book(); new Book(); } } 2.实现属性的自动设置 要求：类中有一个无参构造方法，一个有参构造方法，有参构造方法的功能是传递title值。不论调用的哪个构造方法，均可为title赋值，且属性值尽量不重复。 class Book { private String title; private static int num = 0; public Book() { this(&quot;Title:No.&quot; + num++); } public Book(String title){ this.title = title; } public String getTitle(){ return this.title; } } public class Demo { public static void main(String[] args) { System.out.println(new Book(&quot;Java开发&quot;).getTitle()); // Java开发 System.out.println(new Book().getTitle()); // Title:No.0 System.out.println(new Book().getTitle()); // Title:No.1 } } 总结 （1）类定义属性或方法首时选不是static属性或方法； （2）static属性或方法可直接用类名调用； （3）static属性保存在全局数据区。 （4）内存区有四种: 栈内存（对象的地址），堆内存（普通属性），全局数据区（static属性），全局代码区（所有的方法）","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(七)","slug":"Java Base/Java基础知识(七)","date":"2017-10-14T02:00:14.040Z","updated":"2017-10-21T05:58:03.232Z","comments":true,"path":"article/Java/Java Base/Java基础知识(七)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(七)/","excerpt":"","text":"引用传递分析实例 引用传递 1.引用传递核心意义：同一块堆内存可以被不同栈内存所指向，不同栈内存可以对同一块堆内存进行修改。 范例：引用传递 public class Message { private int num = 10; public Message(int num) { this.num = num; } public int getNum() { return num; } public void setNum(int num) { this.num = num; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(30); System.out.println(msg.getNum()); // 30 fun(msg); // 引用传递 System.out.println(msg.getNum()); // 100 } public static void fun(Message temp) { temp.setNum(100); } } 对上述代码进行内存分析： 2.引用 public class Demo { public static void main(String[] args) { String msg = &quot;Hello&quot;; fun(msg); System.out.println(msg); // Hello } public static void fun(String temp) { temp = &quot;World&quot;; } } 出现上述结果原因：String对象的内容一旦声明不可改变，对象内容的改变依靠的是引用地址的改变。内存分析如下： 3.引用传递 public class Message { private String info = &quot;nihao&quot;; public Message(String info) { this.info = info; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(&quot;Hello&quot;); System.out.println(msg.getInfo()); // Hello fun(msg); System.out.println(msg.getInfo()); // World } public static void fun(Message temp) { temp.setInfo(&quot;World&quot;); } } 内存分析如下： 上述内存分析，是按照int型数据的特点进行的。实际info是String对象，应该按照如下方式进行分析： 结论：虽然String是一个类，属于引用数据类型，但由于其内容不可改的特点，我们常将其当作基本数据类型。即每个String变量只能保存一个数据。 引用传递实例 要求：通过面向对象的方式描述每个人有车或没车。 实现步骤： 1.创建数据库：应设计两张表:汽车表和人员表; 2.根据数据表，定义两个类： （编写简单java类时，可按照数据表的设计来写，规则如下： 类名 = 表名； 属性名(类型) = 表字段(类型); 一个实例化对象 = 一行记录； 多个实例化对象 = 多行记录 引用关系 = 外键描述） public class Member { private int mId; private String name; } public class Car { private String pName; } 3.利用引用来描述两个类的外键，从而使得两个类有联系 public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } } 4.当两个类的对象产生，为这两个对象设置彼此的关系： public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } public Member getMember() { return member; } public void setMember(Member member) { this.member = member; } } 5.测试 测试分为两步： （1）根据定义的结构关系设置数据 （2）根据定义的结构关系取出数据 public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Car c = new Car(&quot;宝马&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); } } 6.进一步设计：每个人都有孩子，孩子还可能有车 思路： （1）设计一个孩子类，如有孙子，在设计孙子类，以此类推。该方案过于冗余，不合适； （2）在Member类中设计属性child，类型为Member： private Member child; // 孩子 public Member getChild() { return child; } public void setChild(Member child) { this.child = child; } 测试： public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Member child = new Member(1,&quot;张四&quot;); Car c = new Car(&quot;宝马&quot;); Car cc =new Car(&quot;法拉利&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 设置车与人的关系：张四有辆法拉利 child.setCar(cc); c.setMember(child); // 设置人与人的关系：张四是张三的儿子 m.setChild(child); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); // 通过人找到孩子 System.out.println(m.getChild().getInfo()); // 通过人找到孩子的车 System.out.println(m.getChild().getCar().getInfo()); } } 7.利用引用描述电脑：电脑由主机、键盘、内存、CPU、显卡等组成，下面用伪代码描述： class 键盘{} class 鼠标{} class CPU{} class 硬盘{} class 内存{} class 显示器{} class 主机{} class 主板{} class 主机{ private CPU 对象[]; private 硬盘 对象[]; private 主板 对象; private 内存 对象[]; } class 电脑{ private 主机 对象; private 显示器 对象; private 键盘 对象; private 鼠标 对象; } 上述设计思路称为合成设计模式。引用是实现两个不同类之间互相关联的主要手段。 数据表与简单Java类映射 要求：通过程序描述部门和雇员关系 属性： ·dept：deptno,dname,loc; ·emp：empno, ename,job,sal,comm,deptno,mgr 关系： ·一个部门有多个雇员； ·一个雇员有一个或零个领导。 第一步： 根据数据表创建简单java类 /** * 部门类 */ public class Dept { private int depNo; // 编号 private String dName; // 名字 private String address; // 地址 // setter,getter,无参构造方法略 public Dept(int depNo, String dName, String address) { this.depNo = depNo; this.dName = dName; this.address = address; } public String getInfo() { return &quot;部门编号：&quot; + this.depNo + &quot;,部门名称：&quot; + this.dName + &quot;,地址：&quot; + this.address; } } /** * 员工类 */ public class Emp { private int eNo; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // setter,getter,无参构造方法略 public Emp(int eNo, String eName, String job, double sal, double comm) { this.eNo = eNo; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } public String getInfo() { return &quot;编 号&quot; + this.eNo + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：设置外键关系 · 一个雇员属于一个部门，应在雇员类中保存部门信息 private Dept dept; // 对应的部门信息 public Dept getDept() { return dept; } public void setDept(Dept dept) { this.dept = dept; } · 一个部门有的多个雇员，可用数组在部门类中保存雇员信息： private Emp emps[]; // 多个雇员信息 public Emp[] getEmps() { return emps; } public void setEmps(Emp[] emps) { this.emps = emps; } · 一个雇员有一个领导（定义在Emp类中） private Emp mgr; // 领导信息 public Emp getMgr() { return mgr; } public void setMgr(Emp mgr) { this.mgr = mgr; } 第三步：测试 （1）设置数据： public class Demo { public static void main(String[] args) { // 1. 产生对象 Dept dept = new Dept(10, &quot;财务部&quot;, &quot;北京&quot;); // 部门信息 // 员工信息 Emp eA = new Emp(1111, &quot;张三&quot;, &quot;保安&quot;, 800.0, 0.0); Emp eB = new Emp(1101, &quot;李四&quot;, &quot;秘书&quot;, 2800.0, 500.0); Emp eC = new Emp(1001, &quot;王五&quot;, &quot;经历&quot;, 6800.0, 1500.0); // 2. 设置员工与领导关系 eA.setMgr(eB); eB.setMgr(eC); // 3. 设置员工和部门关系 eA.setDept(dept); eB.setDept(dept); eC.setDept(dept); dept.setEmps(new Emp[]{eA, eB, eC}); } } （2）：根据给定的结构取出数据，要求如下： |-根据一个雇员查询他所对应的领导信息和部门信息； |-根据一个部门查询所有雇员以及其所对应的领导信息； // 第二步：取出数据 // 1. 通过员工找到领导信息和部门信息 System.out.println(eA.getInfo()); // 获取员工信息 System.out.println(&quot;\\t|-&quot; + eA.getMgr().getInfo()); // 获取领导信息 System.out.println(&quot;\\t|-&quot; + eA.getDept().getInfo()); // 获取部门信息 // 2. 根据部门找到所有员工及其领导信息 System.out.println(&quot;---------------------------------------------&quot;); System.out.println(dept.getInfo()); for (int x = 0; x &lt; dept.getEmps().length; x++) { System.out.println(&quot;\\t|-&quot; + dept.getEmps()[x].getInfo()); // 获取员工信息 if (dept.getEmps()[x].getMgr() != null) { System.out.println(&quot;\\t\\t|-&quot; + dept.getEmps()[x].getMgr().getInfo()); // 获取领导信息 } } 上述代码都是依靠代码链取出数据。 一对多映射 要求：通过程序描述省份和城市的关系 1.通过一个城市找到它对应的省份信息； 2.通过一个省份找到所有城市的信息。 class Province { private int pId; private String pName; private City cities[]; // getter,setter,无参构造方法略 public Province(int pId, String pName) { this.pId = pId; this.pName = pName; } public City[] getCities() { return cities; } public void setCities(City[] cities) { this.cities = cities; } public String getInfo() { return &quot;省份ID：&quot; + this.pId + &quot;，省名：&quot; + this.pName; } } class City { private int cId; private String cName; private Province province; // getter,setter,无参构造方法略 public City(int cId, String cName) { this.cId = cId; this.cName = cName; } public Province getProvince() { return province; } public void setProvince(Province province) { this.province = province; } public String getInfo() { return &quot;城市ID：&quot; + this.cId + &quot;，市名：&quot; + this.cName; } } public class Demo { public static void main(String[] args) { Province province = new Province(350, &quot;福建省&quot;); City cA = new City(1, &quot;福州&quot;); City cB = new City(2, &quot;厦门&quot;); City cC = new City(3, &quot;泉州&quot;); cA.setProvince(province); cB.setProvince(province); cC.setProvince(province); province.setCities(new City[]{cA, cB, cC}); System.out.println(cA.getInfo()); System.out.println(&quot;\\t|-&quot; + cA.getProvince().getInfo()); System.out.println(&quot;==================================&quot;); System.out.println(province.getInfo()); for (int x = 0; x &lt; province.getCities().length; x++) { System.out.println(&quot;\\t|-&quot; + province.getCities()[x].getInfo()); } } } 上述代码存在不足：每次添加城市，就要修改数组的引用关系 双向一对多映射 要求：通过程序描述类型-子类型-商品的关系 （1）通过一个类型找到它对应的子类型； （2）过一个类型找到它所对应的商品； （3）通过一个子类型找到所有对应的商品。 class Type { private int tId; private String tName; private SonType sonTypes[]; private Product products[]; // getter,setter,无参构造方法略 public Type(int tId, String tName) { this.tId = tId; this.tName = tName; } public SonType[] getSontypes() { return this.sonTypes; } public void setSontypes(SonType[] sontypes) { this.sonTypes = sontypes; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;类型编号：&quot; + this.tId + &quot;,类型名称：&quot; + this.tName; } } class SonType { private int sId; private String sName; private Type type; private Product products[]; // getter,setter,无参构造方法略 public SonType(int sId, String sName) { this.sId = sId; this.sName = sName; } public int getsId() { return sId; } public void setsId(int sId) { this.sId = sId; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;子类型编号：&quot; + this.sId + &quot;,子类型名称：&quot; + this.sName; } } class Product { private int pId; private String name; private double price; private Type type; private SonType sonType; // getter,setter,无参构造方法略 public Product(int pId, String name, double price) { this.pId = pId; this.name = name; this.price = price; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public SonType getSonType() { return sonType; } public void setSonType(SonType sonType) { this.sonType = sonType; } public String getInfo() { return &quot;商品编号：&quot; + this.pId + &quot;,商品名称：&quot; + this.name + &quot;,价格：&quot; + this.price; } } public class Demo { public static void main(String[] args) { Type type = new Type(1, &quot;家电类&quot;); SonType stA = new SonType(11, &quot;小型家电&quot;); SonType stB = new SonType(12, &quot;大型家电&quot;); Product pA = new Product(111, &quot;剃须刀&quot;, 99.0); Product pB = new Product(112, &quot;热水壶&quot;, 29.0); Product pC = new Product(121, &quot;电冰箱&quot;, 1199.0); Product pD = new Product(122, &quot;电热水器&quot;, 399.0); stA.setType(type); stB.setType(type); pA.setType(type); pB.setType(type); pC.setType(type); pD.setType(type); type.setSontypes(new SonType[]{stA, stB}); type.setProducts(new Product[]{pA, pB, pC, pD}); pA.setSonType(stA); pB.setSonType(stA); pC.setSonType(stB); pD.setSonType(stB); stA.setProducts(new Product[]{pA, pB}); stB.setProducts(new Product[]{pC, pD}); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getSontypes().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getSontypes()[x].getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getProducts()[x].getInfo()); System.out.println(&quot;\\t\\t|- &quot; + type.getProducts()[x].getSonType().getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(stA.getInfo()); for (int x = 0; x &lt; stA.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + stA.getProducts()[x].getInfo()); } } } 多对多映射 要求：通过程序描述管理员-角色-组-权限的关系； （1）根据一个管理员找到它对应的角色，以及每个角色包含的所有权限组的信息，以及每个权限组所包含的权限的内容； （2）根据一个权限组找到所有具备此权限组的角色以及每个角色所拥有的管理员信息； 角色_权限组表是关系表，保存的是两个外键的关联关系，不需要为其生成映射类。只有实体表才需要生成映射类，多对多的中间转换表只需通过类属性的关系引用即可。 class Admin { private String aid; private String password; private Role role; public void setRole(Role role) { this.role = role; } public Role getRole() { return this.role; } public Admin(String aid, String password) { this.aid = aid; this.password = password; } public String getInfo() { return &quot;管理员编号:&quot; + this.aid + &quot;，管理员密码：&quot; + this.password; } } class Role { private int rid; private String title; private Admin admins[]; private Group groups[]; public void setAdmins(Admin admins[]) { this.admins = admins; } public Admin[] getAdmins() { return this.admins; } public void setGroups(Group groups[]) { this.groups = groups; } public Group[] getGroups() { return this.groups; } public Role(int rid, String title) { this.rid = rid; this.title = title; } public String getInfo() { return &quot;角色编号：&quot; + this.rid + &quot;，角色名称&quot; + this.title; } } class Group { private int gid; private String title; private Role roles[]; private Action actions[]; public void setActions(Action actions[]) { this.actions = actions; } public Action[] getActions() { return this.actions; } public void setRoles(Role roles[]) { this.roles = roles; } public Role[] getRoles() { return this.roles; } public Group(int gid, String title) { this.gid = gid; this.title = title; } public String getInfo() { return &quot;权限组编号：&quot; + this.gid + &quot;，权限组名称：&quot; + this.title; } } class Action { private int aid; private String title; private String url; private Group group; public void setGroup(Group group) { this.group = group; } public Group getGroup() { return this.group; } public Action(int aid, String title, String url) { this.aid = aid; this.title = title; this.url = url; } public String getInfo() { return &quot;权限编号：&quot; + this.aid + &quot;权限名称：&quot; + this.title + &quot;,权限路径：&quot; + this.url; } } public class Demo { public static void main(String[] args) { Admin a1 = new Admin(&quot;admin&quot;, &quot;123456&quot;); Admin a2 = new Admin(&quot;root&quot;, &quot;654321&quot;); Admin a3 = new Admin(&quot;guest&quot;, &quot;654321&quot;); Role r1 = new Role(1, &quot;系统管理员&quot;); Role r2 = new Role(1, &quot;信息管理员&quot;); Group g1 = new Group(10, &quot;信息管理&quot;); Group g2 = new Group(11, &quot;用户管理&quot;); Group g3 = new Group(12, &quot;数据管理&quot;); Group g4 = new Group(13, &quot;接口管理&quot;); Group g5 = new Group(14, &quot;备份管理&quot;); Action ac1 = new Action(1001, &quot;新闻发布&quot;, &quot;-&quot;); Action ac2 = new Action(1002, &quot;新闻列表&quot;, &quot;-&quot;); Action ac3 = new Action(1003, &quot;新闻审核&quot;, &quot;-&quot;); Action ac4 = new Action(1004, &quot;增加用户&quot;, &quot;-&quot;); Action ac5 = new Action(1005, &quot;用户列表&quot;, &quot;-&quot;); Action ac6 = new Action(1006, &quot;登陆日志&quot;, &quot;-&quot;); Action ac7 = new Action(1007, &quot;雇员数据&quot;, &quot;-&quot;); Action ac8 = new Action(1008, &quot;部门数据&quot;, &quot;-&quot;); Action ac9 = new Action(1009, &quot;公司数据&quot;, &quot;-&quot;); Action ac10 = new Action(1010, &quot;服务传输&quot;, &quot;-&quot;); Action ac11 = new Action(1011, &quot;短信平台&quot;, &quot;-&quot;); Action ac12 = new Action(1012, &quot;全部备份&quot;, &quot;-&quot;); Action ac13 = new Action(1013, &quot;局部备份&quot;, &quot;-&quot;); a1.setRole(r1); a2.setRole(r2); a3.setRole(r2); r1.setAdmins(new Admin[]{a1}); r2.setAdmins(new Admin[]{a2, a3}); r1.setGroups(new Group[]{g1, g2, g3, g4, g5}); r2.setGroups(new Group[]{g1, g2}); g1.setRoles(new Role[]{r1, r2}); g2.setRoles(new Role[]{r1, r2}); g3.setRoles(new Role[]{r1}); g4.setRoles(new Role[]{r1}); g5.setRoles(new Role[]{r1}); g1.setActions(new Action[]{ac1, ac2, ac3}); g2.setActions(new Action[]{ac4, ac5, ac6}); g3.setActions(new Action[]{ac7, ac8, ac9}); g4.setActions(new Action[]{ac10, ac11}); g5.setActions(new Action[]{ac12, ac13}); ac1.setGroup(g1); ac2.setGroup(g1); ac3.setGroup(g1); ac4.setGroup(g2); ac5.setGroup(g2); ac6.setGroup(g2); ac7.setGroup(g3); ac8.setGroup(g3); ac9.setGroup(g3); ac10.setGroup(g4); ac11.setGroup(g4); ac12.setGroup(g5); ac13.setGroup(g5); System.out.println(a1.getInfo()); System.out.println(a1.getRole().getInfo()); for (int x = 0; x &lt; a1.getRole().getGroups().length; x++) { System.out.println(&quot;\\t|-&quot; + a1.getRole().getGroups()[x].getInfo()); for (int y = 0; y &lt; a1.getRole().getGroups()[x].getActions().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + a1.getRole().getGroups()[x].getActions()[y].getInfo()); } } System.out.println(&quot;-------------------------------------------------&quot;); System.out.println(g2.getInfo()); for (int x = 0; x &lt; g2.getRoles().length; x++) { System.out.println(g2.getRoles()[x].getInfo()); for (int y = 0; y &lt; g2.getRoles()[x].getAdmins().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + g2.getRoles()[x].getAdmins()[y].getInfo()); } System.out.println(); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Centos7上部署Docker私有仓库","slug":"Docker/Centos7上部署Docker私有仓库","date":"2017-10-11T11:45:51.144Z","updated":"2017-10-11T12:00:20.426Z","comments":true,"path":"article/容器/Docker/Centos7上部署Docker私有仓库/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Centos7上部署Docker私有仓库/","excerpt":"","text":"Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。 环境准备 系统要求 要求 说明 系统 Centos 7 内核 4.13.5-1.el7.elrepo.x86_64 仓库地址 10.0.0.128:5000 docker 1.12.6 关闭防火墙 $ systemctl stop firewalld.service $ systemctl disable firewalld.service $ vim /etc/sysconfig/selinux SELINUX=disabled 搭建Docker私有仓库 搭建仓库 $ docker pull registry // 拉取官方镜像 $ docker run -d -p 5000:5000 --restart=always --name myHub registry // 运行官方镜像 $ curl localhost:5000/v2/_catalog // 查看私有镜像仓库,此时为空 {&quot;repositories&quot;:[]} 修改配置文件 $ vim /etc/sysconfig/docker OPTIONS='--insecure-registry 10.0.0.128:5000' $ systemctl restart docker 上传镜像到私有仓库 $ docker tag mysql 10.0.0.128:5000/mysql:0.1 // docker tage image_name registry_ip:port/images_name:tag $ docker push 10.0.0.128:5000/mysql:0.1 // 上传镜像 $ curl localhost:5000/v2/_catalog // 查看仓库镜像 {&quot;repositories&quot;:[&quot;mysql&quot;]}","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(六)","slug":"Java Base/Java基础知识(六)","date":"2017-10-09T01:00:49.117Z","updated":"2017-10-21T05:58:59.878Z","comments":true,"path":"article/Java/Java Base/Java基础知识(六)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(六)/","excerpt":"","text":"关键字this this调用属性 class Book { private String title; private double price; public Book(String t, double p) { title = t; price = p; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); System.out.println(book.getInfo()); } } 上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。构造方法的功能是为类的属性初始化，参数名最好与属性名一致。 public Book(String title, double price) { title = title; price = price; } 修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的{}的变量名，即数据传到构造方法后，并未传到属性中。为了明确要访问的变量是类的属性，应在变量名前加this。 public Book(String title, double price) { this.title = title; this.price = price; } 在开发中，只要访问类中属性，前面必须加this。 this调用方法 1.this指的是当前对象，一个类除了属性还有方法，因此可以利用this调用方法。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public void print() { System.out.println(&quot;*********&quot;); } // setter和getter方法略 public String getInfo() { this.print(); return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 在类中调用普通方法，加不加this都一样。但为了代码的严谨性，最好加this。 2.this调用构造方法 多个构造方法间互相调用: this(参数1, 参数2…); 范例：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息一个新的Book类对象产生 class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; } public Book(String title, double price) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在重复，要消除重复代码： class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在限制： （1）利用this调用构造方法的语句只能放在构造方法首行； （2）普通方法无法调用构造方法； （3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。 class Book { private String title; private double price; public Book() { // 报错，构造递归调用 this(&quot;Book&quot;,1.1); System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码会出现”构造方法递归调用”错误，说明构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。 3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法; （1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”； （2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”； （3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”； （4）四参构造 实现方式1：不使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this.empNo = 0; this.eName = &quot;无名氏&quot;; this.sal = 0.0; this.dept = &quot;未定&quot;; } public Emp(int empNo) { this.empNo = empNo; this.eName = &quot;临时工&quot;; this.sal = 800.0; this.dept = &quot;后勤部&quot;; } public Emp(int empNo, String eName) { this.empNo = empNo; this.eName = eName; this.sal = 2000.0; this.dept = &quot;技术部&quot;; } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 实现方式2：使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this(0,&quot;无名氏&quot;,0.0,&quot;&quot;); } public Emp(int empNo) { this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;); } public Emp(int empNo, String eName) { this(empNo,eName,2000.0,&quot;技术部&quot;); } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 通过构造方法互相调用解决了代码重复问题。 当前对象 当前对象指的是当前正在调用类中属性或方法的对象 class Book { public void print() { // 哪个对象调用了print(),this就与该对象指向同一块内存地址 // this就是当前调用方法的对象 System.out.println(&quot;this = &quot; + this); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); System.out.println(&quot;bkA = &quot; + bkA); // bkA = com.java.demo.Book@1540e19d bkA.print(); // this = com.java.demo.Book@1540e19d System.out.println( &quot;===============&quot;); Book bkB = new Book(); // bkB = com.java.demo.Book@677327b6 System.out.println(&quot;bkB = &quot; + bkB); // this = com.java.demo.Book@677327b6 bkB.print(); } } class A{ private B b; public A(){ // 2.执行A类构造方法 // 3. 实例化B类对象b，调用B类构造方法 this.b = new B(this); //此时this是temp this.b.get(); // 5. 通过b调用B类的get() } public void print(){ //8. 执行该方法 System.out.println(&quot;Hello World !&quot;); } } class B{ private A a; public B(A a){ // A a = temp this.a = a; // 4. 执行B类构造方法 } public void get(){ // 6. 执行该方法 this.a.print(); // 7. 调用A类的print() } } public class Demo { public static void main(String[] args) { // 1.实例化A类对象，调用A类的无参构造方法 A temp = new A(); // Hello World ! } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(五)","slug":"Java Base/Java基础知识(五)","date":"2017-10-03T13:33:39.028Z","updated":"2017-10-21T05:58:42.729Z","comments":true,"path":"article/Java/Java Base/Java基础知识(五)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(五)/","excerpt":"","text":"String类的特点及使用 JDK_API文档由下面几部分组成： （1）类的定义以及相关的继承结构 （2）类的简短说明 （3）类的成员组成 （4）类所提供的构造方法 （5）类所提供的普通方法 （6）类的成员，构造方法，普通方法的详细说明 deprecated标记表示不再建议使用。 String对象的两种实例化方式 1.String是字符串类,下面将类的角度与内存关系分析其作用： （1）直接赋值String value_name = &quot;字符串&quot; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // 直接赋值 System.out.println(str); } } （2）构造方法public String (String str); public class Demo { public static void main(String[] args) { String str = new String(&quot;Hello World !&quot;); System.out.println(str); } } 字符串比较 1.判断两个int数据是否相等： public class Demo { public static void main(String[] args) { int x = 10; int y = 10; System.out.println(x == y); // true } } 使用==判断String对象是否相等： public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA == strB); // false System.out.println(strA == strC); // false System.out.println(strB == strC); // true } } 对上述代码进行内存分析： 由内存分析可知，String对象使用==比较时，比较的是对象的栈内存地址的值。 2.要比较字符串的内容，应使用String类中的方法public boolean equals（String str） public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA.equals(strB)); // true System.out.println(strA.equals(strC)); // true } } 开发中，字符串比较应用equals(String str). 3.章节例题：==与equals(String str)的区别 ==是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值; equals(String str)是String类的方法，用于比较字符串内容。 String常量是匿名对象 1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但不属于基本数据类型，而是将字符串作为String类的匿名对象。 范例：验证字符串是匿名对象 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; System.out.println(&quot;Hello&quot;.equals(str)); } } 2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化. public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (input.equals(&quot;hello&quot;)){ System.out.println(&quot;Hello World !&quot;); // 报错，NullPointerException } } } 为预防用户输入错误导致input为null，而后调用equals()，出现空指针异常，应使用如下代码： public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (&quot;hello&quot;.equals(input)){ System.out.println(&quot;Hello World !&quot;); } } } 使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将指定字符串放在equals()前。 两种实例化方式的区别 1.直接赋值 直接赋值就是给字符串匿名对象设置对象名。 此时内存中会开辟堆内存，并且有一块栈内存指向堆内存： 观察下列代码： public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = &quot;hello&quot;; String strC = &quot;hello&quot;; String strD = &quot;world&quot;; System.out.println(strA == strB); // true System.out.println(strA == strC); // true System.out.println(strB == strC); // true System.out.println(strA == strD); // false } } 由上述结果可知，strA，strB，strC都指向同一块堆内存： 共享设计模式：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。 2.构造方法实例化 使用构造方法定义String对象，就需要每次开辟新的堆内存。 由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。 public class Demo { public static void main(String[] args) { String strA = new String(&quot;hello&quot;); String strB = &quot;hello&quot;; System.out.println(strA == strB); // false } } 除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用public String intern()手工入池。 3.章节小题：String对象两种定义方式的区别 · 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用； · 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。 字符串内容不可改变 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str += &quot; World&quot;; str += &quot; !!!&quot;; System.out.println(str); } } 对上述代码进行内存分析： 分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。 String类常用方法(字符与字符串) 很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法： No. 方法名称 类型 描述 1 public String (char[] value) 构造 将字符数组变为String类对象 2 public String (char[] value ,int offset,int count) 构造 将部分字符数组变为String对象 3 public char charAt (int index) 普通 返回指定索引对应的字符信息 4 public char[] toCharArray() 普通 将字符串以字符数组的形式返回 范例：取出指定索引的字符 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; char c = str.charAt(0); System.out.println(c); // H } } 范例：将字符串转大写 public class Demo { public static void main(String[] args) { String str = &quot;hello&quot;; char [] data = str.toCharArray(); // 字符串转为字符数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 小写编码 - 32 = 大写编码 } // 将字符数组变为字符串 System.out.println(new String(data)); // HELLO // 将部分字符数组变为String对象 System.out.println(new String(data, 1, 2)); // EL } } 范例：判断一个字符换是否为纯数字 思路：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。 public class Demo { public static void main(String[] args) { String str = &quot;3146017052&quot;; if (isNumber(str)) { System.out.println(&quot;字符串全部由数字组成&quot;); } else { System.out.println(&quot;字符串不是全部由数字组成&quot;); } } // 定义判断字符串是否由数字组成的方法 public static boolean isNumber(String temp) { // 首先将字符串变为字符数组 char[] data = temp.toCharArray(); // 一一比较字符 for (int x = 0; x &lt; data.length; x++) { if (data[x] &gt; '9' || data[x] &lt; '0') { return false; } } // 全部为数字则返回true return true; } } 建议：返回值为boolean的方法命名为isXxx。 String类常用方法(字节与字符串) 字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。 No. 方法名称 类型 描述 1 public String (byte[] bytes) 构造 将字节数组变为字符串 2 public String (byte[] bytes ,int offset,int length) 构造 将部分字节数组变为字符串 3 public byte[] getBytes (String charsetName) throws UnsupportedEncodingException 普通 进行编码转换 4 public byte[] getBytes() 普通 将字符串变为字节数组 范例：字符串与字节数组的转换 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; byte [] data = str.getBytes(); // 将字符串转为字节数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 将小写字母转为大写字母 } System.out.println(new String(data)); // HELLOWORLD System.out.println(new String(data,5,5)); // WORLD } } String类常用方法(字符串比较) No. 方法名称 类型 描述 1 public boolean equals(String anotherString) 普通 进行内容判断，区分大小写 2 public boolean equalsIgnoreCase(String anotherString) 普通 进行内容判断，不区分大小写 3 public int compareTo (String anotherString) 普通 判断两个字符串的大小（按照字符编码）,返回值为0,1,-1 范例：equals()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 } } 范例：equalsIgnoreCase()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写 } } 范例：compareTo() public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.compareTo(strB)); // -32 if (strA.compareTo(strB) &gt; 0){ System.out.println(&quot;大于&quot;); } else if (strA.compareTo(strB) == 0){ System.out.println(&quot;两个字符串相等&quot;); } else { System.out.println(&quot;小于&quot;); } } } 只有String对象才能进行大小判断。 String类常用方法(字符串查找) 要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法： No. 方法名称 类型 描述 1 public boolean contains (String s) 普通 判断指定内容是否存在 2 public int indexOf(String s) 普通 由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。 3 public int indexOf(String s,int fromIndex) 普通 从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1 4 public int lastindexOf(String s) 普通 由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 5 public int lastindexOf(String s, int fromIndex) 普通 由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 6 public boolean startsWith (String prefix) 普通 判断是否以指定字符串开头 7 public boolean startsWith (String prefix，int toffset) 普通 从指定位置开始判断是否是以指定字符串开头 8 public boolean endsWith(String suffix) 普通 判断是否以指定字符串结尾 范例：查找字符串位置 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 返回满足条件的单词的首字母索引 System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引 // 从索引5开始查满足条件单词的索引 System.out.println(str.indexOf(&quot;l&quot;,5)); // 8 // 从后向前查 System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8 } } 在某些程序中，需要查找指定字符串是否存在，早期方法如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.indexOf(&quot;world&quot;) != -1){ System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } JDK1.5出现contains()，使用如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.contains(&quot;world&quot;)) { System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } 范例：开头或结尾判断内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从开头开始查 System.out.println(str.startsWith(&quot;he&quot;)); // 从索引2开始查找 System.out.println(str.startsWith(&quot;ll&quot;,2)); // 从结尾开始查找 System.out.println(str.endsWith(&quot;ld&quot;)); } } String类常用方法(字符串替换) No. 方法名称 类型 描述 1 public String replaceAll(String regex，String replacement) 普通 全部替换 2 public String replaceFirst(String regex，String replacement) 普通 替换首个满足条件的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 替换所有 String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d // 只替换第一个 String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld System.out.println(resultA); System.out.println(resultB); } } String类常用方法(字符串截取) No. 方法名称 类型 描述 1 public String substring(int beginIndex) 普通方法 从指定索引截取到结尾 2 public String substring(int beginIndex,int endIndex) 普通方法 截取指定范围内的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从索引5开始截取直到结尾 String resultA = str.substring(5); // 截取索引5到8之间 String resultB = str.substring(5,8); System.out.println(resultA); // world System.out.println(resultB); // wor } } String类常用方法(字符串拆分) No 方法名称 类型 描述 1 public String[] split (String regex) 普通方法 按照指定的字符串进行全部拆分 2 public String[] split (String regex，int limit) 普通方法 按照指定的字符串进行部分拆分，最后一个数组长度由limit决定 范例：全部拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空格拆分单词 String result[] = str.split(&quot; &quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：hello // world } } } 在拆分的时候，只写一个空字符串（&quot;&quot;不是null），表示按照每一个字符进行拆分。 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空字符串拆分 String result[] = str.split(&quot;&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：h e l l o w o r l d } } } 范例：部分拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world nihao mldn&quot;; // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆 String result[] = str.split(&quot; &quot;,3); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot; } } } 范例：IP地址拆分 public class Demo { public static void main(String[] args) { String str = &quot;192.168.1.1&quot;; String result[] = str.split(&quot;\\\\.&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果为：192 168 1 1 } } } 上述代码中，只用.无法拆分，当遇到这种拆分时，需要使用\\\\.进行转义后拆分。 范例：拆分“张三:20|李四:25|王五:23” public class Demo { public static void main(String[] args) { String str = &quot;张三:20|李四:25|王五:23&quot;; String result[] = str.split(&quot;\\\\|&quot;); for (int x = 0; x &lt; result.length; x++) { String temp[] = result[x].split(&quot;:&quot;); System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]); } } } String类其他方法 No. 方法名称 类型 描述 1 public String concat (String str) 普通方法 字符串连接 2 public String toLowerCase () 普通方法 把字符串转为小写 3 public String toUpperCase () 普通方法 把字符串转为大写 4 public String trim () 普通方法 去掉字符串中左右两边的空格，中间空格保留 5 public int length() 普通方法 取得字符串长度 6 public String intern () 普通方法 数据入池操作 7 public boolean isEmpty () 普通方法 范例：字符串连接 public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = strA + &quot; world&quot;; String strC = &quot;hello&quot; + &quot;world&quot;; String strD = &quot;hello world&quot;; String strE = strA.concat(&quot; world&quot;); System.out.println(strB == strC); // false System.out.println(strB == strD); // false System.out.println(strB == strE); // false System.out.println(strC == strD); // false System.out.println(strC == strE); // false System.out.println(strD == strE); // false } } 范例：字符串进行大小写转换 public class Demo { public static void main(String[] args) { String str = &quot;*Hello*&quot;; // 只转换小写字母 System.out.println(str.toUpperCase()); // *HELLO* // 只转换大写字母 System.out.println(str.toLowerCase()); // *hello* } } 范例：去掉空格 public class Demo { public static void main(String[] args) { String str = &quot; Hello World &quot;; System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】 System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】 } } 用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了trim()。 范例：取得字符串长度 public class Demo { public static void main(String[] args) { String str = &quot;Hello World&quot;; System.out.println(str.length()); // 11 } } 某些情况要求用户输入的数据长度有限制，可以利用此方法判断。 范例：判断是否是空字符串 public class Demo { public static void main(String[] args) { String str = &quot;&quot;; System.out.println(str.isEmpty()); // true System.out.println(&quot;&quot;.equals(str)); // true } } 范例：实现首字母大写，其余字母小写 public class Demo { public static void main(String[] args) { String str = &quot;hElLo&quot;; System.out.println(initcap(str)); // Hello } public static String initcap(String temp) { // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写 return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(四)","slug":"Java Base/Java基础知识(四)","date":"2017-10-03T12:47:52.401Z","updated":"2017-10-21T05:59:15.537Z","comments":true,"path":"article/Java/Java Base/Java基础知识(四)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(四)/","excerpt":"","text":"数组的定义及使用 基本概念 1.数组是一组变量的集合。数组属于引用数据类型。 2.数组的定义语法 （1）声明并开辟数组： 数组类型 数组名[] = new 数据类型[数组长度] （2）分步完成： // 声明数组 数组类型 数组名[] = null; // 开辟数组 数组名 = new 数据类型 [数组长度] 3.数组开辟空间用，可利用数组名[下标|索引]访问，下标从0开始。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现数组越界异常（ArrayIndexOutOfBoundsException）。 4.数组是顺序结构且长度固定，可使用循环语句输出，可用数组名.length获取数组长度。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; // 声明并开辟一个长度为3的数组 datas[0] = 1; // 为数组赋值，如不赋值，默认值为0 datas[1] = 2; datas[2] = 3; // for循环输出数组内容，datas.length获取数组长度 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。 范例：分步完成 public class Demo { public static void main(String[] args) { int datas[] = null; // 声明数组 datas = new int[3]; // 开辟一个长度为3的数组 datas[0] = 1; datas[1] = 2; datas[2] = 3; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 6.数组可以进行引用传递。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; datas[0] = 1; datas[1] = 2; datas[2] = 3; int temp[] = datas; // 引用传递 temp[0] = 99; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); // 99 2 3 } } } 以上都是动态初始化数组，即先开辟数组，再为数组赋值。 7.静态初始化数组： 在定义数组的同时为其赋值，语法： （1）数组类型 数组名[] = {v1, v2 ,…,vn}; （2）数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn}; 范例：静态初始化数组 public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; // 静态初始化数组 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 数组支持顺序数据访问，最大缺点是长度不能改变，因此在开发中不直接使用数组，但会使用数组的概念。 二维数组 1.一维数组就是一行数据： 索引 0 1 2 3 数据 0 10 20 30 在一维数组中要查询一个数据，只要确定其索引即可。 二维数组，是一个数据表： 索引 0 1 2 3 0 0 10 20 30 1 1 2 3 4 2 12 123 231 233 二维数组中要查询一个数据，需要定位列和行。二维数组中第一个[]确定行，第二个[]确定列。 2. 二维数组定义语法： // 动态初始化： 数据类型 数组名称[][]=new 数据类型[行数][列数]; // 静态初始化： 数据类型 数组名称[][]=new 数据类型[][]{数组元素} ; 由此可以发现，二维数组就是将多个一维数组变为一个数组。 public class Demo { public static void main(String[] args) { int datas[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; // 外层循环控制数组的行 for (int x = 0; x &lt; datas.length; x++) { // 内层循环控制数组的列 for (int y = 0; y &lt; datas[x].length ; y++) { System.out.print(datas[x][y] + &quot;\\t&quot;); } System.out.println(); } } } 数组与方法的引用 1.方法的参数可以是数组： public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; change(datas); for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } public static void change(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { temp[x] *= 2; // 数组元素乘2保存 } } } 内存分析： change()执行完毕后，temp不再指向datas的堆内存，但change()对datas数据的修改被保存下来。 2.数组排序（冒泡排序）： 数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; for (int x = 0; x &lt; datas.length; x++) { for (int y = 0; y &lt; datas.length - 1; y++) { if (datas[y] &gt; datas[x]) { int t = datas[y]; datas[y] = datas[x]; datas[x] = t; } } // 为更好地理解冒泡排序，输出每轮排序的结果 System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;); print(datas); System.out.println(); } print(datas); } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 建议：main()是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; sort(datas); print(datas); } // 数组冒泡排序方法 public static void sort(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp.length - 1; y++) { if (temp[y] &gt; temp[x]) { int t = temp[y]; temp[y] = temp[x]; temp[x] = t; } } } } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 3.数组转置 转置的概念（一维数组）：· 原始数组 1，2，3，4，5，6，7，8 转置后 8，7，6，5，4，3，2，1 转置操作的两个思路： （1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用： public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{1,2,3,4,5,6,7,8}; datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾 } // 数组逆序输出方法一 public static int [] reverseOne(int temp[]) { // 定义新数组，长度与原始数组一致 int temps[] = new int[temp.length]; int foot = temp.length - 1; // 控制原始数组的索引 for (int x = 0; x &lt; temps.length ; x++) { temps[x] = temp[foot]; // 新数组按照原始数组倒序排列 foot --; } return temps; } } 上述代码实现转置，但产生了垃圾，不合理。 （2）利用算法，直接在数组上完成转置： 不论数组个数是奇数还是偶数,转换次数 = 数组长度 / 2; // 数组逆序输出方法 public static void reverse(int temp[]) { int len = temp.length / 2; int head = 0; int tail = temp.length - 1; for (int x = 0; x &lt; len; x++) { int t = temp[head]; temp[head] = temp[tail]; temp[tail] = t; head++; tail--; } } 4.行列数相等的二维数组转置： public class Demo { public static void main(String[] args) { int data[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; reverse(data); print(data); } // 专门实现数组的倒置操作 public static void reverse(int arr[][]) { for (int x = 0; x &lt; arr.length; x++) { for (int y = x; y &lt; arr.length; y++) { if (x != y) { //行和列相同，进行交换 int temp = arr[x][y]; arr[x][y] = arr[y][x]; arr[y][x] = temp; } } } } // 专门输出的方法 public static void print(int temp[][]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp[x].length; y++) { System.out.print(temp[x][y] + &quot;、&quot;); } System.out.println(); } System.out.println(); } } 转置过程： 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] 第一次转换（x=0，y=x=0，循环3次） ·y的第一次循环（x==y） 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第二次循环（x=0，y=1，进行交换） 1[0][0] 4[1][0] 3[0][2] 2[0][1] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第三次循环（x=0，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] 第二次转换（x=1，y=x=1，循环2次） ·y的第一次循环（x=1，y=1，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] ·y的第二次循环（x=1，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 第三次转换（x=2，y=x=2，循环11次） ·y的第二次循环（x=2，y=2，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。 5.方法返回数组： public class Demo { public static void main(String[] args) { int data[] = init(); // 接收数组 print(data); System.out.println(init().length); } public static int[] init() { return new int[]{1, 2, 3}; // 方法返回数组 } public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot;、&quot;); } System.out.println(); } } 操作数组的方法 1.Java对数组提供类库支持，下面介绍两个类库中的方法： （1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。 语法：System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)。 范例：数组拷贝 ·数组A：1，2，3，4，5，6，7，8； ·数组B：11，22，33，44，55，66，77，88； ·拷贝后的数组B:11，22，5，6，7，66，77，88 public class Demo { public static void main(String[] args) { int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8}; int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88}; System.arraycopy(dataA, 4, dataB, 2, 3); ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法 } } （2）数组排序： 语法：java.util.Arrays.sort(数组名) public class Demo { public static void main(String[] args) { int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5}; java.util.Arrays.sort(dataA); ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法 } } 对象数组 1.对象数组是将多个对象交由数组处理。 2.对象数组的定义与一般数组一致： 范例： 动态初始化对象数组 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[3]; books[0] = new Book(&quot;Java开发&quot;, 66.6); books[1] = new Book(&quot;JSP&quot;, 6.6); books[2] = new Book(&quot;C++&quot;, 16.6); for (int x = 0; x &lt; books.length; x++) { System.out.println(books[x].getInfo()); //未实例化对象时，输出值全为null } } } 范例：静态初始化对象数组： class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[]{ new Book(&quot;Java开发&quot;, 66.6), new Book(&quot;JSP&quot;, 6.6), new Book(&quot;C++&quot;, 16.6) }; for (int x = 0; x &lt; books.length; x++) { //未实例化对象时，输出值全为null System.out.println(books[x].getInfo()); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(三)","slug":"Java Base/Java基础知识(三)","date":"2017-10-02T07:31:57.908Z","updated":"2017-10-21T05:58:05.374Z","comments":true,"path":"article/Java/Java Base/Java基础知识(三)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(三)/","excerpt":"","text":"方法的定义与使用 方法的基本概念 方法就是将一段可重复使用的代码封装。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是定义在主类中，由主方法直接调用的方法。此类方法的语法： public static 返回值类型 method_name(v_type v1, v_type v2,...) { 方法体; // 方法要进行的若干操作 [return [返回值] ;] // []中内容可写可不写 } 返回值类型: 数据类型(基本数据类型、引用数据类型) 无返回值(void) 如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容 不需要return语句，但可用return结束方法调用 方法名的命名规则：第一个单词小写，随后每个单词首字母大写。 范例：定义无参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { print(); // 直接调用 } public static void print(){ System.out.println(&quot;无参无返回值方法&quot;); } } 范例：定义含参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { compare(10.2); // 调用时必须写入参数 compare(-10.2); } public static void compare(double x){ String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;; System.out.println(str); } } 有了参数后，方法就可以根据不同的参数内容进行数据的处理。 范例：定义含参数有返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { //定义变量接收返回值，而后输出 int result = add(10, 20); System.out.println(result); // 直接输出返回值 System.out.println(add(10, 20)); } public static int add(int x, int y) { return x + y; } } 一个方法使用void定义，该方法无法使用return返回值，但可以使用return结束调用。 package com.java.demo; public class Demo { public static void main(String[] args) { print(1100); // x = 1100 print(3); // 结束调用,不输出x } public static void print(int x) { if (x == 3) { System.out.println(&quot;结束调用,不输出x&quot;); return; } System.out.println(&quot;x = &quot; + x); } } 只有返回值类型为void时，才可使用return结束方法的调用。 方法重载 假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为方法重载（overloading）。 方法重载要求方法名一致，参数类型或个数不同。 package com.java.demo; public class Demo { public static void main(String[] args) { // 根据参数的个数或类型，调用不同方法 add(10,20); add(10.2,20.2); add(10,20,30); } // 方法名相同，参数的类型或个数不同 public static void add(int x, int y) { System.out.println(&quot;两个整数相加：&quot; + (x + y)); } public static void add(double x, double y) { System.out.println(&quot;两个小数相加：&quot; + (x + y)); } public static void add(int x, int y, int z) { System.out.println(&quot;三个整数相加：&quot; + (x + y + z)); } } System.out.println()可以输出不同类型数据，可知此方法是一个被重载后的方法。 方法重载的说明： （1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致； （2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。 package com.java.demo; public class Demo { public static void main(String[] args) { } // 报错,已在类中定义了方法 add(int,int) // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同 public static int add(int x, int y) { return x + y; } public static double add(int x, int y) { return x + y; } } 递归调用 递归调用是指方法调用自身。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。 范例：递归实现1~100的累加操作 package com.java.demo; public class Demo { public static void main(String[] args) { System.out.println(sum(100)); } public static int sum(int num){ if (num == 1) { // 结束递归调用 return 1; } // 递归调用 return num + sum(num - 1); } } 代码的执行步骤： No. 内容 返回值 1 主方法调用sum(100) 100+sum(99) 2 递归调用sum(99) 100 + 99 + sum（98) 3 递归调用sum(98) 100 + 99 + 98+ sum(97) … 依此类推 … 最后一次 递归调用sum(1) sum=100+99+98+…+2+1,结束递归 类与对象 面向对象简介 面向过程：指的是针对某一个问题单独提出解决方案和代码开发。 面向对象：以组件化的形式进行代码设计，优点是代码可重用。 面向对象语言的特征： （1）封装性：保护内部结构安全性。 （2）继承性：在已有的程序结构上扩充新的功能。 （3）多态性：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果 面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。 类与对象 1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。 2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含特征(属性)外，还包括许多行为(方法)。根据这个类产生的对象都具有相同的行为。 3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。 4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。 类与对象的定义及使用 1.定义类使用class class_name {}语句完成。类的组成： (1)field（属性，成员，变量）：一堆变量的集合； (2)method（方法，行为）：由对象调用。 范例：定义类 package com.java.entity; public class Book { // 定义属性 public String title; public double price; // 定义方法 public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 2.要使用类，必须要有对象，对象定义的语法有如下两种： (1)声明并实例化对象：class_name object_name = new class_name()； (2)分步完成： 第一步-声明对象：class_name object_name = null; 第二部-实例化对象：object_name =new class_name(); 引用数据类型与基本数据类型最大区别是需要内存的开辟及使用，所以关键字new的主要功能就是开辟内存空间。 3.当一个对象实例化后，利用如下方式操作类： (1)object_name.field：操作类中的属性； (2)object_name.method()：调用类中的方法。 范例：使用类 public class Demo { public static void main(String[] args) { Book book = new Book(); // 声明并实例化对象 book.title = &quot;Java开发&quot;; // 定义属性 book.price = 66.6; book.getInfo(); // 调用方法 } } 4.堆内存和栈内存的概念： 堆内存 栈内存 保存对象的属性内容，使用关键字new开辟 栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字 范例：分步使用实例化对象 public class Demo { public static void main(String[] args) { Book book = null; // 声明对象 book = new Book(); // 实例化对象 book.title = &quot;Java开发&quot;; book.price = 66.6; book.getInfo(); } } 内存分析：使用关键字new开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为默认值。 使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）” 对象引用分析 1.在引用分析中，每次使用new关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么两个对象占据的是不同的堆内存，因此不会互相影响。 范例：声明两个对象 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); bkB.title = &quot;C++开发&quot;; bkB.price = 22.6; bkB.getInfo(); } } 2. 范例：对象引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = null; bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); // 66.6 bkB = bkA; // 引用传递 bkB.price = 90.5; bkA.getInfo(); // 90.5 bkB.getInfo(); // 90.5 } } 由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。 3. 范例：引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkB.title = &quot;C++开发&quot;; bkB.price = 90.5; bkB = bkA; // 引用传递 bkB.price = 100; bkA.getInfo(); // 100 bkB.getInfo(); // 100 } } 通过内存分析可知，在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。 封装性 public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = -66.6; bkA.getInfo(); } } 上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为对象可以在类的外部直接访问属性。 1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。 public class Book { private String title; private double price; public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性 } } 此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter(). 2. 以Book类中的title属性为例，定义setter()/getter()： setter() getter() 作用 设置属性值 取得属性值 语法 public void setTitle(String t) public void getTitle() 是否含参 有参 无参 package com.java.entity; public class Book { private String title; private double price; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 如果要添加如价格不能为负数的功能，应在setter()中添加： public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } 对于数据的验证，开发中应有其他辅助代码完成，setter()只是简单地设置数据，getter()只用于返回数据。 构造方法与匿名对象 定义对象的语法：类名称 对象名称 = new 类名称(); ①类名称：定义对象的类型； ②对象名称：标识符，要使用对象，需要有一个对象名； ③new：用于开辟堆内存空间，实例化对象； ④类名称()：一个方法名和类名称一样的方法，这就是构造方法。 通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。 1.构造方法的定义原则：方法名称与类名称相同，没有返回值。 class Book { public Book() { // 系统自动生成的构造方法 } } 2.构造方法在对象使用new实例化时调用。 范例：证明构造方法被调用 public class Book { public Book() { System.out.println(&quot;构造方法被调用&quot;); } } public class Demo { public static void main(String[] args) { Book book = null ; // 声明对象 book = new Book(); // 实例化对象时调用构造方法 //结果：构造方法被调用 } } 构造方法与普通方法的最大区别：构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。 3.范例：自定义构造方法 class Book { private String title; private double price; // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法 public Book(String t, double p) { title = t; price = p; } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); book.getInfo(); } } 由上述代码可知构造方法的作用：在类对象实例化时设置属性的初始值，即构造方法用于属性初始化。 4.构造方法也属于方法，因此可以进行重载。 范例：构造方法重载 class Book { public Book() { System.out.println(&quot;系统自动生成的构造方法&quot;); } // 进行方法重载的构造方法 public Book(String t, double p) { System.out.println(&quot;方法重载后的构造方法&quot;); } } public class Demo { public static void main(String[] args) { Book bookA = new Book(); // 系统自动生成的构造方法 Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法 } } 重载方法时要求：按照参数个数，对方法进行升序或者降序排列。 5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：类的加载，内存的分配，默认值的设置，构造方法。 class Book { private String title = &quot;Java开发&quot;; // 设置默认值 private double price; public Book() { } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.getInfo(); // 书名：Java开发,价格：0.0 } } 本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。真实的对象信息都保存在堆内存中。 6.匿名对象：没有栈内存指向的对象，即没有标识符的对象。 public class Demo { public static void main(String[] args) { new Book(&quot;Java开发&quot;,6.6).getInfo(); } } 由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。 何时使用匿名对象：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。 简单Java类实践 题目要求：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。 提示：这种类被称为简单java类，因为这种类不包含过于复杂的程序逻辑。 对于简单Java类而言，它的要求如下： ·类名必须有意义； ·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法； ·类中可以有多个构造方法，但必须保留无参构造方法； ·类中不允许出现输出语句，信息输出必须交给调用处。 ·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。 第一步：定义类 public class Emp { private int eId; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // 定义构造方法 public Emp() { } public Emp(int eId, String eName, String job, double sal, double comm) { this.eId = eId; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } // 定义setter和getter方法 public int geteId() { return eId; } public void seteId(int eId) { this.eId = eId; } public String geteName() { return eName; } public void seteName(String eName) { this.eName = eName; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } public double getComm() { return comm; } public void setComm(double comm) { this.comm = comm; } // 定义普通方法 public String getInfo() { return &quot;编 号&quot; + this.eId + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：测试 public class TEmp { public static void main(String[] args) { Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0); System.out.println(e.getInfo()); // 获取全部信息 System.out.println(e.geteId()); // 通过getter()获取单一信息 } } 类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Kubernetes安装及使用","slug":"Docker/Kubernetes安装及使用","date":"2017-09-30T08:11:30.178Z","updated":"2017-09-30T08:44:56.611Z","comments":true,"path":"article/容器/Docker/Kubernetes安装及使用/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Kubernetes安装及使用/","excerpt":"","text":"环境配置 系统要求: CentOS 7 软件版本: 1.5.2 配置目标: master端 node端 IP 10.0.0.100 10.0.0.101 etcd ✔ flannel ✔ ✔ kube-apiserver ✔ kube-controller-manager ✔ kube-scheduler ✔ kubelet ✔ ✔ kube-proxy ✔ ✔ docker ✔ ✔ 共同配置（即master和node都需要进行的操作） (1)修改/etc/hosts文件，添加master和node节点IP $ echo &quot;10.0.0.100 centos-master 10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts $ cat /etc/hosts 10.0.0.100 centos-master 10.0.0.101 centos-minion (2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services # 关闭fierwalld $ systemctl stop firewalld $ systemctl disable firewalld # 安装iptables，启动该服务并设置开机自启动 $ yum install iptables $ systemctl start iptables $ systemctl enable iptables # 关闭iptables-services $ systemctl disable iptables-services $ systemctl stop iptables-services # 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot; # 解决方法：修改SElinux配置 $ vi /etc/selinux/config # SELINUX=enforcing #注释掉 # SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq! #保存退出 $ setenforce 0 #使配置立即生效 (3)安装","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://yov.oschina.io/tags/Kubernetes/"}]},{"title":"Docker Hub Mysql官方镜像实现首次启动后初始化库表","slug":"Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表","date":"2017-09-29T11:59:23.363Z","updated":"2017-09-30T04:25:40.869Z","comments":true,"path":"article/容器/Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表/","excerpt":"","text":"概述 在Docker Hub中查看MySQL官方镜像的Dockerfile: COPY docker-entrypoint.sh /usr/local/bin/ RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] 镜像启动时，会运行entrypoint.sh脚本，该脚本的shell命令中: echo for f in /docker-entrypoint-initdb.d/*; do case &quot;$f&quot; in *.sh) echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;; *.sql) echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;; *.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;; *) echo &quot;$0: ignoring $f&quot; ;; esac echo done 上述shell命令会遍历/docker-entrypoint-initdb.d/文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。 实现首次启动后初始化库表 创建mysql_data文件夹，将data.sql放入： -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 启动容器 $ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456 mysql 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u root -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。 指定sql文件运行顺序 entrypoint.sh脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法： 将文件按照预期顺序，进行命名，比如1_xx,2_xx; 将必须有前后顺序的sql文件合并在一个sql文件中; 将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。 假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh #!/bin/bash mysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOF source /usr/local/work/database.sql; source /usr/local/work/table.sql; source /usr/local/work/data.sql; 启动容器： $ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql 数据结果应与上述一致。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker实现mysql容器启动后自动建库","slug":"Docker/Docker实现mysql容器启动后自动建库","date":"2017-09-28T09:22:57.955Z","updated":"2017-09-30T01:47:23.779Z","comments":true,"path":"article/容器/Docker/Docker实现mysql容器启动后自动建库/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker实现mysql容器启动后自动建库/","excerpt":"","text":"概述 通过Dockerfile创建一个mysql镜像,该镜像具有如下功能： mysql容器启动时，会自动执行指定的sql文件; 每次启动该容器，数据都进行初始化，删除所有的修改。 执行步骤 创建Dockerfile $ vim Dockerfile # 指定基础镜像，选用docker官方最新mysql镜像 FROM docker.io/mysql:latest # 环境变量设置，设置mysql登陆时不需密码 ENV MYSQL_ALLOW_EMPTY_PASSWORD yes # 复制文件到容器中，要复制的文件有：启动脚本和sql文件 COPY setup.sh /mysql/setup.sh COPY data.sql /mysql/data.sql COPY privileges.sql /mysql/privileges.sql # 容器启动命令启动脚本 CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;] 创建privileges.sql用于修改mysql权限 $vim privileges.sql use mysql; select host, user from user; -- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456： -- 如果用户docker不存在，则创建用户docker grant all on docker_database.* to docker@'%' identified by '123456' with grant option; -- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： flush privileges; 创建data.sql导入数据 $ vim data.sql -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 创建容器启动脚本setup.sh $ vim setup.sh # !/bin/bash set -e # 查看mysql服务的状态，方便调试 echo `service mysql status` echo '1.启动mysql' # 启动mysql service mysql start # 使进程休眠 sleep 3 echo `service mysql status` echo '2.开始导入数据' #导入sql文件 mysql &lt; /mysql/data.sql echo '3.导入数据完毕....' sleep 3 echo `service mysql status` # 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 echo '4.开始修改密码....' # 导入修改mysql权限设置的文件 mysql &lt; /mysql/privileges.sql echo '5.修改密码完毕....' #sleep 3 echo `service mysql status` echo 'mysql容器启动完毕,且数据导入成功' 创建镜像 创建镜像并命名为mysql:9.29 $ docker build -t mysql:9.29 . 验证 启动mysql:9.29镜像，生成容器 $ docker run --name sql -d -p 23306:3306 mysql:9.29 6da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41 查看容器日志 $ docker log sql 1.启动mysql.... 2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=45790 2017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903. 2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened. 2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode. .. MySQL Community Server 5.7.19 is started. MySQL Community Server 5.7.19 is running. 2.开始导入数据.... 3.导入数据完毕.... MySQL Community Server 5.7.19 is running. 4.开始修改密码.... host user localhost mysql.session localhost mysql.sys localhost root 5.修改密码完毕.... MySQL Community Server 5.7.19 is running. mysql容器启动完毕,且数据导入成功 容器启动过程与setup.sh中编写的步骤完全一致。 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 验证重启mysql容器，数据库初始化 插入数据 mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重新启动容器 $ docker stop sql $ docker start sql $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 重启容器后，数据初始化。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"利用TestNG进行单元测试","slug":"Test/利用TestNG进行单元测试","date":"2017-09-26T12:41:55.450Z","updated":"2017-09-30T08:44:05.126Z","comments":true,"path":"article/测试/Test/利用TestNG进行单元测试/","link":"","permalink":"http://yov.oschina.io/article/测试/Test/利用TestNG进行单元测试/","excerpt":"","text":"TestNG简介 TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。 Annotation Annotation 作用 @BeforeSuite 被注释的方法将在所有测试运行前运行 @AfterSuite 被注释的方法将在所有测试运行后运行 @BeforeTest 被注释的方法将在测试运行前运行 @AfterTest 被注释的方法将在测试运行后运行 @BeforeGroups 被注释的方法将在gourp中方法运行前运行 @AfterGroups 被注释的方法将在gourp中方法运行后运行 @BeforeClass 被注释的方法将在当前类的第一个方法运行前运行 @AfterClass 被注释的方法将在当前类的所有方法运行后运行 @BeforeMethod 被注释的方法将在每一个方法运行前运行 @AfterMethod 被注释的方法将在每一个方法运行后运行 @DataProvider 被注释的方法用于为其他方法提供数据 @Factory 被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[] @Parameters 传递参数给测试方法 使用TestNG进行单元测试 @Test() // Test中所有方法变为测试方法 public class Test { @Test(enable = false) // 该注释后，test1()测试时被忽略，相当于普通方法 public void test1(){} @BeforeTest() // 该注释后，test3(),test4()执行前，test2()先执行 public void test2(){} @ public void test3(){} public void test4(){} }","categories":[{"name":"测试","slug":"测试","permalink":"http://yov.oschina.io/categories/测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yov.oschina.io/tags/TestNG/"}]},{"title":"Git使用(Linux)","slug":"Git使用(Linux)","date":"2017-09-25T09:36:06.108Z","updated":"2017-09-26T12:52:36.796Z","comments":true,"path":"article/工具/Git使用(Linux)/","link":"","permalink":"http://yov.oschina.io/article/工具/Git使用(Linux)/","excerpt":"","text":"环境安装 安装git sudo apt-get install git 配置git用户名 git config –global user.name &quot;user_name&quot; 配置用户邮箱地址 git config –global user.email &quot;user_mail&quot; 创建本地仓库 创建空目录 mkdir folder_name 进入空目录 cd folder_name 显示当前目录 pwd 把当前目录变为Git仓库 git init 把文件添加到Git仓库 git add file 把文件提交到Git仓库 git commit -m &quot;commit_message&quot; 版本库操作 查看修改内容 git diff file_name 查看工作区状态 git status 查看历史记录 git log 查看精简历史记录 git log --pretty=oneline 回退到上一个版本 git reset --hard HEAD^ 回到某个指定版本 git reset –-hard commit-id(git log查看) 查看命令记录 git reflog 撤销全部工作区修改 git checkout --file 将暂存区修改撤销放回工作区 git reset HEAD 文件 linux删除文件 rm file git库删除文件 git rm file 下载他人项目 git clone https://github.com/xxx/xxx.git new_git_name 分支管理 创建并切换到分支 git checkout -b dev_name 查看当前分支 git branch (*表示当前分支) 切换分支 git checkout dev_name 合并指定分支到当前分支(fast forward 模式) git merge dev_name 删除分支 git branch -d dev_name 合并分支时冲突,修改文件后,再提交 查看分支合并图 git log --graph --pretty=oneline --addrev-commit 合并分支（普通模式） git merge -- no-ff -m &quot;commit_message&quot; dev 多人合作 查看远程库信息 git remote -v 推送主分支 git push origin master 推送其他分支 git push origin dev_name 创建本地分支 git checkout -b dev_name origin/dev_name 指定本地分支与远程分支的链接 git branch --set-upstream-to=origin/dev_name 获取远程库内容 git pull 解决冲突后commit，再上传 git push origin dev_name 标签管理 创建标签 git tag tag_name 给指定提交打标签 git tag tag_name commit-id 创建带说明的标签 git tag -a tag_name -m &quot;message&quot; commit-id 查看标签说明 git show tag_name 删除标签 git tag -d tag_name 推送标签 git push origin tag_name 一次性推送所有标签 git push origin --tags 删除标签（本地） git tag -d tag_name 删除远程标签 git push origin :refs/tags/tag_name 自定义Git 使git显示不同颜色 git config --global color.ui true 忽略某些文件时，需要编写.gitignore 强制添加被忽略文件 git add -f file 检查某个文件符合被忽略要求 git check-ignore -v file 配置命令别名 git config --global alias.别名 命令","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yov.oschina.io/tags/Git/"}]},{"title":"Docker的安装说明","slug":"Docker/Docker的安装说明","date":"2017-09-24T10:43:23.794Z","updated":"2017-10-19T02:19:59.219Z","comments":true,"path":"article/容器/Docker/Docker的安装说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker的安装说明/","excerpt":"","text":"安装及部署Docker 系统和资源说明 Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。 资源需求：Docker1.12.6 安装步骤 (1)安装 $ yum install docker (2)设置开机启动Docker Daemon进程 $ systemctl start docker.service // 启动docker $ systemctl enable docker.service // 设置Docker开机自启动 $ systemctl disable firewalld // 关闭防火墙 $ yum -y install iptables-services // 安装iptable服务 $ systemctl start iptables.service // 启动iptable $ systemctl enable iptables.service // 设置iptable开机自启动 (3)安装成功的Docker $ docker version (4)建立docker用户组，将使用docker的用户加入docker用户组。 $ groupadd docker $ usermod -aG docker $USER Docker的代理配置 $ vim /usr/lib/systemd/system/docker.service [Service] Environment=”HTTP_PROXY=http://192.168.13.19:7777” Environment=”HTTPS_PROXY=http://192.168.13.19:7777” Type=notify Docker配置加速器 国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了阿里云加速器 注册用户并且申请加速器后，会获得 https://xxx.mirror.aliyuncs.com 这样的地址。 $ vim /usr/lib/systemd/system/docker.service ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com $ systemctl daemon-reload // 重新加载配置 $ systemctl restart docker // 重启docker Docker配置文件说明 $ vim /etc/sysconfig/docker OPTIONS=' --selinux-enabled // 是否开启selinux，默认开启 --insecure registry ip:port // 添加私人仓库地址 --bip=ip // 表示网桥docker0的CIDR地址 ' Docker的常用命令 Docker信息查看 (1)查看docker进程状态 $ systemctl status docker (2)查看docker的具体信息 $ docker info (3)查看docker的版本信息 $ docker version Docker的镜像操作 (1)查找镜像 $ docker search image_name (2)拉取镜像 $ docker pull image_name:tag (3)列出本地镜像 $ docker images 列表参数说明 Repository：镜像的仓库源 Tag：镜像的标签 Image ID： 镜像ID Created： 镜像的创建时间 Size： 镜像大小 (4)设置镜像标签 $ docker tag image_id tag (5)利用镜像创建容器 $ docker run image_name:tag command (6)提交镜像 $ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name Docker的容器操作 (1)启动容器 $ docker run option host_port:contaniner_port image_name:tag command 例如：docker run -it -d -p 5000:5000 java java -version -d：后台运行容器 -p:将容器端口映射到宿主机端口 -it:进行交互式操作 command: 执行java -version命令 (2)查看容器 $ docker ps // 查看正在运行的容器 (3)容器生命周期命令 $ docker create image:tag // 创建容器但不启动 $ docker start container_name // 启动容器 $ docker stop contaniner_name // 停止容器 $ docker restart container_name // 重启容器 $ docker pause contaniner_name // 暂停容器内所有进程 $ docker unpause contaniner_name // 恢复容器内所有进程 $ docker rm contaniner // 删除容器 $ docker rm ${docker ps -a -q} // 删除所有停止的容器","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker的简单说明","slug":"Docker/Docker的简单说明","date":"2017-09-24T09:36:05.889Z","updated":"2017-09-25T08:47:46.483Z","comments":true,"path":"article/容器/Docker/Docker的简单说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker的简单说明/","excerpt":"","text":"Docker简介 Docker的概念 Docker最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。Docker被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将应用软件及其依赖软件（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。 Dcoker的技术依赖 Docker使用Go语言进行开发实现，基于Linux内核的cgroup、namespace以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于LXC、0.7后去除LXC，使用自行开发的libcontainer。从1.11开始，则使用runC和containerd。 （1）cgroup是将任意进程进行分组化管理的Linux内核功能。重要概念是子系统，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。 （2）LXC（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于namespace的隔离机制和cgroup限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。 （3）AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。 （4）App打包：Docker额外提供的Feature,标准统一的打包部署运行方案。 Docker的优势 Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而容器内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。 （1）更高效的利用系统资源 由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。 （2）更快速的启动 Docker容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动，大大节约了开发、测试、部署的时间。 （3）一致的运行环境 Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致性。 （4）持续交付和部署 Docker可以通过定制应用镜像实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来创建镜像，并结合持续集成（Continuous integration）系统进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。 （5）更轻松的迁移 由于Docker确保了运行环境的一致性，使得应用迁移更加容易。 （6）更轻松的维护和扩展 Docker使用的分层存储以及镜像技术，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易. Docker相关的基础概念 Docker Image 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。Docker镜像（Image）就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含一些为运行时准备的配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。 分层存储 因为传统镜像包含操作系统完整的root文件系统，其体积往往庞大。因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，任何额外的东西应在该层构建结束前清理结束。 分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。 Docker Container 镜像（Image）是静态定义，容器（Container）是镜像运行时的实体。容器可以被创建、启动、停止等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。 容器也是分层存储的，每个容器运行时以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。 按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。 Docker Registry 镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即Docker Registry。 一个Docker Registry包含多个仓库（Repository）；每个仓库包含多个标签Tag；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;来获取指定版本的镜像，如果不给出标签，就将以latest为默认标签。 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的Docker Hub。 除了公开服务外，用户还可以在本地搭建私有的Docker Registry。Docker官方提供Docker Registry镜像，可以直接使用作为私有Registry服务。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(二)","slug":"Java Base/Java基础知识(二)","date":"2017-09-24T03:29:54.604Z","updated":"2017-10-21T05:58:30.981Z","comments":true,"path":"article/Java/Java Base/Java基础知识(二)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(二)/","excerpt":"","text":"运算符 常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。 基本运算符 =为赋值运算符。 四则运算符基本组成：+、-、*、/、%。不要使用运算符编写过于复杂的计算。 public class Demo { public static void main(String[] args) { int numA = 10; double numB = 20; int numC = 3; System.out.println(&quot;加法计算：&quot; + (numA + numB)); System.out.println(&quot;减法计算：&quot; + (numA - numB)); System.out.println(&quot;乘法计算：&quot; + (numA * numB)); System.out.println(&quot;除法计算：&quot; + (numA / numB)); System.out.println(&quot;求模计算：&quot; + (numA % numC)); } } 简化运算符：+=、-=、*=、/=、%=: public class Demo { public static void main(String[] args) { int numA = 10; numA += 2; // 等同于 numA = numA + 2 System.out.println(&quot;加法计算&quot; + (numA)); // 12 } } ++（自增），--（自减）：位置不同，功能也不同： ·++变量，--变量：先对变量加/减1，再使用自增或自减后的变量进行计算; ·变量++，变量--：先使用变量进行计算，再进行变量加/减1。 public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; // ++变量，先numA + 1 // 然后(numA + 1) + numB内容 // 最后对numB加1 int result = (++numA) + (numB++); System.out.println(&quot;numA=&quot; + numA); // 11 System.out.println(&quot;numB=&quot; + numB); // 21 System.out.println(&quot;result=&quot; + result); // 31 } } 三目运算符 三目运算符根据布尔表达式的结果进行赋值： value_type value_name = 布尔表达式 ? true_value : false_value; 利用三目运算符可以减少判断代码: public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; int max = 0; /** 使用三目运算符 * 当numA大于numB,返回true,max = numA * 当numA小于numB,返回false,max = numB */ max = numA&gt;numB ? numA : numB; // 不使用三目运算符 // if (numA &gt; numB) { // max = numA; //} else { // max = numB; //} System.out.println(max); } } 逻辑运算符 逻辑运算符：与&amp;，&amp;&amp;、或|，||、非! package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = true; System.out.println(!flag); // false } } 布尔表达式的连接，只能使用与和或操作 与：所有条件都为true时，结果为true;有一个为false，结果就是false. 范例：普通与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：程序报错，因为&amp;会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。 范例：短路与&amp;&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp;&amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // false,不报错 } } } 结果:程序不报错，因为&amp;&amp;只要有一个条件为false后，后续判断就不再进行，从而提高了效率。 或操作：一个条件为true，结果为true。 范例：普通或| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) | (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：使用|，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。 范例：短路或|| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) || (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // true,不报错 } } } 因此使用逻辑运算时就使用&amp;&amp;和||。 位运算符 数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。 位运算主要是进行二进制数据操作，位运算符：&amp;、|、&gt;&gt;(移位)、&lt;&lt;、^(反码)、~。 范例：位与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA &amp; numB); // 9 } } 运算过程： 1001 → 9 &amp; 1011 → 11 1001 → 9 范例：位或| package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA | numB); // 11 } } 运算过程： 1001 → 9 | 1011 → 11 1011 → 11 范例：移位（最快方式计算2的3次方） package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; num = num &lt;&lt; 2; // 向左移位 System.out.println(num); // 8,相当于2的3次方 } } 运算过程： 0010 → 2 2&lt;&lt; 1000 → 8 章节小问题：请解释&amp;与&amp;&amp;的区别，以及|与||的区别: 1. 在逻辑运算中： |- &amp;和|会对所有条件进行判断后，返回结果 |- &amp;&amp;只要一个条件返回false，就不进行后续判断，结果为false |- ||只要一个条件为true，就不进行后续判断，结果为true 2. 在位运算中： |- &amp;为位与元算，|为位或元算 |- &amp;&amp;和||不能用于位运算 Java程序逻辑控制 程序逻辑结构主要分为三种：顺序结构、分支结构、循环结构。顺序结构执行顺序是从前到后，但有时是以代码所在的{}为界限。 分支结构 分支结构即判断结构，有两种语法：if和switch. if语句: if语句的格式: if if…else if…else if…else 范例：if判断 package com.java.demo; public class Demo { public static void main(String[] args) { double score = 90.0; if (score &lt; 60.0) { System.out.println(&quot;不及格&quot;); } else if (score &lt; 90) { System.out.println(&quot;良&quot;); } else { System.out.println(&quot;优秀&quot;); } } } switch语句: switch判断不能使用布尔表达式，JDK1.5之前只能进行整数或字符判断，JDK1.5增加了枚举判断，JDK1.7增加了String判断，语法： switch (数字/字符/枚举/字符串){ case 内容 : 内容满足时执行的代码 ; break; case 内容 : 内容满足时执行的代码 ; break; ... default { 内容都不满足case时执行; break; } } 范例：使用switch package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; switch (num) { case 1: System.out.println(&quot;数字1&quot;); break; case 2: System.out.println(&quot;数字2&quot;); break; default: System.out.println(&quot;大于2的数字&quot;); break; } } } switch默认从第一个符合条件的case语句开始执行，直到整个switch执行完毕或遇到break关键字，才停止执行。程序区分大小写。 循环结构 当某段代码需要重复执行时，可使用循环语句实现，循环有两种：for循环和while循环。 while循环： while循环 do…while循环 while（布尔语句）｛｝ do｛｝while（布尔语句); 范例：实现1到100的累加（while循环先判断再执行）： package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; // 循环的初始化条件 while (current &lt;= 100) { // 循环结束条件 sum += current; // 累加 current++; // 修改循环的初始化条件 } System.out.println(sum); // 5050 } } 范例：实现1到100的累加（do…while循环是先执行再判断） package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; do { sum += current; current++; } while (current &lt;= 100); System.out.println(sum); } } do…while循环先执行再判断，即不论循环条件是否满足，都至少执行一次，因此开发中不建议使用do…while。 for循环： for (循环初始化条件; 循环结束条件; 循环条件变更) { 循环语句; } 即使三个条件都不写，但是两个&quot;;&quot;必须保留。 范例：实现1~100的累加 package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(sum); } } 开发原则: （1）循环次数未知，循环结束条件已知时使用while循环； （2）循环次数已知，使用for循环。 循环嵌套 public class 九九乘法表 { public static void main(String[] args) { for (int x = 1; x &lt;= 9; x++) { for (int y = 1; y &lt;= x; y++) { System.out.print(x + &quot;*&quot; + y + &quot;=&quot; + (x * y) + &quot;\\t&quot;); } System.out.println(); } } } 循环控制 循环控制有两个语句：continue（退出本次循环）和break（结束整个循环）。该语句要和判断语句一起使用。 范例：continue使用 package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { continue; // 跳出本次循环，不进行后续的输出操作 } System.out.print(x + &quot;,&quot;); // 0,1,2,4, } } } 范例：break package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { break; // 结束整体循环 } System.out.print(x + &quot;,&quot;); // 0,1,2, } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2017-09-23T09:19:24.606Z","updated":"2017-09-25T08:47:54.232Z","comments":true,"path":"article/语言/Markdown语法/","link":"","permalink":"http://yov.oschina.io/article/语言/Markdown语法/","excerpt":"","text":"Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。 Markdown语法 区块元素 段落与换行 一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是无法使用空格或制表符来缩进的，因为其默认一个空格就是一个空行。 标题 Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个#，对应1到6级标题。 # 这是H1 ## 这是H2 ... ###### 这是H6 区块引用Blockquotes Markdown标记区块引用方式如下： &gt; 文本内容。 &gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt; 在引用的区域中，也可以使用其他的Markdown语法。 列表 Markdown支持有序列表和无序列表。无序列表使用星号、减号或加号作为列表标记: * red - green + blue 有序列表则使用数字接着一个英文句号： 1. red 2. green 3. blue 如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即： * blue *red 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 如果要在列表项目中放入引用，就需要缩进 * red &gt; this is color 如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。 代码区域 要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。 分隔线 你可以在一行使用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。 星号： * * * 减号： - - - 下划线：_ _ _ 区段元素 链接 Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。 [example](https://www.baidu.com &quot;Title&quot;) 强调 Markdown使用星号和下划线标记强调，被*或_包围的字词会被转为用&lt;em&gt;标签包围，而用两个*或_包起来，则变为&lt;strong&gt; *强调* _强调_ **强调** __强调__ 如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠： \\*文字\\* 代码 如果要标记一小段行内代码，可以使用反引号把它包起来，例如： `printf()` 如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段: `` (`) `` 将变为 &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt; 图片 插入图片有两种方式：行内式和参考式 ![替代图片的文字](/path/to/img.jpg &quot;文字&quot;) 结束 感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yov.oschina.io/tags/Markdown/"}]},{"title":"SpringBoot小例子","slug":"Spring Boot/SpringBoot小例子","date":"2017-09-23T08:58:23.811Z","updated":"2017-10-26T02:15:33.009Z","comments":true,"path":"article/框架/Spring Boot/SpringBoot小例子/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子/","excerpt":"","text":"第一个Spring Boot应用 创建项目 1.打开 IDEA, 选择 Create New Project 2.左侧菜单选择Spring Initializr, Next即可 3.Project Metadata默认即可，Next 4.Dependencies选择Web中的Web即可,Next 5.Project Name默认即可,finsh 项目结构 demo // 项目名 |- .idea |- .mvn |- src // 代码存放区 |- main |- java |- com.example.demo // java包 |- DemoApplication.java // 项目启动类 |- resources |- static // 用于存放css,js等样式文件 |- templates // 用于存放html文件 application.properties // 项目配置文件 |- test //测试代码存放区 |- target .gitignore mvnw mvnw.cmd demo.iml pom.xml // 项目对象模型,添加项目依赖等配置 DemoApplication.java package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(PersonApplication.class, args); } } @SpringBootApplication标注它是一个SpringBoot应用,main方法使说明它是主程序,在应用启动时首先被执行。 右键run,然后在浏览器中输入localhost:8080即可访问页面,因为当前未定义页面,因此显示Error Page 第一个页面 在com.example.demo文件下创建HelloController.java package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { // 设置请求路径为 /hello,请求方式为get @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return &quot;Hello World!&quot;; } } RestController注解该类是一个控制器。当用户访问指定路径时,将调用say()返回&quot;Hello World&quot;。 右键run,然后在浏览器中输入localhost:8080/hello即可访问页面,此时可在页面看到Hello World! 项目属性配置 建议将项目中application.properties改为application.yml,便于配置 server: port: 8080 # 端口号 context-path: /demo # 主路径配置 age: 18 # 自定义属性 content: &quot;age: ${age}&quot; # 配置文件中调用属性 获取配置文件中的属性值 package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Value(&quot;${content}&quot;) private String content; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return content; } } 右键run,然后在浏览器中输入localhost:8080/demo/hello即可访问页面,此时可在页面看到age: 18 当有一系列属性值时 可将其定义为某个属性的子属性 server: port: 8080 person: name: Tom age: 40 定义一个PersonProperties类 package com.temp.person; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component // 将类实例化到Spring容器中 @ConfigurationProperties(prefix = &quot;person&quot;) // 获取前缀为person的配置 public class PersonProperties { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 获取配置文件中的值: package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired private PersonProperties personProperties; // 定义对象,从而间接获取属性值 @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return personProperties.getName; } } 右键run,然后在浏览器中输入localhost:8080/demo/hello即可访问页面,此时可在页面看到Tom。对于配置文件中属性的读取建议采用该方式。 多种配置文件 假设现在有两种配置文件application-dev.yml和application-prod.yml [application-dev.yml] demo: name: you age: 20 [application-prod.yml] demo: name: you age: 20 只需在application.yml中 spring: profiles: # 选择要调用的配置文件 active: dev 当要使用某种时,active设为那个文件的值即可。 Controller的基本使用 注解 功能 @Controller 处理http请求 @RestController Spring4之后新加的注解，原先返回json需要@ResponseBody配合@Controller @RequestMapping 配置url映射 @PathVariable 获取url中的数据 @RequestParam 获取请求参数的值 @GetMapping 组合注解 访问路径和访问方式 1.@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)设置访问路径为&quot;hello&quot;,请求方式为get，可以简写为@GetMapping(value = &quot;/hello&quot;) 2.可将路径设为集合,使得访问的路径不同,但请求的资源相同:@RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;}) 3.可以为整个类设置访问路径,如下： package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController @GetMapping(value = &quot;/demo&quot;) public class HelloController { @GetMapping(value = {&quot;/hello&quot;, &quot;hi&quot;}) public String say() { return &quot;Hello World!&quot;; } } 在浏览器输入地址http://localhost:8080/demo/hello和http://localhost:8080/demo/hi均能看到页面显示Hello World!. 获取路径参数 1.@PathVariable 获取路径参数 @GetMapping(value = &quot;/hello/{id}&quot;) public Integer say(@PathVariable(&quot;id&quot;) Integer id) { return id; } 在浏览器输入地址http://localhost:8080/hello/100此时页面显示100 2.@RequestParam 获取请求参数 @GetMapping(value = &quot;/hello&quot;) // 获取路径中参数id的值,id可不存在，默认为0 public Integer say(@RequestParam(value = &quot;id&quot;,required = false,defaultValue =&quot;0&quot;) Integer id) { return id; } 在浏览器输入地址http://localhost:8080/hello/100?id=100此时页面显示100 数据库操作 Java客户端使用Spring-Data-Jpa组件。 JPA（Java Persistence API）定义了一系列对象持久化的标准,目前实现这一规范的产品有Hibernate、TopLink等。 RESTful API设计 请求类型 请求路径 功能 Get /person 获取数据列表 POST /person 添加数据 Get /person/id 根据id获取数据 PUT /person/id 根据id修改数据 DELETE /person/id 根据id删除数据 添加依赖 在pom.xml添加jpa依赖和MySQL组件 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 修改配置文件 在application.yml中添加数据库配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver # 驱动 url: jdbc:mysql://127.0.0.1:3306/dbperson # 数据库url username: root password: jpa: hibernate: ddl-auto: udate show-sql: true 创建数据表 在Spring Boot中可通过创建实体类，自动生成数据表 package com.example.demo; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity // 注册实体,Spring Boot会自动将其变为数据表 public class Person { @Id // 设为数据表中id属性 @GeneratedValue // 设置为自增 private Integer id; private String name; private Integer age; public Person() { } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } } Spring Boot会将上述代码中类的属性变为数据表的字段。 创建PersonRepository接口 该接口继承JpaRepositoy,实现sql语句 package com.example.demo; import org.springframework.data.jpa.repository.JpaRepository; import java.util.List; public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; { // 自定义方法,实现通过年龄找数据 List&lt;Person&gt; findByAge(Integer age); } 创建PersonController,实现访问时根据访问方式和路径实现数据操作 package com.example.demo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import javax.transaction.Transactional; import java.util.List; @RestController public class PersonController { @Autowired private PersonRepository personRepository; /** * 通过get方式访问localhost:8080/person可获取全部数据 * @return 数据类集 */ @GetMapping(value = &quot;/person&quot;) public List&lt;Person&gt; personList(){ return personRepository.findAll(); } /** * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据 * @param name 数据表的name字段 * @param age 数据表的age字段 * @return 返回Person对象 */ @PostMapping(value = &quot;/person&quot;) public Person addPerson(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) Integer age) { Person person = new Person(); person.setName(name); person.setAge(age); return personRepository.save(person); } /** * 通过get方式访问localhost:8080/person/1可获取id为1的数据 * @param id 要查询的数据id * @return Person对象 */ @GetMapping(value = &quot;/person/{id}&quot;) public Person findPersonById(@PathVariable(&quot;id&quot;) Integer id) { return personRepository.findOne(id); } /** * 通过put方式访问localhost:8080/person/1?name=Jane&amp;age=10可将id为1的数据修改 * @param id 要修改的数据id * @return Person对象 */ @PutMapping(value = &quot;/person/{id}&quot;) public Person updatePersonByid(@PathVariable(&quot;id&quot;) Integer id, @RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) Integer age) { Person person = personRepository.findOne(id); person.setName(name); person.setAge(age); return personRepository.save(person); } /** * 通过delete方式访问localhost:8080/person/1可将id为1的数据删除 * @param id 要删除数据的id */ @DeleteMapping(value = &quot;/person/{id}&quot;) public void deletePersonById(@PathVariable(&quot;id&quot;) Integer id) { personRepository.delete(id); } /** * 通过get方式访问localhost:8080/person/age/10可查找age为10的数据 * @param age 要查找的年龄 */ @GetMapping(value = &quot;/person/age/{age}&quot;) public List&lt;Person&gt; personListByAge(@PathVariable(&quot;age&quot;) Integer age) { return personRepository.findByAge(age); } /** * 实现事务管理,批量增加数据,一个数据失败，全部数据不得入库 * @Transactional 用于标注事务管理 */ @PostMapping(value = &quot;/person/two&quot;) @Transactional public void addTwoPerson() { Person personA = new Person(); personA.setName(&quot;Tony&quot;); personA.setAge(13); personRepository.save(personA); Person personB = new Person(); personB.setName(&quot;Maria&quot;); personB.setAge(18); personRepository.save(personB); } }","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Go基础知识","slug":"Go Base/Go基础知识","date":"2017-09-23T08:57:17.832Z","updated":"2017-10-21T05:57:57.492Z","comments":true,"path":"article/Go/Go Base/Go基础知识/","link":"","permalink":"http://yov.oschina.io/article/Go/Go Base/Go基础知识/","excerpt":"","text":"入门 Go语言是一门编译型语言，是一个开源的编程语言，能让构造简单、而且高效的软件变得容易。Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go语言环境安装 Go语言安装包下载地址为Golang。Windows使用mis后缀的安装包即可。默认情况msi文件会安装在c:\\Go目录下。Go语言的开发工具可以使用LitelDE，是一款开源、跨平台的轻量级Go语言集成开发环境.。也可以在Eclipse或IDEA中安装Go语言插件。 第一个Go程序 package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello World!&quot;) } Go的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go提供的工具都通过go命令调用。其中go run就是编译go的源文件，链接库文件，并运行生成的可执行文件。 $ go run helloworld.go Go语言支持Unicode，可以处理任何语言的文本，包括中文。 如果要编译上述程序，保存编译结果以备将来使用，可以使用build子命令： $ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（注：Windows系统下生成的是helloworld.exe），之后可以随时运行它，不需要任何处理（注：因为是静态编译，所以不必担心系统库更新时的冲突）。 Go语言的代码通过包（package）组织，包类似与其他语言中的库（libraries）或者模块（modules）。一个包由单个目录下的一个或多个go源代码文件组成，目录定义包的作用。每个源文件都以package声明语句为开始。上述例子就是package main，紧跟着导入（import）的包，之后是程序代码。 fmt包含有格式化输出、接收输入的函数，Println是其中一个基础函数。 main包比较特殊，定义了一个独立可执行的程序，而不是一个库。main包中的main函数是整个程序执行时的入口。import声明告诉编译器需要哪些包，缺少必要的包或者导入不需要的包，程序都无法编译通过。 组成程序的函数、变量、常量、类型的声明语句分别由关键字func、var、const、type定义。一个函数的声明由func关键字、函数名、参数列表、返回值列表（mian函数不含返回值）以及包含在大括号里的函数体组成。Go语言不需在语句末尾添加分号，除非一行有多条语句。 程序结构 命名 Go语言的函数名、变量名、常量名、类型名、语句标号和包名等所有命名的规则是： （1）由字母、下划线、或数字组成，以字母或下划线开头，区分大小写。 （2）不能使用关键字。Go语言有25个关键字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var （3）Go语言还有30多个预定义的名字，如int和true等，对应内建的常量、类型和函数。 内建常量 true false iota nil 内建类型 int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数 make len cap new append copy close delete complex real imag panic revover 内部预定义的名字不是关键字，因为可以在定义中重新使用它们。在一些特殊场景重新定义它们时要避免过度而引起的语义混乱。 （4）命名长度没有限制，但应尽量短小。如果作用域较大，生命周期长，应见名知意。 （5）Go语言推荐使用驼峰式命名，而对于ASCII和HTML这样的缩略词则不变，即escapeHTML，而不是escapeHtml。 （6）如果一个标识符是在函数内部定义的，那么它只在函数内部有效。如果在函数外部定义，则当前包中所有的文件都可以访问该标识符。名字开头字母的大小写决定了标识符在包外的可见性：如果开头是大写字母，那么它是公开，可被外部包访问，如fmt包的Printf函数就可以在fmt包外访问。包的名字一般总是小写。 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。 （1）一个Go程序对应一个或多个go源文件。每个源文件以包的声明语句开始，说明该文件属于哪个包。之后是import语句，然后是包一级的类型、变量、常量、函数声明语句。 范例：声明常量、函数、变量 package main // 包声明 import &quot;fmt&quot; // 导入依赖包 const boilingF = 212.0 // 定义常量 /** 进行摄氏度和华氏度的转换 */ func main() { // 定义函数 var f = boilingF // 定义变量 var c = (f - 32) * 5 / 9 fmt.Printf(&quot;boiling point = %g°F or %g°C\\n&quot;, f, c) } 上述代码中，bilingF是包级别的声明,作用范围为包内的所有文件。f和c是在函数内部声明的，作用范围仅在函数内部。 （2）一个函数的声明由函数名、参数、可选的返回值和函数体组成。如果没有返回值，就可不定义返回值。函数的执行从第一个语句，依次执行直到遇到return语句或执行完毕。 如果要多次进行摄氏度与华氏度的转换，可以将其定义为函数。 package main import &quot;fmt&quot; func main() { const freezingF, boilingF = 32.0, 212.0 fmt.Printf(&quot;%g°F = %g°C\\n&quot;, freezingF, fToC(freezingF)) fmt.Printf(&quot;%g°F = %g°C\\n&quot;, boilingF, fToC(boilingF)) } /** 华氏度转为摄氏度 * f: 华氏度值 * return: 返回float64类型数据 */ func fToC(f float64) float64 { return (f - 32) * 5 / 9 } 变量 变量声明的一般语法：var 变量名 类型 = 表达式 类型或表达式可省略其一。如果省略类型，则根据表达式推断变量的类型;如果省略表达式，则变量的值为默认值： 数据类型 初始值 数值类型 0 布尔型 false 字符串型 空字符串 接口或引用类型(包括slice、指针、map、chan和函数) nil 数组或结构体等聚合类型 每个元素或字段对应该类型的初始值 Go的零值初始化机制可以保证每个变量都被初始化，因此Go中不存在未初始化的变量。这个特性可以简化很多代码，在不增加额外工作的情况下，确保边界条件下的合理行为。 可以在声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量，如果忽略每个变量的类型，就可以声明多个不同类型变量（类型由初始表达式推导） var i, j, k int // int, int, int var b, f, s = true, 2.3, &quot;four&quot; // bool, float64, string 变量也可以通过调用函数，由函数的返回值进行初始化： var f, err = os.Open(name) 简短变量声明 简短变量声明，变量的类型根据表达式自动推导，语法变量名 := 表达式 因为其简洁灵活的特点，简短变量声明常用于大部分的局部变量；var声明常用于需要显示变量类型的地方或者变量稍后会被重新赋值的而初始值无关紧要的地方。 i := 100 var boilong float64 = 100 var name []string 简短变量声明也同var一样可以声明一组变量，表达式可以是函数。 （1）简短变量声明左边的变量如果是已经被声明过的，那么此时该语句对该变量的作用只是赋值（简短变量声明一句中至少有一个变量是新地！） in, err := os.Open(infile) out, err := os.Open(outfile) // 此时&quot;:=&quot; 对于err只是进行赋值 out, err := os.Create(outfile) // 报错,没有新的变量 解决上述错误的方法是将第二个简短变量声明改为普通的多重赋值语句。 简短变量声明只对已经在同级作用范围声明的变量起到赋值作用，如果是作用域外的声明，则会在当前作用域重新声明一个新的变量。 指针","categories":[{"name":"Go","slug":"Go","permalink":"http://yov.oschina.io/categories/Go/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"http://yov.oschina.io/tags/Go基础/"}]},{"title":"Java基础知识(一)","slug":"Java Base/Java基础知识(一)","date":"2017-09-23T08:57:00.370Z","updated":"2017-10-21T05:58:00.287Z","comments":true,"path":"article/Java/Java Base/Java基础知识(一)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(一)/","excerpt":"","text":"Java基础知识 Java是一门面向对象语言，支持多线程编程;通过使用更为简单的引用来进行内存关系的匹配，而不是复杂的指针;Java提供垃圾自动回收机制，能更好地处理垃圾空间;可以实现多平台的移植。 第一个Java程序 运行Java程序的步骤 javac xx.java:对Java程序进行编译，生成字节码文件xx.class。 java xx：对Java程序进行解释。 Java程序的核心单元—类 类的声明方式有两种: public class class_name {}：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。 class class_name {}：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。 第一个Java程序：Hello World package com.java.demo; // 包名 public class HelloWorld { // 类 public static void main(String[] args) { // 主方法 System.out.println(&quot;Hello World&quot;); // 方法体 } } Java程序都是从主方法开始执行的.System.out.println()将内容输出后换行。 CLASSPATH环境属性 PATH和CLASSPTH的区别：PATH是操作系统路径，定义了所有可执行程序的路径；CLASSPATH是Java解释类文件时的加载路径，当java命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。 配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。 注释 // 注释内容： 单行注释 /* 注释内容 */： 多行注释 /** 注释内容 */：文档注释 标识符与关键字 标识符 标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下： （1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字； （2）标识符应尽量有意义，可见名知意。 （3）Java标识符可以是中文，但不建议使用中文命名标识符。 关键字 Java中有两个未使用的关键字goto和const；JDK1.4之后增加了assert关键字；JDK1.5之后增加了enum关键字。 Java数据类型 Java数据类型分为两大类：基础数据类型和引用数据类型 两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。 基本数据类型： |-数值型： |-整型：byte、short、int、long； →默认值：0； |-浮点型：float、double； →默认值：0.0 |-字符型：char； →默认值：‘\\u0000’ |-布尔型：boolean； →默认值：false |-引用数据类型：数组、类、接口等。 →默认值：null 数据类型的选择原则 （1）整数用int，小数用double； （2）描述日期时间或内存大小，用long； （3）实现内容传递或编码转换用byte； （4）逻辑控制用boolean； （5）避免中文乱码用char。 整型 数字常量属于int型数据，如数字30。 常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量： package com.java.demo; public class Demo { public static void main(String[] args) { // 一个变量名在同一块代码中只允许声明一次 // 变量赋值语法：value_type value_name = value ; int num = 10; num = num * 2; System.out.println(num); } } 每个数据类型都有其对应的存储范围 package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; // int型数据的最大值 int min = Integer.MIN_VALUE; // int型数据的最小值 System.out.println(max); // 2147483647 System.out.println(max + 1); // -2147483648 System.out.println(min); // -2147483648 System.out.println(min - 1); // 2147483647 System.out.println(min - 2); // 2147483646 } } 当数据超过int型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为数据溢出，解决方法是扩大数据范围： package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; // int变量 + long变量 = long变量,扩大了数据的范围 System.out.println(max + 1L); // 2147483648 System.out.println(min - (long)1); // -2147483649 System.out.println((long)min - 2); // -2147483650 } } 数据类型的转换规律 范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型； 范围大的数据类型只能通过强制转换变为范围小的数据类型。 常量进行强制转换，可通过使用常量标记（如L，l可将int型常量变为long型）或使用(数据类型)常量。范例–强制转换： package com.java.demo; public class Demo { public static void main(String[] args) { // 1000是int型，使用long型变量接收，发生自动转换 long num = 1000; // long型变为int型，强制转换 int x = (int) num; System.out.println(x); // 1000 } } 当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生数据溢出。 package com.java.demo; public class Demo { public static void main(String[] args) { // 2147483650L是long型数据，超出int型的范围 long num = 2147483650L ; int x = (int) num; System.out.println(x); // -2147483646，数据溢出 } } byte型数据的取值范围为-128~127，当整数数值在这个范围内时，会自动转型；超出byte范围时会发生数据溢出。 4. 注意点 变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。 package com.java.demo; public class Demo { public static void main(String[] args) { // 未给变量赋值 int num; // 报错,未初始化变量,无法使用该变量 System.out.println(num); } } 浮点型 Java中浮点数属于double型（double型是保存范围最广的类型）。 package com.java.demo; public class Demo { public static void main(String[] args) { double num = 10.2; // 10.2是小数，属于double型 // double型 * int型 = double型 System.out.println(num * 2); // 20.4 } } 所以使用float数据须将double强制转换为float型： package com.java.demo; public class Demo { public static void main(String[] args) { float fA = 10.2F; // 强制转型方式一 float fB = (float) 10.2; // 强制转型方式二 System.out.println(fA); // 10.2 System.out.println(fB); // 10.2 System.out.println(fA * fB); // 104.03999,该bug无法解决 } } 开发过程中要考虑到整型数据不保留小数位： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / x); // 1 } } 因为int型/int型=int型，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / (double) x); // 1.8 } } 字符型 byte byte是字节，1字符=2字节。Java使用十六进制UNICODE编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。 字符使用单引号'声明，一对单引号只能保存一位字符。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型可以自动转换为int型 System.out.println(c); System.out.println(num); // 65,是A的ASCII码值 } } 编码：'A'(65)~'Z'(90); 'a'（97）~'z'（122）; '0'（48）~'9'(57),可利用A和a的编码差为32，实现字母大小写转换： package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型变为int型才能进行四则运算 num = num + 32; // 大写与小写编码值差为32 c = (char) num; // int型只能强制转换为char型 System.out.println(c); // a } } 传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = '游'; int num = c; System.out.println(num); // 28216 } } 由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。 布尔型 布尔型返回逻辑结果，只保存两种数据：true和false，主要用于逻辑控制： package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = false; // if (布尔值){满足条件时的操作} if (!flag) { System.out.println(&quot;Hello World !&quot;); } } } String型 String型 String属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号&quot;&quot;声明。 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // str为字符串变量 System.out.println(str); // &quot;Hello World !&quot;为字符串常量 System.out.println(&quot;Hello World !&quot;); } } +可实现字符串连接 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str = str + &quot; World !&quot;; System.out.println(str); } } 当四则运算与字符串连接同时存在时： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + numA + numB; System.out.println(str); // 加法计算：10099.9 } } 出现上述结果是因为小范围数据会自动转型为大范围数据，即String型+任意数据类型=String型，然后进行字符串连接，可使用()来实现正确的运算： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + (numA + numB); System.out.println(str); // 加法计算：199.9 } } Java支持转义字符， 例如：换行\\n、制表符\\t、反斜杠\\\\、双引号\\&quot;、单引号\\'： package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello \\&quot;World\\&quot; \\nHello MLDN&quot;; System.out.println(str); /** * Hello &quot;World&quot; * Hello MLDN */ } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Gitee+Hexo搭建个人博客","slug":"Gitee+Hexo搭建个人博客","date":"2017-09-22T13:48:40.242Z","updated":"2017-10-02T06:55:01.573Z","comments":true,"path":"article/博客搭建/Gitee+Hexo搭建个人博客/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/Gitee+Hexo搭建个人博客/","excerpt":"","text":"Gitee: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。 Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。 环境搭建 安装Node.js Windows用户访问Node.js下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。 $ npm config set registry http://registry.npm.taobao.org/ Hexo安装 $ npm install -g hexo-cli Hexo的基本使用请查看hello-world文中所写。 本地运行Hexo 在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件： $ hexo init 初始化后，文件夹的目录如下： . ├── .deploy #需要部署的文件 ├── node_modules #Hexo插件 ├── public #生成的静态网页文件 ├── scaffolds #模板 ├── source #博客正文和其他源文件等都应该放在这里 | ├── _drafts #草稿 | └── _posts #文章 ├── themes #主题 ├── _config.yml #全局配置文件 └── package.json 之后在本地执行如下命令后，即可访问 http://localhost:4000 访问Hexo页面 $ hexo s Git安装 Git安装包地址,根据操作系统选择安装包下载后安装即可。 注册码云账号，并创建一个项目 获取项目地址 发布博客 修改Hexo配置文件_config.yml deploy: type: git repo: 码云的项目地址 branch: master 部署博客 $ npm install hexo-deployer-git --save $ hexo g --d #一键部署 此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。 开启Page功能 访问博客 在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下： 博客使用 在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为file_name.md file_name.md的文件开头如下: --- title: file_name tag: 标签名 categories: 分类 comment: 是否允许评论(true or false) description: 描述 --- 文档正文编写，请参照markdown语法。 结尾 如果搭建过程中，还有什么问题，请在下方留言。谢谢您的阅读！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-22T08:28:42.118Z","updated":"2017-09-25T08:47:28.553Z","comments":true,"path":"article/博客搭建/hello-world/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]}]}