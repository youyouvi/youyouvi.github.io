{"meta":{"title":"Ember","subtitle":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","description":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","author":"子语","url":"http://yov.oschina.io"},"pages":[{"title":"About","date":"2017-09-26T12:54:07.654Z","updated":"2017-09-26T12:54:07.654Z","comments":true,"path":"about/index.html","permalink":"http://yov.oschina.io/about/index.html","excerpt":"","text":"一个被现实从网络架构逼到了编程开发的小菜鸟x.x"},{"title":"Gallery","date":"2017-09-25T03:23:43.087Z","updated":"2017-09-25T03:23:43.087Z","comments":true,"path":"gallery/index.html","permalink":"http://yov.oschina.io/gallery/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-09-25T01:46:53.317Z","updated":"2017-09-25T01:46:53.317Z","comments":true,"path":"links/index.html","permalink":"http://yov.oschina.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-24T15:49:20.806Z","updated":"2017-09-24T15:49:20.806Z","comments":true,"path":"tags/index.html","permalink":"http://yov.oschina.io/tags/index.html","excerpt":"","text":""},{"title":"Timeline","date":"2017-09-24T15:48:28.689Z","updated":"2017-09-24T15:48:28.689Z","comments":true,"path":"timeline/index.html","permalink":"http://yov.oschina.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础知识(九)","slug":"Java基础知识(九)","date":"2017-10-15T01:28:21.489Z","updated":"2017-10-15T02:27:47.750Z","comments":true,"path":"article/语言/Java基础知识(九)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(九)/","excerpt":"","text":"代码块 代码块是{}定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：普通代码块，构造块，静态块和同步代码块。 普通代码块 1.写在方法中的代码块，称为普通代码块。 public class Demo { public static void main(String[] args) { { // 普通代码块 int num = 10; // 局部变量 System.out.println(&quot;num = &quot; + num); // 10 } int num = 100; // 全局变量 System.out.println(&quot;num = &quot; + num); // 100 } } 普通代码块的功能是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。 构造块 1.写在类中的代码块，称为构造块。 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // B. Book类的构造块 // A. Book类的构造方法 } } 输出结果显示：构造块的调用优先于构造方法。 静态块 static定义的代码块，称为静态块。静态块的使用，分为两种情况： 1.在非主类中使用 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } static { System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // C B A new Book(); // B A } } 结果显示：**静态块优先于构造块。**且不论实例化多少个对象，静态块只执行一次。static主要功能是为类中的static属性初始化。 class Book { public static String msg; static { msg = &quot;Hello&quot;.substring(0,2); System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { System.out.println(Book.msg); } } 2.在主类中定义 public class Demo { static { System.out.println(&quot;**************&quot;); } public static void main(String[] args) { System.out.println(&quot;Hello World !&quot;); // ************** // Hello World ! } } 结果显示：静态块优先于main()方法执行。在编写测试时，可以使用静态块。 内部类 从开发角度来说，尽量不要使用内部类 内部类基本概念 1.内部类是指在一个类的内部定义其他的类。 范例：内部类 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象，调用print()方法 new Inner().print(); } } public class Demo { public static void main(String[] args) { // 实例化外部类对象 Outer out = new Outer(); out.fun(); // 调用外部类方法，Hello World } } 上述代码牺牲了程序的结构，实现了一个重要功能。 2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。 范例：取出内部类 class Outer { private String msg = &quot;Hello World&quot;; public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(msg); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); // 报错，msg属于Outer，Inner无法调用 } } （1）要想使得Inner调用msg，就需在Outer中写一个getMsg() public String getMsg(){ return this.msg; } （2）Inner要调用Outer的getMsg()方法，必须实例化一个Outer对象 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg(){ return this.msg; } public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(new Outer().getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg() { return this.msg; } public void fun() { new Inner(this).print(); } } class Inner { private Outer out; public Inner(Outer out) { this.out = out; } public void print() { System.out.println(this.out.getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 由此可得内部类的特点： 内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。 范例：访问内部类私有属性 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象 Inner in = new Inner(); // 使用内部类对象访问内部类私有属性 System.out.println(in.info); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 3.观察代码 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(this.msg); // 报错，找不到msg } } public void fun() { new Inner().print(); } } 报错原因：this.msg指向的是Inner类，而Inner类中没有msg属性。因此要访问Outer的msg属性，需要使用Outer.this.msg. class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } public void fun() { new Inner().print(); } } 4.内部类的class文件名: Outer$Inner.class 直接实例化内部类对象语法：外部类.内部类 对象名 = new 外部类().new 内部类(); 范例：实例化内部类对象 public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.print(); } } 上述代码说明： 要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。 5.内部类只想被外部类使用，不能被外部调用，应使用private定义 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; private class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } } static定义内部类 使用static定义的属性或方法不受实例化对象控制，因此使用static定义的内部类也不受外部类实例化对象控制。 1.static定义的内部类只能访问外部类中static定义的属性或方法 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); // 报错，无法引用非静态变量msg } } } 2.static定义的内部类，相当于外部类 取得static定义的内部类对象语法：外部类.内部类 对象 = new 外部类.内部类();由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于内部类成了一个外部类。 class Outer { // 外部类 private static String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); } } } public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer.Inner(); in.print(); } } 方法中定义内部类 1.内部类可定义在外部类中的任意位置。在方法中定义内部类是最常见的形式。 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun() { class Inner { // 定义在方法中的内部类 public void print() { System.out.println(msg); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(); } } 2.方法可以接收参数，也可以定义变量 范例：访问方法中定义的参数或变量 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(int num) { // 方法参数 double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(100); } } 方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后！在JDK1.8之前的版本严格要求：方法中的内部类只能访问final标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式： class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(final int num) { // 方法参数 final double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java基础知识(八)","slug":"Java基础知识(八)","date":"2017-10-14T02:34:53.423Z","updated":"2017-10-14T06:59:22.294Z","comments":true,"path":"article/语言/Java基础知识(八)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(八)/","excerpt":"","text":"对象比较 1.数字比较用==，字符串比较用equals(String str)。 要进行对象比较，必须对对象中所有属性的值进行比较。 范例：对象比较的基本方式 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.getTitle().equals(bkB.getTitle()) &amp;&amp; bkA.getPrice() == bkB.getPrice()) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 上述程序存在问题：主方法相当于客户端，客户端的程序逻辑应该越简单越好。所以对象比较应该由对象自己完成，即对象所对应的类应该提供对象比较的方法。 附：类的属性使用private封装，那么在类的外部就不能通过对象直接调用属性 class Info{ private String msg = &quot;Hello&quot;; public void print(){ System.out.println(&quot;msg = &quot; + this.msg); } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.msg = &quot;sss&quot;; // 报错，无法访问private属性 x.print(); } } 附：将一个对象作为参数传回类的方法中，相当于取消封装，使得对象可以直接访问属性。 class Info { private String msg = &quot;Hello&quot;; public void print() { System.out.println(&quot;msg = &quot; + this.msg); } public void fun(Info temp) { // 在类的内部直接利用对象访问私有属性 temp.msg = &quot;修改内容&quot;; } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.fun(x); x.print(); // msg = 修改内容 } } 附：一个类接收本类对象形式的代码在对象比较时很常见。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } // 类接收自身对象，对象可以直接访问属性，不需要getter方法 // compare()有两个功能：一带回了要比较的信息；二方便属性访问 public boolean compare(Book book) { if (book == null) { // 要比较的对象为空 return false; // 没必要比较 } if (this == book) { // 内存地址相同 return true; //避免具体比较，节约时间 } // 执行“bkA.equals(bkB)”时，有两个对象： // 一个为当前对象this(调用方法的对象，即bkA） // 一个为传递对象book(引用传递，即bkB） if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } else { return false; } } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.compare(bkB)) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 总结 （1）对象比较的方法必须定义在类中； （2）对象比较时一定要判断是否为null，内存地址是否相同，属性是否相同。 关键字static static 定义属性 问题引出： class Book { private String title; private double price; // 为操作方便，暂不封装 String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 对上述代码进行内存分析： 通过内存分析，发现属性重复：每个对象各自占有相同的属性值。假如有1000个该对象，要修改所有对象的pub属性，就需要分别进行修改。因此如果将pub属性定为普通属性，那每个堆内存都保存有各自的pub值。 1.但所有对象的pub值都一样，应将其定为一个共享的属性，即所有对象都指向同一块pub属性。可以利用static定义共享属性。 class Book { private String title; private double price; // 为操作方便，暂不封装 static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 北京大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 使用static定义属性后，只要有一个对象修改属性值，那么所有对象的该属性值都会改变，内存分析如下： 2. static定义的属性与普通属性区别在于保存数据的内存区域不同。 static定义的是公共属性，任由某个对象直接修改属性值是不合理的，应该由所有对象的代表进行属性访问，即用类访问。因此static定义的属性，可直接用类名调用：Book.pub = &quot;北京大学出版社&quot;; 3. static属性与普通属性的区别在于：普通属性必须由实例化的对象调用，而在没有实例化对象的情况下，static属性依然可以被调用。 public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，输出pub的内容 System.out.println(Book.pub); } } 由结果可知：static虽然定义在类中，但不受对象控制，是独立于类存在的。 4. 何时使用static定义属性 编写类时，static不是首选修饰符，当需要描述共享信息时，才使用static，方便集体修改，不用重复开辟内存空间。 static 定义方法 1.static定义的方法也可以直接被类名调用 class Book { private String title; private double price; // 为操作方便，暂不封装 private static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public static void setPub(String p){ pub = p; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，调用方法 Book.setPub(&quot;北京大学出版社&quot;); Book bkA = new Book(&quot;Java开发&quot;, 79.5); System.out.println(bkA.getInfo()); // 北京大学出版社 } } 上述代码存在问题：类中有两种方法，static方法和普通方法，两种方法间的访问受到限制。 （1）static方法不能直接使用非static属性或方法，只能调用static属性或方法。 public static void setPub(String p){ pub = p; title = &quot;sss&quot;; // 报错，无法引用非静态变量 getInfo(); // 报错，无法引用非静态方法 System.out.println(this); // 报错，无法引用非静态变量 } （2）普通方法可以使用static属性或方法 public String getInfo(){ setPub(&quot;&quot;); // 不报错 return &quot;,出版社：&quot; + this.pub; // 不报错 } 出现上述限制的原因： |- 普通属性和方法必须在对象实例化后分配了堆内存空间，才可以使用； |- static定义的方法和属性，不受实例化对象控制，可在没有实例化对象情况下访问。 2.一个方法定义在主类中，并由主方法直接调用，该方法定义格式如下： public static 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 一个方法定义在类中，由对象直接调用，其语法格式如下： public 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 观察代码： public class Demo { public static void main(String[] args) { fun(); } public static void fun() { System.out.println(&quot;Hello World !&quot;); } } 没有static定义的fun()必须通过对象调用，主方法要使用fun()必须实例化对象 public class Demo { public static void main(String[] args) { // 产生对象，再利用对象调用非static方法 new Demo().fun(); } public void fun() { System.out.println(&quot;Hello World !&quot;); } } 定义类中方法时，static不是首选修饰符，因为每个对象可以利用自己的属性实现方法的不同调用。 class Flag { private boolean flag; public Flag(boolean flag) { this.flag = flag; } public void fun() { if (this.flag) { System.out.println(&quot;可以操作&quot;); } else { System.out.println(&quot;不可以操作&quot;); } } } public class Demo { public static void main(String[] args) { Flag fA = new Flag(true); Flag fB = new Flag(false); fA.fun(); fB.fun(); } } 当一个类中没有属性，只有方法时，建议将所有方法定义为static方法。这样就不用每次调用时都需要有实例化对象。 class MyMath { public static int add(int x, int y) { return x + y; } } public class Demo { public static void main(String[] args) { System.out.println(MyMath.add(10, 20)); } } 主方法 1.主方法的组成： 组成 作用 public 主方法是程序的开始，所以主方法必须是可见、public（公共的）的 static 证明此方法可直接由类名调用 void 主方法是程序的开始，因此不能回头，执行完为止，所以不能有返回值 main 系统规定好的方法名，不能修改 String [] args 指的是程序运行时传递的参数 范例：对主方法传入参数 public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; args.length ; x++) { System.out.println(args[x]); // 未输出参数，为空 } } } 多个参数时，必须使用空格分割。cmd执行的是java Demo 1 3 4 6 输出为：1 3 4 6 如果参数本身带有空格，需用&quot;&quot;描述 cmd执行的是java Demo &quot;Hello world&quot; &quot;Hello Java&quot; static应用案例 已知： （1）多个对象，都使用同一个static属性； （2）static定义方法可以避免实例化对象调用方法的限制。 1.实现对实例化对象个数的统计 要求：每实例化一个对象，就输出&quot;这是第x个实例化对象&quot; 思路：每次实例化对象，就会调用构造方法，因此可在构造方法中增加一个统计数据的操作，每当新对象产生，该属性值就自增加一。 class Book { private static int num = 0; public Book() { num++; System.out.println(&quot;这是第&quot; + num + &quot;个实例化对象&quot;); } } public class Demo { public static void main(String[] args) { new Book(); new Book(); new Book(); } } 2.实现属性的自动设置 要求：类中有一个无参构造方法，一个有参构造方法，有参构造方法的功能是传递title值。不论调用的哪个构造方法，均可为title赋值，且属性值尽量不重复。 class Book { private String title; private static int num = 0; public Book() { this(&quot;Title:No.&quot; + num++); } public Book(String title){ this.title = title; } public String getTitle(){ return this.title; } } public class Demo { public static void main(String[] args) { System.out.println(new Book(&quot;Java开发&quot;).getTitle()); // Java开发 System.out.println(new Book().getTitle()); // Title:No.0 System.out.println(new Book().getTitle()); // Title:No.1 } } 总结 （1）类定义属性或方法首时选不是static属性或方法； （2）static属性或方法可直接用类名调用； （3）static属性保存在全局数据区。 （4）内存区有四种: 栈内存（对象的地址），堆内存（普通属性），全局数据区（static属性），全局代码区（所有的方法）","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java基础知识(七)","slug":"Java基础知识(七)","date":"2017-10-14T02:00:14.040Z","updated":"2017-10-14T02:29:39.213Z","comments":true,"path":"article/语言/Java基础知识(七)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(七)/","excerpt":"","text":"引用传递分析实例 引用传递 1.引用传递核心意义：同一块堆内存可以被不同栈内存所指向，不同栈内存可以对同一块堆内存进行修改。 范例：引用传递 public class Message { private int num = 10; public Message(int num) { this.num = num; } public int getNum() { return num; } public void setNum(int num) { this.num = num; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(30); System.out.println(msg.getNum()); // 30 fun(msg); // 引用传递 System.out.println(msg.getNum()); // 100 } public static void fun(Message temp) { temp.setNum(100); } } 对上述代码进行内存分析： 2.引用 public class Demo { public static void main(String[] args) { String msg = &quot;Hello&quot;; fun(msg); System.out.println(msg); // Hello } public static void fun(String temp) { temp = &quot;World&quot;; } } 出现上述结果原因：String对象的内容一旦声明不可改变，对象内容的改变依靠的是引用地址的改变。内存分析如下： 3.引用传递 public class Message { private String info = &quot;nihao&quot;; public Message(String info) { this.info = info; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(&quot;Hello&quot;); System.out.println(msg.getInfo()); // Hello fun(msg); System.out.println(msg.getInfo()); // World } public static void fun(Message temp) { temp.setInfo(&quot;World&quot;); } } 内存分析如下： 上述内存分析，是按照int型数据的特点进行的。实际info是String对象，应该按照如下方式进行分析： 结论：虽然String是一个类，属于引用数据类型，但由于其内容不可改的特点，我们常将其当作基本数据类型。即每个String变量只能保存一个数据。 引用传递实例 要求：通过面向对象的方式描述每个人有车或没车。 实现步骤： 1.创建数据库：应设计两张表:汽车表和人员表; 2.根据数据表，定义两个类： （编写简单java类时，可按照数据表的设计来写，规则如下： 类名 = 表名； 属性名(类型) = 表字段(类型); 一个实例化对象 = 一行记录； 多个实例化对象 = 多行记录 引用关系 = 外键描述） public class Member { private int mId; private String name; } public class Car { private String pName; } 3.利用引用来描述两个类的外键，从而使得两个类有联系 public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } } 4.当两个类的对象产生，为这两个对象设置彼此的关系： public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } public Member getMember() { return member; } public void setMember(Member member) { this.member = member; } } 5.测试 测试分为两步： （1）根据定义的结构关系设置数据 （2）根据定义的结构关系取出数据 public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Car c = new Car(&quot;宝马&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); } } 6.进一步设计：每个人都有孩子，孩子还可能有车 思路： （1）设计一个孩子类，如有孙子，在设计孙子类，以此类推。该方案过于冗余，不合适； （2）在Member类中设计属性child，类型为Member： private Member child; // 孩子 public Member getChild() { return child; } public void setChild(Member child) { this.child = child; } 测试： public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Member child = new Member(1,&quot;张四&quot;); Car c = new Car(&quot;宝马&quot;); Car cc =new Car(&quot;法拉利&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 设置车与人的关系：张四有辆法拉利 child.setCar(cc); c.setMember(child); // 设置人与人的关系：张四是张三的儿子 m.setChild(child); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); // 通过人找到孩子 System.out.println(m.getChild().getInfo()); // 通过人找到孩子的车 System.out.println(m.getChild().getCar().getInfo()); } } 7.利用引用描述电脑：电脑由主机、键盘、内存、CPU、显卡等组成，下面用伪代码描述： class 键盘{} class 鼠标{} class CPU{} class 硬盘{} class 内存{} class 显示器{} class 主机{} class 主板{} class 主机{ private CPU 对象[]; private 硬盘 对象[]; private 主板 对象; private 内存 对象[]; } class 电脑{ private 主机 对象; private 显示器 对象; private 键盘 对象; private 鼠标 对象; } 上述设计思路称为合成设计模式。引用是实现两个不同类之间互相关联的主要手段。 数据表与简单Java类映射 要求：通过程序描述部门和雇员关系 属性： ·dept：deptno,dname,loc; ·emp：empno, ename,job,sal,comm,deptno,mgr 关系： ·一个部门有多个雇员； ·一个雇员有一个或零个领导。 第一步： 根据数据表创建简单java类 /** * 部门类 */ public class Dept { private int depNo; // 编号 private String dName; // 名字 private String address; // 地址 // setter,getter,无参构造方法略 public Dept(int depNo, String dName, String address) { this.depNo = depNo; this.dName = dName; this.address = address; } public String getInfo() { return &quot;部门编号：&quot; + this.depNo + &quot;,部门名称：&quot; + this.dName + &quot;,地址：&quot; + this.address; } } /** * 员工类 */ public class Emp { private int eNo; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // setter,getter,无参构造方法略 public Emp(int eNo, String eName, String job, double sal, double comm) { this.eNo = eNo; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } public String getInfo() { return &quot;编 号&quot; + this.eNo + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：设置外键关系 · 一个雇员属于一个部门，应在雇员类中保存部门信息 private Dept dept; // 对应的部门信息 public Dept getDept() { return dept; } public void setDept(Dept dept) { this.dept = dept; } · 一个部门有的多个雇员，可用数组在部门类中保存雇员信息： private Emp emps[]; // 多个雇员信息 public Emp[] getEmps() { return emps; } public void setEmps(Emp[] emps) { this.emps = emps; } · 一个雇员有一个领导（定义在Emp类中） private Emp mgr; // 领导信息 public Emp getMgr() { return mgr; } public void setMgr(Emp mgr) { this.mgr = mgr; } 第三步：测试 （1）设置数据： public class Demo { public static void main(String[] args) { // 1. 产生对象 Dept dept = new Dept(10, &quot;财务部&quot;, &quot;北京&quot;); // 部门信息 // 员工信息 Emp eA = new Emp(1111, &quot;张三&quot;, &quot;保安&quot;, 800.0, 0.0); Emp eB = new Emp(1101, &quot;李四&quot;, &quot;秘书&quot;, 2800.0, 500.0); Emp eC = new Emp(1001, &quot;王五&quot;, &quot;经历&quot;, 6800.0, 1500.0); // 2. 设置员工与领导关系 eA.setMgr(eB); eB.setMgr(eC); // 3. 设置员工和部门关系 eA.setDept(dept); eB.setDept(dept); eC.setDept(dept); dept.setEmps(new Emp[]{eA, eB, eC}); } } （2）：根据给定的结构取出数据，要求如下： |-根据一个雇员查询他所对应的领导信息和部门信息； |-根据一个部门查询所有雇员以及其所对应的领导信息； // 第二步：取出数据 // 1. 通过员工找到领导信息和部门信息 System.out.println(eA.getInfo()); // 获取员工信息 System.out.println(&quot;\\t|-&quot; + eA.getMgr().getInfo()); // 获取领导信息 System.out.println(&quot;\\t|-&quot; + eA.getDept().getInfo()); // 获取部门信息 // 2. 根据部门找到所有员工及其领导信息 System.out.println(&quot;---------------------------------------------&quot;); System.out.println(dept.getInfo()); for (int x = 0; x &lt; dept.getEmps().length; x++) { System.out.println(&quot;\\t|-&quot; + dept.getEmps()[x].getInfo()); // 获取员工信息 if (dept.getEmps()[x].getMgr() != null) { System.out.println(&quot;\\t\\t|-&quot; + dept.getEmps()[x].getMgr().getInfo()); // 获取领导信息 } } 上述代码都是依靠代码链取出数据。 一对多映射 要求：通过程序描述省份和城市的关系 1.通过一个城市找到它对应的省份信息； 2.通过一个省份找到所有城市的信息。 class Province { private int pId; private String pName; private City cities[]; // getter,setter,无参构造方法略 public Province(int pId, String pName) { this.pId = pId; this.pName = pName; } public City[] getCities() { return cities; } public void setCities(City[] cities) { this.cities = cities; } public String getInfo() { return &quot;省份ID：&quot; + this.pId + &quot;，省名：&quot; + this.pName; } } class City { private int cId; private String cName; private Province province; // getter,setter,无参构造方法略 public City(int cId, String cName) { this.cId = cId; this.cName = cName; } public Province getProvince() { return province; } public void setProvince(Province province) { this.province = province; } public String getInfo() { return &quot;城市ID：&quot; + this.cId + &quot;，市名：&quot; + this.cName; } } public class Demo { public static void main(String[] args) { Province province = new Province(350, &quot;福建省&quot;); City cA = new City(1, &quot;福州&quot;); City cB = new City(2, &quot;厦门&quot;); City cC = new City(3, &quot;泉州&quot;); cA.setProvince(province); cB.setProvince(province); cC.setProvince(province); province.setCities(new City[]{cA, cB, cC}); System.out.println(cA.getInfo()); System.out.println(&quot;\\t|-&quot; + cA.getProvince().getInfo()); System.out.println(&quot;==================================&quot;); System.out.println(province.getInfo()); for (int x = 0; x &lt; province.getCities().length; x++) { System.out.println(&quot;\\t|-&quot; + province.getCities()[x].getInfo()); } } } 上述代码存在不足：每次添加城市，就要修改数组的引用关系 双向一对多映射 要求：通过程序描述类型-子类型-商品的关系 （1）通过一个类型找到它对应的子类型； （2）过一个类型找到它所对应的商品； （3）通过一个子类型找到所有对应的商品。 class Type { private int tId; private String tName; private SonType sonTypes[]; private Product products[]; // getter,setter,无参构造方法略 public Type(int tId, String tName) { this.tId = tId; this.tName = tName; } public SonType[] getSontypes() { return this.sonTypes; } public void setSontypes(SonType[] sontypes) { this.sonTypes = sontypes; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;类型编号：&quot; + this.tId + &quot;,类型名称：&quot; + this.tName; } } class SonType { private int sId; private String sName; private Type type; private Product products[]; // getter,setter,无参构造方法略 public SonType(int sId, String sName) { this.sId = sId; this.sName = sName; } public int getsId() { return sId; } public void setsId(int sId) { this.sId = sId; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;子类型编号：&quot; + this.sId + &quot;,子类型名称：&quot; + this.sName; } } class Product { private int pId; private String name; private double price; private Type type; private SonType sonType; // getter,setter,无参构造方法略 public Product(int pId, String name, double price) { this.pId = pId; this.name = name; this.price = price; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public SonType getSonType() { return sonType; } public void setSonType(SonType sonType) { this.sonType = sonType; } public String getInfo() { return &quot;商品编号：&quot; + this.pId + &quot;,商品名称：&quot; + this.name + &quot;,价格：&quot; + this.price; } } public class Demo { public static void main(String[] args) { Type type = new Type(1, &quot;家电类&quot;); SonType stA = new SonType(11, &quot;小型家电&quot;); SonType stB = new SonType(12, &quot;大型家电&quot;); Product pA = new Product(111, &quot;剃须刀&quot;, 99.0); Product pB = new Product(112, &quot;热水壶&quot;, 29.0); Product pC = new Product(121, &quot;电冰箱&quot;, 1199.0); Product pD = new Product(122, &quot;电热水器&quot;, 399.0); stA.setType(type); stB.setType(type); pA.setType(type); pB.setType(type); pC.setType(type); pD.setType(type); type.setSontypes(new SonType[]{stA, stB}); type.setProducts(new Product[]{pA, pB, pC, pD}); pA.setSonType(stA); pB.setSonType(stA); pC.setSonType(stB); pD.setSonType(stB); stA.setProducts(new Product[]{pA, pB}); stB.setProducts(new Product[]{pC, pD}); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getSontypes().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getSontypes()[x].getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getProducts()[x].getInfo()); System.out.println(&quot;\\t\\t|- &quot; + type.getProducts()[x].getSonType().getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(stA.getInfo()); for (int x = 0; x &lt; stA.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + stA.getProducts()[x].getInfo()); } } } 多对多映射 要求：通过程序描述管理员-角色-组-权限的关系； （1）根据一个管理员找到它对应的角色，以及每个角色包含的所有权限组的信息，以及每个权限组所包含的权限的内容； （2）根据一个权限组找到所有具备此权限组的角色以及每个角色所拥有的管理员信息； 角色_权限组表是关系表，保存的是两个外键的关联关系，不需要为其生成映射类。只有实体表才需要生成映射类，多对多的中间转换表只需通过类属性的关系引用即可。 class Admin { private String aid; private String password; private Role role; public void setRole(Role role) { this.role = role; } public Role getRole() { return this.role; } public Admin(String aid, String password) { this.aid = aid; this.password = password; } public String getInfo() { return &quot;管理员编号:&quot; + this.aid + &quot;，管理员密码：&quot; + this.password; } } class Role { private int rid; private String title; private Admin admins[]; private Group groups[]; public void setAdmins(Admin admins[]) { this.admins = admins; } public Admin[] getAdmins() { return this.admins; } public void setGroups(Group groups[]) { this.groups = groups; } public Group[] getGroups() { return this.groups; } public Role(int rid, String title) { this.rid = rid; this.title = title; } public String getInfo() { return &quot;角色编号：&quot; + this.rid + &quot;，角色名称&quot; + this.title; } } class Group { private int gid; private String title; private Role roles[]; private Action actions[]; public void setActions(Action actions[]) { this.actions = actions; } public Action[] getActions() { return this.actions; } public void setRoles(Role roles[]) { this.roles = roles; } public Role[] getRoles() { return this.roles; } public Group(int gid, String title) { this.gid = gid; this.title = title; } public String getInfo() { return &quot;权限组编号：&quot; + this.gid + &quot;，权限组名称：&quot; + this.title; } } class Action { private int aid; private String title; private String url; private Group group; public void setGroup(Group group) { this.group = group; } public Group getGroup() { return this.group; } public Action(int aid, String title, String url) { this.aid = aid; this.title = title; this.url = url; } public String getInfo() { return &quot;权限编号：&quot; + this.aid + &quot;权限名称：&quot; + this.title + &quot;,权限路径：&quot; + this.url; } } public class Demo { public static void main(String[] args) { Admin a1 = new Admin(&quot;admin&quot;, &quot;123456&quot;); Admin a2 = new Admin(&quot;root&quot;, &quot;654321&quot;); Admin a3 = new Admin(&quot;guest&quot;, &quot;654321&quot;); Role r1 = new Role(1, &quot;系统管理员&quot;); Role r2 = new Role(1, &quot;信息管理员&quot;); Group g1 = new Group(10, &quot;信息管理&quot;); Group g2 = new Group(11, &quot;用户管理&quot;); Group g3 = new Group(12, &quot;数据管理&quot;); Group g4 = new Group(13, &quot;接口管理&quot;); Group g5 = new Group(14, &quot;备份管理&quot;); Action ac1 = new Action(1001, &quot;新闻发布&quot;, &quot;-&quot;); Action ac2 = new Action(1002, &quot;新闻列表&quot;, &quot;-&quot;); Action ac3 = new Action(1003, &quot;新闻审核&quot;, &quot;-&quot;); Action ac4 = new Action(1004, &quot;增加用户&quot;, &quot;-&quot;); Action ac5 = new Action(1005, &quot;用户列表&quot;, &quot;-&quot;); Action ac6 = new Action(1006, &quot;登陆日志&quot;, &quot;-&quot;); Action ac7 = new Action(1007, &quot;雇员数据&quot;, &quot;-&quot;); Action ac8 = new Action(1008, &quot;部门数据&quot;, &quot;-&quot;); Action ac9 = new Action(1009, &quot;公司数据&quot;, &quot;-&quot;); Action ac10 = new Action(1010, &quot;服务传输&quot;, &quot;-&quot;); Action ac11 = new Action(1011, &quot;短信平台&quot;, &quot;-&quot;); Action ac12 = new Action(1012, &quot;全部备份&quot;, &quot;-&quot;); Action ac13 = new Action(1013, &quot;局部备份&quot;, &quot;-&quot;); a1.setRole(r1); a2.setRole(r2); a3.setRole(r2); r1.setAdmins(new Admin[]{a1}); r2.setAdmins(new Admin[]{a2, a3}); r1.setGroups(new Group[]{g1, g2, g3, g4, g5}); r2.setGroups(new Group[]{g1, g2}); g1.setRoles(new Role[]{r1, r2}); g2.setRoles(new Role[]{r1, r2}); g3.setRoles(new Role[]{r1}); g4.setRoles(new Role[]{r1}); g5.setRoles(new Role[]{r1}); g1.setActions(new Action[]{ac1, ac2, ac3}); g2.setActions(new Action[]{ac4, ac5, ac6}); g3.setActions(new Action[]{ac7, ac8, ac9}); g4.setActions(new Action[]{ac10, ac11}); g5.setActions(new Action[]{ac12, ac13}); ac1.setGroup(g1); ac2.setGroup(g1); ac3.setGroup(g1); ac4.setGroup(g2); ac5.setGroup(g2); ac6.setGroup(g2); ac7.setGroup(g3); ac8.setGroup(g3); ac9.setGroup(g3); ac10.setGroup(g4); ac11.setGroup(g4); ac12.setGroup(g5); ac13.setGroup(g5); System.out.println(a1.getInfo()); System.out.println(a1.getRole().getInfo()); for (int x = 0; x &lt; a1.getRole().getGroups().length; x++) { System.out.println(&quot;\\t|-&quot; + a1.getRole().getGroups()[x].getInfo()); for (int y = 0; y &lt; a1.getRole().getGroups()[x].getActions().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + a1.getRole().getGroups()[x].getActions()[y].getInfo()); } } System.out.println(&quot;-------------------------------------------------&quot;); System.out.println(g2.getInfo()); for (int x = 0; x &lt; g2.getRoles().length; x++) { System.out.println(g2.getRoles()[x].getInfo()); for (int y = 0; y &lt; g2.getRoles()[x].getAdmins().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + g2.getRoles()[x].getAdmins()[y].getInfo()); } System.out.println(); } } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Centos7上部署Docker私有仓库","slug":"Centos7上部署Docker私有仓库","date":"2017-10-11T11:45:51.144Z","updated":"2017-10-11T12:00:20.426Z","comments":true,"path":"article/容器/Centos7上部署Docker私有仓库/","link":"","permalink":"http://yov.oschina.io/article/容器/Centos7上部署Docker私有仓库/","excerpt":"","text":"Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。 环境准备 系统要求 要求 说明 系统 Centos 7 内核 4.13.5-1.el7.elrepo.x86_64 仓库地址 10.0.0.128:5000 docker 1.12.6 关闭防火墙 $ systemctl stop firewalld.service $ systemctl disable firewalld.service $ vim /etc/sysconfig/selinux SELINUX=disabled 搭建Docker私有仓库 搭建仓库 $ docker pull registry // 拉取官方镜像 $ docker run -d -p 5000:5000 --restart=always --name myHub registry // 运行官方镜像 $ curl localhost:5000/v2/_catalog // 查看私有镜像仓库,此时为空 {&quot;repositories&quot;:[]} 修改配置文件 $ vim /etc/sysconfig/docker OPTIONS='--insecure-registry 10.0.0.128:5000' $ systemctl restart docker 上传镜像到私有仓库 $ docker tag mysql 10.0.0.128:5000/mysql:0.1 // docker tage image_name registry_ip:port/images_name:tag $ docker push 10.0.0.128:5000/mysql:0.1 // 上传镜像 $ curl localhost:5000/v2/_catalog // 查看仓库镜像 {&quot;repositories&quot;:[&quot;mysql&quot;]}","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(六)","slug":"Java基础知识(六)","date":"2017-10-09T01:00:49.117Z","updated":"2017-10-14T02:02:50.069Z","comments":true,"path":"article/语言/Java基础知识(六)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(六)/","excerpt":"","text":"关键字this this调用属性 class Book { private String title; private double price; public Book(String t, double p) { title = t; price = p; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); System.out.println(book.getInfo()); } } 上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。构造方法的功能是为类的属性初始化，参数名最好与属性名一致。 public Book(String title, double price) { title = title; price = price; } 修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的{}的变量名，即数据传到构造方法后，并未传到属性中。为了明确要访问的变量是类的属性，应在变量名前加this。 public Book(String title, double price) { this.title = title; this.price = price; } 在开发中，只要访问类中属性，前面必须加this。 this调用方法 1.this指的是当前对象，一个类除了属性还有方法，因此可以利用this调用方法。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public void print() { System.out.println(&quot;*********&quot;); } // setter和getter方法略 public String getInfo() { this.print(); return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 在类中调用普通方法，加不加this都一样。但为了代码的严谨性，最好加this。 2.this调用构造方法 多个构造方法间互相调用: this(参数1, 参数2…); 范例：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息一个新的Book类对象产生 class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; } public Book(String title, double price) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在重复，要消除重复代码： class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在限制： （1）利用this调用构造方法的语句只能放在构造方法首行； （2）普通方法无法调用构造方法； （3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。 class Book { private String title; private double price; public Book() { // 报错，构造递归调用 this(&quot;Book&quot;,1.1); System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码会出现”构造方法递归调用”错误，说明构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。 3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法; （1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”； （2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”； （3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”； （4）四参构造 实现方式1：不使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this.empNo = 0; this.eName = &quot;无名氏&quot;; this.sal = 0.0; this.dept = &quot;未定&quot;; } public Emp(int empNo) { this.empNo = empNo; this.eName = &quot;临时工&quot;; this.sal = 800.0; this.dept = &quot;后勤部&quot;; } public Emp(int empNo, String eName) { this.empNo = empNo; this.eName = eName; this.sal = 2000.0; this.dept = &quot;技术部&quot;; } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 实现方式2：使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this(0,&quot;无名氏&quot;,0.0,&quot;&quot;); } public Emp(int empNo) { this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;); } public Emp(int empNo, String eName) { this(empNo,eName,2000.0,&quot;技术部&quot;); } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 通过构造方法互相调用解决了代码重复问题。 当前对象 当前对象指的是当前正在调用类中属性或方法的对象 class Book { public void print() { // 哪个对象调用了print(),this就与该对象指向同一块内存地址 // this就是当前调用方法的对象 System.out.println(&quot;this = &quot; + this); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); System.out.println(&quot;bkA = &quot; + bkA); // bkA = com.java.demo.Book@1540e19d bkA.print(); // this = com.java.demo.Book@1540e19d System.out.println( &quot;===============&quot;); Book bkB = new Book(); // bkB = com.java.demo.Book@677327b6 System.out.println(&quot;bkB = &quot; + bkB); // this = com.java.demo.Book@677327b6 bkB.print(); } } class A{ private B b; public A(){ // 2.执行A类构造方法 // 3. 实例化B类对象b，调用B类构造方法 this.b = new B(this); //此时this是temp this.b.get(); // 5. 通过b调用B类的get() } public void print(){ //8. 执行该方法 System.out.println(&quot;Hello World !&quot;); } } class B{ private A a; public B(A a){ // A a = temp this.a = a; // 4. 执行B类构造方法 } public void get(){ // 6. 执行该方法 this.a.print(); // 7. 调用A类的print() } } public class Demo { public static void main(String[] args) { // 1.实例化A类对象，调用A类的无参构造方法 A temp = new A(); // Hello World ! } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java基础知识(五)","slug":"Java基础知识(五)","date":"2017-10-03T13:33:39.028Z","updated":"2017-10-08T12:59:45.355Z","comments":true,"path":"article/语言/Java基础知识(五)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(五)/","excerpt":"","text":"String类的特点及使用 JDK_API文档由下面几部分组成： （1）类的定义以及相关的继承结构 （2）类的简短说明 （3）类的成员组成 （4）类所提供的构造方法 （5）类所提供的普通方法 （6）类的成员，构造方法，普通方法的详细说明 deprecated标记表示不再建议使用。 String对象的两种实例化方式 1.String是字符串类,下面将类的角度与内存关系分析其作用： （1）直接赋值String value_name = &quot;字符串&quot; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // 直接赋值 System.out.println(str); } } （2）构造方法public String (String str); public class Demo { public static void main(String[] args) { String str = new String(&quot;Hello World !&quot;); System.out.println(str); } } 字符串比较 1.判断两个int数据是否相等： public class Demo { public static void main(String[] args) { int x = 10; int y = 10; System.out.println(x == y); // true } } 使用==判断String对象是否相等： public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA == strB); // false System.out.println(strA == strC); // false System.out.println(strB == strC); // true } } 对上述代码进行内存分析： 由内存分析可知，String对象使用==比较时，比较的是对象的栈内存地址的值。 2.要比较字符串的内容，应使用String类中的方法public boolean equals（String str） public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA.equals(strB)); // true System.out.println(strA.equals(strC)); // true } } 开发中，字符串比较应用equals(String str). 3.章节例题：==与equals(String str)的区别 ==是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值; equals(String str)是String类的方法，用于比较字符串内容。 String常量是匿名对象 1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但不属于基本数据类型，而是将字符串作为String类的匿名对象。 范例：验证字符串是匿名对象 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; System.out.println(&quot;Hello&quot;.equals(str)); } } 2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化. public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (input.equals(&quot;hello&quot;)){ System.out.println(&quot;Hello World !&quot;); // 报错，NullPointerException } } } 为预防用户输入错误导致input为null，而后调用equals()，出现空指针异常，应使用如下代码： public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (&quot;hello&quot;.equals(input)){ System.out.println(&quot;Hello World !&quot;); } } } 使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将指定字符串放在equals()前。 两种实例化方式的区别 1.直接赋值 直接赋值就是给字符串匿名对象设置对象名。 此时内存中会开辟堆内存，并且有一块栈内存指向堆内存： 观察下列代码： public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = &quot;hello&quot;; String strC = &quot;hello&quot;; String strD = &quot;world&quot;; System.out.println(strA == strB); // true System.out.println(strA == strC); // true System.out.println(strB == strC); // true System.out.println(strA == strD); // false } } 由上述结果可知，strA，strB，strC都指向同一块堆内存： 共享设计模式：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。 2.构造方法实例化 使用构造方法定义String对象，就需要每次开辟新的堆内存。 由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。 public class Demo { public static void main(String[] args) { String strA = new String(&quot;hello&quot;); String strB = &quot;hello&quot;; System.out.println(strA == strB); // false } } 除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用public String intern()手工入池。 3.章节小题：String对象两种定义方式的区别 · 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用； · 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。 字符串内容不可改变 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str += &quot; World&quot;; str += &quot; !!!&quot;; System.out.println(str); } } 对上述代码进行内存分析： 分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。 String类常用方法(字符与字符串) 很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法： No. 方法名称 类型 描述 1 public String (char[] value) 构造 将字符数组变为String类对象 2 public String (char[] value ,int offset,int count) 构造 将部分字符数组变为String对象 3 public char charAt (int index) 普通 返回指定索引对应的字符信息 4 public char[] toCharArray() 普通 将字符串以字符数组的形式返回 范例：取出指定索引的字符 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; char c = str.charAt(0); System.out.println(c); // H } } 范例：将字符串转大写 public class Demo { public static void main(String[] args) { String str = &quot;hello&quot;; char [] data = str.toCharArray(); // 字符串转为字符数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 小写编码 - 32 = 大写编码 } // 将字符数组变为字符串 System.out.println(new String(data)); // HELLO // 将部分字符数组变为String对象 System.out.println(new String(data, 1, 2)); // EL } } 范例：判断一个字符换是否为纯数字 思路：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。 public class Demo { public static void main(String[] args) { String str = &quot;3146017052&quot;; if (isNumber(str)) { System.out.println(&quot;字符串全部由数字组成&quot;); } else { System.out.println(&quot;字符串不是全部由数字组成&quot;); } } // 定义判断字符串是否由数字组成的方法 public static boolean isNumber(String temp) { // 首先将字符串变为字符数组 char[] data = temp.toCharArray(); // 一一比较字符 for (int x = 0; x &lt; data.length; x++) { if (data[x] &gt; '9' || data[x] &lt; '0') { return false; } } // 全部为数字则返回true return true; } } 建议：返回值为boolean的方法命名为isXxx。 String类常用方法(字节与字符串) 字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。 No. 方法名称 类型 描述 1 public String (byte[] bytes) 构造 将字节数组变为字符串 2 public String (byte[] bytes ,int offset,int length) 构造 将部分字节数组变为字符串 3 public byte[] getBytes (String charsetName) throws UnsupportedEncodingException 普通 进行编码转换 4 public byte[] getBytes() 普通 将字符串变为字节数组 范例：字符串与字节数组的转换 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; byte [] data = str.getBytes(); // 将字符串转为字节数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 将小写字母转为大写字母 } System.out.println(new String(data)); // HELLOWORLD System.out.println(new String(data,5,5)); // WORLD } } String类常用方法(字符串比较) No. 方法名称 类型 描述 1 public boolean equals(String anotherString) 普通 进行内容判断，区分大小写 2 public boolean equalsIgnoreCase(String anotherString) 普通 进行内容判断，不区分大小写 3 public int compareTo (String anotherString) 普通 判断两个字符串的大小（按照字符编码）,返回值为0,1,-1 范例：equals()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 } } 范例：equalsIgnoreCase()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写 } } 范例：compareTo() public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.compareTo(strB)); // -32 if (strA.compareTo(strB) &gt; 0){ System.out.println(&quot;大于&quot;); } else if (strA.compareTo(strB) == 0){ System.out.println(&quot;两个字符串相等&quot;); } else { System.out.println(&quot;小于&quot;); } } } 只有String对象才能进行大小判断。 String类常用方法(字符串查找) 要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法： No. 方法名称 类型 描述 1 public boolean contains (String s) 普通 判断指定内容是否存在 2 public int indexOf(String s) 普通 由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。 3 public int indexOf(String s,int fromIndex) 普通 从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1 4 public int lastindexOf(String s) 普通 由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 5 public int lastindexOf(String s, int fromIndex) 普通 由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 6 public boolean startsWith (String prefix) 普通 判断是否以指定字符串开头 7 public boolean startsWith (String prefix，int toffset) 普通 从指定位置开始判断是否是以指定字符串开头 8 public boolean endsWith(String suffix) 普通 判断是否以指定字符串结尾 范例：查找字符串位置 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 返回满足条件的单词的首字母索引 System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引 // 从索引5开始查满足条件单词的索引 System.out.println(str.indexOf(&quot;l&quot;,5)); // 8 // 从后向前查 System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8 } } 在某些程序中，需要查找指定字符串是否存在，早期方法如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.indexOf(&quot;world&quot;) != -1){ System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } JDK1.5出现contains()，使用如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.contains(&quot;world&quot;)) { System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } 范例：开头或结尾判断内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从开头开始查 System.out.println(str.startsWith(&quot;he&quot;)); // 从索引2开始查找 System.out.println(str.startsWith(&quot;ll&quot;,2)); // 从结尾开始查找 System.out.println(str.endsWith(&quot;ld&quot;)); } } String类常用方法(字符串替换) No. 方法名称 类型 描述 1 public String replaceAll(String regex，String replacement) 普通 全部替换 2 public String replaceFirst(String regex，String replacement) 普通 替换首个满足条件的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 替换所有 String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d // 只替换第一个 String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld System.out.println(resultA); System.out.println(resultB); } } String类常用方法(字符串截取) No. 方法名称 类型 描述 1 public String substring(int beginIndex) 普通方法 从指定索引截取到结尾 2 public String substring(int beginIndex,int endIndex) 普通方法 截取指定范围内的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从索引5开始截取直到结尾 String resultA = str.substring(5); // 截取索引5到8之间 String resultB = str.substring(5,8); System.out.println(resultA); // world System.out.println(resultB); // wor } } String类常用方法(字符串拆分) No 方法名称 类型 描述 1 public String[] split (String regex) 普通方法 按照指定的字符串进行全部拆分 2 public String[] split (String regex，int limit) 普通方法 按照指定的字符串进行部分拆分，最后一个数组长度由limit决定 范例：全部拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空格拆分单词 String result[] = str.split(&quot; &quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：hello // world } } } 在拆分的时候，只写一个空字符串（&quot;&quot;不是null），表示按照每一个字符进行拆分。 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空字符串拆分 String result[] = str.split(&quot;&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：h e l l o w o r l d } } } 范例：部分拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world nihao mldn&quot;; // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆 String result[] = str.split(&quot; &quot;,3); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot; } } } 范例：IP地址拆分 public class Demo { public static void main(String[] args) { String str = &quot;192.168.1.1&quot;; String result[] = str.split(&quot;\\\\.&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果为：192 168 1 1 } } } 上述代码中，只用.无法拆分，当遇到这种拆分时，需要使用\\\\.进行转义后拆分。 范例：拆分“张三:20|李四:25|王五:23” public class Demo { public static void main(String[] args) { String str = &quot;张三:20|李四:25|王五:23&quot;; String result[] = str.split(&quot;\\\\|&quot;); for (int x = 0; x &lt; result.length; x++) { String temp[] = result[x].split(&quot;:&quot;); System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]); } } } String类其他方法 No. 方法名称 类型 描述 1 public String concat (String str) 普通方法 字符串连接 2 public String toLowerCase () 普通方法 把字符串转为小写 3 public String toUpperCase () 普通方法 把字符串转为大写 4 public String trim () 普通方法 去掉字符串中左右两边的空格，中间空格保留 5 public int length() 普通方法 取得字符串长度 6 public String intern () 普通方法 数据入池操作 7 public boolean isEmpty () 普通方法 范例：字符串连接 public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = strA + &quot; world&quot;; String strC = &quot;hello&quot; + &quot;world&quot;; String strD = &quot;hello world&quot;; String strE = strA.concat(&quot; world&quot;); System.out.println(strB == strC); // false System.out.println(strB == strD); // false System.out.println(strB == strE); // false System.out.println(strC == strD); // false System.out.println(strC == strE); // false System.out.println(strD == strE); // false } } 范例：字符串进行大小写转换 public class Demo { public static void main(String[] args) { String str = &quot;*Hello*&quot;; // 只转换小写字母 System.out.println(str.toUpperCase()); // *HELLO* // 只转换大写字母 System.out.println(str.toLowerCase()); // *hello* } } 范例：去掉空格 public class Demo { public static void main(String[] args) { String str = &quot; Hello World &quot;; System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】 System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】 } } 用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了trim()。 范例：取得字符串长度 public class Demo { public static void main(String[] args) { String str = &quot;Hello World&quot;; System.out.println(str.length()); // 11 } } 某些情况要求用户输入的数据长度有限制，可以利用此方法判断。 范例：判断是否是空字符串 public class Demo { public static void main(String[] args) { String str = &quot;&quot;; System.out.println(str.isEmpty()); // true System.out.println(&quot;&quot;.equals(str)); // true } } 范例：实现首字母大写，其余字母小写 public class Demo { public static void main(String[] args) { String str = &quot;hElLo&quot;; System.out.println(initcap(str)); // Hello } public static String initcap(String temp) { // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写 return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase(); } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java基础知识(四)","slug":"Java基础知识(四)","date":"2017-10-03T12:47:52.401Z","updated":"2017-10-03T13:33:00.125Z","comments":true,"path":"article/语言/Java基础知识(四)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(四)/","excerpt":"","text":"数组的定义及使用 基本概念 1.数组是一组变量的集合。数组属于引用数据类型。 2.数组的定义语法 （1）声明并开辟数组： 数组类型 数组名[] = new 数据类型[数组长度] （2）分步完成： // 声明数组 数组类型 数组名[] = null; // 开辟数组 数组名 = new 数据类型 [数组长度] 3.数组开辟空间用，可利用数组名[下标|索引]访问，下标从0开始。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现数组越界异常（ArrayIndexOutOfBoundsException）。 4.数组是顺序结构且长度固定，可使用循环语句输出，可用数组名.length获取数组长度。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; // 声明并开辟一个长度为3的数组 datas[0] = 1; // 为数组赋值，如不赋值，默认值为0 datas[1] = 2; datas[2] = 3; // for循环输出数组内容，datas.length获取数组长度 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。 范例：分步完成 public class Demo { public static void main(String[] args) { int datas[] = null; // 声明数组 datas = new int[3]; // 开辟一个长度为3的数组 datas[0] = 1; datas[1] = 2; datas[2] = 3; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 6.数组可以进行引用传递。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; datas[0] = 1; datas[1] = 2; datas[2] = 3; int temp[] = datas; // 引用传递 temp[0] = 99; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); // 99 2 3 } } } 以上都是动态初始化数组，即先开辟数组，再为数组赋值。 7.静态初始化数组： 在定义数组的同时为其赋值，语法： （1）数组类型 数组名[] = {v1, v2 ,…,vn}; （2）数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn}; 范例：静态初始化数组 public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; // 静态初始化数组 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 数组支持顺序数据访问，最大缺点是长度不能改变，因此在开发中不直接使用数组，但会使用数组的概念。 二维数组 1.一维数组就是一行数据： 索引 0 1 2 3 数据 0 10 20 30 在一维数组中要查询一个数据，只要确定其索引即可。 二维数组，是一个数据表： 索引 0 1 2 3 0 0 10 20 30 1 1 2 3 4 2 12 123 231 233 二维数组中要查询一个数据，需要定位列和行。二维数组中第一个[]确定行，第二个[]确定列。 2. 二维数组定义语法： // 动态初始化： 数据类型 数组名称[][]=new 数据类型[行数][列数]; // 静态初始化： 数据类型 数组名称[][]=new 数据类型[][]{数组元素} ; 由此可以发现，二维数组就是将多个一维数组变为一个数组。 public class Demo { public static void main(String[] args) { int datas[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; // 外层循环控制数组的行 for (int x = 0; x &lt; datas.length; x++) { // 内层循环控制数组的列 for (int y = 0; y &lt; datas[x].length ; y++) { System.out.print(datas[x][y] + &quot;\\t&quot;); } System.out.println(); } } } 数组与方法的引用 1.方法的参数可以是数组： public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; change(datas); for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } public static void change(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { temp[x] *= 2; // 数组元素乘2保存 } } } 内存分析： change()执行完毕后，temp不再指向datas的堆内存，但change()对datas数据的修改被保存下来。 2.数组排序（冒泡排序）： 数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; for (int x = 0; x &lt; datas.length; x++) { for (int y = 0; y &lt; datas.length - 1; y++) { if (datas[y] &gt; datas[x]) { int t = datas[y]; datas[y] = datas[x]; datas[x] = t; } } // 为更好地理解冒泡排序，输出每轮排序的结果 System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;); print(datas); System.out.println(); } print(datas); } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 建议：main()是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; sort(datas); print(datas); } // 数组冒泡排序方法 public static void sort(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp.length - 1; y++) { if (temp[y] &gt; temp[x]) { int t = temp[y]; temp[y] = temp[x]; temp[x] = t; } } } } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 3.数组转置 转置的概念（一维数组）：· 原始数组 1，2，3，4，5，6，7，8 转置后 8，7，6，5，4，3，2，1 转置操作的两个思路： （1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用： public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{1,2,3,4,5,6,7,8}; datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾 } // 数组逆序输出方法一 public static int [] reverseOne(int temp[]) { // 定义新数组，长度与原始数组一致 int temps[] = new int[temp.length]; int foot = temp.length - 1; // 控制原始数组的索引 for (int x = 0; x &lt; temps.length ; x++) { temps[x] = temp[foot]; // 新数组按照原始数组倒序排列 foot --; } return temps; } } 上述代码实现转置，但产生了垃圾，不合理。 （2）利用算法，直接在数组上完成转置： 不论数组个数是奇数还是偶数,转换次数 = 数组长度 / 2; // 数组逆序输出方法 public static void reverse(int temp[]) { int len = temp.length / 2; int head = 0; int tail = temp.length - 1; for (int x = 0; x &lt; len; x++) { int t = temp[head]; temp[head] = temp[tail]; temp[tail] = t; head++; tail--; } } 4.行列数相等的二维数组转置： public class Demo { public static void main(String[] args) { int data[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; reverse(data); print(data); } // 专门实现数组的倒置操作 public static void reverse(int arr[][]) { for (int x = 0; x &lt; arr.length; x++) { for (int y = x; y &lt; arr.length; y++) { if (x != y) { //行和列相同，进行交换 int temp = arr[x][y]; arr[x][y] = arr[y][x]; arr[y][x] = temp; } } } } // 专门输出的方法 public static void print(int temp[][]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp[x].length; y++) { System.out.print(temp[x][y] + &quot;、&quot;); } System.out.println(); } System.out.println(); } } 转置过程： 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] 第一次转换（x=0，y=x=0，循环3次） ·y的第一次循环（x==y） 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第二次循环（x=0，y=1，进行交换） 1[0][0] 4[1][0] 3[0][2] 2[0][1] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第三次循环（x=0，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] 第二次转换（x=1，y=x=1，循环2次） ·y的第一次循环（x=1，y=1，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] ·y的第二次循环（x=1，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 第三次转换（x=2，y=x=2，循环11次） ·y的第二次循环（x=2，y=2，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。 5.方法返回数组： public class Demo { public static void main(String[] args) { int data[] = init(); // 接收数组 print(data); System.out.println(init().length); } public static int[] init() { return new int[]{1, 2, 3}; // 方法返回数组 } public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot;、&quot;); } System.out.println(); } } 操作数组的方法 1.Java对数组提供类库支持，下面介绍两个类库中的方法： （1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。 语法：System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)。 范例：数组拷贝 ·数组A：1，2，3，4，5，6，7，8； ·数组B：11，22，33，44，55，66，77，88； ·拷贝后的数组B:11，22，5，6，7，66，77，88 public class Demo { public static void main(String[] args) { int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8}; int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88}; System.arraycopy(dataA, 4, dataB, 2, 3); ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法 } } （2）数组排序： 语法：java.util.Arrays.sort(数组名) public class Demo { public static void main(String[] args) { int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5}; java.util.Arrays.sort(dataA); ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法 } } 对象数组 1.对象数组是将多个对象交由数组处理。 2.对象数组的定义与一般数组一致： 范例： 动态初始化对象数组 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[3]; books[0] = new Book(&quot;Java开发&quot;, 66.6); books[1] = new Book(&quot;JSP&quot;, 6.6); books[2] = new Book(&quot;C++&quot;, 16.6); for (int x = 0; x &lt; books.length; x++) { System.out.println(books[x].getInfo()); //未实例化对象时，输出值全为null } } } 范例：静态初始化对象数组： class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[]{ new Book(&quot;Java开发&quot;, 66.6), new Book(&quot;JSP&quot;, 6.6), new Book(&quot;C++&quot;, 16.6) }; for (int x = 0; x &lt; books.length; x++) { //未实例化对象时，输出值全为null System.out.println(books[x].getInfo()); } } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java基础知识(三)","slug":"Java基础知识(三)","date":"2017-10-02T07:31:57.908Z","updated":"2017-10-03T12:46:41.896Z","comments":true,"path":"article/语言/Java基础知识(三)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(三)/","excerpt":"","text":"方法的定义与使用 方法的基本概念 方法就是将一段可重复使用的代码封装。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是定义在主类中，由主方法直接调用的方法。此类方法的语法： public static 返回值类型 method_name(v_type v1, v_type v2,...) { 方法体; // 方法要进行的若干操作 [return [返回值] ;] // []中内容可写可不写 } 返回值类型: 数据类型(基本数据类型、引用数据类型) 无返回值(void) 如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容 不需要return语句，但可用return结束方法调用 方法名的命名规则：第一个单词小写，随后每个单词首字母大写。 范例：定义无参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { print(); // 直接调用 } public static void print(){ System.out.println(&quot;无参无返回值方法&quot;); } } 范例：定义含参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { compare(10.2); // 调用时必须写入参数 compare(-10.2); } public static void compare(double x){ String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;; System.out.println(str); } } 有了参数后，方法就可以根据不同的参数内容进行数据的处理。 范例：定义含参数有返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { //定义变量接收返回值，而后输出 int result = add(10, 20); System.out.println(result); // 直接输出返回值 System.out.println(add(10, 20)); } public static int add(int x, int y) { return x + y; } } 一个方法使用void定义，该方法无法使用return返回值，但可以使用return结束调用。 package com.java.demo; public class Demo { public static void main(String[] args) { print(1100); // x = 1100 print(3); // 结束调用,不输出x } public static void print(int x) { if (x == 3) { System.out.println(&quot;结束调用,不输出x&quot;); return; } System.out.println(&quot;x = &quot; + x); } } 只有返回值类型为void时，才可使用return结束方法的调用。 方法重载 假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为方法重载（overloading）。 方法重载要求方法名一致，参数类型或个数不同。 package com.java.demo; public class Demo { public static void main(String[] args) { // 根据参数的个数或类型，调用不同方法 add(10,20); add(10.2,20.2); add(10,20,30); } // 方法名相同，参数的类型或个数不同 public static void add(int x, int y) { System.out.println(&quot;两个整数相加：&quot; + (x + y)); } public static void add(double x, double y) { System.out.println(&quot;两个小数相加：&quot; + (x + y)); } public static void add(int x, int y, int z) { System.out.println(&quot;三个整数相加：&quot; + (x + y + z)); } } System.out.println()可以输出不同类型数据，可知此方法是一个被重载后的方法。 方法重载的说明： （1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致； （2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。 package com.java.demo; public class Demo { public static void main(String[] args) { } // 报错,已在类中定义了方法 add(int,int) // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同 public static int add(int x, int y) { return x + y; } public static double add(int x, int y) { return x + y; } } 递归调用 递归调用是指方法调用自身。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。 范例：递归实现1~100的累加操作 package com.java.demo; public class Demo { public static void main(String[] args) { System.out.println(sum(100)); } public static int sum(int num){ if (num == 1) { // 结束递归调用 return 1; } // 递归调用 return num + sum(num - 1); } } 代码的执行步骤： No. 内容 返回值 1 主方法调用sum(100) 100+sum(99) 2 递归调用sum(99) 100 + 99 + sum（98) 3 递归调用sum(98) 100 + 99 + 98+ sum(97) … 依此类推 … 最后一次 递归调用sum(1) sum=100+99+98+…+2+1,结束递归 类与对象 面向对象简介 面向过程：指的是针对某一个问题单独提出解决方案和代码开发。 面向对象：以组件化的形式进行代码设计，优点是代码可重用。 面向对象语言的特征： （1）封装性：保护内部结构安全性。 （2）继承性：在已有的程序结构上扩充新的功能。 （3）多态性：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果 面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。 类与对象 1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。 2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含特征(属性)外，还包括许多行为(方法)。根据这个类产生的对象都具有相同的行为。 3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。 4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。 类与对象的定义及使用 1.定义类使用class class_name {}语句完成。类的组成： (1)field（属性，成员，变量）：一堆变量的集合； (2)method（方法，行为）：由对象调用。 范例：定义类 package com.java.entity; public class Book { // 定义属性 public String title; public double price; // 定义方法 public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 2.要使用类，必须要有对象，对象定义的语法有如下两种： (1)声明并实例化对象：class_name object_name = new class_name()； (2)分步完成： 第一步-声明对象：class_name object_name = null; 第二部-实例化对象：object_name =new class_name(); 引用数据类型与基本数据类型最大区别是需要内存的开辟及使用，所以关键字new的主要功能就是开辟内存空间。 3.当一个对象实例化后，利用如下方式操作类： (1)object_name.field：操作类中的属性； (2)object_name.method()：调用类中的方法。 范例：使用类 public class Demo { public static void main(String[] args) { Book book = new Book(); // 声明并实例化对象 book.title = &quot;Java开发&quot;; // 定义属性 book.price = 66.6; book.getInfo(); // 调用方法 } } 4.堆内存和栈内存的概念： 堆内存 栈内存 保存对象的属性内容，使用关键字new开辟 栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字 范例：分步使用实例化对象 public class Demo { public static void main(String[] args) { Book book = null; // 声明对象 book = new Book(); // 实例化对象 book.title = &quot;Java开发&quot;; book.price = 66.6; book.getInfo(); } } 内存分析：使用关键字new开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为默认值。 使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）” 对象引用分析 1.在引用分析中，每次使用new关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么两个对象占据的是不同的堆内存，因此不会互相影响。 范例：声明两个对象 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); bkB.title = &quot;C++开发&quot;; bkB.price = 22.6; bkB.getInfo(); } } 2. 范例：对象引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = null; bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); // 66.6 bkB = bkA; // 引用传递 bkB.price = 90.5; bkA.getInfo(); // 90.5 bkB.getInfo(); // 90.5 } } 由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。 3. 范例：引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkB.title = &quot;C++开发&quot;; bkB.price = 90.5; bkB = bkA; // 引用传递 bkB.price = 100; bkA.getInfo(); // 100 bkB.getInfo(); // 100 } } 通过内存分析可知，在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。 封装性 public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = -66.6; bkA.getInfo(); } } 上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为对象可以在类的外部直接访问属性。 1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。 public class Book { private String title; private double price; public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性 } } 此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter(). 2. 以Book类中的title属性为例，定义setter()/getter()： setter() getter() 作用 设置属性值 取得属性值 语法 public void setTitle(String t) public void getTitle() 是否含参 有参 无参 package com.java.entity; public class Book { private String title; private double price; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 如果要添加如价格不能为负数的功能，应在setter()中添加： public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } 对于数据的验证，开发中应有其他辅助代码完成，setter()只是简单地设置数据，getter()只用于返回数据。 构造方法与匿名对象 定义对象的语法：类名称 对象名称 = new 类名称(); ①类名称：定义对象的类型； ②对象名称：标识符，要使用对象，需要有一个对象名； ③new：用于开辟堆内存空间，实例化对象； ④类名称()：一个方法名和类名称一样的方法，这就是构造方法。 通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。 1.构造方法的定义原则：方法名称与类名称相同，没有返回值。 class Book { public Book() { // 系统自动生成的构造方法 } } 2.构造方法在对象使用new实例化时调用。 范例：证明构造方法被调用 public class Book { public Book() { System.out.println(&quot;构造方法被调用&quot;); } } public class Demo { public static void main(String[] args) { Book book = null ; // 声明对象 book = new Book(); // 实例化对象时调用构造方法 //结果：构造方法被调用 } } 构造方法与普通方法的最大区别：构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。 3.范例：自定义构造方法 class Book { private String title; private double price; // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法 public Book(String t, double p) { title = t; price = p; } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); book.getInfo(); } } 由上述代码可知构造方法的作用：在类对象实例化时设置属性的初始值，即构造方法用于属性初始化。 4.构造方法也属于方法，因此可以进行重载。 范例：构造方法重载 class Book { public Book() { System.out.println(&quot;系统自动生成的构造方法&quot;); } // 进行方法重载的构造方法 public Book(String t, double p) { System.out.println(&quot;方法重载后的构造方法&quot;); } } public class Demo { public static void main(String[] args) { Book bookA = new Book(); // 系统自动生成的构造方法 Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法 } } 重载方法时要求：按照参数个数，对方法进行升序或者降序排列。 5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：类的加载，内存的分配，默认值的设置，构造方法。 class Book { private String title = &quot;Java开发&quot;; // 设置默认值 private double price; public Book() { } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.getInfo(); // 书名：Java开发,价格：0.0 } } 本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。真实的对象信息都保存在堆内存中。 6.匿名对象：没有栈内存指向的对象，即没有标识符的对象。 public class Demo { public static void main(String[] args) { new Book(&quot;Java开发&quot;,6.6).getInfo(); } } 由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。 何时使用匿名对象：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。 简单Java类实践 题目要求：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。 提示：这种类被称为简单java类，因为这种类不包含过于复杂的程序逻辑。 对于简单Java类而言，它的要求如下： ·类名必须有意义； ·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法； ·类中可以有多个构造方法，但必须保留无参构造方法； ·类中不允许出现输出语句，信息输出必须交给调用处。 ·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。 第一步：定义类 public class Emp { private int eId; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // 定义构造方法 public Emp() { } public Emp(int eId, String eName, String job, double sal, double comm) { this.eId = eId; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } // 定义setter和getter方法 public int geteId() { return eId; } public void seteId(int eId) { this.eId = eId; } public String geteName() { return eName; } public void seteName(String eName) { this.eName = eName; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } public double getComm() { return comm; } public void setComm(double comm) { this.comm = comm; } // 定义普通方法 public String getInfo() { return &quot;编 号&quot; + this.eId + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：测试 public class TEmp { public static void main(String[] args) { Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0); System.out.println(e.getInfo()); // 获取全部信息 System.out.println(e.geteId()); // 通过getter()获取单一信息 } } 类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Kubernetes安装及使用","slug":"Kubernetes安装及使用","date":"2017-09-30T08:11:30.178Z","updated":"2017-09-30T08:44:56.611Z","comments":true,"path":"article/容器/Kubernetes安装及使用/","link":"","permalink":"http://yov.oschina.io/article/容器/Kubernetes安装及使用/","excerpt":"","text":"环境配置 系统要求: CentOS 7 软件版本: 1.5.2 配置目标: master端 node端 IP 10.0.0.100 10.0.0.101 etcd ✔ flannel ✔ ✔ kube-apiserver ✔ kube-controller-manager ✔ kube-scheduler ✔ kubelet ✔ ✔ kube-proxy ✔ ✔ docker ✔ ✔ 共同配置（即master和node都需要进行的操作） (1)修改/etc/hosts文件，添加master和node节点IP $ echo &quot;10.0.0.100 centos-master 10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts $ cat /etc/hosts 10.0.0.100 centos-master 10.0.0.101 centos-minion (2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services # 关闭fierwalld $ systemctl stop firewalld $ systemctl disable firewalld # 安装iptables，启动该服务并设置开机自启动 $ yum install iptables $ systemctl start iptables $ systemctl enable iptables # 关闭iptables-services $ systemctl disable iptables-services $ systemctl stop iptables-services # 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot; # 解决方法：修改SElinux配置 $ vi /etc/selinux/config # SELINUX=enforcing #注释掉 # SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq! #保存退出 $ setenforce 0 #使配置立即生效 (3)安装","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://yov.oschina.io/tags/Kubernetes/"}]},{"title":"Docker Hub Mysql官方镜像实现首次启动后初始化库表","slug":"Docker Hub mysql官方镜像实现首次启动后初始化库表","date":"2017-09-29T11:59:23.363Z","updated":"2017-09-30T04:25:40.869Z","comments":true,"path":"article/容器/Docker Hub mysql官方镜像实现首次启动后初始化库表/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker Hub mysql官方镜像实现首次启动后初始化库表/","excerpt":"","text":"概述 在Docker Hub中查看MySQL官方镜像的Dockerfile: COPY docker-entrypoint.sh /usr/local/bin/ RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] 镜像启动时，会运行entrypoint.sh脚本，该脚本的shell命令中: echo for f in /docker-entrypoint-initdb.d/*; do case &quot;$f&quot; in *.sh) echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;; *.sql) echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;; *.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;; *) echo &quot;$0: ignoring $f&quot; ;; esac echo done 上述shell命令会遍历/docker-entrypoint-initdb.d/文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。 实现首次启动后初始化库表 创建mysql_data文件夹，将data.sql放入： -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 启动容器 $ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456 mysql 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u root -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。 指定sql文件运行顺序 entrypoint.sh脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法： 将文件按照预期顺序，进行命名，比如1_xx,2_xx; 将必须有前后顺序的sql文件合并在一个sql文件中; 将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。 假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh #!/bin/bash mysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOF source /usr/local/work/database.sql; source /usr/local/work/table.sql; source /usr/local/work/data.sql; 启动容器： $ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql 数据结果应与上述一致。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker实现mysql容器启动后自动建库","slug":"Docker实现mysql容器启动后自动建库","date":"2017-09-28T09:22:57.955Z","updated":"2017-09-30T01:47:23.779Z","comments":true,"path":"article/容器/Docker实现mysql容器启动后自动建库/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker实现mysql容器启动后自动建库/","excerpt":"","text":"概述 通过Dockerfile创建一个mysql镜像,该镜像具有如下功能： mysql容器启动时，会自动执行指定的sql文件; 每次启动该容器，数据都进行初始化，删除所有的修改。 执行步骤 创建Dockerfile $ vim Dockerfile # 指定基础镜像，选用docker官方最新mysql镜像 FROM docker.io/mysql:latest # 环境变量设置，设置mysql登陆时不需密码 ENV MYSQL_ALLOW_EMPTY_PASSWORD yes # 复制文件到容器中，要复制的文件有：启动脚本和sql文件 COPY setup.sh /mysql/setup.sh COPY data.sql /mysql/data.sql COPY privileges.sql /mysql/privileges.sql # 容器启动命令启动脚本 CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;] 创建privileges.sql用于修改mysql权限 $vim privileges.sql use mysql; select host, user from user; -- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456： -- 如果用户docker不存在，则创建用户docker grant all on docker_database.* to docker@'%' identified by '123456' with grant option; -- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： flush privileges; 创建data.sql导入数据 $ vim data.sql -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 创建容器启动脚本setup.sh $ vim setup.sh # !/bin/bash set -e # 查看mysql服务的状态，方便调试 echo `service mysql status` echo '1.启动mysql' # 启动mysql service mysql start # 使进程休眠 sleep 3 echo `service mysql status` echo '2.开始导入数据' #导入sql文件 mysql &lt; /mysql/data.sql echo '3.导入数据完毕....' sleep 3 echo `service mysql status` # 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 echo '4.开始修改密码....' # 导入修改mysql权限设置的文件 mysql &lt; /mysql/privileges.sql echo '5.修改密码完毕....' #sleep 3 echo `service mysql status` echo 'mysql容器启动完毕,且数据导入成功' 创建镜像 创建镜像并命名为mysql:9.29 $ docker build -t mysql:9.29 . 验证 启动mysql:9.29镜像，生成容器 $ docker run --name sql -d -p 23306:3306 mysql:9.29 6da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41 查看容器日志 $ docker log sql 1.启动mysql.... 2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=45790 2017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903. 2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened. 2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode. .. MySQL Community Server 5.7.19 is started. MySQL Community Server 5.7.19 is running. 2.开始导入数据.... 3.导入数据完毕.... MySQL Community Server 5.7.19 is running. 4.开始修改密码.... host user localhost mysql.session localhost mysql.sys localhost root 5.修改密码完毕.... MySQL Community Server 5.7.19 is running. mysql容器启动完毕,且数据导入成功 容器启动过程与setup.sh中编写的步骤完全一致。 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 验证重启mysql容器，数据库初始化 插入数据 mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重新启动容器 $ docker stop sql $ docker start sql $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 重启容器后，数据初始化。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"利用TestNG进行单元测试","slug":"利用TestNG进行单元测试","date":"2017-09-26T12:41:55.450Z","updated":"2017-09-30T08:44:05.126Z","comments":true,"path":"article/测试/利用TestNG进行单元测试/","link":"","permalink":"http://yov.oschina.io/article/测试/利用TestNG进行单元测试/","excerpt":"","text":"TestNG简介 TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。 Annotation Annotation 作用 @BeforeSuite 被注释的方法将在所有测试运行前运行 @AfterSuite 被注释的方法将在所有测试运行后运行 @BeforeTest 被注释的方法将在测试运行前运行 @AfterTest 被注释的方法将在测试运行后运行 @BeforeGroups 被注释的方法将在gourp中方法运行前运行 @AfterGroups 被注释的方法将在gourp中方法运行后运行 @BeforeClass 被注释的方法将在当前类的第一个方法运行前运行 @AfterClass 被注释的方法将在当前类的所有方法运行后运行 @BeforeMethod 被注释的方法将在每一个方法运行前运行 @AfterMethod 被注释的方法将在每一个方法运行后运行 @DataProvider 被注释的方法用于为其他方法提供数据 @Factory 被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[] @Parameters 传递参数给测试方法 使用TestNG进行单元测试 @Test() // Test中所有方法变为测试方法 public class Test { @Test(enable = false) // 该注释后，test1()测试时被忽略，相当于普通方法 public void test1(){} @BeforeTest() // 该注释后，test3(),test4()执行前，test2()先执行 public void test2(){} @ public void test3(){} public void test4(){} }","categories":[{"name":"测试","slug":"测试","permalink":"http://yov.oschina.io/categories/测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yov.oschina.io/tags/TestNG/"}]},{"title":"Git使用(Linux)","slug":"Git使用(Linux)","date":"2017-09-25T09:36:06.108Z","updated":"2017-09-26T12:52:36.796Z","comments":true,"path":"article/工具/Git使用(Linux)/","link":"","permalink":"http://yov.oschina.io/article/工具/Git使用(Linux)/","excerpt":"","text":"环境安装 安装git sudo apt-get install git 配置git用户名 git config –global user.name &quot;user_name&quot; 配置用户邮箱地址 git config –global user.email &quot;user_mail&quot; 创建本地仓库 创建空目录 mkdir folder_name 进入空目录 cd folder_name 显示当前目录 pwd 把当前目录变为Git仓库 git init 把文件添加到Git仓库 git add file 把文件提交到Git仓库 git commit -m &quot;commit_message&quot; 版本库操作 查看修改内容 git diff file_name 查看工作区状态 git status 查看历史记录 git log 查看精简历史记录 git log --pretty=oneline 回退到上一个版本 git reset --hard HEAD^ 回到某个指定版本 git reset –-hard commit-id(git log查看) 查看命令记录 git reflog 撤销全部工作区修改 git checkout --file 将暂存区修改撤销放回工作区 git reset HEAD 文件 linux删除文件 rm file git库删除文件 git rm file 下载他人项目 git clone https://github.com/xxx/xxx.git new_git_name 分支管理 创建并切换到分支 git checkout -b dev_name 查看当前分支 git branch (*表示当前分支) 切换分支 git checkout dev_name 合并指定分支到当前分支(fast forward 模式) git merge dev_name 删除分支 git branch -d dev_name 合并分支时冲突,修改文件后,再提交 查看分支合并图 git log --graph --pretty=oneline --addrev-commit 合并分支（普通模式） git merge -- no-ff -m &quot;commit_message&quot; dev 多人合作 查看远程库信息 git remote -v 推送主分支 git push origin master 推送其他分支 git push origin dev_name 创建本地分支 git checkout -b dev_name origin/dev_name 指定本地分支与远程分支的链接 git branch --set-upstream-to=origin/dev_name 获取远程库内容 git pull 解决冲突后commit，再上传 git push origin dev_name 标签管理 创建标签 git tag tag_name 给指定提交打标签 git tag tag_name commit-id 创建带说明的标签 git tag -a tag_name -m &quot;message&quot; commit-id 查看标签说明 git show tag_name 删除标签 git tag -d tag_name 推送标签 git push origin tag_name 一次性推送所有标签 git push origin --tags 删除标签（本地） git tag -d tag_name 删除远程标签 git push origin :refs/tags/tag_name 自定义Git 使git显示不同颜色 git config --global color.ui true 忽略某些文件时，需要编写.gitignore 强制添加被忽略文件 git add -f file 检查某个文件符合被忽略要求 git check-ignore -v file 配置命令别名 git config --global alias.别名 命令","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yov.oschina.io/tags/Git/"}]},{"title":"Docker的安装说明","slug":"Docker的安装说明","date":"2017-09-24T10:43:23.794Z","updated":"2017-09-25T08:47:49.213Z","comments":true,"path":"article/容器/Docker的安装说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker的安装说明/","excerpt":"","text":"安装及部署Docker 系统和资源说明 Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。 资源需求：Docker1.12.6 安装步骤 (1)安装 $ yum install docker (2)设置开机启动Docker Daemon进程 $ systemctl start docker.service // 启动docker $ systemctl enable docker.service // 设置Docker开机自启动 $ systemctl disable firewalld // 关闭防火墙 $ yum -y install iptables-services // 安装iptable服务 $ systemctl start iptables.service // 启动iptable $ systemctl enable iptables.service // 设置iptable开机自启动 (3)安装成功的Docker $ docker version (4)建立docker用户组，将使用docker的用户加入docker用户组。 $ groupadd docker $ usermod -aG docker $USER Docker的代理配置 $ vim /usr/lib/systemd/system/docker.service [Service] Environment=”HTTP_PROXY=http://192.168.13.19:7777” Environment=”HTTPS_PROXY=http://192.168.13.19:7777” Type=notify Docker配置加速器 国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了阿里云加速器 注册用户并且申请加速器后，会获得 https://xxx.mirror.aliyuncs.com 这样的地址。 $ vim /usr/lib/systemd/system/docker.service ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com $ systemctl daemon-reload // 重新加载配置 $ systemctl restart docker // 重启docker Docker配置文件说明 $ vim /etc/sysconfig/docker OPTIONS=' --selinux-enabled // 是否开启selinux，默认开启 --insecure registry ip:port // 添加私人仓库地址 --bip=ip // 表示网桥docker0的CIDR地址 ' Docker的常用命令 Docker信息查看 (1)查看docker进程状态 $ systemctl status docker (2)查看docker的具体信息 $ docker info (3)查看docker的版本信息 $ docker version Docker的镜像操作 (1)查找镜像 $ docker search image_name (2)拉取镜像 $ docker pull image_name:tag (3)列出本地镜像 $ docker images 列表参数说明 Repository：镜像的仓库源 Tag：镜像的标签 Image ID： 镜像ID Created： 镜像的创建时间 Size： 镜像大小 (4)设置镜像标签 $ docker tag image_id tag (5)利用镜像创建容器 $ docker run image_name:tag command (6)提交镜像 $ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name Docker的容器操作 (1)启动容器 $ docker run option host_port:contaniner_port image_name:tag command 例如：docker run -it -d -p 5000:5000 java java -version -d：后台运行容器 -p:将容器端口映射到宿主机端口 -it:进行交互式操作 command: 执行java -version命令 (2)查看容器 $ docker ps // 查看正在运行的容器 (3)容器生命周期命令 $ docker create image:tag // 创建容器但不启动 $ docker start container_name // 启动容器 $ docker stop contaniner_name // 停止容器 $ docker restart container_name // 重启容器 $ docker pause contaniner_name // 暂停容器内所有进程 $ docker unpause contaniner_name // 恢复容器内所有进程 $ docker rm contaniner // 删除容器 $ docker rm ${docker ps -a -q} // 删除所有停止的容器","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker的简单说明","slug":"Docker的简单说明","date":"2017-09-24T09:36:05.889Z","updated":"2017-09-25T08:47:46.483Z","comments":true,"path":"article/容器/Docker的简单说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker的简单说明/","excerpt":"","text":"Docker简介 Docker的概念 Docker最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。Docker被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将应用软件及其依赖软件（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。 Dcoker的技术依赖 Docker使用Go语言进行开发实现，基于Linux内核的cgroup、namespace以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于LXC、0.7后去除LXC，使用自行开发的libcontainer。从1.11开始，则使用runC和containerd。 （1）cgroup是将任意进程进行分组化管理的Linux内核功能。重要概念是子系统，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。 （2）LXC（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于namespace的隔离机制和cgroup限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。 （3）AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。 （4）App打包：Docker额外提供的Feature,标准统一的打包部署运行方案。 Docker的优势 Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而容器内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。 （1）更高效的利用系统资源 由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。 （2）更快速的启动 Docker容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动，大大节约了开发、测试、部署的时间。 （3）一致的运行环境 Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致性。 （4）持续交付和部署 Docker可以通过定制应用镜像实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来创建镜像，并结合持续集成（Continuous integration）系统进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。 （5）更轻松的迁移 由于Docker确保了运行环境的一致性，使得应用迁移更加容易。 （6）更轻松的维护和扩展 Docker使用的分层存储以及镜像技术，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易. Docker相关的基础概念 Docker Image 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。Docker镜像（Image）就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含一些为运行时准备的配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。 分层存储 因为传统镜像包含操作系统完整的root文件系统，其体积往往庞大。因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，任何额外的东西应在该层构建结束前清理结束。 分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。 Docker Container 镜像（Image）是静态定义，容器（Container）是镜像运行时的实体。容器可以被创建、启动、停止等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。 容器也是分层存储的，每个容器运行时以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。 按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。 Docker Registry 镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即Docker Registry。 一个Docker Registry包含多个仓库（Repository）；每个仓库包含多个标签Tag；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;来获取指定版本的镜像，如果不给出标签，就将以latest为默认标签。 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的Docker Hub。 除了公开服务外，用户还可以在本地搭建私有的Docker Registry。Docker官方提供Docker Registry镜像，可以直接使用作为私有Registry服务。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(二)","slug":"Java基础知识(二)","date":"2017-09-24T03:29:54.604Z","updated":"2017-10-02T07:29:57.343Z","comments":true,"path":"article/语言/Java基础知识(二)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(二)/","excerpt":"","text":"运算符 常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。 基本运算符 =为赋值运算符。 四则运算符基本组成：+、-、*、/、%。不要使用运算符编写过于复杂的计算。 public class Demo { public static void main(String[] args) { int numA = 10; double numB = 20; int numC = 3; System.out.println(&quot;加法计算：&quot; + (numA + numB)); System.out.println(&quot;减法计算：&quot; + (numA - numB)); System.out.println(&quot;乘法计算：&quot; + (numA * numB)); System.out.println(&quot;除法计算：&quot; + (numA / numB)); System.out.println(&quot;求模计算：&quot; + (numA % numC)); } } 简化运算符：+=、-=、*=、/=、%=: public class Demo { public static void main(String[] args) { int numA = 10; numA += 2; // 等同于 numA = numA + 2 System.out.println(&quot;加法计算&quot; + (numA)); // 12 } } ++（自增），--（自减）：位置不同，功能也不同： ·++变量，--变量：先对变量加/减1，再使用自增或自减后的变量进行计算; ·变量++，变量--：先使用变量进行计算，再进行变量加/减1。 public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; // ++变量，先numA + 1 // 然后(numA + 1) + numB内容 // 最后对numB加1 int result = (++numA) + (numB++); System.out.println(&quot;numA=&quot; + numA); // 11 System.out.println(&quot;numB=&quot; + numB); // 21 System.out.println(&quot;result=&quot; + result); // 31 } } 三目运算符 三目运算符根据布尔表达式的结果进行赋值： value_type value_name = 布尔表达式 ? true_value : false_value; 利用三目运算符可以减少判断代码: public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; int max = 0; /** 使用三目运算符 * 当numA大于numB,返回true,max = numA * 当numA小于numB,返回false,max = numB */ max = numA&gt;numB ? numA : numB; // 不使用三目运算符 // if (numA &gt; numB) { // max = numA; //} else { // max = numB; //} System.out.println(max); } } 逻辑运算符 逻辑运算符：与&amp;，&amp;&amp;、或|，||、非! package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = true; System.out.println(!flag); // false } } 布尔表达式的连接，只能使用与和或操作 与：所有条件都为true时，结果为true;有一个为false，结果就是false. 范例：普通与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：程序报错，因为&amp;会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。 范例：短路与&amp;&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp;&amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // false,不报错 } } } 结果:程序不报错，因为&amp;&amp;只要有一个条件为false后，后续判断就不再进行，从而提高了效率。 或操作：一个条件为true，结果为true。 范例：普通或| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) | (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：使用|，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。 范例：短路或|| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) || (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // true,不报错 } } } 因此使用逻辑运算时就使用&amp;&amp;和||。 位运算符 数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。 位运算主要是进行二进制数据操作，位运算符：&amp;、|、&gt;&gt;(移位)、&lt;&lt;、^(反码)、~。 范例：位与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA &amp; numB); // 9 } } 运算过程： 1001 → 9 &amp; 1011 → 11 1001 → 9 范例：位或| package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA | numB); // 11 } } 运算过程： 1001 → 9 | 1011 → 11 1011 → 11 范例：移位（最快方式计算2的3次方） package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; num = num &lt;&lt; 2; // 向左移位 System.out.println(num); // 8,相当于2的3次方 } } 运算过程： 0010 → 2 2&lt;&lt; 1000 → 8 章节小问题：请解释&amp;与&amp;&amp;的区别，以及|与||的区别: 1. 在逻辑运算中： |- &amp;和|会对所有条件进行判断后，返回结果 |- &amp;&amp;只要一个条件返回false，就不进行后续判断，结果为false |- ||只要一个条件为true，就不进行后续判断，结果为true 2. 在位运算中： |- &amp;为位与元算，|为位或元算 |- &amp;&amp;和||不能用于位运算 Java程序逻辑控制 程序逻辑结构主要分为三种：顺序结构、分支结构、循环结构。顺序结构执行顺序是从前到后，但有时是以代码所在的{}为界限。 分支结构 分支结构即判断结构，有两种语法：if和switch. if语句: if语句的格式: if if…else if…else if…else 范例：if判断 package com.java.demo; public class Demo { public static void main(String[] args) { double score = 90.0; if (score &lt; 60.0) { System.out.println(&quot;不及格&quot;); } else if (score &lt; 90) { System.out.println(&quot;良&quot;); } else { System.out.println(&quot;优秀&quot;); } } } switch语句: switch判断不能使用布尔表达式，JDK1.5之前只能进行整数或字符判断，JDK1.5增加了枚举判断，JDK1.7增加了String判断，语法： switch (数字/字符/枚举/字符串){ case 内容 : 内容满足时执行的代码 ; break; case 内容 : 内容满足时执行的代码 ; break; ... default { 内容都不满足case时执行; break; } } 范例：使用switch package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; switch (num) { case 1: System.out.println(&quot;数字1&quot;); break; case 2: System.out.println(&quot;数字2&quot;); break; default: System.out.println(&quot;大于2的数字&quot;); break; } } } switch默认从第一个符合条件的case语句开始执行，直到整个switch执行完毕或遇到break关键字，才停止执行。程序区分大小写。 循环结构 当某段代码需要重复执行时，可使用循环语句实现，循环有两种：for循环和while循环。 while循环： while循环 do…while循环 while（布尔语句）｛｝ do｛｝while（布尔语句); 范例：实现1到100的累加（while循环先判断再执行）： package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; // 循环的初始化条件 while (current &lt;= 100) { // 循环结束条件 sum += current; // 累加 current++; // 修改循环的初始化条件 } System.out.println(sum); // 5050 } } 范例：实现1到100的累加（do…while循环是先执行再判断） package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; do { sum += current; current++; } while (current &lt;= 100); System.out.println(sum); } } do…while循环先执行再判断，即不论循环条件是否满足，都至少执行一次，因此开发中不建议使用do…while。 for循环： for (循环初始化条件; 循环结束条件; 循环条件变更) { 循环语句; } 即使三个条件都不写，但是两个&quot;;&quot;必须保留。 范例：实现1~100的累加 package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(sum); } } 开发原则: （1）循环次数未知，循环结束条件已知时使用while循环； （2）循环次数已知，使用for循环。 循环嵌套 public class 九九乘法表 { public static void main(String[] args) { for (int x = 1; x &lt;= 9; x++) { for (int y = 1; y &lt;= x; y++) { System.out.print(x + &quot;*&quot; + y + &quot;=&quot; + (x * y) + &quot;\\t&quot;); } System.out.println(); } } } 循环控制 循环控制有两个语句：continue（退出本次循环）和break（结束整个循环）。该语句要和判断语句一起使用。 范例：continue使用 package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { continue; // 跳出本次循环，不进行后续的输出操作 } System.out.print(x + &quot;,&quot;); // 0,1,2,4, } } } 范例：break package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { break; // 结束整体循环 } System.out.print(x + &quot;,&quot;); // 0,1,2, } } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2017-09-23T09:19:24.606Z","updated":"2017-09-25T08:47:54.232Z","comments":true,"path":"article/语言/Markdown语法/","link":"","permalink":"http://yov.oschina.io/article/语言/Markdown语法/","excerpt":"","text":"Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。 Markdown语法 区块元素 段落与换行 一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是无法使用空格或制表符来缩进的，因为其默认一个空格就是一个空行。 标题 Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个#，对应1到6级标题。 # 这是H1 ## 这是H2 ... ###### 这是H6 区块引用Blockquotes Markdown标记区块引用方式如下： &gt; 文本内容。 &gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt; 在引用的区域中，也可以使用其他的Markdown语法。 列表 Markdown支持有序列表和无序列表。无序列表使用星号、减号或加号作为列表标记: * red - green + blue 有序列表则使用数字接着一个英文句号： 1. red 2. green 3. blue 如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即： * blue *red 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 如果要在列表项目中放入引用，就需要缩进 * red &gt; this is color 如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。 代码区域 要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。 分隔线 你可以在一行使用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。 星号： * * * 减号： - - - 下划线：_ _ _ 区段元素 链接 Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。 [example](https://www.baidu.com &quot;Title&quot;) 强调 Markdown使用星号和下划线标记强调，被*或_包围的字词会被转为用&lt;em&gt;标签包围，而用两个*或_包起来，则变为&lt;strong&gt; *强调* _强调_ **强调** __强调__ 如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠： \\*文字\\* 代码 如果要标记一小段行内代码，可以使用反引号把它包起来，例如： `printf()` 如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段: `` (`) `` 将变为 &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt; 图片 插入图片有两种方式：行内式和参考式 ![替代图片的文字](/path/to/img.jpg &quot;文字&quot;) 结束 感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yov.oschina.io/tags/Markdown/"}]},{"title":"SpringBoot使用","slug":"SpringBoot使用","date":"2017-09-23T08:58:23.811Z","updated":"2017-09-25T08:47:55.716Z","comments":true,"path":"article/框架/SpringBoot使用/","link":"","permalink":"http://yov.oschina.io/article/框架/SpringBoot使用/","excerpt":"","text":"","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Go基础知识","slug":"Go基础知识","date":"2017-09-23T08:57:17.832Z","updated":"2017-10-14T12:54:39.737Z","comments":true,"path":"article/语言/Go基础知识/","link":"","permalink":"http://yov.oschina.io/article/语言/Go基础知识/","excerpt":"","text":"入门 Go语言是一门编译型语言，是一个开源的编程语言，能让构造简单、而且高效的软件变得容易。Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go语言环境安装 Go语言安装包下载地址为Golang。Windows使用mis后缀的安装包即可。默认情况msi文件会安装在c:\\Go目录下。Go语言的开发工具可以使用LitelDE，是一款开源、跨平台的轻量级Go语言集成开发环境.。也可以在Eclipse或IDEA中安装Go语言插件。 第一个Go程序 package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello World!&quot;) } Go的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go提供的工具都通过go命令调用。其中go run就是编译go的源文件，链接库文件，并运行生成的可执行文件。 $ go run helloworld.go Go语言支持Unicode，可以处理任何语言的文本，包括中文。 如果要编译上述程序，保存编译结果以备将来使用，可以使用build子命令： $ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（注：Windows系统下生成的是helloworld.exe），之后可以随时运行它，不需要任何处理（注：因为是静态编译，所以不必担心系统库更新时的冲突）。 Go语言的代码通过包（package）组织，包类似与其他语言中的库（libraries）或者模块（modules）。一个包由单个目录下的一个或多个go源代码文件组成，目录定义包的作用。每个源文件都以package声明语句为开始。上述例子就是package main，紧跟着导入（import）的包，之后是程序代码。 fmt包含有格式化输出、接收输入的函数，Println是其中一个基础函数。 main包比较特殊，定义了一个独立可执行的程序，而不是一个库。main包中的main函数是整个程序执行时的入口。import声明告诉编译器需要哪些包，缺少必要的包或者导入不需要的包，程序都无法编译通过。 组成程序的函数、变量、常量、类型的声明语句分别由关键字func、var、const、type定义。一个函数的声明由func关键字、函数名、参数列表、返回值列表（mian函数不含返回值）以及包含在大括号里的函数体组成。Go语言不需在语句末尾添加分号，除非一行有多条语句。","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://yov.oschina.io/tags/Go/"}]},{"title":"Java基础知识(一)","slug":"Java基础知识(一)","date":"2017-09-23T08:57:00.370Z","updated":"2017-09-25T08:47:50.732Z","comments":true,"path":"article/语言/Java基础知识(一)/","link":"","permalink":"http://yov.oschina.io/article/语言/Java基础知识(一)/","excerpt":"","text":"Java基础知识 Java是一门面向对象语言，支持多线程编程;通过使用更为简单的引用来进行内存关系的匹配，而不是复杂的指针;Java提供垃圾自动回收机制，能更好地处理垃圾空间;可以实现多平台的移植。 第一个Java程序 运行Java程序的步骤 javac xx.java:对Java程序进行编译，生成字节码文件xx.class。 java xx：对Java程序进行解释。 Java程序的核心单元—类 类的声明方式有两种: public class class_name {}：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。 class class_name {}：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。 第一个Java程序：Hello World package com.java.demo; // 包名 public class HelloWorld { // 类 public static void main(String[] args) { // 主方法 System.out.println(&quot;Hello World&quot;); // 方法体 } } Java程序都是从主方法开始执行的.System.out.println()将内容输出后换行。 CLASSPATH环境属性 PATH和CLASSPTH的区别：PATH是操作系统路径，定义了所有可执行程序的路径；CLASSPATH是Java解释类文件时的加载路径，当java命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。 配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。 注释 // 注释内容： 单行注释 /* 注释内容 */： 多行注释 /** 注释内容 */：文档注释 标识符与关键字 标识符 标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下： （1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字； （2）标识符应尽量有意义，可见名知意。 （3）Java标识符可以是中文，但不建议使用中文命名标识符。 关键字 Java中有两个未使用的关键字goto和const；JDK1.4之后增加了assert关键字；JDK1.5之后增加了enum关键字。 Java数据类型 Java数据类型分为两大类：基础数据类型和引用数据类型 两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。 基本数据类型： |-数值型： |-整型：byte、short、int、long； →默认值：0； |-浮点型：float、double； →默认值：0.0 |-字符型：char； →默认值：‘\\u0000’ |-布尔型：boolean； →默认值：false |-引用数据类型：数组、类、接口等。 →默认值：null 数据类型的选择原则 （1）整数用int，小数用double； （2）描述日期时间或内存大小，用long； （3）实现内容传递或编码转换用byte； （4）逻辑控制用boolean； （5）避免中文乱码用char。 整型 数字常量属于int型数据，如数字30。 常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量： package com.java.demo; public class Demo { public static void main(String[] args) { // 一个变量名在同一块代码中只允许声明一次 // 变量赋值语法：value_type value_name = value ; int num = 10; num = num * 2; System.out.println(num); } } 每个数据类型都有其对应的存储范围 package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; // int型数据的最大值 int min = Integer.MIN_VALUE; // int型数据的最小值 System.out.println(max); // 2147483647 System.out.println(max + 1); // -2147483648 System.out.println(min); // -2147483648 System.out.println(min - 1); // 2147483647 System.out.println(min - 2); // 2147483646 } } 当数据超过int型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为数据溢出，解决方法是扩大数据范围： package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; // int变量 + long变量 = long变量,扩大了数据的范围 System.out.println(max + 1L); // 2147483648 System.out.println(min - (long)1); // -2147483649 System.out.println((long)min - 2); // -2147483650 } } 数据类型的转换规律 范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型； 范围大的数据类型只能通过强制转换变为范围小的数据类型。 常量进行强制转换，可通过使用常量标记（如L，l可将int型常量变为long型）或使用(数据类型)常量。范例–强制转换： package com.java.demo; public class Demo { public static void main(String[] args) { // 1000是int型，使用long型变量接收，发生自动转换 long num = 1000; // long型变为int型，强制转换 int x = (int) num; System.out.println(x); // 1000 } } 当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生数据溢出。 package com.java.demo; public class Demo { public static void main(String[] args) { // 2147483650L是long型数据，超出int型的范围 long num = 2147483650L ; int x = (int) num; System.out.println(x); // -2147483646，数据溢出 } } byte型数据的取值范围为-128~127，当整数数值在这个范围内时，会自动转型；超出byte范围时会发生数据溢出。 4. 注意点 变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。 package com.java.demo; public class Demo { public static void main(String[] args) { // 未给变量赋值 int num; // 报错,未初始化变量,无法使用该变量 System.out.println(num); } } 浮点型 Java中浮点数属于double型（double型是保存范围最广的类型）。 package com.java.demo; public class Demo { public static void main(String[] args) { double num = 10.2; // 10.2是小数，属于double型 // double型 * int型 = double型 System.out.println(num * 2); // 20.4 } } 所以使用float数据须将double强制转换为float型： package com.java.demo; public class Demo { public static void main(String[] args) { float fA = 10.2F; // 强制转型方式一 float fB = (float) 10.2; // 强制转型方式二 System.out.println(fA); // 10.2 System.out.println(fB); // 10.2 System.out.println(fA * fB); // 104.03999,该bug无法解决 } } 开发过程中要考虑到整型数据不保留小数位： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / x); // 1 } } 因为int型/int型=int型，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / (double) x); // 1.8 } } 字符型 byte byte是字节，1字符=2字节。Java使用十六进制UNICODE编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。 字符使用单引号'声明，一对单引号只能保存一位字符。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型可以自动转换为int型 System.out.println(c); System.out.println(num); // 65,是A的ASCII码值 } } 编码：'A'(65)~'Z'(90); 'a'（97）~'z'（122）; '0'（48）~'9'(57),可利用A和a的编码差为32，实现字母大小写转换： package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型变为int型才能进行四则运算 num = num + 32; // 大写与小写编码值差为32 c = (char) num; // int型只能强制转换为char型 System.out.println(c); // a } } 传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = '游'; int num = c; System.out.println(num); // 28216 } } 由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。 布尔型 布尔型返回逻辑结果，只保存两种数据：true和false，主要用于逻辑控制： package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = false; // if (布尔值){满足条件时的操作} if (!flag) { System.out.println(&quot;Hello World !&quot;); } } } String型 String型 String属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号&quot;&quot;声明。 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // str为字符串变量 System.out.println(str); // &quot;Hello World !&quot;为字符串常量 System.out.println(&quot;Hello World !&quot;); } } +可实现字符串连接 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str = str + &quot; World !&quot;; System.out.println(str); } } 当四则运算与字符串连接同时存在时： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + numA + numB; System.out.println(str); // 加法计算：10099.9 } } 出现上述结果是因为小范围数据会自动转型为大范围数据，即String型+任意数据类型=String型，然后进行字符串连接，可使用()来实现正确的运算： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + (numA + numB); System.out.println(str); // 加法计算：199.9 } } Java支持转义字符， 例如：换行\\n、制表符\\t、反斜杠\\\\、双引号\\&quot;、单引号\\'： package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello \\&quot;World\\&quot; \\nHello MLDN&quot;; System.out.println(str); /** * Hello &quot;World&quot; * Hello MLDN */ } }","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Gitee+Hexo搭建个人博客","slug":"Gitee+Hexo搭建个人博客","date":"2017-09-22T13:48:40.242Z","updated":"2017-10-02T06:55:01.573Z","comments":true,"path":"article/博客搭建/Gitee+Hexo搭建个人博客/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/Gitee+Hexo搭建个人博客/","excerpt":"","text":"Gitee: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。 Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。 环境搭建 安装Node.js Windows用户访问Node.js下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。 $ npm config set registry http://registry.npm.taobao.org/ Hexo安装 $ npm install -g hexo-cli Hexo的基本使用请查看hello-world文中所写。 本地运行Hexo 在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件： $ hexo init 初始化后，文件夹的目录如下： . ├── .deploy #需要部署的文件 ├── node_modules #Hexo插件 ├── public #生成的静态网页文件 ├── scaffolds #模板 ├── source #博客正文和其他源文件等都应该放在这里 | ├── _drafts #草稿 | └── _posts #文章 ├── themes #主题 ├── _config.yml #全局配置文件 └── package.json 之后在本地执行如下命令后，即可访问 http://localhost:4000 访问Hexo页面 $ hexo s Git安装 Git安装包地址,根据操作系统选择安装包下载后安装即可。 注册码云账号，并创建一个项目 获取项目地址 发布博客 修改Hexo配置文件_config.yml deploy: type: git repo: 码云的项目地址 branch: master 部署博客 $ npm install hexo-deployer-git --save $ hexo g --d #一键部署 此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。 开启Page功能 访问博客 在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下： 博客使用 在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为file_name.md file_name.md的文件开头如下: --- title: file_name tag: 标签名 categories: 分类 comment: 是否允许评论(true or false) description: 描述 --- 文档正文编写，请参照markdown语法。 结尾 如果搭建过程中，还有什么问题，请在下方留言。谢谢您的阅读！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-22T08:28:42.118Z","updated":"2017-09-25T08:47:28.553Z","comments":true,"path":"article/博客搭建/hello-world/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]}]}