{"meta":{"title":"Ember","subtitle":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","description":"一切有为法,如梦幻泡影。如露亦如电,应作如是观。","author":"子语","url":"http://yov.oschina.io"},"pages":[{"title":"About","date":"2017-09-26T12:54:07.655Z","updated":"2017-09-26T12:54:07.655Z","comments":true,"path":"about/index.html","permalink":"http://yov.oschina.io/about/index.html","excerpt":"","text":"一个被现实从网络架构逼到了编程开发的小菜鸟x.x"},{"title":"Gallery","date":"2017-09-25T03:23:43.087Z","updated":"2017-09-25T03:23:43.087Z","comments":true,"path":"gallery/index.html","permalink":"http://yov.oschina.io/gallery/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-24T15:49:20.806Z","updated":"2017-09-24T15:49:20.806Z","comments":true,"path":"tags/index.html","permalink":"http://yov.oschina.io/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-09-25T01:46:53.318Z","updated":"2017-09-25T01:46:53.318Z","comments":true,"path":"links/index.html","permalink":"http://yov.oschina.io/links/index.html","excerpt":"","text":""},{"title":"Timeline","date":"2017-09-24T15:48:28.689Z","updated":"2017-09-24T15:48:28.689Z","comments":true,"path":"timeline/index.html","permalink":"http://yov.oschina.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"IDEA中Spring Boot实现热部署","slug":"Tool/IDEA中SpringBoot实现热部署","date":"2018-01-04T11:47:37.732Z","updated":"2018-01-04T11:58:35.410Z","comments":true,"path":"article/工具/Tool/IDEA中SpringBoot实现热部署/","link":"","permalink":"http://yov.oschina.io/article/工具/Tool/IDEA中SpringBoot实现热部署/","excerpt":"","text":"IntelliJ IDEA 作为当下较为热门的Java IDE,当使用Spring Boot进行开发时，由于静态页面经常修改，每次重启十分麻烦。因此实现Spring Boot热部署尤为重要。 Devtools Spring为开发者提供了spring-boot-devtools模块进行Spring Boot热部署,提高了开发效率，无需手动重启应用。使用需要在pom.xml添加如下配置： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; 在application.yml中添加配置 thymeleaf: cache: false # 关闭cache，刷新即可显示新页面 devtools: restart: enabled: true # 启用热部署 additional-paths: src/main/resources # 设置重启目录 IDEA设置 （1）File-&gt;Settings-&gt;Compiler-&gt;Build project automatically，将其打勾。 （2）ctrl + shift + A，在检索框输入Registry，随后找到Compiler autoMake allow when app running，勾选。 重启应用，此时不论是修改java文件还是修改html文件都会自动重新加载，不会重启应用。","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yov.oschina.io/tags/IDEA/"}]},{"title":"一个Go程序","slug":"Go Base/一个Go程序","date":"2018-01-03T12:12:27.888Z","updated":"2018-01-03T14:54:15.739Z","comments":true,"path":"article/Go/Go Base/一个Go程序/","link":"","permalink":"http://yov.oschina.io/article/Go/Go Base/一个Go程序/","excerpt":"","text":"","categories":[{"name":"Go","slug":"Go","permalink":"http://yov.oschina.io/categories/Go/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"http://yov.oschina.io/tags/Go基础/"}]},{"title":"基础篇01--单块架构及其面临的挑战","slug":"Micro Service/基础篇01--单块架构及其面临的挑战","date":"2018-01-02T12:47:03.123Z","updated":"2018-01-02T13:21:34.781Z","comments":true,"path":"article/微服务/Micro Service/基础篇01--单块架构及其面临的挑战/","link":"","permalink":"http://yov.oschina.io/article/微服务/Micro Service/基础篇01--单块架构及其面临的挑战/","excerpt":"","text":"第一部分 基础篇 系统的架构设计是每个系统构建过程及其关键的一部分，决定了系统是否能够被正确、有效地构建。 系统架构设计描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多重因素，将应用系统划分成不同的部分，并使这些部分相互分工，相互协作，从而为用户提供某种特定价值的方式。 随着面向对象分析、设计模式、企业架构模式等方法论的深入人心，从功能实现、代码组织的角度考虑，系统中不同职责的部分逐渐被划分到了如下三个部分： 表示层：聚焦数据显示和用户交互 业务逻辑层：聚焦业务逻辑处理 数据访问层：聚焦数据的存储与访问 每层负责的部分更趋向于具体化、细致化，这就是最初的软件三层架构，该架构解决了系统间调用复杂、职责不清的问题，更有效地降低了层与层之间的依赖关系。这是将系统在逻辑上进行划分，而不是物理上划分，即不同层的代码在进行编译、打包、部署后依然运行在同一个进程中。 对于这种功能集中、代码中心化、一个发布包、部署后运行在同一进程的应用程序，通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或项目。 随着业务的扩大，需求的增加，单块架构很难满足业务快速变化的需求：一方面代码的可维护性、扩展性、灵活性在降低；另一方面系统的修改成本、构建以及维护成本在显著增加。 单块架构及其面临的挑战 三层应用架构 三层应用架构的发展 层能帮助我们划分出构成某整体事务的、上下互相支撑的不同部分。层的概念： 层能被单独构造； 每层具有区别于其它层的显著特点； 层与层之间能够互相连接，互相支撑，互相作用，相互协作，从而构成一个整体； 层的内部可以被替换成其他可工作的部分，但对整体的影响不大。 Web程序开发早期收到面向过程思维以及设计方式的影响，所有的逻辑代码调用相互交错，错综复杂，如早期的PHP、JSP以及ASP便是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，即一层架构。 随着Java、.NET的发展，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，即二层架构。 随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从而为用户提供以及有效组织软件结构的考虑，Web根据职责的不同逐渐被定义在不同的层次，每一层负责的部分更趋向于具体化、细致化，即三层架构。 什么是三层架构 三层架构通常包括表示层、业务逻辑层以及数据访问层、 表示层 表示层指的是用户使用应用程序时与其交互操作的部分，通过该部分进行交互并获取期望的结果。目前用户接口大部分为Web形式，也可以是桌面软件形式。","categories":[{"name":"微服务","slug":"微服务","permalink":"http://yov.oschina.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://yov.oschina.io/tags/微服务/"}]},{"title":"Go语言简介","slug":"Go Base/Go语言简介","date":"2018-01-02T11:33:54.288Z","updated":"2018-01-02T12:39:34.568Z","comments":true,"path":"article/Go/Go Base/Go语言简介/","link":"","permalink":"http://yov.oschina.io/article/Go/Go Base/Go语言简介/","excerpt":"","text":"用Go解决现有编程难题 开发速度 编译一个大型的C或C++项目需要花费较长的时间。而Go使用了更为智能的编译器，简化了解决依赖的算法，最终提高了编译速度。编译Go程序时，编译器只会关注那些被直接引用的库，而不像Java或C那样遍历依赖链中所有依赖的库。 因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出，代价是动态语言不提供静态语言提供的类型安全特性，因此经常需要使用大量的测试套件来避免运行时出现类型错误这类bug。 并发 Go语言对并发的支持是这门语言最重要的特性之一。goroutine很像线程，但它占据的内存远少于线程，且使用它需要的代码更少。channel(通道)是一种内置的数据结构，可以让不同用户在不同的goroutine之间同步发送具有类型的消息，这让编程模型更倾向于在goroutine间发送消息，而不是让多个goroutine争夺同一个数据的试用权。 goroutine goroutine是可以与其它goroutine并行执行的函数，同时也会与主程序并行执行。在其他编程代码中，需要使用线程来完成同样的事，而在Go中会使用同一个线程来执行多个goroutine。例如：用户在写一个Web服务器，希望同时处理不同的Web请求，Java需要写大量额外的代码来使用线程。而在Go中，net/http库直接使用了内置的goroutine，每个请求都自动在自己的goroutine里处理。Go运行时会自动在配置的一组逻辑处理器上调度运行goroutine，每个逻辑处理器绑定到一个操作系统线程上，这让应用程序执行效率更高，而开发工作量减少。 如果想在执行一段代码时，并行去做另外的事，goroutine是很好的选择，下面是一个简单的例子： func log(msg string) { // 此处是处理日志的代码 } // 代码中有些地方检测到错误 go log(\"发生错误\") 关键字go是唯一需要去编写的代码，调用log()作为独立的goroutine去运行，以便与其他goroutine并行执行，这意味着应用程序的其他部分会与记录日志并行执行。 通道 通道是一种数据结构，可以让goroutine之间安全的通信，可以避免其他语言中常见的共享内存访问的问题。 并发最难的部分就是要确保其他并发运行的进程、线程或goroutine不会意外修改用户的数据。当不同线程在没有同步保护的情况下修改同一个数据时，将会导致错误。在其他语言中如果使用全局变量或共享内存，需要使用复杂的锁规则来防止对同一个变量的不同步修改。 通道提供了新模式，这一模式保证同一时刻只会有一个goroutine修改数据。通道用于在几个goroutine之间发哦那个数据。例子：一个应用程序，有多个进程需要顺序读取或修改某个数据，使用goroutine和通道可以为这个过程建立安全的模型。运行过程如下图所示： 上图有三个goroutine，还有2个不带缓存的通道。第一个goroutine通过通道将数据传给已经在等待的第二个goroutine。两个goroutine间传输数据是同步的，一旦传输完成，两者都会知道数据完成传输。第二个goroutinelion个数据完成任务后，会将数据传给第三个goroutine，传输依然是同步的。这种在goroutine之间安全传输数据的方法不需要任何锁或者同步机制。 需要注意的是，通道不提供跨goroutine的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个goroutine都会持有一份副本，各自对自己的副本做修改是安全的。当传输指向数据的指针时，如果读和写是由不同的goroutine完成，每个goroutine依旧需要额外的同步动作。 Go的数据类型 Go提供灵活的、无继承的类型系统，无需降低运行性能就能最大程度复用代码，这个类型依然支持面向对象开发。Go使用组合composition设计模式，只需要简单地将一个类型嵌入另一个类型，就能复用所有的功能。 此外Go还有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行建模。在Go中不需要声明某个类型实现某个接口，编译器会判断类型的实例是否符合正在使用的接口。 类型简单 Go不仅有int和string这样的内置类型，还支持自定义类型。Go中自定义的类型通常包含一组带类型的子弹，用于存储数据，类似于C语言的结构，但Go的类型可以声明操作该类型数据的方法。传统语言使用继承来扩展结构，而Go构建更小的开发类型，然后将这些小类型组合为更大的类型。 Go接口对一组行为建模 接口用于描述类型的行为，如果一个类型的实例实现了一个接口，意味着这个实例可以执行一组特地的行为。你甚至不要去声明这个实例实现了某个接口，只需要实现这组行为就好了，这种特性被称为鸭子特性。Go中如果一个类型实现了一个接口所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。 Go的接口一般只会描述一个单一的动作，在Go中最常用的接口之一就是io.Reader，该接口提供了一个简单的方法，用来声明一个类型有数据可以读取，其定义如下： type Reader interface { Read(p []byte) (n int, err error) } 为了实现该接口，你只需要实现一个Read方法，这个方法接受一个byte切片，返回一个整数和可能出现的错误。 这个与传统接口有本质区别，更有利于使用组合来复用代码，用户几乎可以给所有包含数据的类型实现io.Reader,然后把这个类型的实例传给任何一个知道如何读取io.Reader的Go函数。 内存管理 不当的内存管理会导致程序崩溃或者内存泄漏，甚至系统崩溃。Go具有现代化的垃圾回收机制。其他语言使用内存前要先分配这段内存，然后使用完毕后释放。哪怕出现一点失误，就会导致程序崩溃或内存泄漏。这存在一个问题，追踪内存是否还在被使用是件艰难的事，而要想支持多线程和高并发，更是让这件事愈发困难。虽然Go的垃圾回收会造成额外开销，但降低了开发难度。 Hello ，Go package main // Go程序都组织成包 import \"fmt\" // 导入外部代码，fmt包用于格式化并输出数据 func main() { // main函数是程序的入口 fmt.Println(\"Hello World!\") }","categories":[{"name":"Go","slug":"Go","permalink":"http://yov.oschina.io/categories/Go/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"http://yov.oschina.io/tags/Go基础/"}]},{"title":"Node.js安装及环境配置","slug":"Tool/Node.js安装说明","date":"2017-12-31T05:33:25.278Z","updated":"2017-12-31T07:05:59.363Z","comments":true,"path":"article/工具/Tool/Node.js安装说明/","link":"","permalink":"http://yov.oschina.io/article/工具/Tool/Node.js安装说明/","excerpt":"","text":"简而言之,Node.js 就是运行在服务端的 JavaScript, 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常好。 安装环境 1.系统：Window10 Pro（64位） 2.Node.js：v6.11.3LTS（64位） 安装步骤 下载Node.js 打开Node.js官网下载安装包 安装Node.js 安装目录可修改,默认为C盘: 安装成功: 安装成功则可以查看node.js版本以及npm版本: 环境配置 此处配置的是npm安装的全局模块锁在路径，以及缓存cache的路径。进行该项配置是当执行npm install xxxx -g时，会默认安装到C:\\User\\用户名\\npm路径下，占据C盘空间。 修改全局模块安装路径和缓存路径 在node.js的安装文件中新建node_cache和node_global，在node_global下新建node_modules文件夹。随后使用cmd命令进行配置： npm config set prefix \"D:\\Program Files\\nodejs\\node_global\" npm config set cace \"D:\\Program Files\\nodejs\\node_cache\" 设置环境变量 “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” 在系统变量(S)中新建NODE_PATH，变量值为D:\\Program Files\\nodejs\\node_global\\node_modules; 修改用户变量(U)中的PATH将C:\\User\\用户名\\npm改为D:\\Program Files\\nodejs\\node_global 测试环境变量修改成功，使用cmd命令进行安装 npm install express -g # -g 全局安装 D:\\Program Files\\nodejs\\node_global `-- express@4.16.2 +-- accepts@1.3.4 | +-- mime-types@2.1.17 | | `-- mime-db@1.30.0 | `-- negotiator@0.6.1 +-- array-flatten@1.1.1 +-- body-parser@1.18.2 | +-- bytes@3.0.0 | +-- http-errors@1.6.2 | | +-- inherits@2.0.3 | | `-- setprototypeof@1.0.3 | +-- iconv-lite@0.4.19 | `-- raw-body@2.3.2 +-- content-disposition@0.5.2 +-- content-type@1.0.4 +-- cookie@0.3.1 +-- cookie-signature@1.0.6 +-- debug@2.6.9 | `-- ms@2.0.0 +-- depd@1.1.1 +-- encodeurl@1.0.1 +-- escape-html@1.0.3 +-- etag@1.8.1 +-- finalhandler@1.1.0 | `-- unpipe@1.0.0 +-- fresh@0.5.2 +-- merge-descriptors@1.0.1 +-- methods@1.1.2 +-- on-finished@2.3.0 | `-- ee-first@1.1.1 +-- parseurl@1.3.2 +-- path-to-regexp@0.1.7 +-- proxy-addr@2.0.2 | +-- forwarded@0.1.2 | `-- ipaddr.js@1.5.2 +-- qs@6.5.1 +-- range-parser@1.2.0 +-- safe-buffer@5.1.1 +-- send@0.16.1 | +-- destroy@1.0.4 | `-- mime@1.4.1 +-- serve-static@1.13.1 +-- setprototypeof@1.1.0 +-- statuses@1.3.1 +-- type-is@1.6.15 | `-- media-typer@0.3.0 +-- utils-merge@1.0.1 `-- vary@1.1.2 安装时不加-g参数则会默认安装在路径下。 配置Node.js源 node.js安装速度缓慢,因此需要更换npm的源,打开cmd使用如下命令: npm config set registry http://registry.npm.taobao.org/","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yov.oschina.io/tags/Node-js/"}]},{"title":"Java中的小问题（不断更新中）","slug":"Java/Java中的小问题(不断更新中)","date":"2017-12-23T10:47:05.360Z","updated":"2017-12-24T08:49:08.374Z","comments":true,"path":"article/Java/Java/Java中的小问题(不断更新中)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java/Java中的小问题(不断更新中)/","excerpt":"","text":"1、使用private声明main()会怎样? A: 报错,找不到main方法, 请将 main 方法定义为:public static void main(String[] args)。 2、Java中传引用和传值的区别是什么？ A：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。 3、如果要重写一个对象的equals()，还要考虑什么？ A：hashCode。 *4、Java的”一次编写，处处运行”是如何实现的？ A：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。 *5、public static void main(String args[])这段声明里每个关键字的作用 A：public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见,所以可见性设置为pulic. static: Java平台调用这个方法时不会创建这个类的实例对象，因此这个方法必须声明为static。 void: main方法没有返回值。 String是命令行传进参数的类型，args是指命令行传进的字符串数组。 *6、==与equals()的区别 A：==比较两个对象在内存里是不是同一个对象，即内存地址是否一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .==比较的是引用 而equals()比较的是内容。public boolean equals(Object obj)这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,此时和==是等价的。String, BitSet, Date, 和File都对equals()进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。 public class EqualsTest { public static void main(String[] args) { Strings1 = &quot;abc&quot;; Strings2 = s1; Strings5 = &quot;abc&quot;; Strings3 = newString(&quot;abc&quot;); Strings4 = newString(&quot;abc&quot;); System.out.println(&quot; == comparison:&quot; + (s1 == s5)); System.out.println(&quot; == comparison:&quot; + (s1 == s2)); System.out.println(&quot;Using equals method:&quot; + s1.equals(s2)); System.out.println(&quot; == comparison:&quot; + s3 == s4); System.out.println(&quot;Using equals method : &quot; + s3.equals(s4)); } } 结果： ==comparison:true ==comparison:true Usingequals method:true false Usingequals method:true 7 main()去掉static修饰符会怎样？ A：报错，main 方法不是类 com.java.demo.Demo 中的static 8、为什么oracle type4驱动被称作瘦驱动？ A：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的,可以在运行时由浏览器下载,不依赖任何客户端的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。 9、final,finally,finalize() A：final: 常量声明。 finally: 处理异常。 finalize(): 帮助进行垃圾回收。 接口里声明的变量默认是final的。final类无法继承,也就是没有子类。这么做是出于基本类型的安全考虑，比如String和Integer,这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。 finalize()在对象被销毁和回收前会被调用。 finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如,关闭连接通常放到finally块中完成。 10、什么是Java API？ A：Java API是大量软件组件的集合,它们提供了大量有用的功能,比如GUI组件。 11、GregorianCalendar类是什么东西？ A：GregorianCalendar提供了西方传统日历的支持。 12、ResourceBundle类是什么? A：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。 13、为什么Java里没有全局变量? A：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。 14、如何将String类型转化成Number类型？ A：Integer类的valueOf方法可以将String转成Number。下面是代码示例： String numString = &quot;1000&quot;; int id = Integer.valueOf(numString).intValue(); 15、SimpleTimeZone类是什么? A：SimpleTimeZone提供公历日期支持。 16、while循环和do循环有什么不同？ A：while结构在循环的开始判断下一个迭代是否应该继续。 do/while结构在循环的结尾来判断是否将继续下一轮迭代,do结构至少会执行一次循环体。 17、Locale类是什么？ A：Locale类用来根据语言环境来动态调整程序的输出。 *18、面向对象编程的原则是什么? A：多态,继承和封装。 19、简述继承性 A：继承使得一个类可以获取另一个类的属性和方法。使用继承可以让已经测试完备的功能得以复用,并且可以一次修改,所有继承的地方都同时生效。 20、什么是隐式的类型转化? A：隐式的类型转化就是直接将一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。 代码示例： int i = 1000; long j = i;//Implicit casting 21、sizeof是Java的关键字吗? A：不是。 22、native方法是什么? A：native方法是非Java代码实现的方法。 23、在System.out.println()里面,System, out, println分别是什么? A：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。 24、多态是什么？ A：简单来说,多态是指一个名字多种实现,多态使得一个实体通过一个通用的方式来实现不同的操作,具体的操作是由实际的实现来决定的。 多态在Java里有三种表现方式：方法重载通过继承实现方法重写通过Java接口进行方法重写。 25、显式的类型转化是什么? A：显式的类型转化是明确告诉了编译器来进行对象的转化。 代码示例： long i = 700.20; int j = (int)i; 26、什么是Java虚拟机? A：Java虚拟机是能移植到不同硬件平台上的软件系统。 27、类型向下转换是什么? A：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。 28、Java的访问修饰符是什么? A：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含： public: 所有类都可以访问 protected: 同一个包内以及所有子类都可以访问 private: 只有归属的类才能访问默认: 归属类及相同包下的子类可以访问 29、所有类的父类是什么？ A：Object. 30、Java的基本类型有哪些? A：byte,char, short, int, long, float, double, boolean。 31、静态类型有什么特点? A：static定义的变量与类绑定,即每个实例对象都共享同一个静态变量。不论有多少个实例对象,静态变量只有一个。static定义的变量通常使用类名访问,当程序运行时,这个变量就会被创建直到程序结束才会被销毁。静态变量的作用域与普通变量一致,初始值也是一致的。变量没被初始化时根据其数据类型会有一个默认值。 static定义的方法属于类,而不是类对象,其调用不作用于类对象,也不需要创建类实例.静态方法本身就带有final,因为重写只会发生在类实例上，即只要原方法没声明为final,非静态方法就不能重写静态方法。父类的静态方法会被子类的静态方法屏蔽，但你不能在子类把父类的静态方法改为实例方法。 32、&amp;操作符和&amp;&amp;操作符有什么区别? A：当一个&amp;表达式在求值的时候，两个操作数都会被求值。 当一个&amp;&amp;表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。 33、Java是如何处理整型的溢出和下溢的? A：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。 34、public static void写成static public void会怎样？ A：程序正常编译及运行. 35、声明变量和定义变量有什么不同？ 答案：声明变量只提供变量的类型和名字,并没有进行初始化。 定义包括声明和初始化两个阶段：String s;只是变量声明,String s = new String(&quot;bob&quot;);或者String s = &quot;bob&quot;;是变量定义。 36、Java支持哪种参数传递类型? A：Java参数都是进行传值.对于对象而言,传递的值是对象的引用,也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。 37、对象封装的原则是什么? A：封装是将数据及操作数据的代码绑定到一个独立的单元,这样保障了数据的安全,防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。 38、你怎么理解变量？ A：变量是一块命名的内存区域,以便程序进行访问。变量用来存储数据,随着程序的执行,存储的数据也可能跟着改变。 39、数值提升是什么? A：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中,byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。 40、Java的类型转化是什么? A：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的类型转换，一个是隐式的。 41、main()方法的参数里面,字符串数组的第一个参数是什么? A：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。 42、怎么判断数组是null还是为空? A：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。 43、程序中可以允许多个类同时拥有都有main方法吗? A：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。 44、静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？ A：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。 45、一个类能拥有多个main方法吗？ A：可以，但只能有一个main方法拥有以下签名： public static void main(String[] args) {} 否则程序将无法通过编译。编译器会警告你main方法已经存在。 46、简述JVM是如何工作的? A：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。 47、如何原地交换两个变量的值？ A：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下： int a = 5, b = 10; a = a + b; b = a - b; a = a - b; 使用异或操作也可以交换。第一个方法还可能会引起溢出。异或的方法如下： int a = 5;int b = 10; a=a^b; b=a^b; a=a^b; 48、什么是数据的封装? A：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。 49、什么是反射API？它是如何实现的？ A：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。 50、JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？ A：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。 51、虚拟内存是什么? A：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。 52、方法可以同时即是static又是synchronized的吗? A：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于： synchronized(XYZ.class){ } 53、String和StringTokenizer的区别是什么？ A：StringTokenizer是一个用来分割字符串的工具类。 String Tokenizerst = new StringTokenizer(&quot;Hello World&quot;); while(st.hasMoreTokens()){ System.out.println(st.nextToken()); } 输出： Hello World 54、transient变量有什么特点? A：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。 55、哪些容器使用Border布局作为它们的默认布局? A：Window, Frame, Dialog。 56、什么是同步? A：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。 对方法进行同步： public synchronized void Method1(){ // Appropriate method-related code. } 在方法内部对代码块进行同步： public myFunction() { synchronized(this){ // Synchronized code here. } } 57、问题：给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？ A： public class Test{ public static void main(String[] args) { //给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？ int a = 8; //打印二进制 System.out.println(Integer.toBinaryString(a)); //输出 1000 System.out.println(Integer.toBinaryString(a|4)); //输出 1100 } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java知识(四)","slug":"Java/Java知识(四)","date":"2017-12-23T08:17:41.083Z","updated":"2017-12-23T10:03:08.266Z","comments":true,"path":"article/Java/Java/Java知识(四)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java/Java知识(四)/","excerpt":"","text":"Java多线程实现 Java可通过以下两种方式实现多线程： · 继承Thread类； · 实现Runnable接口（此外扩充了Callable接口） 线程与进程 Java支持多线程。 1、进程指的是一次程序的完整运行，在运行过程中内存、处理器、IO等资源都是为该进程服务。 DOS系统时代，有一种现象：假如病毒运行，那电脑就无法运行，因为所有资源都被病毒占用。但在windows时代，即使病毒在运行，电脑也可以运行。 这是因为windows系统是多进程操作系统。其资源分配方法是：在同一时间段，多进程轮流抢占资源，但在某时间点，只会有一个进程在运行 2、线程是在进程基础上进一步地划分的结果：即一个进程可以同时创建多个线程。线程是比进程更快的处理单元，而且所占的资源更小。多线程的应用也是性能最高的应用。 Thread类实现多线程 1、Thread类是一个支持多线程的功能类，只要是其子类，就可以实现多线程。 class MyThread extends Thread { // 多线程操作类} 程序的起点是main()。而每个线程也有它的起点run()。多线程类必须覆写Thread类的run()：public void run(){}，该方法没有返回值，表示线程一旦开始，就需要一直运行，不能返回内容。 // 线程操作主类 class MyThread extends Thread { private String name; public MyThread(String name) { this.name = name; } @Override public void run() { // 覆写run(),作为线程的主体操作方法 for (int x = 0; x &lt; 200; x++) { System.out.println(this.name + &quot;--&gt;&quot; + x); } } } public class Demo { public static void main(String[] args) { MyThread mA = new MyThread(&quot;线程A&quot;); MyThread mB = new MyThread(&quot;线程B&quot;); MyThread mC = new MyThread(&quot;线程C&quot;); mA.run(); mB.run(); mC.run(); } } 运行上述代码，输出结果是线程A、B、C依次进行循环输出。 2、线程与进程是一样的，都必须轮流去抢占资源，多线程的执行应该是多个线程彼此交替执行。但直接调用run()并不能启用多线程，多线程启用依靠的是Thread类的start()：public void start()（调用此方法，执行的方法体是run()定义的）。 public class Demo { public static void main(String[] args) { // 主类 MyThread mtA = new MyThread(&quot;线程A&quot;); MyThread mtB = new MyThread(&quot;线程B&quot;); MyThread mtC = new MyThread(&quot;线程C&quot;); mtA.start(); mtB.start(); mtC.start(); } } 上述代码结果中每个线程对象交替执行。 问题：为什么多线程启用不是调用run()而是调用start()？ 打开Java的源代码，观察start()的定义 public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); start()利用throw抛出IllegalThreadStateException，本应使用try…catch处理，或者start()上使用throws声明，但此处没有这样处理，这是因为该异常是RuntimeException的子类，属于选择性处理。如果某一个线程重复启动，就会抛出异常。 start()要调用start0()，而且该方法结构与抽象方法类似，唯一不同的是使用native声明。Java中有一个JNI技术（Java Native Interface），其特点是：使用Java调用本机操作系统提供的函数。其缺点：不能离开特定的操作系统。 如果线程要执行，需要操作系统进行资源分配，所以此操作是由JVM根据不同的操作系统实现的。即：使用Thread类的start()不仅仅要启动多线程的执行代码，还要根据不同的操作系统进行资源的分配。 Runnable接口实现多线程 1、虽然Thread类可以实现多线程。但存在问题：Java存在单继承限制。任何情况下，对于类的单继承都是应该尽量回避的，多线程也一样。为了解决单继承的限制，在Java中专门提供了Runnable接口，此接口定义如下： @FunctionalInterface public interface Runnable{ public void run(); } 接口中都是public权限，不存在default权限。那么只需要让一个类实现Runnable接扣，并覆写run()方法即可。 class MyThread implements Runnable { private String name; public MyThread(String name) { this.name = name; } @Override public void run() { for (int x = 0; x &lt; 10; x++) { System.out.println(this.name + &quot;--&gt;&quot; + x); } } } 与继承Thread类相比，此时MyThread类在结构上并没有区别，但存在一个不同：继承Thread类，可以直接继承start()，但是实现Runnable接口，并没有start()。 2、要想启用多线程，一定依靠Thread类完成，在Thread类定义有如下构造方法： public Thread（Runnable target），接收的是Runable接口对象； 范例：启动多线程 public class Demo { public static void main(String[] args) { // 主类 MyThread mtA = new MyThread(&quot;线程A&quot;); MyThread mtB = new MyThread(&quot;线程B&quot;); MyThread mtC = new MyThread(&quot;线程C&quot;); new Thread(mtA).start(); new Thread(mtB).start(); new Thread(mtC).start(); } } 此时就避免了单继承局限，所以实际开发中使用接口是最合适的。 两种实现方式的区别 Runnable接口与Thread类相比，解决了单继承的局限，所以如果要使用，一定使用Runnable接口。 1、观察Thread类的定义 public class Thread extends Object implements Runnable Thread类实现了Runnable接口。 2、除了以上的联系外，还有一点：使用Runnable接口可以比Thread类更好地描述出数据共享这一概念。此时的数据共享指的是多个线程访问同一资源的操作。 范例：观察代码（每一个线程对象都必须通过start()启动） class MyThread extends Thread { private int ticket = 10; @Override public void run() { for (int x = 0; x &lt; 100; x++) { if (this.ticket &gt; 0) { System.out.println(&quot;卖票，ticket = &quot; + this.ticket--); } } } } public class Demo { public static void main(String[] args) { // 主类 MyThread mtA = new MyThread(); MyThread mtB = new MyThread(); MyThread mtC = new MyThread(); mtA.start(); mtB.start(); mtC.start(); } } 上述代码声明了三个MyThread对象，并且分别调用start()方法，启动线程，发现每个线程都在卖各自的十张票，此时的内存关系如下： 此时并不存在数据共享。 范例：利用Runnable实现 class MyThread implements Runnable { private int ticket = 10; @Override public void run() { for (int x = 0; x &lt; 100; x++) { if (this.ticket &gt; 0) { System.out.println(&quot;卖票，ticket = &quot; + this.ticket--); } } } } public class Demo { public static void main(String[] args) { // 主类 MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); } } 上述代码的内存分析如下： 此时也属于三个线程对象，唯一的区别是，这三个线程对象都直接占用了同一个MyThread类对象引用，即这三个线程对象都直接访问同一个数据资源。 请解释Thread与Runnable实现多线程的区别？（请解释多线程两种实现方式的区别？） 1、Thread类是Runnable接口的子类，使用Runnable接口多线程可以避免单继承局限； 2、Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚地描述数据共享的概念； Callable接口实现多继承 1、使用Runnable实现多线程可以避免单继承局限，但是Runnable中的run()不能返回操作结果。为了解该问题，Java提供了一个新的接口java.util.concurrent.Callable。 @FunctionalInterface public interface Callable&lt;V&gt;{ public V call() throws Exception; } call()执行完线程的主体功能之后可以返回一个结果，而返回类型由Callable的泛型决定。 范例：定义一个线程主体类 class MyThread implements Callable&lt;String&gt; { private int ticket = 10; @Override public String call() throws Exception { for (int x = 0; x &lt; 100; x++) { if (this.ticket &gt; 0) { System.out.println(\"卖票，ticket = \" + this.ticket--); } } return \"票已经卖光\"; } } 此时发现Thread类中没有接收Callable对象的应用。但从JDK1.5开始增加java.util.concurrent.FutureTask&lt;V&gt;类，这个类主要负责Callable接口对象的操作。这个类的结构： public class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt; 而上述的RunnableFuture结构如下： public interface RunnableFuture&lt;V&gt; extends Runnable,Future&lt;V&gt; 在FutureTask类中定义有构造方法：public FutureTask(Callable&lt;V&gt; callable)，接收的是call()的返回值。 范例：启动多线程 public class Demo { public static void main(String[] args) throws Exception { MyThread mtA = new MyThread(); MyThread mtB = new MyThread(); FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mtA); FutureTask&lt;String&gt; taskB = new FutureTask&lt;String&gt;(mtB); // 目的是取得call()的返回值 // FutureTask是Runnable接口的子类，所以可以使用Thread的构造接收 new Thread(taskA).start(); // 启动多线程 new Thread(taskB).start(); // 多线程执行完毕后，可以通过FutureTask的父接口Future中的get()方法取得返回内容 System.out.println(&quot;A线程的返回结果:&quot; + taskA.get()); System.out.println(&quot;B线程的返回结果:&quot; + taskB.get()); } } 上述代码最麻烦的地方在于需要接收返回值，并且又要与原始的多线程实现靠拢（向Thread类靠拢）。 多线程常用操作方法 多线程有许多方法，但大部分方法都定义在Thread类中，本章只介绍几种开发常用方法。 线程命名和获取线程 1、线程的每次运行结果都不同，因为其会根据实际情况进行资源抢占。因此要区分每个线程，必须依靠线程名。线程名一般是在其启动前定义。不建议更改已经启动的线程名或为不同线程设置相同的名字。 2.、对线程进行命名，可以利用Thread类的如下方法： 构造方法：public Thread(Runnable target, String name); 2）设置名字：public final void setName(String name); 3）取得名字：public final String getName(); Runable子类没有继承Thread类，要想获取线程名即获取当前执行方法的线程名需要利用Thread类中提供的取得当前线程对象的方法:public static Thread currentThread()； **范例：**不设置线程名 class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); } } public class Demo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt).start(); // Thread-0 new Thread(mt).start(); // Thread-1 new Thread(mt).start(); // Thread-2 } } 实例化Thread类对象时，如果没有为其设置名字，会自动进行编号命名Thread-x，来保证线程名字不重复。 **范例：**设置线程名 class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); } } public class Demo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, \"线程A\").start(); // 线程A new Thread(mt).start(); // Thread-0 new Thread(mt, \"线程B\").start(); // 线程B } } 3、观察下述代码 public class Demo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, \"线程A\").start(); // 线程A mt.run(); // 直接调用run()方法，结果为main } } 上述代码说明主方法就是一个线程main线程，所有在主方法上创建的线程实际上都可以将其视为子线程。上述代码也说明线程一直都存在（主方法就是主线程），每当使用java命令去解释一个程序类时，对于操作系统而言，都相当于启动了一个进程，而main只是这进程上的一个子线程而已。 **问题：**一个JVM进程启动时至少启动几个线程？ **答：**至少启用了2个线程 1.main线程：程序的主要执行，以及启动子线程； 2.gc线程：负责垃圾收集 休眠 1、线程休眠指的是让线程的执行暂时停顿，其方法：public static void sleep(longmillis) throws InterruptedException **范例：**观察休眠特点 class MyThread implements Runnable { @Override public void run() { for (int x = 0; x &lt; 10000; x++) { try { Thread.sleep(1000); // 让其休眠1秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \",x = \" + x); } } } public class Demo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, \"线程A\").start(); } } 由于每次执行run()都要休眠1秒，所以执行的速度变慢。一般情况下，休眠时设置多个线程对象将导致所有线程对象一起进入run()（所谓一起进入实际上是因为先后进入的顺序时间间隔短，肉眼忽略，但实际上不是同时进入）。 线程优先级 1、 线程优先级越高，越有可能先被执行。在Thread类中提供有以下两个方法设置和获取优先级： ​ · 设置优先级：public final void setPriority(int new Priority)； ​ · 取得优先级：public final int getPriority()； 设置和取得优先级都是使用int型数据类型，对于此内容有三种取值： ​ · 最高优先级：public static final int MAX_PRIORITY；// 值为10 ​ · 默认优先级：public static final int NORM_PRIORITY；// 值为5 ​ · 最低优先级：public static final int MIN_PRIORITY。 // 值为1 **范例：**优先级 class MyThread implements Runnable { @Override public void run() { for (int x = 0; x &lt; 20; x++) { System.out.println(Thread.currentThread().getName() + \",x = \" + x); } } } public class Demo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); Thread tA = new Thread(mt, \"线程A\"); Thread tB = new Thread(mt, \"线程B\"); Thread tC = new Thread(mt, \"线程C\"); tA.setPriority(Thread.MAX_PRIORITY); tA.start(); tB.start(); tC.start(); } } **范例：**主线程优先级 public class Demo { public static void main(String[] args) throws Exception { // 获取主线程的优先级 System.out.println(Thread.currentThread().getPriority()); // 5 } } 总结： Thread.currentThread()可以取得当前线程类对象； Thread.sleep()用于线程休眠，看起来是一起休眠，实际存在时间间隔 优先级越高的线程越有可能先执行。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java知识(三)","slug":"Java/Java知识(三)","date":"2017-12-20T01:31:23.603Z","updated":"2017-12-20T01:35:50.595Z","comments":true,"path":"article/Java/Java/Java知识(三)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java/Java知识(三)/","excerpt":"","text":"Java8特性 接口定义增强 JDK1.8之前，接口的组成只有全局变量和抽象方法。从JDK1.8开始，接口的组成增加了。 假设：现有一个接口，其子类有2W个。现在发现该接口功能不足，要增加一个方法，该方法对于所有子类而言的功能是一样的（即方法体是一样的）。此时要修改每个子类的方法，要修改2W次。 上述问题在JDK1.8中不存在，因为其允许接口中定义普通方法，但普通方法必须使用default定义。 interface Fruit { public void print(); // 接口原本定义的方法 default public void fun() { // 普通方法 System.out.println(&quot;JDK1.8&quot;); } } class Apple implements Fruit { @Override public void print() { System.out.println(&quot;苹果&quot;); } } public class Demo { public static void main(String[] args) { Fruit f = new Apple(); f.fun(); f.print(); } } 除了使用default定义方法，还可以使用static定义方法 范例：定义static方法 interface Fruit { public void print(); // 接口原本定义的方法 default public void fun() { // 普通方法 System.out.println(&quot;JDK1.8&quot;); } static void get() { System.out.println(&quot;直接由接口调用&quot;); } } class Apple implements Fruit { @Override public void print() { System.out.println(&quot;苹果&quot;); } } public class Demo { public static void main(String[] args) { Fruit f = new Apple(); f.fun(); f.print(); Fruit.get(); } } JDK1.8有个新功能：内部类访问方法参数时可以不加上final关键字。 这些新特性，完全打破了Java已有的代码组成形式。 Lamda表达式 Lamda属于函数式编程的概念，下面通过匿名内部类，来分析函数式编程的产生目的。 范例：匿名内部类 interface Fruit { public void print(); // 接口原本定义的方法 } public class Demo { public static void main(String[] args) { fun(new Fruit() { @Override public void print() { System.out.println(&quot;水果&quot;); } }); } public static void fun(Fruit fru) { fru.print(); } } 上述代码中fun()最终需要的只是输出，但是由于Java的开发结构的完整性要求，不得不在这个核心语句上嵌套更多的内容。但是该做法过于严谨复杂，在JDK1.8引入函数式编程，简化过程。 范例：使用Lamda表达式 interface Fruit { public void print(); // 接口原本定义的方法 } public class Demo { public static void main(String[] args) { fun(()-&gt; System.out.println(&quot;水果&quot;)); } public static void fun(Fruit fru) { fru.print(); } } Lamda语法有三种形式： ·(参数)-&gt;单行语句； ·(参数)-&gt;｛单行语句｝； ·(参数)-&gt;表达式； 范例：观察有参单行 interface Fruit { public void print(String str); // 接口原本定义的方法 } public class Demo { public static void main(String[] args) { // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出 fun((s) -&gt; System.out.println(s)); } public static void fun(Fruit fru) { fru.print(&quot;苹果&quot;); // 设置参数的内容 } } 范例：编写多行语句 interface Fruit { public void print(String str); // 接口原本定义的方法 } public class Demo { public static void main(String[] args) { // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出 fun((s) -&gt; { s = s.toUpperCase(); System.out.println(s); }); } public static void fun(Fruit fru) { fru.print(&quot;Hello&quot;); // 设置参数的内容 } } 范例：编写表达式 interface Fruit { public int add(int x, int y); } public class Demo { public static void main(String[] args) { // 首先要定义此表达式里面需要接收变量，单行语句直接进行输出 fun((s1, s2) -&gt; s1 + s2); } public static void fun(Fruit fru) { System.out.println(fru.add(10, 20)); } } 方法引用 对象引用的特点：不同对象可以操作同一块内容。而方法引用就是指为一个方法设置别名，相当于一个方法定义了不同的名字。 1、方法引用在Java8中一共定义了四种形式： · 引用静态方法： 类名称::static 方法名称; · 引用某个对象的方法：实例化对象::普通方法； · 引用特定类型的方法：特定类::普通方法; · 引用构造方法：类名称::new。 范例：引用静态方法 String类中的valueof()：public static String valueof(int x) package com.java.demo; /** * 只有一个方法的接口 * @param &lt;P&gt; 参数的数据类型 * @param &lt;R&gt; 返回值的数据类型 */ interface Math&lt;P, R&gt; { public R exchange(P p); } public class Demo { public static void main(String[] args) { // 覆写了exchange(),使其具有valueOf()的功能 Math&lt;Integer, String&gt; math = String::valueOf; String msg = math.exchange(10000); // 将所有的0替换成9 System.out.println(msg.replaceAll(&quot;0&quot;, &quot;9&quot;)); } } 范例：普通方法引用 String类中的toUpperCase()：public String toUpperCase() package com.java.demo; interface Math&lt;R&gt; { public R upper(); } public class Demo { public static void main(String[] args) { // 覆写了upper,使其具有toUpperCase的功能 // toUpperCase是普通方法,必须由String对象调用 // hello是String对象,代码如下 Math&lt;String&gt; math = &quot;hello&quot;::toUpperCase; String msg = math.upper(); System.out.println(msg); } } 上述例子显示，要实现方法引用，必须要有接口，且该接口只能有一个方法。为了保证该接口只有一个方法，可对其进行注解说明。 @FunctionalInterface // 此为函数式接口，只能定义一个方法 interface ITest&lt;R&gt; { public R upper(); } 2、在进行方法引用的过程中，还有一种形式的引用（这种形式需要特定类的对象支持）。一般使用“类::方法”，引用的是类中的静态方法。但是这种形式也可以引用普通方法。 例如：在String类中有一个方法：public int compareTo(String anotherString)，比较的形式是String对象1.compareTo(String对象2)，即要引用该方法，需要有两个参数。 范例：引用特定类的方法 interface IMessage&lt;P&gt; { public int compare(P p1, P p2); } public class Demo { public static void main(String[] args) { IMessage&lt;String&gt; msg = String::compareTo; System.out.println(msg.compare(&quot;A&quot;, &quot;B&quot;)); } } 与之前相比，方法引用前不需要定义对象，可以理解为将对象定义在参数上。 范例：引用构造方法 interface IMessage&lt;C&gt; { public C create(String t, double p); } class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public String toString() { return &quot;书名:&quot; + this.title + &quot;,价格：&quot; + this.price; } } public class Demo { public static void main(String[] args) { IMessage&lt;Book&gt; msg = Book::new; // 引用构造方法 // 虽然调用的是create()，实际引用了Book类的构造方法 Book book = msg.create(&quot;Java开发&quot;, 66.6); System.out.println(book); } } 对象引用是使用不同的名字，而方法引用需要一个函数接口。 内建函数式接口 1、JDK1.8中提供了一个包：java.util.function，提供有以下四个核心接口： (1)功能性接口（Function）：public interface Function&lt;T,R&gt;{public R apply(T t);} |- 此接口需要接收一个参数，并且返回一个处理结果； (2)消费型接口（Consumer）：public interface Consumer{public void accept(T t);} |- 此接口只负责接收数据（引用数据是不需要返回的），并且不返回结果； (3)供给型接口（Suplier）：public interface Supplier{public T get();} |- 此接口不接收参数，但是可以返回结果 (4)断言型接口（Predicate）：public interface Predicate{public boolean Test(T t);} |- 进行判断操作使用； 在JDK1.8中存在以上四个功能型接口，所以很少会由用户去定义新的函数式接口。 范例：函数式接口——接收参数并返回处理结果 · String类有一个方法：public boolean startsWith(String str) package com.java.demo; import java.util.function.Function; public class Demo { public static void main(String[] args) { Function&lt;String, Boolean&gt; fun = &quot;##hello&quot;::startsWith; System.out.println(fun.apply(&quot;##&quot;)); // true } } 范例：消费型接口 package com.java.demo; import java.util.function.Consumer; class MyDemo { // 此方法没有返回值，但是有参数 public void print(String str) { System.out.println(str); } } public class Demo { public static void main(String[] args) { Consumer&lt;String&gt; cons = new MyDemo()::print; cons.accept(&quot;Hello World&quot;); } } 范例：供给型接口 · 引用String类的toUpperCase()：public String toUpperCase(); package com.java.demo; import java.util.function.Supplier; public class Demo { public static void main(String[] args) { Supplier&lt;String&gt; sup = &quot;hello&quot;::toUpperCase; System.out.println(sup.get()); } } 范例：断言型接口 · String类中有equalsIgnoreCase() import java.util.function.Predicate; public class Demo { public static void main(String[] args) { Predicate&lt;String&gt; pre = &quot;hello&quot;::equalsIgnoreCase; System.out.println(pre.test(&quot;Hello&quot;)); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Java知识(二)","slug":"Java/Java知识(二)","date":"2017-12-19T01:46:40.216Z","updated":"2017-12-20T01:30:35.584Z","comments":true,"path":"article/Java/Java/Java知识(二)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java/Java知识(二)/","excerpt":"","text":"枚举 枚举简介 1、多例设计模式： 构造方法私有化，而后在类的内部提供有若干个实例化对象，并且通过static方法返回。 范例：定义一个表示颜色基色的多例 class Color { private String title; private static final Color RED = new Color(&quot;红色&quot;); private static final Color GREEN = new Color(&quot;绿色&quot;); private static final Color BLUE = new Color(&quot;蓝色&quot;); private Color(String title) { this.title = title; } public static Color getInstance(int ch) { switch (ch) { case 1: return RED; case 2: return GREEN; case 3: return BLUE; default: return null; } } public String toString() { return this.title; } } public class Demo { public static void main(String[] args) { Color red = Color.getInstance(1); System.out.println(red); } } 2005年之前，Java定义枚举采用上述方式，即多例设计解决了Java无法直接定义枚举的问题。 2、从2005年之后，Java增加了枚举的概念，使用enum关键字定义。 范例：定义枚举 enum Color { // 定义枚举类 RED, GREEN, BLUE; // 实例化对象 } public class Demo { public static void main(String[] args) { Color red = Color.RED; System.out.println(red); } } 枚举可以地替代多例设计模式。 3、Java使用enum定义枚举，相当于一个类继承了Enum类。 public abstract class Enum&lt;E extends Enum&gt; extends Object implements Comparable, Serializable Enum是一个抽象类，里面定义的构造方法如下：protected Enum(String name, int ordinal) Enum类的构造方法依然是被封装的，也属于构造方法私有化。多例设计模式的前提：构造方法私有化。 4、在Enum类中定义了两个方法： · 取得枚举的索引：public final int ordinal(); · 取得枚举的名字：public final String name(); 除了以上支持的方法外，使用enum关键字定义的枚举类还有一个values()方法，可以将枚举对象以对象数组的形式的返回。 enum Color { // 定义枚举类 RED, GREEN, BLUE; } public class Demo { public static void main(String[] args) { for (Color c : Color.values()) { System.out.println(c.ordinal() + &quot;-&quot; + c.name()); } } } 请解释enum和Enum的区别？ · enum是一个关键字，而Enum是一个抽象类； · 使用enum定义的枚举就相当于一个类继承了Enum类。 定义其它结构 1、多例设计模式可以在类中定义属性和方法等；枚举也可以，但有如下要求： · 枚举之中定义的构造方法不能使用public声明，如果没有无参构造方法，要手工调用构造传递参数； · 枚举对象必须要放在首行，随后才可以定义属性、构造方法、普通方法。 范例：扩充枚举功能 enum Color { // 定义枚举类 RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行 private String title; //属性 private Color(String title) { this.title = title; } public String toString() { return this.title; } } public class Demo { public static void main(String[] args) { for (Color c : Color.values()) { System.out.println(c); // 调用toString() } } } 此时与之前定义的多例设计模式操作方式完全相同，而且代码更加简单。 2. 枚举还可以实现接口 范例：枚举实现接口 interface Message { public String getTitle(); } enum Color implements Message { // 定义枚举类 RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;); // 对象必须要放在首行 private String title; //属性 private Color(String title) { this.title = title; } public String getTitle() { return this.title; } public String toString() { return this.title; } } public class Demo { public static void main(String[] args) { Message msg = Color.RED; System.out.println(msg.getTitle()); } } 3、枚举还可以在每个对象后面以匿名内部类的形式使用抽象方法。 范例：另一种形式的接口 interface Message { public String getTitle(); } enum Color implements Message { // 定义枚举类 RED(&quot;红色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }, GREEN(&quot;绿色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }, BLUE(&quot;蓝色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }; // 对象必须要放在首行 private String title; //属性 private Color(String title) { this.title = title; } public String getTitle() { return this.title; } public String toString() { return this.title; } } public class Demo { public static void main(String[] args) { Message msg = Color.RED; System.out.println(msg.getTitle()); } } 4、枚举中还能直接定义抽象方法，此时每一个枚举对象必须分别覆写抽象方法。 范例：定义抽象方法并覆写 enum Color { // 定义枚举类 RED(&quot;红色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }, GREEN(&quot;绿色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }, BLUE(&quot;蓝色&quot;) { public String getTitle() { return &quot;自己的&quot; + this; } }; // 对象必须要放在首行 private String title; //属性 private Color(String title) { this.title = title; } public String toString() { return this.title; } public abstract String getTitle(); } public class Demo { public static void main(String[] args) { System.out.println(Color.RED.getTitle()); } } 枚举应用 1、枚举应用于switch。 public class Demo { public static void main(String[] args) { Color c =Color.RED; switch (c){ // 枚举判断 case RED: System.out.println(&quot;这是红色&quot;); break; case GREEN: System.out.println(&quot;这是绿色&quot;); break; case BULE: System.out.println(&quot;这是蓝色&quot;); break; } } } 范例：利用枚举编写一个程序： enum Sex { MALE(&quot;男&quot;), FEMALE(&quot;女&quot;); private String title; private Sex(String title){ this.title = title; } public String toString(){ return this.title; } } class Person{ private String name; private int age; private Sex sex; public Person(String name,int age,Sex sex) { this.name = name; this.age = age; this.sex = sex; } public String toString(){ return &quot;姓名:&quot; + this.name + &quot;,年龄:&quot; + this.age + &quot;,性别:&quot; + this.sex; } } public class Demo { public static void main(String[] args) { System.out.println(new Person(&quot;张三&quot;, 24, Sex.FEMALE)); } } Annotation 软件开发经历了三个阶段： （1）与配置相关的代码写在程序中； （2）配置与程序代码独立，即程序运行时根据配置文件操作；但会造成配置文件过多时，查错困难； （3）配置信息对用户而言无用，而且错误的修改还会导致程序异常。因此将配置信息写回到程序中，但利用一些明显的标记来区分配置信息与程序。 Annotation简介 Annotation是JDK1.5最大的特色，利用注解的形式来实现程序的不同功能。在Java SE中支持自定义Annotation的开发，并且提供了三个最为常用的基础Annotation：@Override、@Deprecated、@SuppressWarnings。 准确覆写 如果在输出对象时，希望其可以返回需要的内容，就必须覆写toString()。 在覆写方法时，可能由于写错方法名等错误，导致未进行覆写，并且这种错误在编译时，并不能被发现。所以为了告诉编译器toString()是覆写的方法，应该加上@Override。 过期声明 假设现在有工具包，其中有一个Demo类，类中有一个fun()。在项目最初阶段，fun()非常适用。但随着技术提升，fun()显得功能不足，此时开发者有两个选择： · 1. 直接在新版本的工具包里删除fun()，同时给出新的fun2()； · 2. 在新版本的开发包里保存fun()，但是通过某种途径告诉开发者，这个方法有问题，同时提供fun2()供开发者使用。 明显，第二种选择比较合适，可以兼顾已使用fun()的项目。这时，就可以使用@Deprecated声明。 范例：声明过期操作 class Book{ @Deprecated public void fun(){} } public class Demo { public static void main(String[] args) { Book bk = new Book(); bk.fun(); } } 利用此操作可以很好地实现方法功能的新旧交替。 压制警告 可以压制多个警告（warning） class Book&lt;T&gt;{ private T title; public void setTitle(T title){ this.title = title; } } public class Demo { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { Book bk = new Book(); bk.setTitle(&quot;Hello&quot;); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"MySQL避免乱码","slug":"MySQL避免乱码","date":"2017-12-13T01:21:07.855Z","updated":"2017-12-16T06:44:05.112Z","comments":true,"path":"article/工具/MySQL避免乱码/","link":"","permalink":"http://yov.oschina.io/article/工具/MySQL避免乱码/","excerpt":"","text":"编码简介 （1）ASCII码，占7bit，由128个字符组成，包括大小写字母、数字0-9、标点符号、非打印字符（换行符、制表符等4个）以及控制字符（退格、响铃等）组成； （2）latin1，占1byte，在ASCII基础上，增加128 ～ 255区间的字符； （3）GB2312等CJK字符集，可变长字符集，最多占2bytes，用于存储常见的CJK字符； （4）UTF8，可变长字符集，最多占3bytes，可以囊括ASCII、CJK及其他绝大多数常用语言文字；这中间其实还有个UNICODE字符集，它也是2bytes的，也能囊括ASCII字符，但即便是ASCII字符也需要消耗2bytes，存在一定浪费，而用UTF8存储ASCII字符时，实际只需要1byte，更为节省存储空间； （5）UTF8MB4，可变长字符集，最多占4bytes，可以包含上面其他几种字符集；同样地，以UTF8MB4存储ASCII字符时，实际上也是只占用1bytes，存储一般的汉字占用3bytes，而存储个别汉字则需要4bytes，存储emoji也至少需要4bytes； MySQL采用UTF8MB4字符集时,存储文本实际消耗字节数是由文本内容的字节数决定的,并非总是需要4字节,列举几种情况： 输入字符集任意，且存储ASCII字符时，每个字符需要1byte； 输入字符集是GB2312，且存储的字符是汉字时，每个字符需要2bytes； 输入字符集是UTF8/UTF8MB4，且存储的字符是低编码汉字时，每个字符需要3bytes； 输入字符集是UTF8/UTF8MB4，且存储的字符是高编码汉字时，每个字符需要4bytes； 输入字符集是binary，且存储的字符是高编码汉字时，每个字符需要4bytes； 表字符集由UTF8直接转换成UTF8MB4的方法 1、只修改字符集（使用默认校验集） mysql&gt; alter table t1 convert to character set utf8mb4 2、同时修改表字符集和校验集 mysql&gt; alter table t1 convert to character set utf8mb4 collate utf8mb4_bin; 3、只修改某列的字符集 mysql&gt; alter table t1 modify c1 varchar(20) character set utf8mb4 not null default ‘’ 4、同时修改某列的字符集和校验集 mysql&gt; alter table t1 modify c1 varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci not null default ‘’ MySQL端字符集 character_set_server：server端默认字符集； character_set_database：database默认字符集，若未设定，则和 character_set_server 的设定一样；database中的数据表/stored procedure/stored function 也可以自行设定字符集，若未指定，则和 character_set_database的设置一样；数据表中的字符类型列，也可以单独设定字符集，若未设定，则和该表指定的字符集一样； character_set_client：客户端显示读取结果的字符集； character_set_connection：客户端从server端读取数据时传输字符集； character_set_results：server端将数据发送给客户端时的字符集； MySQL涉及到字符集的设置实在太多，因此强烈建议各个环节全部采用同一种字符集，避免出现意外状况。 总结建议 (1)从前端到后端（浏览器=&gt;WEB Server=&gt;MySQL连接层=&gt;Server层=&gt;DB层&gt;TABLE层）,尽可能使用同一种字符集； (2)尽可能采用大字符集，也就是优先级：UTF8Mb4 &gt; UTF8 &gt; GBK &gt; LATIN1; (3)采用逻辑备份数据时，切记要不定期进行恢复测试.","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java知识(一)","slug":"Java/Java知识(一)","date":"2017-12-06T06:31:22.456Z","updated":"2017-12-11T03:06:49.094Z","comments":true,"path":"article/Java/Java/Java知识(一)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java/Java知识(一)/","excerpt":"","text":"Java5特性 可变参数 要求：定义一个方法，可以接收多个整型数据的相加。 范例：用数组解决该问题 public class Demo { public static void main(String[] args) { System.out.println(add(new int[]{1, 2, 3})); System.out.println(add(new int[]{1, 2})); } // 实现任意多个整型数据的相加 // 因为有多个数据，所以用数组接收 // return 累加的结果 public static int add(int[] data) { int sum = 0; for (int x = 0; x &lt; data.length; x++) { sum += data[x]; } return sum; } } 使用数组是因为方法的参数个数是固定的，无法接收随机个参数。但通过数组接收参数不符合预期，理想的调用形式：add(1,2,3),add(10,20); 该功能从JDK1.5后实现，它主要是在方法上使用，定义形式： [public | protected | private] [static] [final] [abstract] 返回值类型 方法名称(数据类型 ... 变量){ [return [返回值] ;] } 上述代码中，[]中的内容可以忽略。上述形式中的参数不再是一个内容，而是多个内容，尽管参数的定义形式变了，但是参数的访问却没变，即进行参数访问的时候按照数组的形式操作。 public class Demo { public static void main (String [] args){ // 可变参数支持数组 System.out.println(add(new int[] {1,2,3}));// 传递3个整型数据 // 可变参数支持参数 System.out.println(add(1,2,3));// 传递3个整型数据 System.out.println(add(10,20));// 传递2个整型数据 System.out.println(add());// 不传递数据 } // 实现任意多个整型数据的相加操作 // 由于要接收多个整型数据，所以要用数组完成接收 // return 多个整型数据的累加结果 public static int add(int ... data){ int sum = 0 ; for (int x = 0 ; x &lt; data.length ; x ++){ sum += data[x] ; } return sum; } } 在大部分开发中，应该要求参数的个数是准确的，因此可变参数多用于一些程序相关系统类的设计使用上，而不是开发中。可变参数属于数组的变形应用。 foreach循环 foreach的功能是进行数组或者是集合数据的输出。语法如下： for(类型 变量 : 数组 | 集合) { // 每一次循环会自动将数组内容设置给变量 } 范例：for循环输出 public class Demo { public static void main (String [] args){ int data [] = new int[] {1,2,3,4,5,6}; for (int x = 0 ; x &lt; data.length ; x ++){ System.out.println(data[x]) ; } } } 范例：foreach输出 public class Demo { public static void main (String [] args){ int data [] = new int[] {1,2,3,4,5,6}; for (int x : data) { // 循环次数由数组长度决定 // 每一次循环都表示数组的脚标增长，会取得每个数组的内容，并将其设置给了x System.out.println(x); } } } 静态导入 假设一个类中定义的方法都是static方法，那么其他类引用此类时必须用“类名称.方法（）”进行调用。 范例： package com.java.util; public class MyMath { public static int add(int x, int y) { return x + y; } public static int div(int x, int y) { return x / y; } } 此时MyMath中方法都是static方法，随后在其它类中使用这些方法。 范例：基本使用形式 package com.java.demo; import com.java.util.MyMath; public class Demo { public static void main(String [] args) { System.out.println(&quot;加法操作：&quot; + MyMath.add(10,20)); System.out.println(&quot;加法操作：&quot; + MyMath.div(20,10)); } } 范例：静态导入 package com.java.demo; // 将MyMath类中的全部static方法导入，这些方法就好比直接定义在了main方法中 import static com.java.util.MyMath.* ; public class Demo { public static void main(String [] args) { System.out.println(&quot;加法操作：&quot; + add(10,20)); System.out.println(&quot;加法操作：&quot; + div(20,10)); } } 泛型 问题引出 1、要求：定义一个表示坐标的类（Point），该类要保存以下几种坐标： · 整数：x = 10、y = 20； · 小数：x = 10.2、y = 20.3； · 字符串：x = 东经20度、y = 北纬15度。 Poin类的设计关键在于x和y的类型。必须有一种类型可以保存这三类数据，首先想到的是Object类型： · int：int自动装箱为Integer，Integer向上转型为Object； · double：double自动装箱为Double，Double向上转型为Object； · String：直接向上转型为Object； 范例：设计如下 class Point{ // 定义坐标类 private Object x; private Object y; public Object getX() { return x; } public void setX(Object x) { this.x = x; } public Object getY() { return y; } public void setY(Object y) { this.y = y; } } 范例：测试上述代码 public class Demo { public static void main(String[] args) { // 1. 设置数据 Point pA = new Point(); pA.setX(10); pA.setY(20); // 2. 取出数据 int x = (Integer) pA.getX(); int y = (Integer) pA.getY(); System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;); } } 上述代码利用Object数据类型解决了问题，但依然可能有一定问题。 范例：错误代码： public class Demo { public static void main(String[] args) { // 1. 设置数据 Point pA = new Point(); pA.setX(&quot;东经10度&quot;); pA.setY(10); // 2. 取出数据 String x = (String) pA.getX(); String y = (String) pA.getY(); System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;); } } 上述问题产生的原因是因为设置时存放的是int(Integer),而取出时是String。两个没有任何关系的类对象之间发生强制转换，会出现java.lang.ClassCastException错误。 2、向上转型是为了统一参数，向下转型是为了调用子类定义的特殊功能。向下转型是一种不安全的操作，那么这操作应该在代码运行前排查出来。从JDK1.5增加了泛型，泛型的核心作用在于：类在定义的时候，可以使用一个标记，此标记动态表示类中属性或方法参数的类型，使用时设置具体类型。 // T在Point类定义上只表示一个标记，使用时需要为其设置具体的类型 class Point&lt;T&gt; { // 定义坐标,Type = T private T x; // 该属性类型未知，由Point动态设置 private T y; // 该属性类型未知，由Point动态设置 public T getX() { return x; } public void setX(T x) { this.x = x; } public T getY() { return y; } public void setY(T y) { this.y = y; } } 在使用Point类时，才设置标记的类型，即设置类中属性的类型。 范例：设置为String public class Demo { public static void main(String[] args) { // 1. 设置数据 Point&lt;String&gt; pA = new Point(); pA.setX(&quot;东经10度&quot;); pA.setY(&quot;北纬20度&quot;); // 此时Point类的类型为String，不需要向下转型 // 2. 取出数据 String x = pA.getX(); String y = pA.getY(); System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;); } } 3、使用泛型后，类中属性的类型都是动态设置的，这样避免了向下转型的问题。但是泛型只能用于类，即不能用于基本数据类型，只能是引用类型（例如，不能用&lt;int&gt;，只能用&lt;Integer&gt;） public class Demo { public static void main(String[] args) { // 1. 设置数据 Point&lt;Integer&gt; pA = new Point(); pA.setX(10); pA.setY(20); // 利用包装类的自动装箱和自动拆箱 // 2. 取出数据 int x = pA.getX(); int y = pA.getY(); System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;); } } 4、对于泛型有两点说明： · 使用泛型类或接口时，没有设置接口的具体类型会出现编译警告，为了保证程序不出错，将默认使用Object表示。 public class Demo { public static void main(String[] args) { // 1. 设置数据 Point pA = new Point(); // 将使用Object描述泛型 pA.setX(10); pA.setY(20); // 2. 取出数据,需要转型 int x = (Integer) pA.getX(); int y = (Integer) pA.getY(); System.out.println(&quot;(&quot; + x + &quot; , &quot; + y + &quot;)&quot;); } } · JDK1.7开始，可以简化泛型声明 Point&lt;Integer&gt; pA = new Point(); 即实例化时只要在前面声明一个泛型的具体类型。 通配符 范例：观察下述程序 class Message&lt;T&gt; { private T msg; public void setMsg(T msg) { this.msg = msg; } public T getMsg() { return msg; } } public class Demo { public static void main(String[] args) { Message&lt;String&gt; m = new Message&lt;String&gt;(); m.setMsg(&quot;Hello&quot;); fun(m); // 引用传递 } public static void fun(Message&lt;String&gt; temp) { System.out.println(temp.getMsg()); } } 上述代码为Message类设置String型的泛型，但是此时设置其他类型时，fun()中的Message就不能使用了，并且fun()不能针对不同的泛型进行重载，因为方法重载只认得参数类型，无法辨别泛型的不同。 解决方法一：不设置方法参数的泛型 public class Demo { public static void main(String[] args) { Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;(); Message&lt;String&gt; mB = new Message&lt;String&gt;(); mA.setMsg(100); mB.setMsg(&quot;Hello&quot;); fun(mA); // 引用传递 fun(mB); } public static void fun(Message temp) { System.out.println(temp.getMsg()); } } 此时fun()存在警告，因为不设置具体泛型，就会存在警告。并且存在下述问题： public class Demo { public static void main(String[] args) { Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;(); mA.setMsg(100); fun(mA); // 引用传递 } public static void fun(Message temp) { // 不设置泛型，默认为Object型 temp.setMsg(&quot;Hello&quot;); // 设置Striing型 System.out.println(temp.getMsg()); } } 1、上述代码说明，需要一种方式可以接收任意的泛型类型，但是不可以修改，只能取出。就可以使用?来描述 public class Demo { public static void main(String[] args) throws Exception { Message&lt;Integer&gt; num = new Message&lt;&gt;(); num.setMsg(100); fun(num); } public static void fun (Message&lt;?&gt; tmp) { //tmp.setMsg(&quot;String&quot;); 报错,无法应用 System.out.println(tmp.getMsg()); } } 在?通配符基础上还有两个子通配符： · ?extends 类：设置泛型上限，可以在声明上和方法参数上使用； |- ?extends Number：意味着可以设置Number或者Number的子类(Integer，Double等) · ?super 类：设置泛型下限，方法参数使用； |-?super String：意味着只能设置String或者它的父类Object. 范例：设置泛型上限 class Message&lt;T extends Number&gt; { private T msg; public void setMsg(T msg) { this.msg = msg; } public T getMsg() { return msg; } } public class Demo { public static void main(String[] args) { Message&lt;Integer&gt; mA = new Message&lt;Integer&gt;(); mA.setMsg(100); fun(mA); // 引用传递 } public static void fun(Message&lt;? extends Number&gt; temp) { System.out.println(temp.getMsg()); } } 范例：将Integer改为String Message&lt;String&gt; mA = new Message&lt;String&gt;(); 此时设置为非Number或其子类，那就会出现语法错误。 范例：设置泛型下限 class Message&lt;T&gt; { private T msg; public void setMsg(T msg) { this.msg = msg; } public T getMsg() { return msg; } } public class Demo { public static void main(String[] args) { Message&lt;String&gt; mA = new Message&lt;String&gt;(); mA.setMsg(&quot;Hello&quot;); fun(mA); // 引用传递 } public static void fun(Message&lt;? super String&gt; temp) { System.out.println(temp.getMsg()); } } 泛型接口 1、泛型可以在接口上声明，这样的接口称为泛型接口。 范例：定义泛型接口 // 如果是接口在前面加“I”，例如：IMessage; // 如果是抽象类前面加Abstract,例如:AbstractMessage // 如果是普通类直接写，例如：Message interface IMessage&lt;T&gt; { // 设置泛型接口 public void print(T t); } 2、接口必须定义其相应的子类，定义子类有两种形式： 形式一：在子类继续设置泛型 // 子类也继续使用泛型，接口使用和子类一样的泛型标记 class Message&lt;T&gt; implements IMessage&lt;T&gt; { public void print(T t) { System.out.println(t); } } public class Demo { public static void main(String[] args) { IMessage&lt;String&gt; msg = new Message&lt;String&gt;(); msg.print(&quot;Hello&quot;); } } 形式二：在子类不设置泛型，但为接口明确定义一个泛型 class Message implements IMessage&lt;String&gt; { public void print(String t) { System.out.println(t); } } public class Demo { public static void main(String[] args) { IMessage&lt;String&gt; msg = new Message(); msg.print(&quot;Hello&quot;); } } 泛型方法 泛型方法也可以定义在普通类中。 范例：泛型方法定义 public class Demo { public static void main(String[] args) { String str = fun(&quot;Hello&quot;); System.out.println(str.length()); } // T的类型由传入的参数类型决定 public static &lt;T&gt; T fun(T t) { return t; } } 总结： 1、泛型解决的是向下转型所带来的安全隐患，其核心是在声明类或接口时不设置参数或属性的类型； 2、“?”可以接收任意的泛型类型，只能取出，不能修改泛型","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"}]},{"title":"Eclipse使用","slug":"Tool/Eclipse使用","date":"2017-12-05T07:01:25.864Z","updated":"2017-12-05T07:05:25.084Z","comments":true,"path":"article/工具/Tool/Eclipse使用/","link":"","permalink":"http://yov.oschina.io/article/工具/Tool/Eclipse使用/","excerpt":"","text":"Eclipse简介 Eclipse是一款Java开发IDE，是免费的绿色版本软件，不需要安装，直接解压缩。Eclipse包含以下几个部分：JDT、JUNIT、CVS客户端、插件开发、GIT客户端。 JDT使用 JDT是Eclipse中进行Java程序开发的基础工具。 Eclipse中项目建立完成后，会在项目的文件目录下生成两个子目录： · src：保存所有的.java源文件； · bin：保存所有的.class文件； Eclipse最大特点在于代码生成功能。 1、Eclipse中最常用的快捷键： ·Alt + / ：进行代码提示； ·Ctrl + 1：为错误的代码给出纠正方案； ·Ctrl + Shift + O：组织导入，导入其它包的类； ·Ctrl + D：删除当前行代码； ·Ctrl + Alt + ↓：删除当前行代码； ·Ctrl + /：使用单行注释； ·Ctrl + H：强力搜索； ·Ctrl + Shift + L：全部快捷键列表； 2、Eclipse中有debug（代码跟踪调试）功能，设置好断点之后，采用调试的方式运行程序。 进入到调试视图后，Eclipse将等待用户的操作指令，并且在设置断点处停止执行，调试方式有如下几个： · 单步进入【F5】：指的是进入到执行的方法之中观察方法的执行效果； · 单步跳过【F6】：在当前代码的表面上执行； · 单步返回【F7】：不再观察了，返回进入处； · 恢复执行【F8】：停止调试，直接正常执行完毕； 在调试过程之中可以清楚地知道方法中所有变量的数值的变化情况。 Junit测试工具 junit是一个测试工具。对于软件测试分为两种： ·黑盒测试：针对功能测试，看不见代码 ·白盒测试：针对性能测试，算法的调整 除了上述两种测试，还有一类测试----用例测试（UseCase测试工程师），junit是一个use case测试工具，但是其使用不麻烦。","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十七)","slug":"Java Base/Java基础知识(十七)","date":"2017-12-04T06:59:17.310Z","updated":"2017-12-04T07:27:48.777Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十七)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十七)/","excerpt":"","text":"异常捕获及处理 合理使用异常处理，可以让程序更加健壮。 异常的产生 异常是导致程序中断执行的一种指令流。当异常出现时，如果没有合理处理，程序就会中断执行。 范例：不产生异常的代码 public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 2)); System.out.println(&quot;3.除法计算结束&quot;); } } 范例：产生异常 public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); // 2.中将出现异常 System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0)); System.out.println(&quot;3.除法计算结束&quot;); } } // 结果为： // 1.除法计算开始 // Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero // at com.java.util.Demo.main(Demo.java:7) 异常产生后，产生异常的语句以及之后的语句将不再执行。默认情况下系统会输出异常信息，而后自动结束程序的执行。 异常的处理 1、Java中进行处理异常，使用try、catch、finally这三个关键字，语法如下： try { // 可能出现异常的语句 } catch (异常类型 对象1) { // 异常处理 } catch (异常类型 对象2) { // 异常处理 } finally { // 不论是否出现异常都执行的语句 } 对于上述操作的组合有：try…catch、try…catch…finally、try…finally(这个不建议使用)。 范例：应用异常处理格式 public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0)); } catch (ArithmeticException e) { } System.out.println(&quot;3.除法计算结束&quot;); } } // 结果为： // 1.除法计算开始 // 3.除法计算结束 2、出现异常就要处理异常，为了能进行异常处理，可以使用异常类中的printStackTrace()输出完整的异常信息： public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0)); } catch (ArithmeticException e) { e.printStackTrace(); } System.out.println(&quot;3.除法计算结束&quot;); } } // 结果为： // 1.除法计算开始 // java.lang.ArithmeticException: / by zero // at com.java.util.Demo.main(Demo.java:7) // 3.除法计算结束 范例：使用try…catch…finally public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { System.out.println(&quot;2.出发计算：10 / 2 = &quot; + (10 / 0)); } catch (ArithmeticException e) { e.printStackTrace(); } finally { System.out.println(&quot;不论是否异常，都执行&quot;); } System.out.println(&quot;3.除法计算结束&quot;); } } 3、异常捕获时，一个try语句可以跟多个catch语句。 public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { int x = Integer.parseInt(args[0]); int y = Integer.parseInt(args[1]); System.out.println(&quot;2.出发计算：&quot; + (x / y)); } catch (ArithmeticException e) { e.printStackTrace(); } finally { System.out.println(&quot;不论是否异常，都执行&quot;); } System.out.println(&quot;3.除法计算结束&quot;); } } 上述程序将由用户输入数据，可能存在以下异常： · 用户执行时不输入参数（java Demo）：java.lang.ArrayIndexOutOfBoundsException数组越界错误； · 输入的数据不是数字（java Demo a b）：java.lang.NumberFormatException； · 被除数为0（java Demo 10 0）：java.lang.ArithmeticException 以上代码只有一个catch，只能处理一个异常，其他异常依然会导致程序中断 范例：增加多个catch public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { int x = Integer.parseInt(args[0]); int y = Integer.parseInt(args[1]); System.out.println(&quot;2.出发计算：&quot; + (x / y)); } catch (ArithmeticException e) { e.printStackTrace(); } catch (NumberFormatException e) { e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { e.printStackTrace(); } finally { System.out.println(&quot;不论是否异常，都执行&quot;); } System.out.println(&quot;3.除法计算结束&quot;); } } 异常处理流程 1、观察两个异常类的继承结构： NumberFormatException： java.lang.Object |- java.lang.Throwable |- Exception |- RuntimeException |- IllegalArgumentException |- NumberFormatException ArithmeticException： java.lang.Object |-java.lang.Throwable |- Exception |- RuntimeException |- ArithmeticException 由上表可得，所有异常类都是Throwable的子类。Throwable下有两个子类Error和Exception。 请解释Error和Exception的区别： · Error：指的是JVM错误，即：此时程序还没有执行，用户不能处理； · Exception：指的是程序运行中产生的异常，用户可以处理。 所谓的异常处理指的是Exception以及它的子类异常。 2、异常处理流程图 流程描述： 1）当程序运行时出现异常，由JVM自动根据异常类型实例化一个与之类型匹配的异常类对象； 2）产生异常对象后，会判断当前语句是否存在异常处理。如果没有异常处理，就交给JVM进行默认的异常处理（输出异常信息，结束程序调用）； 3）如果有异常捕获操作，会由try语句捕获产生的异常类实例化对象，之后与catch语句进行比较，如果有符合的捕获类型，则使用catch语句进行异常处理；如果不匹配，则继续向下匹配其它catch语句； 4）不论异常处理是否能够匹配，都要继续执行，如果程序中存在finally语句，就先执行finally语句中的代码，执行完毕后根据之前catch匹配结果来决定如何执行，如果之前成功捕获异常，那就继续执行finally之后的语句；如果没有成功捕获，就交给JVM进行默认处理。 整个过程和catch中的异常类型进行匹配，但是所有Java对象都可以自动向上转型。即如果真的要匹配类型，简单的做法就是匹配Exception。 public class Demo { public static void main(String[] args) { System.out.println(&quot;1.除法计算开始&quot;); try { int x = Integer.parseInt(args[0]); int y = Integer.parseInt(args[1]); System.out.println(&quot;2.出发计算：&quot; + (x / y)); } catch (Exception e) { e.printStackTrace(); } finally { System.out.println(&quot;不论是否异常，都执行&quot;); } System.out.println(&quot;3.除法计算结束&quot;); } } 上述将所有的异常都交由Exception类处理，因此程序无法知道具体产生的是什么异常。 说明： · 使用多个catch时，范围大的异常一定要放在范围小的异常后面，否则会出现语法错误。 · 直接捕获Exception比较方便，但不合理，因为所有异常都按照同种方式处理。项目中应根据具体异常类型处理。 throws关键字 1、throws关键字主要用于方法声明，将异常交由被调用处（如main方法）处理。 范例：使用throws关键字 class MyMath { public static int div(int x, int y) throws Exception { // 使用了throws,所以该方法产生的异常交由调用处处理 return x / y; } } 范例：调用上述方法 public class Demo { public static void main(String[] args) { // 必须进行异常处理，否则代码报错 try { System.out.println(MyMath.div(10, 2)); } catch (Exception e) { e.printStackTrace(); } } } 调用了具有throws声明的方法，不论操作是否异常，都需要使用try..catch进行异常处理。 2.在主方法使用throws关键字后，异常将交给JVM处理，即采用默认处理方式。由于开发的程序多数希望正常结束调用，因此主方法不应该使用throws关键字。 public class Demo { public static void main(String[] args) throws Exception { System.out.println(MyMath.div(10, 0)); } } throw关键字 1、程序中可以使用throw手工抛出一个异常类的对象。 public class Demo { public static void main(String[] args) { try { throw new Exception(&quot;自定义异常&quot;); } catch (Exception e) { e.printStackTrace(); } } } throws与throw的区别： ·throw：在方法中手工抛出一个异常类对象（该对象可以是自定义的，或者已经存在的）； ·throws：用于方法声明上，使得调用该方法时必须处理异常。 异常处理标准格式 要求：定义div()，在执行除法前打印提示信息，在计算结束后打印提示信息；如果计算中产生了异常，交给调用处处理。 范例： class MyMath { public static void div(int x, int y) { System.out.println(&quot;==== 除法计算开始 ====&quot;); System.out.println(x / y); System.out.println(&quot;==== 除法计算结束 ====&quot;); } } public class Demo { public static void main(String[] args) { MyMath.div(10,2); } } 上述代码可能出现异常，因此要进行异常处理。根据要求，异常交由调用处处理，因此使用throws关键字。 class MyMath { // 如果div()出现异常，异常交给调用处处理 public static void div(int x, int y) throws Exception { System.out.println(&quot;==== 除法计算开始 ====&quot;); System.out.println(x / y); System.out.println(&quot;==== 除法计算结束 ====&quot;); } } public class Demo { public static void main(String[] args) { try { MyMath.div(10, 2); } catch (Exception e) { e.printStackTrace(); } } } 上述代码产生错误后，程序运行到System.out.println(&quot;==== 除法计算结束 ====&quot;);就不执行了。 范例：正确做法如下： class MyMath { // 如果div()出现异常，异常交给调用处处理 public static void div(int x, int y) throws Exception { System.out.println(&quot;==== 除法计算开始 ====&quot;); try { System.out.println(x / y); } catch (Exception e) { throw e; // 抛出异常 } finally { System.out.println(&quot;==== 除法计算结束 ====&quot;); } } } public class Demo { public static void main(String[] args) { try { MyMath.div(10, 0); } catch (Exception e) { e.printStackTrace(); } } } RuntimeException类 范例：观察下述程序 public class Demo { public static void main(String[] args) { int temp = Integer.parseInt(&quot;100&quot;); } } parseInt()： public static int parseInt(String s) throws NumberFormatException; parseInt()抛出了NumberFormatException，按照之前知识点，此处应强制进行异常捕获，但实际并没有该要求： 观察一下NumberFormatException的继承结构: java.lang.Object |- java.lang.Throwable |- java.lang.Exception |- java.lang.RuntimeException → 运行时异常 |- java.lang.IllegalArgumentException |- java.lang.NumberFormatException Java为方便代码编写，提供了RuntimeException类，该类的特征是：程序在编译时，不会强制性要求用户处理异常，用户可以根据自己的需求选择性处理，但是没有处理又发生异常，就会交给JVM默认处理。 请解释Exception与RuntimeException的区别，请列举常见的几种RuntimeException · Exception是RuntimeExceptio的父类； · 使用Exception定义的异常必须要被处理，而RuntimeException的异常可以选择性处理。 ·常见的RuntimeException：ArithmeticException、NullPointerException、ClassCastException。 异常的捕获及处理（断言） assert关键字在JDK1.4引入，其功能是进行断言。 public class Demo { public static void main(String[] args) { int num = 10; assert num == 20 : &quot;num 不等于20&quot;; System.out.println(&quot;num = &quot; + num); } } 默认情况下，断言是不应该影响程序的运行，即Java在解释程序时，断言是默认不起作用的。 启用断言：java -ea Demo Exception in thread &quot;main&quot; java.lang.AssertionError: num的内容不是20 at Demo.main(Demo.java:6) 异常的捕获及处理（自定义异常） Java自身提供了大量的异常类，但对于实际开发是不够。例如：进行添加数据操作时，可能出现错误数据，错误数据出现就应该抛出异常，例如AddException，而该异常Java没有，需要自己开发。 如果要自己开发一个异常类可以选择继承Exception或RuntimeException。 范例：定义AddException class AddException extends Exception { public AddException(String msg) { super(msg); } } public class Demo { public static void main(String[] args) { int num = 11; try { if (num &gt; 10) { throw new AddException(&quot;数值传递过大&quot;); } } catch (Exception e) { e.printStackTrace(); } } } 上述代码，只是介绍自定义异常的形式，不能说明自定义异常的作用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十六)","slug":"Java Base/Java基础知识(十六)","date":"2017-11-22T02:16:01.974Z","updated":"2017-11-22T07:04:37.775Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十六)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十六)/","excerpt":"","text":"访问控制权限 访问控制权限 Java有四种访问控制权限：public,protected,default,private。 No. 范围 public protected default private 1 在同一个类中 √ √ √ √ 2 在同一包的不同类 √ √ √ 3 在不同包的子类 √ √ 4 在不同包的非子类 √ protected权限与包的定义有关。 范例：定义com.java.demoA.A类 package com.java.demoa; public class A { protected String info = &quot;Hello&quot;; } 范例：定义com.java.demoB.B类 package com.java.demoB; import com.java.demoa.A; public class B extends A { // 与A处于不同包中 public void print() { System.out.println(&quot;A中的info：&quot; + super.info); } } 范例：测试 package com.java.test; import com.java.demoB.B; public class Test { public static void main(String[] args) { new B().print(); // A中的info：Hello } } 范例：由Test类直接输出A类中的属性 package com.java.test; import com.java.demoa.A; public class Test { public static void main(String[] args) { System.out.println(new A().info); // 报错，无法访问info } } 由于Test与A不在同一个包，并且没有继承关系，所以是无法访问protected权限。 总结： 1.Java的封装性是以private、protected、default三种权限为主； 2.对于权限的选择，建议如下： ·声明属性就用private； ·声明方法就用public； 3.关于命名要求： · 类名称每个单词的首字母大写，其余字母小写，例如：StudentInfo； · 属性名称第一个单词字母小写，而后每个单词首字母大写，例如：studentName； · 方法名称第一个单词字母小写，而后每个单词首字母大写，例如：toString()； · 常量名全部大写，例如：MSG； · 包名全部小写，例如：com.java.demo 单例设计模式 （1）正常情况下，类只有产生实例化对象后才能操作这个类。 范例：观察程序 package com.java.demo; class Singleton{ public void print() { System.out.println(&quot;Hello World!&quot;); } } public class Demo { public static void main(String[] args) { Singleton singleton = new Singleton(); // 生成实例化对象 singleton.print(); } } Singleton类中存在构造方法，没有自定义构造方法时系统会自动生成一个无参无返回值操作的构造方法，即：一个类至少存在一个构造方法。 范例：修改Singleton类定义 package com.java.demo; class Singleton{ private Singleton() {} // 构造方法私有化 public void print() { System.out.println(&quot;Hello World!&quot;); } } public class Demo { public static void main(String[] args) { Singleton singleton = new Singleton(); // 报错,无法访问Singleton() singleton.print(); } } 构造方法私有化后，无法调用构造方法实例化对象。 范例：调用私有化方法 分析步骤： 1.构造方法上使用了private声明，导致构造方法只能内部使用，因此直接在内部实例化对象： class Singleton{ Singleton instance = new Singleton(); private Singleton() {} // 构造方法私有化 public void print() { System.out.println(&quot;Hello World!&quot;); } } 2.instance是普通属性，普通属性只有实例化对象才可以调用，因此需要使用static声明instance属性，使其不受实例化对象控制。 package com.java.demo; class Singleton{ static Singleton instance = new Singleton(); private Singleton() {} // 构造方法私有化 public void print() { System.out.println(&quot;Hello World!&quot;); } } public class Demo { public static void main(String[] args) { Singleton singleton = Singleton.instance; singleton.print(); } } 3.类中属性需要进行封装private static Singleton instance = new Singleton(); 4.获取封装的属性要使用getter()，因此要定义一个同样不受实例化对象控制的getter()，使用static定义。 package com.java.demo; class Singleton{ private static Singleton instance = new Singleton(); private Singleton() {} // 构造方法私有化 public void print() { System.out.println(&quot;Hello World!&quot;); } public static Singleton getInstance() { return instance; } } public class Demo { public static void main(String[] args) { Singleton singletonA = Singleton.getInstance(); Singleton singletonB = Singleton.getInstance(); System.out.println(singletonA == singletonB); // true } } 上述代码的意义：要限制一个类实例化底下的个数，首先要锁定的是构造方法，因为实例化对象必须调用构造方法 ，那么构造方法私有化，就无法产生新的对象。此时要实例化一个对象，就需要在类中使用static定义一个公共对象 ，并使用static方法返回该对象，这样不论外部调用多少次，最终该类中只产生了一个对象，这就是单例设计模式（Singleton）。 （2）单例设计模式有两种形式：饿汉式、懒汉式 上述单例设计模式就属于饿汉式，即在定义Singleton类时就实例化一个对象，不论该对象最后是否被使用。 而懒汉式则是在第一次使用时才进行实例化对象，如果不使用， 就不进行实例化操作。 范例：实现懒汉式 class Singleton{ private static Singleton instance; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(&quot;Hello World!&quot;); } public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 单例设计模式的目的是让该类在整个系统中只有一个实例化对象。 多例设计模式 多例设计模式，可以让一个类产生指定数量的实例化对象。 范例：定义一个表示性别的类 package com.java.demo; class Sex { private String title; private static final Sex MALE = new Sex(&quot;男&quot;); private static final Sex FEMALe = new Sex(&quot;女&quot;); private Sex(String title) { this.title = title; } public static Sex getInstance(int ch) { switch (ch) { case 0: return FEMALe; case 1: return MALE; default: return null; } } @Override public String toString() { return this.title; } } public class Demo { public static void main(String[] args) { Sex sex = Sex.getInstance(0); System.out.println(sex); } } JDK1.7之前，switch只能判断int或char，由于数字或字符表示不太直观，在1.7增加了String判断。 package com.java.demo; class Sex { private String title; private static final Sex MALE = new Sex(&quot;男&quot;); private static final Sex FEMALe = new Sex(&quot;女&quot;); private Sex(String title) { this.title = title; } public static Sex getInstance(String sex) { switch (sex) { case &quot;woman&quot;: return FEMALe; case &quot;man&quot;: return MALE; default: return null; } } @Override public String toString() { return this.title; } } 如果不想在switch语句中使用String，则可以引入一个标记接口（该方式不好） package com.java.demo; class Sex { private String title; private static final Sex MALE = new Sex(&quot;男&quot;); private static final Sex FEMALe = new Sex(&quot;女&quot;); private Sex(String title) { this.title = title; } public static Sex getInstance(int ch) { switch (ch) { case 0: return FEMALe; case 1: return MALE; default: return null; } } @Override public String toString() { return this.title; } } interface Choose { int WOMAN = 0; int MAN = 1; } public class Demo { public static void main(String[] args) { Sex sex = Sex.getInstance(Choose.MAN); System.out.println(sex); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十五)","slug":"Java Base/Java基础知识(十五)","date":"2017-11-11T11:13:36.150Z","updated":"2017-11-22T02:26:44.504Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十五)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十五)/","excerpt":"","text":"扩展概念 匿名内部类 interface Message { public void print(); } class Messagelmpl implements Message { public void print() { System.out.println(&quot;Hello&quot;); } } public class Demo { public static void main(String[] args) { fun(new Messagelmpl()); } public static void fun(Message msg) { msg.print(); } } 假如Messagelmpl只使用一次，那么就可以利用匿名内部类。 范例：使用匿名内部类 interface Message { public void print(); } public class Demo { public static void main(String[] args) { fun(new Message() { // 匿名内部类 public void print() { System.out.println(&quot;Hello&quot;); } }); } public static void fun(Message msg) { msg.print(); } } 使用匿名内部类的前提：必须基于接口或抽象类的应用。 匿名内部类定义在方法中，方法的参数或是变量要被匿名内部类访问，必须加上final关键字。匿名内部类的优点在于减少了类的定义。 基本数据类型的包装类 1、Java设计的基本原则：一切皆对象，一切操作都以对象的形式进行描述。此时我们发现，有一个矛盾点，基本数据类型不是对象。对于这个矛盾点，我们可以进行处理： class MyInt { // 定义类 private int num; // 类封装基本数据类型 // 定义构造方法，将基本数据类型传递给对象 public MyInt(int num) { this.num = num; } public int intValue() { // 返回被封装的数据 return this.num; } } public class Demo { public static void main(String[] args) { MyInt mi = new MyInt(10); // 装箱 int temp = mi.intValue(); // 拆箱 // 被封装的数据只有拆箱后才能进行计算 System.out.println(temp * 2); } } Java为了方便用户使用，专门提供了一组包装类，来包装所有的基本类型：byte(Byte)、short(Short)、int(Integer)、long(Long)、float(Float)、double(Double)、boolean(Boolean)、char（Character）。（）中为基本类型对应的包装类。 以上包装类严格讲分为两种子类型： · 对象型包装类（Object直接子类）：Character，Boolean； · 数值型包装类（Number直接子类）：Byte、Short、Integer、Float、Long、Double Numbe是一个抽象类，一共定义了六个操作方法：byteValue()、shortValue()、integerValue()、floatValue()、longValue()、doubleValue()。 装箱与拆箱 1、基本数据类型与包装类间的转换通过以下方式： · 装箱操作： 将基本数据类型变为包装类的形式： |- 每个包装类的构造方法都可以接收各自数据类型的变量； · 拆箱操作： 将包装类取出被包装基本数据类型数据： |- 利用Number类中提供的一些列xxValue()方法 范例：使用int和Integer public class Demo { public static void main(String[] args) { Integer obj = new Integer(10); // 装箱 int temp = obj.intValue(); // 拆箱 System.out.println(temp * 2); } } 范例：使用double和Double public class Demo { public static void main(String[] args) { Double obj = new Double(10.2); // 装箱 double temp = obj.doubleValue(); // 拆箱 System.out.println(temp * 2); } } 范例：使用boolean和Boolean public class Demo { public static void main(String[] args) { Boolean obj = new Boolean(true); // 装箱 boolean temp = obj.booleanValue(); // 拆箱 System.out.println(!temp); } } 2、所有包装类都利用同种格式的方法进行操作。但在JDK1.5之后，增加了自动装箱和自动拆箱的机制，并且可以直接使用包装类的对象进行数字计算，为开发提供了便利。 public class Demo { public static void main(String[] args) { Integer obj = 10; // 自动装箱 int temp = obj; // 自动拆箱 obj++; // 包装类直接进行数学计算 System.out.println(temp * obj); } } 3、注意点：Integer对象可以直接赋值，也可以使用构造方法赋值，二者有何区别？ 两者的区别可以参考String类直接赋值和构造方法赋值的区别。 public class Demo { public static void main(String[] args) { Integer objA = 10; // 自动装箱 Integer objB = 10; // 自动装箱 Integer objC = new Integer(10); System.out.println(objA == objB); // true System.out.println(objA == objC); // false System.out.println(objA.equals(objC)); // true } } 使用包装类时，几乎都是直接赋值，很少使用构造方法，判断内容是否相等时依然使用equals()方法。 4、Object类可以接收一切引用数据类型，由于自动装箱机制的存在，Object也可以接收基本数据类型。 流程：基本数据类型 → 自动装箱（成为对象） → 向上转型为Object。 public class Demo { public static void main(String[] args) { Object obj = 10; // Object不能直接向下转型向int // Object只能自动转型为Integer int temp = (Integer) obj; System.out.println(temp * 2); } } 数据类型转换 1、包装类多用于数据类型转换：在包装类中提供了将String数据变为基本数据类型的方法。 如下： · Integer类：public static int parseInt（String s）； · Double类：public static double parseDouble（String s）； · Boolean类：public static boolean parseBoolean（String s）； 注意：Character类不存在将字符串变为字符的方法，但String类的charAt()可以根据索引取出字符。 范例：将String变为int型 public class Demo { public static void main(String[] args) { String str = &quot;123&quot;; int temp = Integer.parseInt(str); System.out.println(temp * 2); } } 将字符串变为int型的前提是：该字符串全部为数字. 范例：将String变为double型 public class Demo { public static void main(String[] args) { String str = &quot;12.3&quot;; double temp = Double.parseDouble(str); System.out.println(temp * 2); } } 范例：将String变为boolean public class Demo { public static void main(String[] args) { String str = &quot;true&quot;; boolean temp = Boolean.parseBoolean(str); System.out.println(!temp); } } Boolean转换时，如果字符串的值不是true或false，默认转为false。 2、字符串可以变为基本数据类型，基本数据类型也可变为字符串。方法有两种： （1）任何基本数据类型与字符串使用+连接后，都会变为String类型数据 public class Demo { public static void main(String[] args) { int num = 100; String str = num + &quot;&quot;; // 变为String类 System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199 } } 上述方式虽然完成了转换，但产生了垃圾&quot;&quot; （2）利用public static String valueOf(数据类型 变量) public class Demo { public static void main(String[] args) { int num = 100; String str = String.valueOf(num); System.out.println(str.replaceAll(&quot;0&quot;, &quot;9&quot;)); // 199 } } 上述方式不会产生垃圾，因此开发中常用上述方法。 包的定义及使用 包的定义 1、包指的是程序的目录。早期开发一个程序是将所有类写在一个java文件中，编译后程序将直接保存在根目录下。利用包可以实现程序拆分，将不同的类根据要求保存在不同目录中。 包的定义通过关键字package完成。 范例：定义包 package com.java.demo; public class Demo { public static void main(String[] args) { } } 2、定义包时用.表示子目录。如果类中有包的定义，就必须使其保存在对应的目录下，而这些目录不需要手动创建，可以使用命令自动生成： （1）打包编译：java -d . Demo.java |- -d: 根据package定义生成目录； |-.：设置保存路径。.表示在当前路径下生成。 （2）解释程序时不要进入包中解释程序，而是在包外输入类的完整名称包.类： |- java com.java.demo.Demo 包的导入 1、使用包可以将一个完整的程序拆分为不同文件，从而分别保存。这存在问题：不同包间可能要进行互相访问，就需要进行导包操作，使用import语句完成。 范例：定义com.java.util.Message package com.java.util; class Message{ public static void print(){ System.out.println(&quot;Hello World !&quot;); } } 定义com.java.test.TestMessage package com.java.test; import com.java..util.Message; public class TestMessage { public static void print() { Message msg = new Message(); msg.print(); } } 编译时，应先编译Message，再编译TestMessage： |- javac -d . Message.java |- javac -d . TestMessage.java 此时报错：Message在com.java.util中不是公共的; 无法从外部程序包中对其进行访问 出现上述问题是因为public class定义的类可以被不同的包访问；而class定义的类只能被本包所访问。因此我们要修改Message.java: package com.java.util; public class Message{ public static void print(){ System.out.println(&quot;Hello World !&quot;); } } Java编译器考虑到大型程序开发,因此可以使用通配符*：java -d . *.java编译当前目录下所有java文件。 2、当要导入一个包中多个类时，可以使用import 包.* package com.java.test; import com.java..util.*; public class TestMessage { public static void print() { Message msg = new Message(); msg.print(); } } import 包.*并不是导入包中所有的类，而是只导入程序所需的类，因此不用担心性能问题。 3、一个Java文件可能导入多个包，而不同包中可能存在同名的类。现假设： ·com.java.util.Message; ·com.java.demo.Message. package com.java.demo; public class Message { public static void print() { System.out.println(&quot;世界你好！&quot;); } } 由于需要，要同时导入上述两个类： package com.java.test; import com.java.demo.Message; import com.java.util.Message; public class TestMessage { public static void main(String[] args) { Message msg = new Message(); msg.print(); } } 系统报错：Error:(4, 1) java: com.java.demo.Message的 single-type-import 已定义具有相同简名的类型。为了避免该错误，在使用类时，应加上包名： package com.java.test; import com.java.demo.Message; import com.java.util.Message; public class TestMessage { public static void main(String[] args) { com.java.demo.Message msg = new com.java.demo.Message(); Message.print(); } } 系统常用包 Java提供了许多程序开发包，此外还有许多第三方包。Java自带的常见系统包如下： （1）java.lang：包含了String、Object、Integer等类，此包系统自动导入； （2）java.lang.reflect：反射开发包； （3）java.util：Java的工具包，提供了大量的工具类，像链表； （4）java.util.regex：正则工具包； （5）java.text：国际化处理程序包； （6）java.io：进行输入、输出处理以及文件操作； （7）java.net：网络编程开发包； （8）java.sql：数据库程序开发包； （9）java.applet：Applet程序开发包（已经不用了）； |-Applet指的是在网页上嵌套的程序，可以使用Applet做一些动态效果，是采用绘图的方式完成的显示。随着时间的发展，Applet程序已经不再使用了（如果要再实现同样的功能，都是用Canvas绘图）。 （10）java.awt、javax.swing：图形界面的开发包，主要功能是开发单机程序界面。 |-JDK1.0时推出了awt开发包，但是这个开发包使用了大量的windows图形函数，使Java丧失了可移植性； |-JDK1.2时推出了javax.swing开发包，是一个轻量级（Java自己开发的，不再使用windows），所以Java更名为Java2； jar命令 使用jar命令压缩class文件，压缩的单位为包。 范例：定义Message.java文件 package com.java.util; class Message{ public static void print(){ System.out.println(&quot;Hello World !&quot;); } } 编译后会生成class文件，此时要交付给用户使用，将改包的代码压缩：jar -cvf my.jar com。生成的jar文件不能直接使用，必须配置CLASSPATH才能使用：SET CLASSPATH = .;jar包所在路径。开发中需要使用大量的第三方jar文件，都需要配置CLASSPATH，最简单的配置就是在环境变量中配置。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十四)","slug":"Java Base/Java基础知识(十四)","date":"2017-11-11T10:24:38.982Z","updated":"2017-11-11T11:12:55.508Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十四)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十四)/","excerpt":"","text":"Object类 Object类用于统一对象、数组和接口。 Object类基本描述 1、Object类是所有类的父类，即任何一个类在没有定义继承某个类时，Object类就是其父类。 class Book{} class Book extends Object{} 上述两个类声明是等价的，Object类是唯一没有父类的类。Object类是所有类的父类，因此可以利用Object类通过向上转型，接收所有类型的对象。 class Book extends Object { } public class Demo { public static void main(String[] args) { Object objA = new Book(); // 向上转型 Object objB = &quot;Hello&quot;; // 向上转型 Book b = (Book) objA; // 向下转型 String s = (String) objB; // 向下转型 } } 因此在不确定参数类型时，使用Object类型是最好的选择。 2、Object类中定义了一个无参构造方法，因为其是所有类的父类，所以实例化子类对象时必然会调用父类的无参构造方法。 一般而言，定义简单Java类时应覆写Object类中的如下方法： · 取得对象信息：public String toString(); · 对象比较：public boolean equals(Object obj); · 取得对象HASH码：public int hashCode(); toString() class Book extends Object { } public class Demo { public static void main(String[] args) { Book b = new Book(); String s = &quot;Hello&quot;; System.out.println(b); // Book@1540e19d System.out.println(b.toString()); // Book@1540e19d System.out.println(s); // Hello } } 上述代码中直接输出实例对象和使用toString()输出的结果是一样。因为输出对象时，会自动调用toString()将对象变为字符串后输出。Object类中的toString()为了适应对象的输出，仅输出对象的编码。 但是这和我们的想法不符，我们想输出的应该是实例化对象的属性信息，因此要覆写toString()。 范例：覆写toString() class Book extends Object { private String title; private double price; // getter,setter,无参构造方法暂时略 public Book(String title, double price) { this.title = title; this.price = price; } public String toString() { return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price; } } public class Demo { public static void main(String[] args) { Book b = new Book(&quot;Java开发&quot;, 20.3); System.out.println(b); // 书名：Java开发,价格：20.3 } } 此时直接输出对象，调用的就是覆写后的方法。 equals() 范例：对象比较 class Book extends Object { private String title; private double price; // getter,setter,无参构造方法暂时略 public Book(String title, double price) { this.title = title; this.price = price; } public String toString() { return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price; } public boolean equals(Object obj) { if (this == obj) { // 地址相同 return true; } if (obj == null) { return false; } if (!(obj instanceof Book)) { // 不是Book类对象 return false; } Book book = (Book) obj; if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } return false; } } public class Demo { public static void main(String[] args) { Book bA = new Book(&quot;Java开发&quot;, 20.3); Book bB = new Book(&quot;Java开发&quot;, 20.3); System.out.println(bA.equals(bB)); // true System.out.println(bA.equals(&quot;Hello&quot;)); // false } } 覆写后的equals()用于进行对象比较。 Object接收引用类型 1、Object类是所有类的父类，因此Object类对象可以接收所有类型的对象，包括数组和接口对象。 范例：接收数组数据 public class Demo { public static void main(String[] args) { Object obj = new int[]{1, 2, 3}; System.out.println(obj); // [I@1540e19d表示数组 if (obj instanceof int[]) { // 如果是数组，则输出 int data[] = (int[]) obj; // 向下转型 for (int x = 0; x &lt; data.length; x++) { System.out.println(data[x]); } } } } 范例：接收接口对象 interface A { public void fun(); } class B implements A { public void fun() { System.out.println(&quot;Hello&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); Object obj = a; A t = (A) obj; t.fun(); // Hello } } 上述代码把参数类型统一为Object，有利于开发。 Object修改链表 此时我们可以利用Object类的特点解决之前开发的链表存在的问题：由于参数类型不统一，每次使用都要进行重新开发。 范例：修改链表 class Link { // 链表类，外部可见 private class Node { // 节点类 private Object data; // 保存数据 private Node next; // 引用关系 public Node(Object data) { // 有数据才有Node this.data = data; } // 设置关系 public void addNode(Node newNode) { if (this.next == null) { this.next = newNode; } else { this.next.addNode(newNode); } } // 数据查询 public boolean containsNode(Object data) { if (data.equals(this.data)) { // 当前数据等于要目标数据 return true; // 结束查询 } else { // 当前数据不等于目标数据 if (this.next != null) { // 有后续节点 return this.next.containsNode(data); } else { // 没有后续节点 return false; } } } public Object getNode(int index) { // 当前foot内容与要查询的索引比较 // foot自增，目的是下次查询方便 if (Link.this.foot++ == index) { return this.data; } else { return this.next.getNode(index); } } // 修改节点信息 public void setNode(int index, Object data) { if (Link.this.foot++ == index) { this.data = data; } else { this.next.setNode(index, data); } } // 删除非根节点 public void removeNode(Node previous, Object data) { // 参数中传递上一个节点和要删除的数据 if (data.equals(this.data)) { previous.next = this.next; } else { this.next.removeNode(this, data); } } public void toArrayNode() { Link.this.retArray[Link.this.foot++] = this.data; if (this.next != null) { this.next.toArrayNode(); } } } // ====================以上为内部类===================== private Node root; // 根节点 private int count = 0; // 节点的个数 private int foot = 0; // 索引 private Object[] retArray; // 返回的数组 public void add(Object data) { if (data == null) { // 输入数据为空 return; } Node newNode = new Node(data); // 要保存的数据 if (this.root == null) { // 根节点不存在 this.root = newNode; // 设为根节点 } else { // 根节点存在，交由Node处理 this.root.addNode(newNode); } this.count++; // 每次增加节点，count+1 } // 获取链表长度 public int size() { return this.count; } // 判断是否为空链表 public boolean isEmpty() { return this.count == 0; } // 判断数据是否存在 public boolean contains(Object data) { if (data == null || root == null) { return false; } return this.root.containsNode(data); } // 根据索引获取信息 public Object get(int index) { if (index &gt; this.count) { // 超出查询范围 return null; } this.foot = 0; return this.root.getNode(index); // 查询交给Node类 } // 设置信息 public void set(int index, Object data) { if (index &gt; this.count) { return; } this.foot = 0; // 重置foot,作为索引 this.root.setNode(index, data); // Node进行修改数据 } // 判断删除节点是否为root public void remove(Object data) { if (this.contains(data)) { // 判断数据是否存在 if (data.equals(this.root.data)) { // 判断数据是否是root数据 this.root = this.root.next; } else { // root是Node对象，此处直接访问内部类私有操作 this.root.next.removeNode(this.root, data); } this.count--; // 删除后数据个数减少 } } public Object[] toArray() { if (this.root == null) { return null; } this.foot = 0; // 需要脚标控制 this.retArray = new Object[this.count]; // 根据保存内容开辟数组 this.root.toArrayNode(); return this.retArray; } } 范例: 测试程序 public class Demo { public static void main(String[] args) { Link all = new Link(); all.add(&quot;A&quot;); all.add(&quot;B&quot;); all.add(&quot;C&quot;); System.out.println(all.size()); all.remove(&quot;B&quot;); Object[] data = all.toArray(); for (int x = 0; x &lt; data.length; x++) { String str = (String) data[x]; System.out.println(str); } } } 综合实战: 宠物商店 要求: 以程序结构为主,实现一个宠物商店的模型,具有保存多个宠物的信息(名字,年龄),宠物上架、下架、模糊查询功能。 思路图： 宠物商店的商品（宠物）要符合宠物这一标准（接口），宠物商店借助链表实现上架、下架和模糊查询功能。 范例：定义宠物的标准 interface Pet { // 定义宠物的标准 public String getName(); public int getAge(); } 宠物商店与具体的宠物无关，只和宠物这一接口有联系。 范例：定义宠物商店 class PetShop { private Link pets = new Link(); // 要保存的宠物信息 public void add(Pet pet) { // 上架 this.pets.add(pet); } public void delete(Pet pet) { // 下架 this.pets.remove(pet); } public Link search(String keyWord) { // 模糊查询，返回的内容个数不明 Link result = new Link(); // 将集合以数组的形式返回， // 真正要查询的数据是Pet接口对象的getName()的返回值 Object obj[] = this.pets.toArray(); for (int x = 0; x &lt; obj.length; x++) { Pet p = (Pet) obj[x]; if (p.getName().contains(keyWord)) { result.add(p); } } return result; } } 范例： 定义猫类 class Cat implements Pet { private String name; private int age; public Cat(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (!(obj instanceof Cat)) { return false; } Cat cat = (Cat) obj; if (this.name.equals(cat.name) &amp;&amp; this.age == cat.age) { return true; } return false; } public String toString() { return &quot;猫名：&quot; + this.name + &quot;, 年龄&quot; + this.age; } } 可参照上述结构，定义一个狗类。 范例：测试 public class Demo { public static void main(String[] args) { PetShop shop = new PetShop(); shop.add(new Cat(&quot;阿猫&quot;, 9)); shop.add(new Cat(&quot;猫咪&quot;, 19)); shop.add(new Dog(&quot;阿狗&quot;, 10)); shop.add(new Dog(&quot;狗子&quot;, 8)); // 模糊查询 Link all = shop.search(&quot;阿&quot;); Object obj[] = all.toArray(); for (int x = 0; x &lt; obj.length; x++) { System.out.println(obj[x]); } shop.delete(new Dog(&quot;狗子&quot;, 8)); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十三)","slug":"Java Base/Java基础知识(十三)","date":"2017-10-28T12:06:18.603Z","updated":"2017-10-28T12:25:13.479Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十三)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十三)/","excerpt":"","text":"接口 接口的基本定义 1、接口是只由抽象方法和全局变量组成的类,使用interface关键字定义。 interface A { // 定义接口 public static final String MSG = &quot;Hello&quot;; // 全局常量 public abstract void print(); // 抽象方法 } 由于接口中存在抽象方法，因此接口对象不能直接实例化，其使用原则如下： （1）接口必须要有子类，子类可以使用implements关键字实现多接口； （2）接口的子类（非抽象类时），必须对接口的抽象方法进行覆写； （3）接口的对象可以利用子类对象通过向上转型实现实例化。 interface A { // 定义接口 public static final String MSG = &quot;Hello&quot;; // 全局常量 public abstract void print(); // 抽象方法 } interface B { public abstract void get(); } class X implements A, B { // X 实现A和B两个接口 public void print() { System.out.println(&quot;A.抽象方法&quot;); } public void get() { System.out.println(&quot;B.抽象方法&quot;); } } public class Demo { public static void main(String[] args) { X x = new X(); // 实例化子类对象 A a = x; // 向上转型 B b = x; // 向上转型 a.print(); b.get(); } } X是A和B的子类，因此X的对象可以变为A或者B接口的对象。 public class Demo { public static void main(String[] args) { A a = new X(); B b = (B) a; b.get(); // B.抽象方法 System.out.println(a instanceof A); // true System.out.println(b instanceof B); // true } } 从结构上来说，A和B接口没有直接关系，但是两个接口拥有共同的子类X，最终实例化的是X，这个子类向上转型为B类对象，因此代码可以执行。 2、子类同时继承类和接口时，语法:class X extends A implements B {} 接口的组成只有抽象方法和全局变量，因此可以不写abstract和public static final,并且方法是否使用public定义都是一样的，因为接口只能使用public权限。 |interface A{ public static final String MSG = &quot;Hello&quot;; //全局常量 public abstract void print(); //抽象方法 } |interface A{ String MSG = &quot;Hello&quot;; //全局常量 void print(); //抽象方法 } 上述代码是等价的。在接口中，默认访问权限为public，而不是default。但开发时，定义接口中的方法时要写上public。 3、一个抽象类只能继承一个抽象类，但一个接口可以使用extends关键字同时继承多个接口，接口不能继承抽象类。 interface A { public void funA(); } interface B { public void funB(); } interface C extends A, B { public void funC(); } class X implements C { public void funA() { } public void funB() { } public void funC() { } } 从继承上来说，抽象类的限制比接口多： （1）一个抽象类只能继承一个抽象父类，而接口没有该限制； （2）一个子类只能继承一个抽象类，但可以实现多接口。 因此Java中接口的功能是解决单继承限制。 4、从概念而言，接口只能由抽象方法和全局变量组成。但接口中可以定义普通内部类、抽象内部类、内部接口。这些内部接口不受接口的概念限制。 interface A { public void funA(); abstract class B { // 定义抽象内部类 public abstract void funB(); } } class X implements A { // X实现A接口 public void funA() { } class Y extends B { // 抽象内部类的子类 public void funB() { } } } 上述代码形式，几乎不会用到。 5、在接口中使用static定义一个内部接口，相当于外部接口。 interface A { public void funA(); static interface B { // 相当于外部接口 public void funB(); } } class X implements A.B { // X实现B接口 public void funB() { } } 总结： 接口在实际开发中的三大作用： （1）定义不同层之间的操作标准； （2）表示一种操作的能力； （3）表示将服务器端的远程方法视图暴露给客户端。 定义标准 根据上图编写代码：电脑利用USB接口标准和其他设备关联。 范例：定义USB标准 // 标准可以连接不同层的操作类 interface USB { // 接口就是标准 public void start(); public void stop(); } 范例：定义电脑 class Computer{ public void plugin(USB usb){ // 插入USB设备 usb.start(); usb.stop(); } } 不论是什么设备，只要实现了USB标准，就可以在电脑上使用。 范例：定义U盘 class Flash implements USB { public void start() { System.out.println(&quot;U盘开始使用&quot;); } public void stop() { System.out.println(&quot;U盘停止使用&quot;); } } 范例：定义打印机 class Print implements USB { public void start() { System.out.println(&quot;打印机开始使用&quot;); } public void stop() { System.out.println(&quot;打印机停止使用&quot;); } } 范例：测试 public class Demo { public static void main(String[] args) { Computer com = new Computer(); com.plugin(new Flash()); com.plugin(new Print()); } } Java中，标准就是被定义为接口。 工厂设计模式 interface Fruit { public void eat(); } class Apple implements Fruit { public void eat() { System.out.println(&quot;吃苹果&quot;); } } 上述代码通过主方法可以取得Fruit对象，但存在如下问题： 附：要确定代码是否合理，标准如下： （1）客户端调用简单，不用关注具体实现； （2）客户端之外的代码修改，不影响用户的使用，即用户不用关注代码的变更。 由上述标准可知该程序的问题是一个接口不一定只有子类，现在添加一个Fruit子类： class Orange implements Fruit { public void eat() { System.out.println(&quot;吃橘子&quot;); } } 客户端要使用这个新子类，需要修改代码： public class Demo { public static void main(String[] args) { Fruit f = new Orange (); f.eat(); // 吃橘子 } } 在上述代码，我们最关注的是如何获得Fruit对象,之后进行方法调用。至于该对象是怎么实例的,不是客户端的工作。 1、上述程序中，客户端每次更换对象，就需要修改主方法的代码，这不符合标准。该问题的关键在于new的使用，这种问题是因为耦合度太高（两者联系程度太高）。耦合度太高，代码不便于维护。 解决思路：参考Java虚拟机的设定-程序→JVM→适应不同的操作系统。 范例：增加一个过渡 class Factory { // 工厂设计模式 public static Fruit getInstance(String className) { if (&quot;apple&quot;.equals(className)) { return new Apple(); } else if (&quot;orange&quot;.equals(className)) { return new Orange(); } else { return null; } } } public class Demo { public static void main(String[] args) { Fruit f = Factory.getInstance(&quot;apple&quot;); f.eat(); // 吃苹果 } } 此时，所有子类对于客户端是不可见的，因为Fruit对象的实例化是通过Factory对象获取的，日后扩充Fruit子类时，只需修改Factory即可，不用修改客户端代码。 上图描述的是工厂设计模式，客户端可见的只有接口和Factory。 代理设计模式 代理设计模式的核心在于有一个主题操作接口（可能有很多接口），核心操作类只完成核心功能，而代理主题负责完成所有与核心操作有关的辅助性操作。 1、以去餐馆吃饭为例,外人只看到吃饭,看不到厨师和顾客。皇帝完成核心业务,厨师完成辅助业务。 package com.java.demo; interface Subject { // 核心业务 public void eat(); } class RealSubject implements Subject { // 实际进行核心业务的对象 public void eat() { System.out.println(&quot;顾客在吃饭&quot;); } } class ProxySubject implements Subject { // 执行代理操作的对象 private Subject subject; // 接收进行核心业务的对象 public ProxySubject(Subject subject) { this.subject = subject; } public void prepared() { System.out.println(&quot;为吃做准备&quot;); } public void eat() { this.prepared(); this.subject.eat(); this.destory(); } public void destory() { System.out.println(&quot;为吃收尾&quot;); } } public class Demo { public static void main(String[] args) { Subject sub = new ProxySubject(new RealSubject()); sub.eat(); // 调用代理操作 } } 接口与抽象类的区别 No. 区别 抽象类 接口 1 关键字 abstract class interface 2 组成 构造方法、普通方法、抽象方法、static方法、变量、常量 抽象方法，全局常量 3 子类使用 class 子类 extends 抽象类 class 子类implements 接口,接口… 4 关系 抽象类可以实现多接口 接口不能继承抽象类，却可以继承多个接口 5 权限 可以使用任意权限 只能使用public权限 6 限制 单继承局限 没有单继承局限 7 子类 抽象类和接口都必须有子类，子类必须要覆写全部抽象方法 抽象类和接口都必须有子类，子类必须要覆写全部抽象方法 8 实例化对象 依靠子类对象的向上转型进行对象的实例化 依靠子类对象的向上转型进行对象的实例化 经过比较发现，抽象类存在单继承限制，因此当抽象类和接口都可以使用时，优先考虑接口。 （1）当进行公共操作时，要定义接口； （2）有了接口就需要使用子类完善方法 （3）自定义的接口，不能直接实例化接口子类，应使用工厂设计模式。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(十二)","slug":"Java Base/Java基础知识(十二)","date":"2017-10-23T12:21:57.952Z","updated":"2017-10-24T07:25:08.911Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十二)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十二)/","excerpt":"","text":"辅助概念 关键字final Java中，final被称为终结器，可以用于定义类、方法、属性，具有如下特点： 1、final定义的类不能有子类 final class A{} class B extends A{} //报错，无法继承A类 开发系统类或者进行一些架构代码开发时使用到final定义类。 2、final定义的方法不能被方法覆写 父类中某些方法具备某种隐藏的特性，或子类必须使用该方法时，使用final定义，意思是子类不要破坏父类中该方法的结构。 class A{ public final void fun(){} } class B extends A{ public void fun(){} // 报错，无法覆写方法 } 3、final定义的变量就成了常量。常量必须在定义时设置好值，且不能修改。 class A { final double GOOD = 100.0; public void fun() { GOOD = 200; // 无法修改常量GOOD的值 } } 用final定义变量，就可以使用变量名来描述一些数据。开发中常量名均为大写，变量名首个单词小写，之后的单词首字母大写。 4、全局常量：public static final 声明的变量就是全局常量: public static final String MSG = &quot;MLDN&quot;; static数据存在公共数据区，因此MSG是一个公共常量。 总结： （1）final定义的类和方法不能继承，不能覆写； （2）public static final 定义的是全局常量，常量名全部大写。 对象多态性 多态性依赖于方法覆写。 class A { public void print() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void print() { System.out.println(&quot;覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); // 覆写的方法 } } 1、多态性分为两种： （1）方法的多态性 |- 方法重载：同一个方法名，根据传入的参数类型或个数的不同，执行不同方法体； |- 方法覆写：同一个方法，根据对象所属的子类不同，执行不同方法体。 （2）对象的多态性：指发生在具有继承关系的类中，父类与子类的转换。 |- 向上转型（自动完成）：父类 父类对象 = 子类实例化; |- 向下转型（强制完成）：子类 子类对象 = （父类）父类实例化; 范例：向上转型 public class Demo { public static void main(String[] args) { A a = new B(); a.print(); // 覆写的方法 } } 范例：向下转型 public class Demo { public static void main(String[] args) { B b = (B) new A(); // 向下转型 b.print(); // 覆写的方法 } } 2、向上转型：由于子类对象都可以自动向上转型，所以可应用于参数的统一。 class A { public void print() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void print() { System.out.println(&quot;B覆写的方法&quot;); } } class C extends A { public void print() { System.out.println(&quot;C覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { A a1 = new B(); // 向上转型 A a2 = new C(); // 向上转型 a1.print(); // B覆写的方法 a2.print(); // C覆写的方法 } } a1,a2参数统一后，还可以调用子类覆写的方法，即同一个方法针对不同子类可以有不同实现。 3、向下转型：父类发生向上转型后，不能调用子类中自定义的方法。因此当父类要调用子类自定义方法时，需要进行向下转型，将父类对象变为子类对象。 class A { } class B extends A { public void fun() { System.out.println(&quot;自定义方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 a.fun(); // 报错，无法调用B自定义方法 } } 向下转型后，可以调用子类自定义的方法： class A { } class B extends A { public void fun() { System.out.println(&quot;自定义方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 B b = (B) a; // 向下转型 b.fun(); } } 问题：上述代码中不适用向下转型,直接实例化子类对象就可以直接调用fun(),为什么还要转型？ 答：数据的操作分为两步：设置数据（最需要进行参数统一）和取出数据。 public class Demo { public static void main(String[] args) { fun(new B()); // 向上转型 } public static void fun(A a){ // 统一参数 B b = (B) a; // 向下转型 b.fun(); // 调用子类自定义方法 } } 5、个性化操作在开发中尽量少出现，因为对象的强制转型容易带来安全隐患。 class A { public void print() { System.out.println(&quot;A.print()&quot;); } } class B extends A { public void print() { System.out.println(&quot;B.print()&quot;); } } public class Demo { public static void main(String[] args) { A a = new A(); B b = (B) a; b.print(); } } 上述代码会报错,Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at ExDemo.main(ExDemo.java:15)，表示类转换异常，指的是两个没有关系的类对象强制进行向下转型时发生的异常，因此向下转型存在风险。 为保证转型的安全性，Java提供关键字instanceof,其返回结果为boolean:对象 instanceof 类 如果某个对象是某个类的实例，则会返回true，反之返回false。 class A { public void print() { System.out.println(&quot;A.print()&quot;); } } class B extends A { public void print() { System.out.println(&quot;B.print()&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); System.out.println(a instanceof A); // true System.out.println(a instanceof B); // true if (a instanceof B) { B b = (B) a; b.print(); // B.print() } } } 向下转型前应先进行对象的向上转型，建立关系后才能进行向下转型。 总结： （1）大多数情况只使用向上转型，使得参数统一，便于程序设计；子类尽量覆写方法，而不是自定义方法； （2）极少情况使用向下转型调用子类的自定义方法，或者不转型。 抽象类 基本概念 1、抽象类是含有抽象方法的类。抽象方法没有方法体，必须用abstract定义。 abstract class A { // 抽象类 public void fun(){方法体;} // 普通方法 public abstract void print(); // 抽象方法 } public class Demo { public static void main(String[] args) { A a = new A(); // 报错，A是抽象类，无法实例化 } } 结果显示，无法直接实例化抽象类对象.普通类的对象实例化后,该对象可以调用类中的属性和方法.而抽象类中存在抽象方法,抽象方法没有方法体无法调用，因此无法产生实例化对象. 2、抽象类使用原则： （1）抽象类必须有子类； （2）抽象类的子类（非抽象类时）必须覆写抽象类中所有的抽象方法（强制子类进行方法覆写） （3）抽象类对象的实例化依靠子类完成，采用向上转型方式。 范例：使用抽象类 abstract class A { // 抽象类 public void fun() { // 普通方法 System.out.println(&quot;普通方法&quot;); } public abstract void print(); // 抽象方法 } class B extends A { // 强制要求对抽象方法进行覆写，否则会报错 public void print() { System.out.println(&quot;覆写后的抽象方法&quot;); } } public class Demo { public static void main(String[] args) { A a = new B(); // 向上转型 a.fun(); a.print(); } } 由上述代码，可知： （1）抽象类的子类明确要求方法覆写，而普通类没有； （2）抽象类只比普通类多了抽象方法，其他部分相同； （3）抽象类对象必须经过向上转型才能实例化； （4）虽然子类可以继承任何类，但开发中，普通类最好继承抽象类。 使用限制 1、抽象类由于存在属性，因此会有构造方法来初始化属性。子类对象实例化时依然先执行父类构造方法，再调用子类构造方法。 2、抽象类不能使用final定义，因为抽象类必须有子类。 3、抽象外部类不允许使用static定义，而抽象内部类可以使用static声明。使用static定义的抽象内部类相当于抽象外部类，继承时使用外部类.内部类的形式表示类名。 abstract class A { // 抽象类 static abstract class B { public abstract void print(); } } class X extends A.B { public void print() { System.out.println(&quot;*****&quot;); } } public class Demo { public static void main(String[] args) { A.B ab = new X(); // 向上转型 ab.print(); } } 4、static定义的方法可以没有实例化对象的情况下直接调用，即使是抽象类中的static方法。 abstract class A { // 抽象类 public static void print() { System.out.println(&quot;static方法&quot;); } } public class Demo { public static void main(String[] args) { A.print(); // static方法 A a = new A() ; // 报错 } } 5、有时抽象类只需要一个特定的子类操作，因此可以将该子类定义为该抽象类的内部类。 abstract class A { // 抽象类 public abstract void print(); private static class B extends A { // 内部抽象类子类 public void print() { System.out.println(&quot;Hello&quot;); } } public static A getInstance() { // 获取B的实例化对象 return new B(); } } public class Demo { public static void main(String[] args) { // 客户端得到抽象类对象时，B对其不可见 A a = A.getInstance(); a.print(); } } 上述设计在系统类库中较为常见，目的是：为用户隐藏不需要知道的子类。 6、观察下述代码： abstract class A { // 抽象类 // 1. 先调用父类构造 public A() { this.print(); } public abstract void print(); } class B extends A { private int num = 100; // 3.调用子类构造，并初始化num = 30.运行结束，未输出初始化后的num public B(int num) { this.num = num; } // 2. 父类构造调用子类的print，此时num = 0,打印输出。 public void print() { System.out.println(&quot;num = &quot; + num); } } public class Demo { public static void main(String[] args) { new B(30); // 4. 结果为0 } } 在构造方法执行完之前，属性的内容均为其对应的数据类型的默认值。子类在执行构造方法前必先执行父类的构造方法，因为此时子类构造方法还没执行，就调用print()输出了num的值，所以num为0. 模板设计模式 要求：设计三个类，通过类描述如下行为： （1）机器人：充电、工作； （2）人：吃饭、工作、睡觉； （3）猪：吃饭、睡觉 思路：定义一个抽象类，具有吃饭、睡觉、工作的抽象方法。根据子类的不同，具体实现抽象方法。 abstract class Action { public static final int EAT = 1; public static final int SLEEP = 5; public static final int WORK = 7; public void command(int flag) { switch (flag) { case EAT: this.eat(); break; case SLEEP: this.sleep(); break; case WORK: this.work(); break; case EAT + WORK: this.eat(); this.work(); break; } } // 不确定方法中的具体行为，定义为抽象类 public abstract void eat(); public abstract void sleep(); public abstract void work(); } 定义子类： class Robot extends Action { public void eat() { System.out.println(&quot;机器人正在补充能量&quot;); } public void sleep() { } public void work() { System.out.println(&quot;机器人正在工作&quot;); } } class Human extends Action { public void eat() { System.out.println(&quot;人正在吃饭&quot;); } public void sleep() { System.out.println(&quot;人正在睡觉&quot;); } public void work() { System.out.println(&quot;人正在工作&quot;); } } class Pig extends Action { public void eat() { System.out.println(&quot;猪正在吃饭&quot;); } public void sleep() { System.out.println(&quot;猪正在睡觉&quot;); } public void work() { } } 范例：测试程序 public class Demo { public static void main(String[] args) { fun(new Robot()); fun(new Human()); fun(new Pig()); } public static void fun(Action act) { act.command(Action.EAT); act.command(Action.SLEEP); act.command(Action.WORK); } } 结果显示：子类要实现操作，必须按照Action类的标准。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"使用IDEA将SpringBoot打包成war","slug":"Spring Boot/使用IDEA将SpringBoot打包成war包","date":"2017-10-22T12:33:06.711Z","updated":"2017-10-22T12:48:32.913Z","comments":true,"path":"article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/使用IDEA将SpringBoot打包成war包/","excerpt":"","text":"修改pom.xml 将package格式改为war &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; 排除内置tomcat &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 打包过程跳过测试 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; 打包 打开IDE右侧边栏的Maven Projects demo |- Lifecycle |- clean |- validate |- compile |- test |- package |- verify |- install |- site |- deploy |- Plugins |- Dependencies 双击package即可开始打包，打包后,会在项目文件target中。 发布war包 删除tomcat下webapps中的文件,将文件war包文件复制放入。点击tomcat中bin文件夹下的startup.bat，此时便可进行访问localhost查看SpringBoot。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.8.RELEASE) 20:45:57 CST 2017]; root of context hierarchy 2017-10-22 20:46:01.008 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello],methods=[GET]}&quot; onto public java.lang.String com.demo.DemoApplication.hello() 2017-10-22 20:46:01.016 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2017-10-22 20:46:01.030 INFO 5972 --- [ost-startStop-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView 2017-10-22 20:46:01.635 INFO 5972 --- [ost-startStop-1] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup 2017-10-22 20:46:01.687 INFO 5972 --- [ost-startStop-1] com.demo.DemoApplication : Started DemoApplication in 5.963 seconds (JVM running for 11.781) 2017-10-22 20:46:02.385 WARN 5972 --- [ost-startStop-1] o.a.c.util.SessionIdGeneratorBase : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [682] milliseconds. application archive E:\\apache-tomcat-8.0.45\\webapps\\ROOT.war has finished in 10,051 ms 22-Oct-2017 20:46:02.430 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8888&quot;] 22-Oct-2017 20:46:02.454 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;] 22-Oct-2017 20:46:02.468 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 10192 ms 在上述信息中，告诉了我们可以访问的端口为8888.","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Java基础知识(十一)","slug":"Java Base/Java基础知识(十一)","date":"2017-10-22T07:53:56.490Z","updated":"2017-10-22T08:29:57.020Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十一)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十一)/","excerpt":"","text":"继承性 继承性的作用是解决代码重用问题。 继承问题的引出 范例:定义两个类Person和Student class Person{ private String name; private int age; public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age; } public String getName(){ return this.name; } public int getAge(){ return this.age; } } class Student{ private String name; private int age; private String school; public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age; } public void setSchool(String school){ this.school = school; } public String getName(){ return this.name; } public int getAge(){ return this.age; } public String getSchool(){ return this.school; } } 由代码可见Studen和Person存在代码重复。在自然关系上，Student是Person的一种，只是Student描述的更细致，范围更小。 实现继承 继承使用关键字extends实现，语法如下：class 子类 extends 父类{} 子类也被称为派生类，父类也被称为基类、超类或super类。 范例：实现继承 class Person { // 父类 private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student extends Person { // 继承Person类 } public class Demo { public static void main(String[] args) { Student stu = new Student(); stu.setName(&quot;张三&quot;); stu.setAge(18); System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;,年龄：&quot; + stu.getAge()); } } Student继承了Person，可以使用Person类中的方法。 范例：在Student中添加属性和方法 class Student extends Person { // 继承Person类 private String school; public String getSchool() { return school; } public void setSchool(String school) { this.school = school; } } 由上述代码，可知继承性的优点： （1）子类可以直接使用父类的属性和方法，进行代码重用； （2）子类可以扩充属于自己的操作。 继承的限制 Java中继承存在如下限制： 1、Java不允许多重继承，但允许多层继承。 C++允许多继承，即一个子类可以同时继承多个父类。但该操作在Java中是不允许的。多继承是为了使子类可以同时拥有多个父类的操作。Java中使用多层继承替代，语法如下： class A{} class B extends A{} class C extends B{} 相当于C是B的子类，是A的孙子类。多层继承没有层数限制，但最好不超过三层。 2、子类继承父类时，会继承父类全部操作。对于私有操作属于隐式继承，对于非私有操作属于显式继承。 class A { private String msg; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } class B extends A { } public class Demo { public static void main(String[] args) { B b = new B(); b.setMsg(&quot;Hello&quot;); System.out.println(b.getMsg()); // Hello } } 上述代码显示B类中也存在属性msg,因为如果msg不存在，setMsg()设置的内容就不能保存，即getMsg()无法输出内容。 class B extends A { public void fun() { System.out.println(msg); // 报错，无法访问 } } 但是在B类中无法直接访问msg，因为msg是A类的私有属性，只能间接访问。 3、在实例化子类对象之前，会先调用父类构造方法（默认是无参构造方法），以保证父类对象先实例化，而后在实例化子类对象。 class A { public A() { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B() { System.out.println(&quot;B 构造方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); // A 构造方法 // B 构造方法 } } 由结果可知，在实例化子类对象前，会先实例化父类对象。对于子类构造方法来说相当于隐藏一个”super()”. class B extends A { public B() { super(); // 父类有无参构造方法时，加不加都一样 System.out.println(&quot;B 构造方法&quot;); } } 何时要在子类构造方法中添加super()：如果父类中没有无参构造方法，就必须使用super调用父类的有参构造方法。 class A { public A(String title) { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B() { // 子类默认调用无参构造，但A中没有无参构造 System.out.println(&quot;B 构造方法&quot;); } } 上述代码执行后，不会调用A中的有参构造，因此需要在B类中的构造方法添加super(): class A { public A(String title) { System.out.println(&quot;A 构造方法&quot;); } } class B extends A { public B(String title) { super(title); System.out.println(&quot;B 构造方法&quot;); } } super()必须放在子类构造方法的第一行。而this()也应该放在构造方法的首行。 问题：子类构造方法未添加super()，系统默认使用super()调用父类的无参构造方法。如果在子类构造方法中添加this()，那么子类是不是无法调用父类构造方法？ class B extends A { public B() { // 报错，构造递归调用 this(); System.out.println(&quot;B 构造方法&quot;); } } 由结果可知，super()和this()不能同时存在。不论子类怎么修改，子类构造方法执行前都必须先执行父类的构造方法。 方法覆写 继承性的特点是子类可以对父类已有的功能进行扩展。子类在定义属性或方法时有可能与父类重名，该操作就称为覆写。 1、方法覆写：子类定义一个与父类方法的方法名、参数类型及个数、返回值都相同的方法。 class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // A中的方法 } } 此时B中没有fun()，所以调用的是从A继承的fun(). 范例：方法覆写 class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void fun(){ // 方法覆写 System.out.println(&quot;覆写的方法&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // 覆写的方法 } } 当方法覆写后，此时会调用子类中覆写的方法。 2、覆写结果的分析要素： （1）实例化的是那个类； （2）该对象调用的方法是否被覆写，如果未覆写将调用父类中的方法。 class B extends A { public String fun(){ System.out.println(&quot;覆写的方法&quot;); // 报错，B中fun()无法覆盖A中fun()，返回类型不兼容 return &quot;Hello&quot;; } } 进行方法覆写时，不能改变方法中的返回值和参数个数。 3、方法覆写的使用原则：父类方法不能满足子类需求，但又必须使用该方法名时，要进行方法覆写。 方法覆写时还要考虑到权限问题，被子类覆写的方法不能拥有比父类更高的访问控制权限。 访问控制权限：public&gt;default&gt;private，private的访问权限最严格。即如果父类方法使用public方法，子类覆写此方法时，只能使用public。父类使用的是default，子类覆写时，只能用default或public. 范例：正确覆写 class A { void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { public void fun(){ System.out.println(&quot;覆写的方法&quot;); } } 错误覆写： class A { public void fun() { System.out.println(&quot;A中的方法&quot;); } } class B extends A { void fun(){ System.out.println(&quot;覆写的方法&quot;); // 报错，正在尝试分配更低权限。 } } 上述代码中子类使用default，比public权限更严格，不符合方法覆写原则。 问题：父类方法使用private声明，子类使用public声明该方法，是覆写吗？ 答：从概念上，private声明权限高于public，因此从权限上而言符合覆写的要求。观察下述代码： class A { public void fun() { print(); } private void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // Hello } } 从上述代码来看，子类并没有覆写print()，因为使用private定义的方法对于子类而言是不可见，因此子类定义的print()虽然符合覆写的要求，但是实际只是相当于定义了一个全新的方法，而不是方法覆写。而正确的覆写结果应该如下： class A { public void fun() { print(); } public void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.fun(); // World } } 5、默认情况下，子类对象调用是一定是覆写后的方法。 class A { public void print(){ System.out.println(&quot;Hello&quot;); } } class B extends A { public void print(){ print(); // 等同于this.print() System.out.println(&quot;World&quot;); } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); // 报错，方法递归调用，死循环 } } 上述代码中，B类会优先调用B中print()，因此发生了递归调用。如果B中没有print()，则会调用父类中的。 范例：调用父类中方法super.方法名() class B extends A { public void print(){ super.print(); System.out.println(&quot;World&quot;); } } super.方法名()与this.方法名()的区别： （1）this.方法名()会优先查找本类中是否有目标方法，如果有则直接调用，没有就继续在父类中查找。 （2）super.方法名()会直接在父类中查找目标方法，不会在子类中查找。 问题：请说明重载（overloading）和覆写（override）的区别 No. 区别 重载 覆写 1 英文单词 Overloading Overrid 2 发生范围 发生在一个类中 发生在继承关系中 3 定义 方法名相同，参数类型及个数不相同 方法名称、参数类型及个数，方法返回值都相同 4 权限 没有权限限制 被覆写的方法不能拥有比父类更严格的权限 在方法重载时，返回值可以不同，但为了程序设计的统一性，应尽量保证返回值类型一致。 属性覆写 1、子类定义了与父类完全相同的属性名时，称为属性覆写。 class A { String info = &quot;Hello&quot;; } class B extends A { String info = &quot;World&quot;; public void print(){ System.out.println(super.info); // 调用父类属性 System.out.println(this.info); // 调用本类属性 } } public class Demo { public static void main(String[] args) { B b = new B(); b.print(); } } 由于在开发中，类的属性必须封装，而封装后，属性覆写就没有意义。因为父类定义的私有属性，子类不可见，因此不会互相影响。 问题：super和this的区别 No. 区别 this super 1 功能 调用本类中的操作 子类调用父类中的操作 2 形式 先从本类查找目标操作,再从父类中查找 只查找父类 3 特殊 表示本类的当前对象 super不能单独使用 在开发中，对于本类或父类的操作，最好加上this.或super.，这样便于代码调试。 继承综合实战：数组操作 要求：定义Array类，在类中可以进行整型数组的操作：由外部传入数组的数据，可以进行数据的保存和输出，并且在这个类上派生出两个子类： （1）排序类：通过此类取得的数据可以进行排序； （2）反转类：通过此类取得的数据采用倒序的方式输出。 开发时，先不考虑子类，先开发父类。 根据要求定义父类Array，实现其操作。 思路：开辟好数组后，根据索引，一一存放数据。 class Array { private int data[]; // 数组 private int foot; // 脚标 // 开辟数组空间 public Array(int len) { if (len &gt; 0) { this.data = new int[len]; } else { // 数组默认长度为1 this.data = new int[1]; } } // 为数组添加数据 public boolean add(int num) { if (this.foot &lt; this.a[this.foot++] = num; // 保存数据 return true; } return false; } // 取得数组内容 public int[] getData() { return this.data; } } public class Demo { public static void main(String[] args) { Array array = new Array(3); System.out.println(array.add(10)); // true System.out.println(array.add(20)); // true System.out.println(array.add(30)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } ####定义子类。 思路：将Array类getData()返回的结果进行排序输出即可，因此要覆写父类的方法。 // 定义一个排序数组的子类 class SortArray extends Array { // Array中没有无参构造方法， // 需要明确调用父类的有参构造方法 public SortArray(int len) { super(len); } // Array的getData()无法排序，进行方法覆写 public int[] getData() { // 调用类库中的方法排序 java.util.Arrays.sort(super.getData()); return super.getData(); } } public class Demo { public static void main(String[] args) { SortArray array = new SortArray(3); System.out.println(array.add(20)); // true System.out.println(array.add(30)); // true System.out.println(array.add(10)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } ####定义反转子类，也要保持客户端操作不变，因此要覆写父类的方法。 // 定义一个反转子类 class ReverseArray extends Array { public ReverseArray(int len) { super(len); } public int[] getData() { int center = super.getData().length / 2; int head = 0; int tail = super.getData().length - 1; for (int x = 0; x &lt; center; x++) { int temp = super.getData()[head]; super.getData()[head] = super.getData()[tail]; super.getData()[tail] = temp; head++; tail--; } return super.getData(); } } public class Demo { public static void main(String[] args) { ReverseArray array = new ReverseArray(3); System.out.println(array.add(20)); // true System.out.println(array.add(10)); // true System.out.println(array.add(30)); // true // 超出数组长度，false System.out.println(array.add(40)); int[] temp = array.getData(); for (int x = 0; x &lt; temp.length; x++) { System.out.println(temp[x]); // 10 20 30 } } } 总结： 子类扩充方法时，尽量根据需求覆写父类方法，而不是直接定义新方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"SpringBoot小例子进阶","slug":"Spring Boot/SpringBoot小例子进阶","date":"2017-10-21T05:42:31.770Z","updated":"2017-10-21T13:10:31.828Z","comments":true,"path":"article/框架/Spring Boot/SpringBoot小例子进阶/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子进阶/","excerpt":"","text":"本部分代码是基于SpringBoot基础应用博文的。 代码结构如下： demo // 项目名 |- .idea |- .mvn |- src // 代码存放区 |- main |- java |- com.example.demo // java包 |- aspect // 拦截器 |- HttpAspect.java |- controller // 控制器 |- PersonController |- domain // 实体类 |- Person |- Result // 定义异常的响应信息的格式 |- enums |- ResultEnum // 定义异常的code和信息 |- exception // 自定义异常 |- PersonException |- handle // 捕获异常 |- ExceptionHandle |- repository // jpa操作 |- PersonRepository |- service // 处理业务逻辑 |- PersonService |- DemoApplication.java // 项目启动类 |- resources |- static // 用于存放css,js等样式文件 |- templates // 用于存放html文件 application.properties // 项目配置文件 |- test //测试代码存放区 |- target .gitignore mvnw mvnw.cmd demo.iml pom.xml // 项目对象模型,添加项目依赖等配置 实现表单验证 要求： age小于18的数据无法入库 修改Person类 package com.example.demo.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.validation.constraints.Min; @Entity public class Person { @Id @GeneratedValue private Integer id; private String name; // @Min 使得该属性必须大于18,当数值小于18时,有提示信息 @Min(value = 18, message = &quot;年龄小于18无法添加&quot;) private Integer age; public Person() { } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 修改PersonController类addPerson() /** * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据 * @param person 要添加的person对象 * @param bindingResult 获取绑定结果信息 * @return 返回Person类信息 */ @PostMapping(value = &quot;/person&quot;) public Person addPerson(@Valid Person person, BindingResult bindingResult) { // 当输入数据不符合要求时,后台输出错误信息 if (bindingResult.hasErrors()) { System.out.println(bindingResult.getFieldError().getDefaultMessage()); return null; } return personRepository.save(person); } @Valid用于对传入的数据进行校验。 使用AOP处理请求 什么是AOP (1)AOP(面向切面, Aspect Oriented Programming)是一种编程范式,是一种程序设计思想。思想是将通用逻辑从业务逻辑中分离出来 将纵向的分析变为横向分析,从而将通用逻辑从业务逻辑中分离出来。 (2)除了AOP还有OOP(面向对象,Object Oriented Programming),POP(面向过程,Proceduer Oriented Programming) AOP统一处理请求日志 要求：记录每一个http请求 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 创建HttpAspect类 @Aspect实现切面注入;@Component将该类注册到SpringBoot容器中 package com.example.demo.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; // 切面注入 @Aspect @Component public class HttpAspect { // 日志对象 private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect .class); // 指明哪些方法需要执行AOP @Pointcut(&quot;execution(public * com.example.demo.controller.PersonController&quot; + &quot;.*(..))&quot;) public void log() {} /** * 该方法功能是将请求中的信息输出至日志中 * @Before 在使用PersonController中方法前先执行该注解下的方法 * @param joinpoint 目标类连接点对象 */ @Before(&quot;log()&quot;) public void doBefore(JoinPoint joinpoint) { ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 获取url LOGGER.info(&quot;url = {}&quot;, request.getRequestURL()); // 获取请求方式 LOGGER.info(&quot;method = {}&quot;, request.getMethod()); // 获取请求方的ip LOGGER.info(&quot;ip = {}&quot;, request.getRemoteAddr()); // 获取被调用的方法名 LOGGER.info(&quot;class_method = {}&quot;, joinpoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinpoint.getSignature().getName() + &quot;()&quot;); // 获取请求参数 LOGGER.info(&quot;args = {}&quot;, joinpoint.getArgs()); } /** 该方法功能是将响应中的信息输出至日志中 * @AfterReturning 使得该类可以接收HttpResponse中对象信息 * @param object 返回的对象信息 */ @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;) public void doAfterReturning(Object object) { LOGGER.info(&quot;response = {}&quot;, object.toString()); } } 统一异常处理 要求:获取Person对象的age并判断 age &lt; 12 : 返回&quot;正在上小学&quot; age &gt; 12 &amp;&amp; age &lt; 15: 返回&quot;正在上初中&quot; 定义异常响应信息格式 package com.example.demo.domain; public class Result&lt;T&gt; { private Integer code; // 错误码 private String msg; // 提示信息 private T data; // 具体内容 public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public T getData() { return data; } public void setData(T data) { this.data = data; } } 自定义异常类 package com.example.demo.exception; import com.example.demo.enums.ResultEnum; public class PersonException extends RuntimeException { private Integer code; public PersonException(ResultEnum resultEnum) { super(resultEnum.getMsg()); this.code = resultEnum.getCode(); } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } } 规范响应code和msg package com.example.demo.enums; public enum ResultEnum { UNKNOW_ERROR(-1, &quot;未知错误&quot;), SUCCESS(200, &quot;添加成功&quot;), PRIMARY_SCHOOL(403, &quot;在上小学&quot;), MIDDLE_SCHOOL(404, &quot;在上初中&quot;), ; private Integer code; private String msg; ResultEnum(Integer code, String msg) { this.code = code; this.msg = msg; } public Integer getCode() { return code; } public String getMsg() { return msg; } } 进行异常捕获 package com.example.demo.handle; import com.example.demo.domain.Result; import com.example.demo.exception.PersonException; import com.example.demo.util.ResultUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class ExceptionHandle { private final static Logger LOGGER = LoggerFactory.getLogger (ExceptionHandle.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Result handle(Exception e){ if (e instanceof PersonException) { PersonException personException = (PersonException) e; return ResultUtil.error(personException.getCode(), personException.getMessage()); } else { LOGGER.error(&quot;[系统异常] {}&quot;, e); return ResultUtil.error(-1, &quot;未知错误&quot;); } } } 进行逻辑判断,从而判断异常 package com.example.demo.service; import com.example.demo.domain.Person; import com.example.demo.enums.ResultEnum; import com.example.demo.exception.PersonException; import com.example.demo.repository.PersonRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PersonService { @Autowired private PersonRepository personRepository; public void getAge(Integer id) throws Exception{ Person person = personRepository.findOne(id); Integer age = person.getAge(); if (age &lt; 10) { throw new PersonException(ResultEnum.PRIMARY_SCHOOL); } else if (age &gt; 10 &amp;&amp; age &lt; 16) { throw new PersonException(ResultEnum.MIDDLE_SCHOOL); } } } 单元测试 对Service进行测试 package com.example.demo; import com.example.demo.domain.Person; import com.example.demo.service.PersonService; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class PersonServiceTest { @Autowired private PersonService personService; @Test public void findOneTest() { Person person = personService.findOne(9); // 断言 Assert.assertEquals(new Integer(19), person.getAge()); } } 对API进行测试 package com.example.demo.controller; import com.example.demo.domain.Person; import com.example.demo.repository.PersonRepository; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet .AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class PersonControllerTest { @Autowired private MockMvc mockMvc; @Test public void personList() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person&quot;)). // 对状态码进行断言 andExpect(MockMvcResultMatchers.status().isOk()). // 对响应文本进行断言 andExpect(MockMvcResultMatchers.content().string(&quot;&quot;)); } }","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Java基础知识(十)","slug":"Java Base/Java基础知识(十)","date":"2017-10-18T02:24:29.526Z","updated":"2017-10-21T05:59:07.648Z","comments":true,"path":"article/Java/Java Base/Java基础知识(十)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(十)/","excerpt":"","text":"链表 链表是引用的加强应用. 知识点前提：依赖于引用传递；this表示当前对象。 链表基本概念 1.链表是一种简单的数据结构，功能是依靠引用关系实现多个数据的保存。 根据上图编写代码： 要求：定义一个Node类，保存String类型数据，同时拥有下一个节点的引用。 // 每个链表由多个节点组成 class Node { // 定义节点类 private String data; // 要保存的数据 private Node next; // 要保存的下一个节点 // 每个Node对象都必须保存相应的数据 public Node(String data) { // 有数据才有Node this.data = data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } public String getData() { return this.data; } } Node类专门负责保存节点关系，需要其他类负责Node之间的关系匹配。 范例：使用循环取出数据 public class Demo { public static void main(String[] args) { // 1. 设置数据 Node root = new Node(&quot;火车头&quot;); Node n1 = new Node(&quot;车厢A&quot;); Node n2 = new Node(&quot;车厢B&quot;); root.setNext(n1); n1.setNext(n2); // 2. 取出数据 Node currentNode = root; //从根节点开始读取数据 while (currentNode != null) { // 当前节点存在数据 System.out.println(currentNode.getData()); // 将下一节点设置为当前节点 currentNode = currentNode.getNext(); } } } 利用循环取出数据不够便捷，应使用递归。 范例：使用递归取出数据 public class Demo { public static void main(String[] args) { // 1. 设置数据 Node root = new Node(&quot;火车头&quot;); Node n1 = new Node(&quot;车厢A&quot;); Node n2 = new Node(&quot;车厢B&quot;); root.setNext(n1); n1.setNext(n2); print(root); } public static void print(Node current){ if (current == null){ // 节点不存在 return ; // 结束方法调用 } System.out.println(current.getData()); print(current.getNext()); // 递归调用 } } 因为循环次数未知，所以使用while循环。节点操作中，递归比while循环更直观。 问题：为什么要设置Node类 答：数据本身不具有先后关系，因此需要使用Node类封装份数据，同时利用Node类指向下一节点。 链表基本实现 通过分析发现： (1)用户操作过程中，Node类应该是不可见的，即用户无需关注Node类的结构 (2)Node之间的关系不应该由用户定义，而应该由一个专门的类处理。 范例：定义Link类，隐藏Node类 程序要描述的步骤如下： 第一步： 第二步： 第三步： 第四步： // 处理Node对象间关系 class Link { private Node root; // 根节点 // 设置数据 public void add(String data) { // 为了设置数据的先后关系，将data包装在Node对象中 Node newNode = new Node(data); if (this.root == null) { // 保存数据时，根节点不存在 // 该判断执行一次，因为链表只有一个根节点 this.root = newNode; // 将新节点设置为根节点 } else { // 根节点存在 // 新节点应交给Node决定 // 从root之后设置合适的位置 this.root.addNode(newNode); } } // 输出数据 public void print() { if (this.root != null) { this.root.printNode(); } } } 范例:根据Link类，修改Node类 class Node { private String data; private Node next; public Node(String data) { this.data = data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } public String getData() { return this.data; } // 添加节点 // 第一次Link调用: this = link.root // 第二次Node调用：this = link.root.next // 第三次Node调用：this = link.root.next.next public void addNode(Node newNode) { if (this.next == null) { // 当前节点的next为空 this.next = newNode; // 保存为新节点 } else { // 当前节点的next的next继续保存 this.next.addNode(newNode); } } // 第一次Link调用: this = link.root // 第二次Node调用：this = link.root.next // 第三次Node调用：this = link.root.next.next public void printNode() { System.out.println(this.data); // 输出当前节点数据 if (this.next != null) { // 当前节点有next this.next.printNode(); // 输出next节点信息 } } } 范例：测试 public class Demo { public static void main(String[] args) { Link link = new Link(); // 负责数据操作 // 增加数据 link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); // 输出数据 link.print(); } } 由上述代码可知链表操作的基本特点： （1）对于客户端而言Node是不可见的，只能利用Link中的方法 （2）Link类的功能是控制Node对象的产生和根节点的使用； （3）Node类的功能是保存数据以及配置引用关系。 可用链表基本结构 1.可用链表指的是能实现数据的增删改查的链表。 2.可用链表开发要求：Node类负责节点数据的保存以及节点关系的匹配，因此Node类不能被单独使用，即外部不能绕过Link去使用Node 范例：修改Node结构，使得Node类只能被Link类使用 思路：将Node类变为private定义的内部类。 class Link { // 链表类，外部可见 // Node定义在内部让其只为Link服务 private class Node { private String data; // 保存数据 private Node next; // 引用关系 public Node(String data) { this.data = data; } } // ====================以上为内部类===================== private Node root; // 根节点 } 上述代码即为可用链表的基本结构，后续为其增加功能代码。 增加数据功能 思路：数据的增加应由Link负责节点对象的产生，以及根节点的维护。节点间的关系匹配，由Node类处理。 范例：Node类中添加addNode()，Link类中添加add() // 设置关系 public void addNode(Node newNode) { if (this.next == null) { this.next = newNode; } else { this.next.addNode(newNode); } } public void add(String data) { if (data == null) { // 输入数据为空 return; } Node newNode = new Node(data); // 要保存的数据 if (this.root == null) { // 根节点不存在 this.root = newNode; // 设为根节点 } else { // 根节点存在，交由Node处理 this.root.addNode(newNode); } } 范例：测试 public class Demo { public static void main(String[] args) { Link link = new Link(); link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); } } 获取链表长度 思路：每个链表对象都只有一个root，可以在Link类中设置count属性，随后每次添加数据后，count自增。 范例：修改Link类 （1）增加count属性:private int count = 0; // 节点的个数 （2）在add()添加统计节点个数的操作 public void add(String data) { if (data == null) { return; } Node newNode = new Node(data); if (this.root == null) { this.root = newNode; } else { // this.root.addNode(newNode); } this.count++; // 每次增加节点，count+1 } （3）添加获取链表长度的方法size() public int size() { return this.count; } （4）判断链表是否为空，有两种方式，一是判断root是否为null，二是判断count是否为0，在此采用第二种方式，在Link类中添加isEmpty() public boolean isEmpty() { return this.count == 0; } 内容查询 思路：判断链表中是否存在某数据，以String为例，仅需遍历链表中的数据，与要查询的数据记性匹配（使用equals(String str)），如果匹配成功返回true，反之返回false。 根据上图编写代码： （1）Link中添加contains() public boolean contains(String data) { if (data == null || root == null) { return false; } return this.root.containsNode(data); } Link从root节点开始查询数据是否存在，数据不存在，Node开始查询非根节点。 （2）Node中添加containsNode() public boolean containsNode(String data) { if (data.equals(this.data)) { // 当前数据等于要目标数据 return true; // 结束查询 } else { // 当前数据不等于目标数据 if (this.next != null) { // 有后续节点 return this.next.containsNode(data); } else { return false; } } } （3）测试 public class Demo { public static void main(String[] args) { Link link = new Link(); link.add(&quot;火车头&quot;); link.add(&quot;车厢A&quot;); link.add(&quot;车厢B&quot;); System.out.println(link.contains(&quot;火车头&quot;)); } } 案例中使用的是String类型数据，所以判断数据使用equals(String str)。如果判断的是自定义类型数据，就需要定义一个对象比较的方法，方法名暂定为compare()。 根据索引取得数据 链表中保存有多个对象。数组也可以保存多个对象。链表和数组相比优势在于没有长度限制。因此链表相当于一个动态对象数组，具备像数组那样根据索引取得元素的功能。 由于是动态对象数组，所以元素的索引也是动态生成的。 根据上图，编写代码： （1）Link中增加foot属性，表示Node的索引:private int foot = 0; // 索引 每次查询前，应该重置为0.链表查询数据前应先判断要查询的索引小于索引总数。 public String get(int index) { if (index &gt; this.count) { // 超出查询范围 return null; } this.foot = 0; return this.root.getNode(index); // 查询交给Node类 } （2）Node定义getNode()，内部类和外部类间可以方便地进行私有属性的访问。 public String getNode(int index) { // 当前foot内容与要查询的索引比较 // foot自增，目的是下次查询方便 if (Link.this.foot++ == index) { return this.data; } else { return this.next.getNode(index); } } 修改链表数据 修改和查询思路差不多，不同的是查询是当满足索引值时，返回数据；修改是满足索引时，对数据重新赋值。 （1）Link添加set(int index, String data) public void set(int index, String data) { if (index &gt; this.count) { return; } this.foot = 0; // 重置foot,作为索引 this.root.setNode(index, data); // Node进行修改数据 } （2）Node添加setNode(int index, String data) public void setNode(int index, String data) { if (Link.this.foot++ == index) { this.data = data; } else { this.next.setNode(index, data); } } 删除链表数据 删除链表数据应分为两种情况： （1）要删除的是根节点，root.next()变为root，在Link中处理，因为由Link来维护root； （2）要删除的是非根节点，当前节点的上一节点.next()=当前节点.next()，即空出了当前节点。非根节点应交由Node处理。 1.Node添加removeNode(Node previous, String data) public void removeNode(Node previous, String data) { // 参数中传递上一个节点和要删除的数据 if (data.equals(this.data)) { previous.next = this.next; } else { this.next.removeNode(this, data); } } Link添加remove(String data) public void remove(String data) { if (this.contains(data)) { // 判断数据是否存在 if (data.equals(this.root.data)) { // 判断数据是否是root数据 this.root = this.root.next; } else { // root是Node对象，此处直接访问内部类私有操作 this.root.next.removeNode(this.root, data); } this.count -- ; // 删除后数据个数减少 } } 对象数组转换 开发中，类中不应该有输出语句。想输出数据应将数据返回到调用处。链表属于动态数组，因此可以将链表以对象数组的形式返回。 由上图可知，Link的toArray()要返回一个对象数组，且该数组也要由Node操作。因此该数组应定义为Link的属性。 （1）Link添加一个数组属性，便于Node和Link访问。添加toArray() private String[] retArray; // 返回的数组 public String[] toArray() { if (this.root == null) { return null; } this.foot = 0; // 需要脚标控制 this.retArray = new String[this.count]; // 根据保存内容开辟数组 this.root.toArrayNode(); return this.retArray; } （2）Node添加toArrayNode()进行数组数据保存 public void toArrayNode() { Link.this.retArray[Link.this.foot++] = this.data; if (this.next != null) { this.next.toArrayNode(); } } 链表数据变为对象数组取出是重要功能！ 链表使用 上述链表只能操作String数据。下面要使用链表操作自定义类，由于链表具有contains()，因此类中需定义对象比较的方法。 （1）定义Book类（setter/getter暂时省略） class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo() { return &quot;书名：&quot; + this.title + &quot;,价格&quot; + this.price; } public boolean compare(Book book) { if (book == null) { return false; } if (this == book) { return true; } if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } else { return false; } } } （2）修改链表 class Link { private class Node { // 节点类 private Book data; // 保存数据 private Node next; // 引用关系 public Node(Book data) { this.data = data; } // 设置关系 public void addNode(Node newNode) { if (this.next == null) { this.next = newNode; } else { this.next.addNode(newNode); } } // 数据查询 public boolean containsNode(Book data) { if (data.equals(this.data)) { // 当前数据等于要目标数据 return true; // 结束查询 } else { // 当前数据不等于目标数据 if (this.next != null) { // 有后续节点 return this.next.containsNode(data); } else { // 没有后续节点 return false; } } } public Book getNode(int index) { // 当前foot内容与要查询的索引比较 // foot自增，目的是下次查询方便 if (Link.this.foot++ == index) { return this.data; } else { return this.next.getNode(index); } } // 修改节点信息 public void setNode(int index, Book data) { if (Link.this.foot++ == index) { this.data = data; } else { this.next.setNode(index, data); } } // 删除非根节点 public void removeNode(Node previous, Book data) { // 参数中传递上一个节点和要删除的数据 if (data.equals(this.data)) { previous.next = this.next; } else { this.next.removeNode(this, data); } } public void toArrayNode() { Link.this.retArray[Link.this.foot++] = this.data; if (this.next != null) { this.next.toArrayNode(); } } } // ====================以上为内部类===================== private Node root; // 根节点 private int count = 0; // 节点的个数 private int foot = 0; // 索引 private Book[] retArray; // 返回的数组 public void add(Book data) { if (data == null) { // 输入数据为空 return; } Node newNode = new Node(data); // 要保存的数据 if (this.root == null) { // 根节点不存在 this.root = newNode; // 设为根节点 } else { // 根节点存在，交由Node处理 this.root.addNode(newNode); } this.count++; // 每次增加节点，count+1 } // 获取链表长度 public int size() { return this.count; } // 判断是否为空链表 public boolean isEmpty() { return this.count == 0; } // 判断数据是否存在 public boolean contains(Book data) { if (data == null || root == null) { return false; } return this.root.containsNode(data); } // 根据索引获取信息 public Book get(int index) { if (index &gt; this.count) { // 超出查询范围 return null; } this.foot = 0; return this.root.getNode(index); // 查询交给Node类 } // 设置信息 public void set(int index, Book data) { if (index &gt; this.count) { return; } this.foot = 0; // 重置foot,作为索引 this.root.setNode(index, data); // Node进行修改数据 } // 判断删除节点是否为root public void remove(Book data) { if (this.contains(data)) { // 判断数据是否存在 if (data.equals(this.root.data)) { // 判断数据是否是root数据 this.root = this.root.next; } else { // root是Node对象，此处直接访问内部类私有操作 this.root.next.removeNode(this.root, data); } this.count--; // 删除后数据个数减少 } } public Book[] toArray() { if (this.root == null) { return null; } this.foot = 0; // 需要脚标控制 this.retArray = new Book[this.count]; // 根据保存内容开辟数组 this.root.toArrayNode(); return this.retArray; } } （3）测试 public class Demo { public static void main(String[] args) { Link all = new Link(); all.add(new Book(&quot;Java开发&quot;, 69.8)); all.add(new Book(&quot;JSP&quot;, 78.8)); all.add(new Book(&quot;C++开发&quot;, 19.8)); System.out.println(&quot;保存书的个数：&quot; + all.size()); System.out.println(all.contains(new Book(&quot;Java开发&quot;, 69.8))); all.remove(new Book(&quot;C++开发&quot;, 19.8)); Book[] books = all.toArray(); for (int x = 0; x &lt; books.length; x++) { System.out.println(books[x].getInfo()); } } } 链表的最佳应用就是横向替换对象数组。 在映射中使用链表 链表属于动态对象数组。之前进行数据表映射时，都会出现对象数组的概念，现在就用链表来进行对象保存。本节以一对多为例，即用前文中的省份-城市表为例： （1）对于使用链表的类，要添加对象比较的方法 class Province { private int pid; private String pname; private Link cities = new Link(); public Link getCities() { return this.cities; } //getter/setter,无参构造方法略 public Province(int pid, String pname) { this.pid = pid; this.pname = pname; } public boolean compare(Province province) { if (province == null) { return false; } if (this == province) { return true; } if (this.pid == province.pid &amp;&amp; this.pname.equals(province.pname)) { return true; } else { return false; } } public String getInfo() { return &quot;省份ID：&quot; + this.pid + &quot;,省份名称：&quot; + this.pname; } } class City { private int cid; private String cname; private Province province; public void setProvince(Province province) { this.province = province; } public Province getProvince() { return this.province; } //getter/setter,无参构造方法略 public City(int cid, String cname) { this.cid = cid; this.cname = cname; } public String getInfo() { return &quot;城市ID：&quot; + this.cid + &quot;,城市名称：&quot; + this.cname; } public boolean compare(City city) { if (city == null) { return false; } if (this == city) { return true; } if (this.cid == city.cid &amp;&amp; this.cname.equals(city.cname) &amp;&amp; this.province.compare(city.province)) { return true; } else { return false; } } } 此时只需将链表中的Book改为City即可。 在此时发现问题：每定义一个新的类，链表就需要重新进行修改。方法解决了代码重复问题。但是该问题不属于代码重复，属于数据类型不同意，该问题需要依靠面向对象的特性的来结局。 总结 （1）本章所讲的只是最基础的单向链表； （2）链表中应有如下方法： No. 方法名称 类型 作用 1 public void add(数据类型 变量) 普通 向链表中添加数据 2 public int size() 普通 取得链表中数据个数 3 public boolean isEmpty() 普通 判断是否为空链表 4 public boolean contains(数据类型 变量) 普通 判断数据是否存在 5 public 数据类型 get(int index) 普通 根据索引取得数据 6 public void set(int index,数据类型 变量) 普通 修改数据 7 public void remove(数据类型 变量) 普通 删除指定数据 8 public 数据类型 [] toArray() 普通 将链表以对象数组的形式转换","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(九)","slug":"Java Base/Java基础知识(九)","date":"2017-10-15T01:28:21.490Z","updated":"2017-10-21T05:58:17.386Z","comments":true,"path":"article/Java/Java Base/Java基础知识(九)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(九)/","excerpt":"","text":"代码块 代码块是{}定义的一段语句，根据定义的位置和关键字的不同，代码块分为四种：普通代码块，构造块，静态块和同步代码块。 普通代码块 1.写在方法中的代码块，称为普通代码块。 public class Demo { public static void main(String[] args) { { // 普通代码块 int num = 10; // 局部变量 System.out.println(&quot;num = &quot; + num); // 10 } int num = 100; // 全局变量 System.out.println(&quot;num = &quot; + num); // 100 } } 普通代码块的功能是防止方法中代码过多时出现变量重名问题，对方法的代码进行局部分割。**编写方法时，代码不应太长，**因此也没必要使用普通代码块。 构造块 1.写在类中的代码块，称为构造块。 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // B. Book类的构造块 // A. Book类的构造方法 } } 输出结果显示：构造块的调用优先于构造方法。 静态块 static定义的代码块，称为静态块。静态块的使用，分为两种情况： 1.在非主类中使用 class Book { public Book(){ // 构造方法 System.out.println(&quot;A. Book类的构造方法&quot;); } { // 构造块 System.out.println(&quot;B. Book类的构造块&quot;); } static { System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { new Book(); // C B A new Book(); // B A } } 结果显示：**静态块优先于构造块。**且不论实例化多少个对象，静态块只执行一次。static主要功能是为类中的static属性初始化。 class Book { public static String msg; static { msg = &quot;Hello&quot;.substring(0,2); System.out.println(&quot;C. Book类的静态块&quot;); } } public class Demo { public static void main(String[] args) { System.out.println(Book.msg); } } 2.在主类中定义 public class Demo { static { System.out.println(&quot;**************&quot;); } public static void main(String[] args) { System.out.println(&quot;Hello World !&quot;); // ************** // Hello World ! } } 结果显示：静态块优先于main()方法执行。在编写测试时，可以使用静态块。 内部类 从开发角度来说，尽量不要使用内部类 内部类基本概念 1.内部类是指在一个类的内部定义其他的类。 范例：内部类 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象，调用print()方法 new Inner().print(); } } public class Demo { public static void main(String[] args) { // 实例化外部类对象 Outer out = new Outer(); out.fun(); // 调用外部类方法，Hello World } } 上述代码牺牲了程序的结构，实现了一个重要功能。 2.为说明内部类特点，现将内部类取出，作为一个单独的类，并要求实现与之前一样的功能。 范例：取出内部类 class Outer { private String msg = &quot;Hello World&quot;; public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(msg); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); // 报错，msg属于Outer，Inner无法调用 } } （1）要想使得Inner调用msg，就需在Outer中写一个getMsg() public String getMsg(){ return this.msg; } （2）Inner要调用Outer的getMsg()方法，必须实例化一个Outer对象 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg(){ return this.msg; } public void fun() { new Inner().print(); } } class Inner { public void print() { System.out.println(new Outer().getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 上述的做法不合理，最好是将主方法中的Outer对象传递给Inner对象。 class Outer { private String msg = &quot;Hello World&quot;; public String getMsg() { return this.msg; } public void fun() { new Inner(this).print(); } } class Inner { private Outer out; public Inner(Outer out) { this.out = out; } public void print() { System.out.println(this.out.getMsg()); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 由此可得内部类的特点： 内部类可以直接访问外部类的私有属性和方法，外部类也可以通过内部类对象访问内部类的私有属性。 范例：访问内部类私有属性 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(msg); } } public void fun() { // 实例化内部类对象 Inner in = new Inner(); // 使用内部类对象访问内部类私有属性 System.out.println(in.info); } } public class Demo { public static void main(String[] args) { Outer out = new Outer(); out.fun(); } } 3.观察代码 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 private String info = &quot;世界你好&quot;; public void print() { System.out.println(this.msg); // 报错，找不到msg } } public void fun() { new Inner().print(); } } 报错原因：this.msg指向的是Inner类，而Inner类中没有msg属性。因此要访问Outer的msg属性，需要使用Outer.this.msg. class Outer { // 外部类 private String msg = &quot;Hello World&quot;; class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } public void fun() { new Inner().print(); } } 4.内部类的class文件名: Outer$Inner.class 直接实例化内部类对象语法：外部类.内部类 对象名 = new 外部类().new 内部类(); 范例：实例化内部类对象 public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.print(); } } 上述代码说明： 要想使用内部类对象，必须先实例化外部类对象。开发中一般是通过外部类访问内部类，不用创建内部类对象。 5.内部类只想被外部类使用，不能被外部调用，应使用private定义 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; private class Inner { // 内部类 public void print() { // 外部类.this = 外部类的当前对象 System.out.println(Outer.this.msg); } } } static定义内部类 使用static定义的属性或方法不受实例化对象控制，因此使用static定义的内部类也不受外部类实例化对象控制。 1.static定义的内部类只能访问外部类中static定义的属性或方法 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); // 报错，无法引用非静态变量msg } } } 2.static定义的内部类，相当于外部类 取得static定义的内部类对象语法：外部类.内部类 对象 = new 外部类.内部类();由该语法可知，static定义的内部类，不需要先实例化外部类对象，再实例化内部类对象，相当于内部类成了一个外部类。 class Outer { // 外部类 private static String msg = &quot;Hello World&quot;; static class Inner { // 内部类 public void print() { System.out.println(msg); } } } public class Demo { public static void main(String[] args) { Outer.Inner in = new Outer.Inner(); in.print(); } } 方法中定义内部类 1.内部类可定义在外部类中的任意位置。在方法中定义内部类是最常见的形式。 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun() { class Inner { // 定义在方法中的内部类 public void print() { System.out.println(msg); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(); } } 2.方法可以接收参数，也可以定义变量 范例：访问方法中定义的参数或变量 class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(int num) { // 方法参数 double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } } public class Demo { public static void main(String[] args) { new Outer().fun(100); } } 方法中的内部类可以访问方法中未用关键字修饰的参数或变量，该操作仅限于JDK1.8后！在JDK1.8之前的版本严格要求：方法中的内部类只能访问final标记的参数或变量，所以上述代码在JDK1.7前应该改为如下形式： class Outer { // 外部类 private String msg = &quot;Hello World&quot;; public void fun(final int num) { // 方法参数 final double score = 99.9; // 方法变量 class Inner { // 定义在方法中的内部类 public void print() { System.out.println(&quot;属性：&quot; + msg); System.out.println(&quot;方法参数：&quot; + num); System.out.println(&quot;方法变量：&quot; + score); } } new Inner().print(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(八)","slug":"Java Base/Java基础知识(八)","date":"2017-10-14T02:34:53.423Z","updated":"2017-10-21T05:58:52.668Z","comments":true,"path":"article/Java/Java Base/Java基础知识(八)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(八)/","excerpt":"","text":"对象比较 1.数字比较用==，字符串比较用equals(String str)。 要进行对象比较，必须对对象中所有属性的值进行比较。 范例：对象比较的基本方式 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.getTitle().equals(bkB.getTitle()) &amp;&amp; bkA.getPrice() == bkB.getPrice()) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 上述程序存在问题：主方法相当于客户端，客户端的程序逻辑应该越简单越好。所以对象比较应该由对象自己完成，即对象所对应的类应该提供对象比较的方法。 附：类的属性使用private封装，那么在类的外部就不能通过对象直接调用属性 class Info{ private String msg = &quot;Hello&quot;; public void print(){ System.out.println(&quot;msg = &quot; + this.msg); } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.msg = &quot;sss&quot;; // 报错，无法访问private属性 x.print(); } } 附：将一个对象作为参数传回类的方法中，相当于取消封装，使得对象可以直接访问属性。 class Info { private String msg = &quot;Hello&quot;; public void print() { System.out.println(&quot;msg = &quot; + this.msg); } public void fun(Info temp) { // 在类的内部直接利用对象访问私有属性 temp.msg = &quot;修改内容&quot;; } } public class Demo { public static void main(String[] args) { Info x = new Info(); x.fun(x); x.print(); // msg = 修改内容 } } 附：一个类接收本类对象形式的代码在对象比较时很常见。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } //省略无参构造方法和setter方法 public String getTitle() { return this.title; } public double getPrice() { return this.price; } // 类接收自身对象，对象可以直接访问属性，不需要getter方法 // compare()有两个功能：一带回了要比较的信息；二方便属性访问 public boolean compare(Book book) { if (book == null) { // 要比较的对象为空 return false; // 没必要比较 } if (this == book) { // 内存地址相同 return true; //避免具体比较，节约时间 } // 执行“bkA.equals(bkB)”时，有两个对象： // 一个为当前对象this(调用方法的对象，即bkA） // 一个为传递对象book(引用传递，即bkB） if (this.title.equals(book.title) &amp;&amp; this.price == book.price) { return true; } else { return false; } } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); if (bkA.compare(bkB)) { System.out.println(&quot;bkA和bkB是同一个对象！&quot;); } else { System.out.println(&quot;bkA和bkB是不同对象！&quot;); } } } 总结 （1）对象比较的方法必须定义在类中； （2）对象比较时一定要判断是否为null，内存地址是否相同，属性是否相同。 关键字static static 定义属性 问题引出： class Book { private String title; private double price; // 为操作方便，暂不封装 String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 对上述代码进行内存分析： 通过内存分析，发现属性重复：每个对象各自占有相同的属性值。假如有1000个该对象，要修改所有对象的pub属性，就需要分别进行修改。因此如果将pub属性定为普通属性，那每个堆内存都保存有各自的pub值。 1.但所有对象的pub值都一样，应将其定为一个共享的属性，即所有对象都指向同一块pub属性。可以利用static定义共享属性。 class Book { private String title; private double price; // 为操作方便，暂不封装 static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { Book bkA = new Book(&quot;Java开发&quot;, 79.5); Book bkB = new Book(&quot;JSP&quot;, 45.6); System.out.println(bkA.getInfo()); // 清华大学出版社 System.out.println(bkB.getInfo()); // 清华大学出版社 bkB.pub = &quot;北京大学出版社&quot;; System.out.println(bkA.getInfo()); // 北京大学出版社 System.out.println(bkB.getInfo()); // 北京大学出版社 } } 使用static定义属性后，只要有一个对象修改属性值，那么所有对象的该属性值都会改变，内存分析如下： 2. static定义的属性与普通属性区别在于保存数据的内存区域不同。 static定义的是公共属性，任由某个对象直接修改属性值是不合理的，应该由所有对象的代表进行属性访问，即用类访问。因此static定义的属性，可直接用类名调用：Book.pub = &quot;北京大学出版社&quot;; 3. static属性与普通属性的区别在于：普通属性必须由实例化的对象调用，而在没有实例化对象的情况下，static属性依然可以被调用。 public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，输出pub的内容 System.out.println(Book.pub); } } 由结果可知：static虽然定义在类中，但不受对象控制，是独立于类存在的。 4. 何时使用static定义属性 编写类时，static不是首选修饰符，当需要描述共享信息时，才使用static，方便集体修改，不用重复开辟内存空间。 static 定义方法 1.static定义的方法也可以直接被类名调用 class Book { private String title; private double price; // 为操作方便，暂不封装 private static String pub = &quot;清华大学出版社&quot;; public Book(String title, double price) { this.title = title; this.price = price; } public static void setPub(String p){ pub = p; } public String getInfo(){ return &quot;书名：&quot; + this.title + &quot;,价格：&quot; + this.price + &quot;,出版社：&quot; + this.pub; } } public class Demo { public static void main(String[] args) { // 没有实例化对象的情况下，调用方法 Book.setPub(&quot;北京大学出版社&quot;); Book bkA = new Book(&quot;Java开发&quot;, 79.5); System.out.println(bkA.getInfo()); // 北京大学出版社 } } 上述代码存在问题：类中有两种方法，static方法和普通方法，两种方法间的访问受到限制。 （1）static方法不能直接使用非static属性或方法，只能调用static属性或方法。 public static void setPub(String p){ pub = p; title = &quot;sss&quot;; // 报错，无法引用非静态变量 getInfo(); // 报错，无法引用非静态方法 System.out.println(this); // 报错，无法引用非静态变量 } （2）普通方法可以使用static属性或方法 public String getInfo(){ setPub(&quot;&quot;); // 不报错 return &quot;,出版社：&quot; + this.pub; // 不报错 } 出现上述限制的原因： |- 普通属性和方法必须在对象实例化后分配了堆内存空间，才可以使用； |- static定义的方法和属性，不受实例化对象控制，可在没有实例化对象情况下访问。 2.一个方法定义在主类中，并由主方法直接调用，该方法定义格式如下： public static 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 一个方法定义在类中，由对象直接调用，其语法格式如下： public 返回值类型 方法名(参数类型 参数, 参数类型 参数,...) { 方法体; [return [返回值] ;] // []中内容可写可不写 } 观察代码： public class Demo { public static void main(String[] args) { fun(); } public static void fun() { System.out.println(&quot;Hello World !&quot;); } } 没有static定义的fun()必须通过对象调用，主方法要使用fun()必须实例化对象 public class Demo { public static void main(String[] args) { // 产生对象，再利用对象调用非static方法 new Demo().fun(); } public void fun() { System.out.println(&quot;Hello World !&quot;); } } 定义类中方法时，static不是首选修饰符，因为每个对象可以利用自己的属性实现方法的不同调用。 class Flag { private boolean flag; public Flag(boolean flag) { this.flag = flag; } public void fun() { if (this.flag) { System.out.println(&quot;可以操作&quot;); } else { System.out.println(&quot;不可以操作&quot;); } } } public class Demo { public static void main(String[] args) { Flag fA = new Flag(true); Flag fB = new Flag(false); fA.fun(); fB.fun(); } } 当一个类中没有属性，只有方法时，建议将所有方法定义为static方法。这样就不用每次调用时都需要有实例化对象。 class MyMath { public static int add(int x, int y) { return x + y; } } public class Demo { public static void main(String[] args) { System.out.println(MyMath.add(10, 20)); } } 主方法 1.主方法的组成： 组成 作用 public 主方法是程序的开始，所以主方法必须是可见、public（公共的）的 static 证明此方法可直接由类名调用 void 主方法是程序的开始，因此不能回头，执行完为止，所以不能有返回值 main 系统规定好的方法名，不能修改 String [] args 指的是程序运行时传递的参数 范例：对主方法传入参数 public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; args.length ; x++) { System.out.println(args[x]); // 未输出参数，为空 } } } 多个参数时，必须使用空格分割。cmd执行的是java Demo 1 3 4 6 输出为：1 3 4 6 如果参数本身带有空格，需用&quot;&quot;描述 cmd执行的是java Demo &quot;Hello world&quot; &quot;Hello Java&quot; static应用案例 已知： （1）多个对象，都使用同一个static属性； （2）static定义方法可以避免实例化对象调用方法的限制。 1.实现对实例化对象个数的统计 要求：每实例化一个对象，就输出&quot;这是第x个实例化对象&quot; 思路：每次实例化对象，就会调用构造方法，因此可在构造方法中增加一个统计数据的操作，每当新对象产生，该属性值就自增加一。 class Book { private static int num = 0; public Book() { num++; System.out.println(&quot;这是第&quot; + num + &quot;个实例化对象&quot;); } } public class Demo { public static void main(String[] args) { new Book(); new Book(); new Book(); } } 2.实现属性的自动设置 要求：类中有一个无参构造方法，一个有参构造方法，有参构造方法的功能是传递title值。不论调用的哪个构造方法，均可为title赋值，且属性值尽量不重复。 class Book { private String title; private static int num = 0; public Book() { this(&quot;Title:No.&quot; + num++); } public Book(String title){ this.title = title; } public String getTitle(){ return this.title; } } public class Demo { public static void main(String[] args) { System.out.println(new Book(&quot;Java开发&quot;).getTitle()); // Java开发 System.out.println(new Book().getTitle()); // Title:No.0 System.out.println(new Book().getTitle()); // Title:No.1 } } 总结 （1）类定义属性或方法首时选不是static属性或方法； （2）static属性或方法可直接用类名调用； （3）static属性保存在全局数据区。 （4）内存区有四种: 栈内存（对象的地址），堆内存（普通属性），全局数据区（static属性），全局代码区（所有的方法）","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(七)","slug":"Java Base/Java基础知识(七)","date":"2017-10-14T02:00:14.041Z","updated":"2017-10-21T05:58:03.232Z","comments":true,"path":"article/Java/Java Base/Java基础知识(七)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(七)/","excerpt":"","text":"引用传递分析实例 引用传递 1.引用传递核心意义：同一块堆内存可以被不同栈内存所指向，不同栈内存可以对同一块堆内存进行修改。 范例：引用传递 public class Message { private int num = 10; public Message(int num) { this.num = num; } public int getNum() { return num; } public void setNum(int num) { this.num = num; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(30); System.out.println(msg.getNum()); // 30 fun(msg); // 引用传递 System.out.println(msg.getNum()); // 100 } public static void fun(Message temp) { temp.setNum(100); } } 对上述代码进行内存分析： 2.引用 public class Demo { public static void main(String[] args) { String msg = &quot;Hello&quot;; fun(msg); System.out.println(msg); // Hello } public static void fun(String temp) { temp = &quot;World&quot;; } } 出现上述结果原因：String对象的内容一旦声明不可改变，对象内容的改变依靠的是引用地址的改变。内存分析如下： 3.引用传递 public class Message { private String info = &quot;nihao&quot;; public Message(String info) { this.info = info; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } public class TMessage { public static void main(String[] args) { Message msg = new Message(&quot;Hello&quot;); System.out.println(msg.getInfo()); // Hello fun(msg); System.out.println(msg.getInfo()); // World } public static void fun(Message temp) { temp.setInfo(&quot;World&quot;); } } 内存分析如下： 上述内存分析，是按照int型数据的特点进行的。实际info是String对象，应该按照如下方式进行分析： 结论：虽然String是一个类，属于引用数据类型，但由于其内容不可改的特点，我们常将其当作基本数据类型。即每个String变量只能保存一个数据。 引用传递实例 要求：通过面向对象的方式描述每个人有车或没车。 实现步骤： 1.创建数据库：应设计两张表:汽车表和人员表; 2.根据数据表，定义两个类： （编写简单java类时，可按照数据表的设计来写，规则如下： 类名 = 表名； 属性名(类型) = 表字段(类型); 一个实例化对象 = 一行记录； 多个实例化对象 = 多行记录 引用关系 = 外键描述） public class Member { private int mId; private String name; } public class Car { private String pName; } 3.利用引用来描述两个类的外键，从而使得两个类有联系 public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } } 4.当两个类的对象产生，为这两个对象设置彼此的关系： public class Member { private int mId; private String name; // 有Car类实例化对象表示有车 // Car为null表示没车 private Car car; public Member(int mId, String name) { this.mId = mId; this.name = name; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } public String getInfo() { return &quot;人员编号：&quot; + this.mId + &quot;,姓名：&quot; + this.name; } } public class Car { private Member member; // 车属于一个人 private String pName; public Car(String pName) { this.pName = pName; } public String getInfo() { return &quot;车名：&quot; + this.pName; } public Member getMember() { return member; } public void setMember(Member member) { this.member = member; } } 5.测试 测试分为两步： （1）根据定义的结构关系设置数据 （2）根据定义的结构关系取出数据 public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Car c = new Car(&quot;宝马&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); } } 6.进一步设计：每个人都有孩子，孩子还可能有车 思路： （1）设计一个孩子类，如有孙子，在设计孙子类，以此类推。该方案过于冗余，不合适； （2）在Member类中设计属性child，类型为Member： private Member child; // 孩子 public Member getChild() { return child; } public void setChild(Member child) { this.child = child; } 测试： public class TCar { public static void main(String[] args) { // 1. 设置数据 Member m = new Member(1,&quot;张三&quot;); Member child = new Member(1,&quot;张四&quot;); Car c = new Car(&quot;宝马&quot;); Car cc =new Car(&quot;法拉利&quot;); // 设置车与人的关系：张三有辆宝马 m.setCar(c); c.setMember(m); // 设置车与人的关系：张四有辆法拉利 child.setCar(cc); c.setMember(child); // 设置人与人的关系：张四是张三的儿子 m.setChild(child); // 2. 取出数据 // 通过人找到车 System.out.println(m.getCar().getInfo()); // 通过车找到人 System.out.println(c.getMember().getInfo()); // 通过人找到孩子 System.out.println(m.getChild().getInfo()); // 通过人找到孩子的车 System.out.println(m.getChild().getCar().getInfo()); } } 7.利用引用描述电脑：电脑由主机、键盘、内存、CPU、显卡等组成，下面用伪代码描述： class 键盘{} class 鼠标{} class CPU{} class 硬盘{} class 内存{} class 显示器{} class 主机{} class 主板{} class 主机{ private CPU 对象[]; private 硬盘 对象[]; private 主板 对象; private 内存 对象[]; } class 电脑{ private 主机 对象; private 显示器 对象; private 键盘 对象; private 鼠标 对象; } 上述设计思路称为合成设计模式。引用是实现两个不同类之间互相关联的主要手段。 数据表与简单Java类映射 要求：通过程序描述部门和雇员关系 属性： ·dept：deptno,dname,loc; ·emp：empno, ename,job,sal,comm,deptno,mgr 关系： ·一个部门有多个雇员； ·一个雇员有一个或零个领导。 第一步： 根据数据表创建简单java类 /** * 部门类 */ public class Dept { private int depNo; // 编号 private String dName; // 名字 private String address; // 地址 // setter,getter,无参构造方法略 public Dept(int depNo, String dName, String address) { this.depNo = depNo; this.dName = dName; this.address = address; } public String getInfo() { return &quot;部门编号：&quot; + this.depNo + &quot;,部门名称：&quot; + this.dName + &quot;,地址：&quot; + this.address; } } /** * 员工类 */ public class Emp { private int eNo; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // setter,getter,无参构造方法略 public Emp(int eNo, String eName, String job, double sal, double comm) { this.eNo = eNo; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } public String getInfo() { return &quot;编 号&quot; + this.eNo + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：设置外键关系 · 一个雇员属于一个部门，应在雇员类中保存部门信息 private Dept dept; // 对应的部门信息 public Dept getDept() { return dept; } public void setDept(Dept dept) { this.dept = dept; } · 一个部门有的多个雇员，可用数组在部门类中保存雇员信息： private Emp emps[]; // 多个雇员信息 public Emp[] getEmps() { return emps; } public void setEmps(Emp[] emps) { this.emps = emps; } · 一个雇员有一个领导（定义在Emp类中） private Emp mgr; // 领导信息 public Emp getMgr() { return mgr; } public void setMgr(Emp mgr) { this.mgr = mgr; } 第三步：测试 （1）设置数据： public class Demo { public static void main(String[] args) { // 1. 产生对象 Dept dept = new Dept(10, &quot;财务部&quot;, &quot;北京&quot;); // 部门信息 // 员工信息 Emp eA = new Emp(1111, &quot;张三&quot;, &quot;保安&quot;, 800.0, 0.0); Emp eB = new Emp(1101, &quot;李四&quot;, &quot;秘书&quot;, 2800.0, 500.0); Emp eC = new Emp(1001, &quot;王五&quot;, &quot;经历&quot;, 6800.0, 1500.0); // 2. 设置员工与领导关系 eA.setMgr(eB); eB.setMgr(eC); // 3. 设置员工和部门关系 eA.setDept(dept); eB.setDept(dept); eC.setDept(dept); dept.setEmps(new Emp[]{eA, eB, eC}); } } （2）：根据给定的结构取出数据，要求如下： |-根据一个雇员查询他所对应的领导信息和部门信息； |-根据一个部门查询所有雇员以及其所对应的领导信息； // 第二步：取出数据 // 1. 通过员工找到领导信息和部门信息 System.out.println(eA.getInfo()); // 获取员工信息 System.out.println(&quot;\\t|-&quot; + eA.getMgr().getInfo()); // 获取领导信息 System.out.println(&quot;\\t|-&quot; + eA.getDept().getInfo()); // 获取部门信息 // 2. 根据部门找到所有员工及其领导信息 System.out.println(&quot;---------------------------------------------&quot;); System.out.println(dept.getInfo()); for (int x = 0; x &lt; dept.getEmps().length; x++) { System.out.println(&quot;\\t|-&quot; + dept.getEmps()[x].getInfo()); // 获取员工信息 if (dept.getEmps()[x].getMgr() != null) { System.out.println(&quot;\\t\\t|-&quot; + dept.getEmps()[x].getMgr().getInfo()); // 获取领导信息 } } 上述代码都是依靠代码链取出数据。 一对多映射 要求：通过程序描述省份和城市的关系 1.通过一个城市找到它对应的省份信息； 2.通过一个省份找到所有城市的信息。 class Province { private int pId; private String pName; private City cities[]; // getter,setter,无参构造方法略 public Province(int pId, String pName) { this.pId = pId; this.pName = pName; } public City[] getCities() { return cities; } public void setCities(City[] cities) { this.cities = cities; } public String getInfo() { return &quot;省份ID：&quot; + this.pId + &quot;，省名：&quot; + this.pName; } } class City { private int cId; private String cName; private Province province; // getter,setter,无参构造方法略 public City(int cId, String cName) { this.cId = cId; this.cName = cName; } public Province getProvince() { return province; } public void setProvince(Province province) { this.province = province; } public String getInfo() { return &quot;城市ID：&quot; + this.cId + &quot;，市名：&quot; + this.cName; } } public class Demo { public static void main(String[] args) { Province province = new Province(350, &quot;福建省&quot;); City cA = new City(1, &quot;福州&quot;); City cB = new City(2, &quot;厦门&quot;); City cC = new City(3, &quot;泉州&quot;); cA.setProvince(province); cB.setProvince(province); cC.setProvince(province); province.setCities(new City[]{cA, cB, cC}); System.out.println(cA.getInfo()); System.out.println(&quot;\\t|-&quot; + cA.getProvince().getInfo()); System.out.println(&quot;==================================&quot;); System.out.println(province.getInfo()); for (int x = 0; x &lt; province.getCities().length; x++) { System.out.println(&quot;\\t|-&quot; + province.getCities()[x].getInfo()); } } } 上述代码存在不足：每次添加城市，就要修改数组的引用关系 双向一对多映射 要求：通过程序描述类型-子类型-商品的关系 （1）通过一个类型找到它对应的子类型； （2）过一个类型找到它所对应的商品； （3）通过一个子类型找到所有对应的商品。 class Type { private int tId; private String tName; private SonType sonTypes[]; private Product products[]; // getter,setter,无参构造方法略 public Type(int tId, String tName) { this.tId = tId; this.tName = tName; } public SonType[] getSontypes() { return this.sonTypes; } public void setSontypes(SonType[] sontypes) { this.sonTypes = sontypes; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;类型编号：&quot; + this.tId + &quot;,类型名称：&quot; + this.tName; } } class SonType { private int sId; private String sName; private Type type; private Product products[]; // getter,setter,无参构造方法略 public SonType(int sId, String sName) { this.sId = sId; this.sName = sName; } public int getsId() { return sId; } public void setsId(int sId) { this.sId = sId; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public Product[] getProducts() { return products; } public void setProducts(Product[] products) { this.products = products; } public String getInfo() { return &quot;子类型编号：&quot; + this.sId + &quot;,子类型名称：&quot; + this.sName; } } class Product { private int pId; private String name; private double price; private Type type; private SonType sonType; // getter,setter,无参构造方法略 public Product(int pId, String name, double price) { this.pId = pId; this.name = name; this.price = price; } public Type getType() { return type; } public void setType(Type type) { this.type = type; } public SonType getSonType() { return sonType; } public void setSonType(SonType sonType) { this.sonType = sonType; } public String getInfo() { return &quot;商品编号：&quot; + this.pId + &quot;,商品名称：&quot; + this.name + &quot;,价格：&quot; + this.price; } } public class Demo { public static void main(String[] args) { Type type = new Type(1, &quot;家电类&quot;); SonType stA = new SonType(11, &quot;小型家电&quot;); SonType stB = new SonType(12, &quot;大型家电&quot;); Product pA = new Product(111, &quot;剃须刀&quot;, 99.0); Product pB = new Product(112, &quot;热水壶&quot;, 29.0); Product pC = new Product(121, &quot;电冰箱&quot;, 1199.0); Product pD = new Product(122, &quot;电热水器&quot;, 399.0); stA.setType(type); stB.setType(type); pA.setType(type); pB.setType(type); pC.setType(type); pD.setType(type); type.setSontypes(new SonType[]{stA, stB}); type.setProducts(new Product[]{pA, pB, pC, pD}); pA.setSonType(stA); pB.setSonType(stA); pC.setSonType(stB); pD.setSonType(stB); stA.setProducts(new Product[]{pA, pB}); stB.setProducts(new Product[]{pC, pD}); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getSontypes().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getSontypes()[x].getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(type.getInfo()); for (int x = 0; x &lt; type.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + type.getProducts()[x].getInfo()); System.out.println(&quot;\\t\\t|- &quot; + type.getProducts()[x].getSonType().getInfo()); } System.out.println(&quot;--------------------------------------&quot;); System.out.println(stA.getInfo()); for (int x = 0; x &lt; stA.getProducts().length; x++) { System.out.println(&quot;\\t|- &quot; + stA.getProducts()[x].getInfo()); } } } 多对多映射 要求：通过程序描述管理员-角色-组-权限的关系； （1）根据一个管理员找到它对应的角色，以及每个角色包含的所有权限组的信息，以及每个权限组所包含的权限的内容； （2）根据一个权限组找到所有具备此权限组的角色以及每个角色所拥有的管理员信息； 角色_权限组表是关系表，保存的是两个外键的关联关系，不需要为其生成映射类。只有实体表才需要生成映射类，多对多的中间转换表只需通过类属性的关系引用即可。 class Admin { private String aid; private String password; private Role role; public void setRole(Role role) { this.role = role; } public Role getRole() { return this.role; } public Admin(String aid, String password) { this.aid = aid; this.password = password; } public String getInfo() { return &quot;管理员编号:&quot; + this.aid + &quot;，管理员密码：&quot; + this.password; } } class Role { private int rid; private String title; private Admin admins[]; private Group groups[]; public void setAdmins(Admin admins[]) { this.admins = admins; } public Admin[] getAdmins() { return this.admins; } public void setGroups(Group groups[]) { this.groups = groups; } public Group[] getGroups() { return this.groups; } public Role(int rid, String title) { this.rid = rid; this.title = title; } public String getInfo() { return &quot;角色编号：&quot; + this.rid + &quot;，角色名称&quot; + this.title; } } class Group { private int gid; private String title; private Role roles[]; private Action actions[]; public void setActions(Action actions[]) { this.actions = actions; } public Action[] getActions() { return this.actions; } public void setRoles(Role roles[]) { this.roles = roles; } public Role[] getRoles() { return this.roles; } public Group(int gid, String title) { this.gid = gid; this.title = title; } public String getInfo() { return &quot;权限组编号：&quot; + this.gid + &quot;，权限组名称：&quot; + this.title; } } class Action { private int aid; private String title; private String url; private Group group; public void setGroup(Group group) { this.group = group; } public Group getGroup() { return this.group; } public Action(int aid, String title, String url) { this.aid = aid; this.title = title; this.url = url; } public String getInfo() { return &quot;权限编号：&quot; + this.aid + &quot;权限名称：&quot; + this.title + &quot;,权限路径：&quot; + this.url; } } public class Demo { public static void main(String[] args) { Admin a1 = new Admin(&quot;admin&quot;, &quot;123456&quot;); Admin a2 = new Admin(&quot;root&quot;, &quot;654321&quot;); Admin a3 = new Admin(&quot;guest&quot;, &quot;654321&quot;); Role r1 = new Role(1, &quot;系统管理员&quot;); Role r2 = new Role(1, &quot;信息管理员&quot;); Group g1 = new Group(10, &quot;信息管理&quot;); Group g2 = new Group(11, &quot;用户管理&quot;); Group g3 = new Group(12, &quot;数据管理&quot;); Group g4 = new Group(13, &quot;接口管理&quot;); Group g5 = new Group(14, &quot;备份管理&quot;); Action ac1 = new Action(1001, &quot;新闻发布&quot;, &quot;-&quot;); Action ac2 = new Action(1002, &quot;新闻列表&quot;, &quot;-&quot;); Action ac3 = new Action(1003, &quot;新闻审核&quot;, &quot;-&quot;); Action ac4 = new Action(1004, &quot;增加用户&quot;, &quot;-&quot;); Action ac5 = new Action(1005, &quot;用户列表&quot;, &quot;-&quot;); Action ac6 = new Action(1006, &quot;登陆日志&quot;, &quot;-&quot;); Action ac7 = new Action(1007, &quot;雇员数据&quot;, &quot;-&quot;); Action ac8 = new Action(1008, &quot;部门数据&quot;, &quot;-&quot;); Action ac9 = new Action(1009, &quot;公司数据&quot;, &quot;-&quot;); Action ac10 = new Action(1010, &quot;服务传输&quot;, &quot;-&quot;); Action ac11 = new Action(1011, &quot;短信平台&quot;, &quot;-&quot;); Action ac12 = new Action(1012, &quot;全部备份&quot;, &quot;-&quot;); Action ac13 = new Action(1013, &quot;局部备份&quot;, &quot;-&quot;); a1.setRole(r1); a2.setRole(r2); a3.setRole(r2); r1.setAdmins(new Admin[]{a1}); r2.setAdmins(new Admin[]{a2, a3}); r1.setGroups(new Group[]{g1, g2, g3, g4, g5}); r2.setGroups(new Group[]{g1, g2}); g1.setRoles(new Role[]{r1, r2}); g2.setRoles(new Role[]{r1, r2}); g3.setRoles(new Role[]{r1}); g4.setRoles(new Role[]{r1}); g5.setRoles(new Role[]{r1}); g1.setActions(new Action[]{ac1, ac2, ac3}); g2.setActions(new Action[]{ac4, ac5, ac6}); g3.setActions(new Action[]{ac7, ac8, ac9}); g4.setActions(new Action[]{ac10, ac11}); g5.setActions(new Action[]{ac12, ac13}); ac1.setGroup(g1); ac2.setGroup(g1); ac3.setGroup(g1); ac4.setGroup(g2); ac5.setGroup(g2); ac6.setGroup(g2); ac7.setGroup(g3); ac8.setGroup(g3); ac9.setGroup(g3); ac10.setGroup(g4); ac11.setGroup(g4); ac12.setGroup(g5); ac13.setGroup(g5); System.out.println(a1.getInfo()); System.out.println(a1.getRole().getInfo()); for (int x = 0; x &lt; a1.getRole().getGroups().length; x++) { System.out.println(&quot;\\t|-&quot; + a1.getRole().getGroups()[x].getInfo()); for (int y = 0; y &lt; a1.getRole().getGroups()[x].getActions().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + a1.getRole().getGroups()[x].getActions()[y].getInfo()); } } System.out.println(&quot;-------------------------------------------------&quot;); System.out.println(g2.getInfo()); for (int x = 0; x &lt; g2.getRoles().length; x++) { System.out.println(g2.getRoles()[x].getInfo()); for (int y = 0; y &lt; g2.getRoles()[x].getAdmins().length; y++) { System.out.println(&quot;\\t\\t|-&quot; + g2.getRoles()[x].getAdmins()[y].getInfo()); } System.out.println(); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Centos7上部署Docker私有仓库","slug":"Docker/Centos7上部署Docker私有仓库","date":"2017-10-11T11:45:51.144Z","updated":"2017-10-11T12:00:20.426Z","comments":true,"path":"article/容器/Docker/Centos7上部署Docker私有仓库/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Centos7上部署Docker私有仓库/","excerpt":"","text":"Docker除了官网的docker hub外，还可以利用官方的镜像搭建自己的私有仓库。 环境准备 系统要求 要求 说明 系统 Centos 7 内核 4.13.5-1.el7.elrepo.x86_64 仓库地址 10.0.0.128:5000 docker 1.12.6 关闭防火墙 $ systemctl stop firewalld.service $ systemctl disable firewalld.service $ vim /etc/sysconfig/selinux SELINUX=disabled 搭建Docker私有仓库 搭建仓库 $ docker pull registry // 拉取官方镜像 $ docker run -d -p 5000:5000 --restart=always --name myHub registry // 运行官方镜像 $ curl localhost:5000/v2/_catalog // 查看私有镜像仓库,此时为空 {&quot;repositories&quot;:[]} 修改配置文件 $ vim /etc/sysconfig/docker OPTIONS='--insecure-registry 10.0.0.128:5000' $ systemctl restart docker 上传镜像到私有仓库 $ docker tag mysql 10.0.0.128:5000/mysql:0.1 // docker tage image_name registry_ip:port/images_name:tag $ docker push 10.0.0.128:5000/mysql:0.1 // 上传镜像 $ curl localhost:5000/v2/_catalog // 查看仓库镜像 {&quot;repositories&quot;:[&quot;mysql&quot;]}","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(六)","slug":"Java Base/Java基础知识(六)","date":"2017-10-09T01:00:49.117Z","updated":"2017-10-21T05:58:59.879Z","comments":true,"path":"article/Java/Java Base/Java基础知识(六)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(六)/","excerpt":"","text":"关键字this this调用属性 class Book { private String title; private double price; public Book(String t, double p) { title = t; price = p; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); System.out.println(book.getInfo()); } } 上述代码中，构造方法的功能是为title和price进行初始化，但是存在不足：方法中的参数名t和p无法表示具体含义。构造方法的功能是为类的属性初始化，参数名最好与属性名一致。 public Book(String title, double price) { title = title; price = price; } 修改后，发现构造方法中的参数值并未传递到属性中。这是因为java代码以”{}”为界限，当属性名与参数名一致时，默认情况下，找到的是最近的{}的变量名，即数据传到构造方法后，并未传到属性中。为了明确要访问的变量是类的属性，应在变量名前加this。 public Book(String title, double price) { this.title = title; this.price = price; } 在开发中，只要访问类中属性，前面必须加this。 this调用方法 1.this指的是当前对象，一个类除了属性还有方法，因此可以利用this调用方法。 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public void print() { System.out.println(&quot;*********&quot;); } // setter和getter方法略 public String getInfo() { this.print(); return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 在类中调用普通方法，加不加this都一样。但为了代码的严谨性，最好加this。 2.this调用构造方法 多个构造方法间互相调用: this(参数1, 参数2…); 范例：Book类中有三个构造方法，要求不论调用哪个构造方法都会输出一行提示信息一个新的Book类对象产生 class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; } public Book(String title, double price) { System.out.println(&quot;一个新的Book类对象产生&quot;); this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在重复，要消除重复代码： class Book { private String title; private double price; public Book() { System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码中存在限制： （1）利用this调用构造方法的语句只能放在构造方法首行； （2）普通方法无法调用构造方法； （3）构造方法互相调用时，一定要保留调用的出口，即必须有个构造方法没有调用其他构造方法。 class Book { private String title; private double price; public Book() { // 报错，构造递归调用 this(&quot;Book&quot;,1.1); System.out.println(&quot;一个新的Book类对象产生&quot;); } public Book(String title) { this(); // 调用本类中的无参构造 this.title = title; } public Book(String title, double price) { this(title); // 调用本类中的单参构造方法 this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } 上述代码会出现”构造方法递归调用”错误，说明构造方法互相调用时，必须至少有一个构造方法没有使用”this()”调用其它构造方法。 3.**范例：**定义一个雇员类（编号，姓名，工资，部门），类中有4个构造方法; （1）无参构造：编号为0，姓名“无名氏”，工资为0.0，部门为”未定”； （2）单参构造（传递编号）：姓名“临时工”，工资为800.0，部门为”后勤部”； （3）双参构造（传递编号、姓名）：工资为2000.0，部门为”技术部”； （4）四参构造 实现方式1：不使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this.empNo = 0; this.eName = &quot;无名氏&quot;; this.sal = 0.0; this.dept = &quot;未定&quot;; } public Emp(int empNo) { this.empNo = empNo; this.eName = &quot;临时工&quot;; this.sal = 800.0; this.dept = &quot;后勤部&quot;; } public Emp(int empNo, String eName) { this.empNo = empNo; this.eName = eName; this.sal = 2000.0; this.dept = &quot;技术部&quot;; } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 实现方式2：使用this class Emp { private int empNo; private String eName; private double sal; private String dept; public Emp() { this(0,&quot;无名氏&quot;,0.0,&quot;&quot;); } public Emp(int empNo) { this(empNo,&quot;临时工&quot;,800.0,&quot;后勤部&quot;); } public Emp(int empNo, String eName) { this(empNo,eName,2000.0,&quot;技术部&quot;); } public Emp(int empNo, String eName, double sal, String dept) { this.empNo = empNo; this.eName = eName; this.sal = sal; this.dept = dept; } // setter和getter方法略 public String getInfo() { return &quot;雇员编号：&quot; + this.empNo + &quot;\\n&quot; + &quot;姓 名：&quot; + this.eName + &quot;\\n&quot; + &quot;工 资：&quot; + this.sal + &quot;\\n&quot; + &quot;部 门：&quot; + this.dept; } } 通过构造方法互相调用解决了代码重复问题。 当前对象 当前对象指的是当前正在调用类中属性或方法的对象 class Book { public void print() { // 哪个对象调用了print(),this就与该对象指向同一块内存地址 // this就是当前调用方法的对象 System.out.println(&quot;this = &quot; + this); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); System.out.println(&quot;bkA = &quot; + bkA); // bkA = com.java.demo.Book@1540e19d bkA.print(); // this = com.java.demo.Book@1540e19d System.out.println( &quot;===============&quot;); Book bkB = new Book(); // bkB = com.java.demo.Book@677327b6 System.out.println(&quot;bkB = &quot; + bkB); // this = com.java.demo.Book@677327b6 bkB.print(); } } class A{ private B b; public A(){ // 2.执行A类构造方法 // 3. 实例化B类对象b，调用B类构造方法 this.b = new B(this); //此时this是temp this.b.get(); // 5. 通过b调用B类的get() } public void print(){ //8. 执行该方法 System.out.println(&quot;Hello World !&quot;); } } class B{ private A a; public B(A a){ // A a = temp this.a = a; // 4. 执行B类构造方法 } public void get(){ // 6. 执行该方法 this.a.print(); // 7. 调用A类的print() } } public class Demo { public static void main(String[] args) { // 1.实例化A类对象，调用A类的无参构造方法 A temp = new A(); // Hello World ! } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(五)","slug":"Java Base/Java基础知识(五)","date":"2017-10-03T13:33:39.028Z","updated":"2017-10-21T05:58:42.729Z","comments":true,"path":"article/Java/Java Base/Java基础知识(五)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(五)/","excerpt":"","text":"String类的特点及使用 JDK_API文档由下面几部分组成： （1）类的定义以及相关的继承结构 （2）类的简短说明 （3）类的成员组成 （4）类所提供的构造方法 （5）类所提供的普通方法 （6）类的成员，构造方法，普通方法的详细说明 deprecated标记表示不再建议使用。 String对象的两种实例化方式 1.String是字符串类,下面将类的角度与内存关系分析其作用： （1）直接赋值String value_name = &quot;字符串&quot; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // 直接赋值 System.out.println(str); } } （2）构造方法public String (String str); public class Demo { public static void main(String[] args) { String str = new String(&quot;Hello World !&quot;); System.out.println(str); } } 字符串比较 1.判断两个int数据是否相等： public class Demo { public static void main(String[] args) { int x = 10; int y = 10; System.out.println(x == y); // true } } 使用==判断String对象是否相等： public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA == strB); // false System.out.println(strA == strC); // false System.out.println(strB == strC); // true } } 对上述代码进行内存分析： 由内存分析可知，String对象使用==比较时，比较的是对象的栈内存地址的值。 2.要比较字符串的内容，应使用String类中的方法public boolean equals（String str） public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = new String(&quot;Hello&quot;); String strC = strB; System.out.println(strA.equals(strB)); // true System.out.println(strA.equals(strC)); // true } } 开发中，字符串比较应用equals(String str). 3.章节例题：==与equals(String str)的区别 ==是关系运算符，用于判断数值相等，当用于String对象时对比的是两个对象的栈内存地址的值; equals(String str)是String类的方法，用于比较字符串内容。 String常量是匿名对象 1.编程语言中没有字符串概念，很多语言使用字符数组描述字符串。Java开发由于离不开字符串的使用，便创造了字符串，但不属于基本数据类型，而是将字符串作为String类的匿名对象。 范例：验证字符串是匿名对象 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; System.out.println(&quot;Hello&quot;.equals(str)); } } 2.直接赋值的方式相当于给匿名对象设置了对象名，区别是String匿名对象是系统自动生成，不需要由用户实例化. public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (input.equals(&quot;hello&quot;)){ System.out.println(&quot;Hello World !&quot;); // 报错，NullPointerException } } } 为预防用户输入错误导致input为null，而后调用equals()，出现空指针异常，应使用如下代码： public class Demo { public static void main(String[] args) { String input = null; // 假设该内容是用户输入的 if (&quot;hello&quot;.equals(input)){ System.out.println(&quot;Hello World !&quot;); } } } 使用上述代码将不会出现空指针异常，因此在判断用户输入的内容是否符合预期时，应将指定字符串放在equals()前。 两种实例化方式的区别 1.直接赋值 直接赋值就是给字符串匿名对象设置对象名。 此时内存中会开辟堆内存，并且有一块栈内存指向堆内存： 观察下列代码： public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = &quot;hello&quot;; String strC = &quot;hello&quot;; String strD = &quot;world&quot;; System.out.println(strA == strB); // true System.out.println(strA == strC); // true System.out.println(strB == strC); // true System.out.println(strA == strD); // false } } 由上述结果可知，strA，strB，strC都指向同一块堆内存： 共享设计模式：JVM底层存在一个对象池，保存有对象。当使用直接赋值定义String对象时，会将该对象使用的匿名对象入池保存。而后如果有其他String对象也采用直接赋值方式且内容相同时，便不再开辟新的堆内存，而是引用对象池中已有的匿名对象。 2.构造方法实例化 使用构造方法定义String对象，就需要每次开辟新的堆内存。 由内存分析可知，使用构造方法实例化时开辟了两块堆内存，并且其中一块会成为垃圾。 public class Demo { public static void main(String[] args) { String strA = new String(&quot;hello&quot;); String strB = &quot;hello&quot;; System.out.println(strA == strB); // false } } 除了内存的浪费外，使用构造方法定义的String对象，其内容不会保存在对象池中，因为每次开辟的都是新的堆内存。如果希望开辟的新的的堆内存也进入对象池保存，可以使用public String intern()手工入池。 3.章节小题：String对象两种定义方式的区别 · 直接赋值只开辟一块堆内存，且会自动保存在对象池中，以便下次使用； · 构造方法赋值会开辟两块堆内存，其中一块会成为垃圾，不会自动入池，但可以使用”intern()”手工入池。 字符串内容不可改变 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str += &quot; World&quot;; str += &quot; !!!&quot;; System.out.println(str); } } 对上述代码进行内存分析： 分析后可知，字符串内容并未改变（Java规定String对象内容不可变）,字符串内容的变动实际是引用关系的变化,每次都会出现垃圾。因此字符串内容不要频繁改动。 String类常用方法(字符与字符串) 很多语言利用字符数组描述字符串，Java中String类的方法也有相似方法： No. 方法名称 类型 描述 1 public String (char[] value) 构造 将字符数组变为String类对象 2 public String (char[] value ,int offset,int count) 构造 将部分字符数组变为String对象 3 public char charAt (int index) 普通 返回指定索引对应的字符信息 4 public char[] toCharArray() 普通 将字符串以字符数组的形式返回 范例：取出指定索引的字符 public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; char c = str.charAt(0); System.out.println(c); // H } } 范例：将字符串转大写 public class Demo { public static void main(String[] args) { String str = &quot;hello&quot;; char [] data = str.toCharArray(); // 字符串转为字符数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 小写编码 - 32 = 大写编码 } // 将字符数组变为字符串 System.out.println(new String(data)); // HELLO // 将部分字符数组变为String对象 System.out.println(new String(data, 1, 2)); // EL } } 范例：判断一个字符换是否为纯数字 思路：对字符串整体进行判断是无法实现的，但是可以将字符串转为字符数组，判断每一个字符是否为数字。 public class Demo { public static void main(String[] args) { String str = &quot;3146017052&quot;; if (isNumber(str)) { System.out.println(&quot;字符串全部由数字组成&quot;); } else { System.out.println(&quot;字符串不是全部由数字组成&quot;); } } // 定义判断字符串是否由数字组成的方法 public static boolean isNumber(String temp) { // 首先将字符串变为字符数组 char[] data = temp.toCharArray(); // 一一比较字符 for (int x = 0; x &lt; data.length; x++) { if (data[x] &gt; '9' || data[x] &lt; '0') { return false; } } // 全部为数字则返回true return true; } } 建议：返回值为boolean的方法命名为isXxx。 String类常用方法(字节与字符串) 字节使用byte描述，一般用于数据传输或编码转换。String提供了将字符数组变为字节数组的方法。 No. 方法名称 类型 描述 1 public String (byte[] bytes) 构造 将字节数组变为字符串 2 public String (byte[] bytes ,int offset,int length) 构造 将部分字节数组变为字符串 3 public byte[] getBytes (String charsetName) throws UnsupportedEncodingException 普通 进行编码转换 4 public byte[] getBytes() 普通 将字符串变为字节数组 范例：字符串与字节数组的转换 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; byte [] data = str.getBytes(); // 将字符串转为字节数组 for (int x = 0; x &lt; data.length ; x++) { data[x] -= 32; // 将小写字母转为大写字母 } System.out.println(new String(data)); // HELLOWORLD System.out.println(new String(data,5,5)); // WORLD } } String类常用方法(字符串比较) No. 方法名称 类型 描述 1 public boolean equals(String anotherString) 普通 进行内容判断，区分大小写 2 public boolean equalsIgnoreCase(String anotherString) 普通 进行内容判断，不区分大小写 3 public int compareTo (String anotherString) 普通 判断两个字符串的大小（按照字符编码）,返回值为0,1,-1 范例：equals()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 } } 范例：equalsIgnoreCase()判断 public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.equals(strB)); // false,说明区分大小写 System.out.println(strA.equalsIgnoreCase(strB)); // true,说明不区分大小写 } } 范例：compareTo() public class Demo { public static void main(String[] args) { String strA = &quot;Hello&quot;; String strB = &quot;hello&quot;; System.out.println(strA.compareTo(strB)); // -32 if (strA.compareTo(strB) &gt; 0){ System.out.println(&quot;大于&quot;); } else if (strA.compareTo(strB) == 0){ System.out.println(&quot;两个字符串相等&quot;); } else { System.out.println(&quot;小于&quot;); } } } 只有String对象才能进行大小判断。 String类常用方法(字符串查找) 要判断指定内容的字符串是否存在于一个字符串中，可使用如下方法： No. 方法名称 类型 描述 1 public boolean contains (String s) 普通 判断指定内容是否存在 2 public int indexOf(String s) 普通 由前向后查找指定字符串的位置，找到后返回首字母索引，未找到，返回-1。 3 public int indexOf(String s,int fromIndex) 普通 从指定索引由前向后查找指定字符串的位置，找到后返回首字母的索引。未找到，返回-1 4 public int lastindexOf(String s) 普通 由后向前查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 5 public int lastindexOf(String s, int fromIndex) 普通 由后向前从指定位置查找指定字符串的位置，找到后返回首字母的索引，如果找不到，返回-1 6 public boolean startsWith (String prefix) 普通 判断是否以指定字符串开头 7 public boolean startsWith (String prefix，int toffset) 普通 从指定位置开始判断是否是以指定字符串开头 8 public boolean endsWith(String suffix) 普通 判断是否以指定字符串结尾 范例：查找字符串位置 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 返回满足条件的单词的首字母索引 System.out.println(str.indexOf(&quot;world&quot;)); // 5，为w的索引 // 从索引5开始查满足条件单词的索引 System.out.println(str.indexOf(&quot;l&quot;,5)); // 8 // 从后向前查 System.out.println(str.lastIndexOf(&quot;l&quot;)); // 8 } } 在某些程序中，需要查找指定字符串是否存在，早期方法如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.indexOf(&quot;world&quot;) != -1){ System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } JDK1.5出现contains()，使用如下： public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; if (str.contains(&quot;world&quot;)) { System.out.println(&quot;该字符串存在&quot;); } else { System.out.println(&quot;该字符串不存在&quot;); } } } 范例：开头或结尾判断内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从开头开始查 System.out.println(str.startsWith(&quot;he&quot;)); // 从索引2开始查找 System.out.println(str.startsWith(&quot;ll&quot;,2)); // 从结尾开始查找 System.out.println(str.endsWith(&quot;ld&quot;)); } } String类常用方法(字符串替换) No. 方法名称 类型 描述 1 public String replaceAll(String regex，String replacement) 普通 全部替换 2 public String replaceFirst(String regex，String replacement) 普通 替换首个满足条件的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 替换所有 String resultA = str.replace(&quot;l&quot;,&quot;_&quot;); // he__owor_d // 只替换第一个 String resultB = str.replaceFirst(&quot;l&quot;,&quot;_&quot;); // he_loworld System.out.println(resultA); System.out.println(resultB); } } String类常用方法(字符串截取) No. 方法名称 类型 描述 1 public String substring(int beginIndex) 普通方法 从指定索引截取到结尾 2 public String substring(int beginIndex,int endIndex) 普通方法 截取指定范围内的内容 public class Demo { public static void main(String[] args) { String str = &quot;helloworld&quot;; // 从索引5开始截取直到结尾 String resultA = str.substring(5); // 截取索引5到8之间 String resultB = str.substring(5,8); System.out.println(resultA); // world System.out.println(resultB); // wor } } String类常用方法(字符串拆分) No 方法名称 类型 描述 1 public String[] split (String regex) 普通方法 按照指定的字符串进行全部拆分 2 public String[] split (String regex，int limit) 普通方法 按照指定的字符串进行部分拆分，最后一个数组长度由limit决定 范例：全部拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空格拆分单词 String result[] = str.split(&quot; &quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：hello // world } } } 在拆分的时候，只写一个空字符串（&quot;&quot;不是null），表示按照每一个字符进行拆分。 public class Demo { public static void main(String[] args) { String str = &quot;hello world&quot;; // 按照空字符串拆分 String result[] = str.split(&quot;&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：h e l l o w o r l d } } } 范例：部分拆分 public class Demo { public static void main(String[] args) { String str = &quot;hello world nihao mldn&quot;; // 把字符串按空格拆成3个，前2个拆完后，后面的不再按空格拆 String result[] = str.split(&quot; &quot;,3); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果：&quot;hello&quot; &quot;world&quot; &quot;nihao mldn&quot; } } } 范例：IP地址拆分 public class Demo { public static void main(String[] args) { String str = &quot;192.168.1.1&quot;; String result[] = str.split(&quot;\\\\.&quot;); for (int x = 0; x &lt; result.length; x++) { System.out.println(result[x]); // 结果为：192 168 1 1 } } } 上述代码中，只用.无法拆分，当遇到这种拆分时，需要使用\\\\.进行转义后拆分。 范例：拆分“张三:20|李四:25|王五:23” public class Demo { public static void main(String[] args) { String str = &quot;张三:20|李四:25|王五:23&quot;; String result[] = str.split(&quot;\\\\|&quot;); for (int x = 0; x &lt; result.length; x++) { String temp[] = result[x].split(&quot;:&quot;); System.out.println(&quot;姓名：&quot; + temp[0] + &quot;,年龄&quot; + temp[1]); } } } String类其他方法 No. 方法名称 类型 描述 1 public String concat (String str) 普通方法 字符串连接 2 public String toLowerCase () 普通方法 把字符串转为小写 3 public String toUpperCase () 普通方法 把字符串转为大写 4 public String trim () 普通方法 去掉字符串中左右两边的空格，中间空格保留 5 public int length() 普通方法 取得字符串长度 6 public String intern () 普通方法 数据入池操作 7 public boolean isEmpty () 普通方法 范例：字符串连接 public class Demo { public static void main(String[] args) { String strA = &quot;hello&quot;; String strB = strA + &quot; world&quot;; String strC = &quot;hello&quot; + &quot;world&quot;; String strD = &quot;hello world&quot;; String strE = strA.concat(&quot; world&quot;); System.out.println(strB == strC); // false System.out.println(strB == strD); // false System.out.println(strB == strE); // false System.out.println(strC == strD); // false System.out.println(strC == strE); // false System.out.println(strD == strE); // false } } 范例：字符串进行大小写转换 public class Demo { public static void main(String[] args) { String str = &quot;*Hello*&quot;; // 只转换小写字母 System.out.println(str.toUpperCase()); // *HELLO* // 只转换大写字母 System.out.println(str.toLowerCase()); // *hello* } } 范例：去掉空格 public class Demo { public static void main(String[] args) { String str = &quot; Hello World &quot;; System.out.println(&quot;【&quot; + str + &quot;】&quot;); // 【 Hello World 】 System.out.println(&quot;【&quot; + str.trim() + &quot;】&quot;); // 【Hello World】 } } 用户进行数据输入时，可能携带无用的空格，接收到这些数据后就要消掉这些无用的空格，这时候就用到了trim()。 范例：取得字符串长度 public class Demo { public static void main(String[] args) { String str = &quot;Hello World&quot;; System.out.println(str.length()); // 11 } } 某些情况要求用户输入的数据长度有限制，可以利用此方法判断。 范例：判断是否是空字符串 public class Demo { public static void main(String[] args) { String str = &quot;&quot;; System.out.println(str.isEmpty()); // true System.out.println(&quot;&quot;.equals(str)); // true } } 范例：实现首字母大写，其余字母小写 public class Demo { public static void main(String[] args) { String str = &quot;hElLo&quot;; System.out.println(initcap(str)); // Hello } public static String initcap(String temp) { // 截取第一个字母，将其变为大写；截取首字母之后的字母将其变为小写 return temp.substring(0, 1).toUpperCase() + temp.substring(1).toLowerCase(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(四)","slug":"Java Base/Java基础知识(四)","date":"2017-10-03T12:47:52.402Z","updated":"2017-10-21T05:59:15.538Z","comments":true,"path":"article/Java/Java Base/Java基础知识(四)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(四)/","excerpt":"","text":"数组的定义及使用 基本概念 1.数组是一组变量的集合。数组属于引用数据类型。 2.数组的定义语法 （1）声明并开辟数组： 数组类型 数组名[] = new 数据类型[数组长度] （2）分步完成： // 声明数组 数组类型 数组名[] = null; // 开辟数组 数组名 = new 数据类型 [数组长度] 3.数组开辟空间用，可利用数组名[下标|索引]访问，下标从0开始。即长度为3的数组，下标值为0，1，2。下标超出范围，会出现数组越界异常（ArrayIndexOutOfBoundsException）。 4.数组是顺序结构且长度固定，可使用循环语句输出，可用数组名.length获取数组长度。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; // 声明并开辟一个长度为3的数组 datas[0] = 1; // 为数组赋值，如不赋值，默认值为0 datas[1] = 2; datas[2] = 3; // for循环输出数组内容，datas.length获取数组长度 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 5.数组属于**引用数据类型，**因此要进行内存分配。与保存对象的区别是对象的堆内存保存的是属性，数组的堆内存保存的是数据。 范例：分步完成 public class Demo { public static void main(String[] args) { int datas[] = null; // 声明数组 datas = new int[3]; // 开辟一个长度为3的数组 datas[0] = 1; datas[1] = 2; datas[2] = 3; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 6.数组可以进行引用传递。 public class Demo { public static void main(String[] args) { int datas[] = new int[3]; datas[0] = 1; datas[1] = 2; datas[2] = 3; int temp[] = datas; // 引用传递 temp[0] = 99; for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); // 99 2 3 } } } 以上都是动态初始化数组，即先开辟数组，再为数组赋值。 7.静态初始化数组： 在定义数组的同时为其赋值，语法： （1）数组类型 数组名[] = {v1, v2 ,…,vn}; （2）数组类型 数组名[] = new 数据类型[] {v1, v2 ,…,vn}; 范例：静态初始化数组 public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; // 静态初始化数组 for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } } 数组支持顺序数据访问，最大缺点是长度不能改变，因此在开发中不直接使用数组，但会使用数组的概念。 二维数组 1.一维数组就是一行数据： 索引 0 1 2 3 数据 0 10 20 30 在一维数组中要查询一个数据，只要确定其索引即可。 二维数组，是一个数据表： 索引 0 1 2 3 0 0 10 20 30 1 1 2 3 4 2 12 123 231 233 二维数组中要查询一个数据，需要定位列和行。二维数组中第一个[]确定行，第二个[]确定列。 2. 二维数组定义语法： // 动态初始化： 数据类型 数组名称[][]=new 数据类型[行数][列数]; // 静态初始化： 数据类型 数组名称[][]=new 数据类型[][]{数组元素} ; 由此可以发现，二维数组就是将多个一维数组变为一个数组。 public class Demo { public static void main(String[] args) { int datas[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; // 外层循环控制数组的行 for (int x = 0; x &lt; datas.length; x++) { // 内层循环控制数组的列 for (int y = 0; y &lt; datas[x].length ; y++) { System.out.print(datas[x][y] + &quot;\\t&quot;); } System.out.println(); } } } 数组与方法的引用 1.方法的参数可以是数组： public class Demo { public static void main(String[] args) { int datas[] = new int[]{1, 2, 3}; change(datas); for (int x = 0; x &lt; datas.length; x++) { System.out.println(datas[x]); } } public static void change(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { temp[x] *= 2; // 数组元素乘2保存 } } } 内存分析： change()执行完毕后，temp不再指向datas的堆内存，但change()对datas数据的修改被保存下来。 2.数组排序（冒泡排序）： 数据的不同会造成排序次数的不同，但不论有多少数据，**总的排序次数不会超过数组长度。**只要排序次数达到数组长度的平方，就能排序成功。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; for (int x = 0; x &lt; datas.length; x++) { for (int y = 0; y &lt; datas.length - 1; y++) { if (datas[y] &gt; datas[x]) { int t = datas[y]; datas[y] = datas[x]; datas[x] = t; } } // 为更好地理解冒泡排序，输出每轮排序的结果 System.out.print(&quot;第&quot; + (x + 1) + &quot;次排序结果:&quot;); print(datas); System.out.println(); } print(datas); } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 建议：main()是程序的起点，可以称为客户端。客户端的代码逻辑应简单，因此可将排序封装为方法。 public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{2, 1, 9, 0, 5, 7, 6, 8}; sort(datas); print(datas); } // 数组冒泡排序方法 public static void sort(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp.length - 1; y++) { if (temp[y] &gt; temp[x]) { int t = temp[y]; temp[y] = temp[x]; temp[x] = t; } } } } // 数组输出的方法 public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot; &quot;); } } } 3.数组转置 转置的概念（一维数组）：· 原始数组 1，2，3，4，5，6，7，8 转置后 8，7，6，5，4，3，2，1 转置操作的两个思路： （1）定义一个新的数组，而后将原始数组按照倒序的方式插入到新的数组之中，随后改变原始数组的引用： public class ArrayDemo { public static void main(String[] args) { int datas[] = new int[]{1,2,3,4,5,6,7,8}; datas = reverseOne(datas); // 让datas指向新数组，原始数据成为垃圾 } // 数组逆序输出方法一 public static int [] reverseOne(int temp[]) { // 定义新数组，长度与原始数组一致 int temps[] = new int[temp.length]; int foot = temp.length - 1; // 控制原始数组的索引 for (int x = 0; x &lt; temps.length ; x++) { temps[x] = temp[foot]; // 新数组按照原始数组倒序排列 foot --; } return temps; } } 上述代码实现转置，但产生了垃圾，不合理。 （2）利用算法，直接在数组上完成转置： 不论数组个数是奇数还是偶数,转换次数 = 数组长度 / 2; // 数组逆序输出方法 public static void reverse(int temp[]) { int len = temp.length / 2; int head = 0; int tail = temp.length - 1; for (int x = 0; x &lt; len; x++) { int t = temp[head]; temp[head] = temp[tail]; temp[tail] = t; head++; tail--; } } 4.行列数相等的二维数组转置： public class Demo { public static void main(String[] args) { int data[][] = new int[][]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; reverse(data); print(data); } // 专门实现数组的倒置操作 public static void reverse(int arr[][]) { for (int x = 0; x &lt; arr.length; x++) { for (int y = x; y &lt; arr.length; y++) { if (x != y) { //行和列相同，进行交换 int temp = arr[x][y]; arr[x][y] = arr[y][x]; arr[y][x] = temp; } } } } // 专门输出的方法 public static void print(int temp[][]) { for (int x = 0; x &lt; temp.length; x++) { for (int y = 0; y &lt; temp[x].length; y++) { System.out.print(temp[x][y] + &quot;、&quot;); } System.out.println(); } System.out.println(); } } 转置过程： 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] 第一次转换（x=0，y=x=0，循环3次） ·y的第一次循环（x==y） 1[0][0] 2[0][1] 3[0][2] 4[1][0] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第二次循环（x=0，y=1，进行交换） 1[0][0] 4[1][0] 3[0][2] 2[0][1] 5[1][1] 6[1][2] 7[2][0] 8[2][1] 9[2][2] ·y的第三次循环（x=0，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] 第二次转换（x=1，y=x=1，循环2次） ·y的第一次循环（x=1，y=1，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 6[1][2] 3[0][2] 8[2][1] 9[2][2] ·y的第二次循环（x=1，y=2，进行交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 第三次转换（x=2，y=x=2，循环11次） ·y的第二次循环（x=2，y=2，不交换） 1[0][0] 4[1][0] 7[2][0] 2[0][1] 5[1][1] 8[2][1] 3[0][2] 6[1][2] 9[2][2] 行列数不同的数组进行倒置，其思路是：数组的行数是原数组的列数，数组的列数是源数组的行数。需要改变原始数组的引用，会产生垃圾。 5.方法返回数组： public class Demo { public static void main(String[] args) { int data[] = init(); // 接收数组 print(data); System.out.println(init().length); } public static int[] init() { return new int[]{1, 2, 3}; // 方法返回数组 } public static void print(int temp[]) { for (int x = 0; x &lt; temp.length; x++) { System.out.print(temp[x] + &quot;、&quot;); } System.out.println(); } } 操作数组的方法 1.Java对数组提供类库支持，下面介绍两个类库中的方法： （1）数组拷贝：用一个数组的指定内容覆盖另一个数组指定内容。 语法：System.arraycopy(源数组名，源数组拷贝开始索引，目标数组名，目标数组开始拷贝索引，拷贝长度)。 范例：数组拷贝 ·数组A：1，2，3，4，5，6，7，8； ·数组B：11，22，33，44，55，66，77，88； ·拷贝后的数组B:11，22，5，6，7，66，77，88 public class Demo { public static void main(String[] args) { int dataA[] = new int[]{1, 2, 3, 4, 5, 6, 7, 8}; int dataB[] = new int[]{11, 22, 33, 44, 55, 66, 77, 88}; System.arraycopy(dataA, 4, dataB, 2, 3); ArrayDemo.print(dataB); // 调用之前代码中的数组输出方法 } } （2）数组排序： 语法：java.util.Arrays.sort(数组名) public class Demo { public static void main(String[] args) { int dataA[] = new int[]{3, 2, 1, 4, 7, 0, 6, 5}; java.util.Arrays.sort(dataA); ArrayDemo.print(dataA); // 调用之前代码中的数组输出方法 } } 对象数组 1.对象数组是将多个对象交由数组处理。 2.对象数组的定义与一般数组一致： 范例： 动态初始化对象数组 class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[3]; books[0] = new Book(&quot;Java开发&quot;, 66.6); books[1] = new Book(&quot;JSP&quot;, 6.6); books[2] = new Book(&quot;C++&quot;, 16.6); for (int x = 0; x &lt; books.length; x++) { System.out.println(books[x].getInfo()); //未实例化对象时，输出值全为null } } } 范例：静态初始化对象数组： class Book { private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } // setter和getter方法略 public String getInfo() { return &quot;书名：&quot; + title + &quot;，价格：&quot; + price; } } public class Demo { public static void main(String[] args) { Book books[] = new Book[]{ new Book(&quot;Java开发&quot;, 66.6), new Book(&quot;JSP&quot;, 6.6), new Book(&quot;C++&quot;, 16.6) }; for (int x = 0; x &lt; books.length; x++) { //未实例化对象时，输出值全为null System.out.println(books[x].getInfo()); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Java基础知识(三)","slug":"Java Base/Java基础知识(三)","date":"2017-10-02T07:31:57.908Z","updated":"2017-10-21T05:58:05.374Z","comments":true,"path":"article/Java/Java Base/Java基础知识(三)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(三)/","excerpt":"","text":"方法的定义与使用 方法的基本概念 方法就是将一段可重复使用的代码封装。因此如要反复执行一段代码时，可考虑将这段代码定义为方法。本章中的方法指的是定义在主类中，由主方法直接调用的方法。此类方法的语法： public static 返回值类型 method_name(v_type v1, v_type v2,...) { 方法体; // 方法要进行的若干操作 [return [返回值] ;] // []中内容可写可不写 } 返回值类型: 数据类型(基本数据类型、引用数据类型) 无返回值(void) 如果方法设置了返回值类型，那么必须使用return返回与之类型对应的内容 不需要return语句，但可用return结束方法调用 方法名的命名规则：第一个单词小写，随后每个单词首字母大写。 范例：定义无参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { print(); // 直接调用 } public static void print(){ System.out.println(&quot;无参无返回值方法&quot;); } } 范例：定义含参无返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { compare(10.2); // 调用时必须写入参数 compare(-10.2); } public static void compare(double x){ String str = x &gt; 0.0 ? &quot;这是正数&quot;:&quot;这是负数&quot;; System.out.println(str); } } 有了参数后，方法就可以根据不同的参数内容进行数据的处理。 范例：定义含参数有返回值方法 package com.java.demo; public class Demo { public static void main(String[] args) { //定义变量接收返回值，而后输出 int result = add(10, 20); System.out.println(result); // 直接输出返回值 System.out.println(add(10, 20)); } public static int add(int x, int y) { return x + y; } } 一个方法使用void定义，该方法无法使用return返回值，但可以使用return结束调用。 package com.java.demo; public class Demo { public static void main(String[] args) { print(1100); // x = 1100 print(3); // 结束调用,不输出x } public static void print(int x) { if (x == 3) { System.out.println(&quot;结束调用,不输出x&quot;); return; } System.out.println(&quot;x = &quot; + x); } } 只有返回值类型为void时，才可使用return结束方法的调用。 方法重载 假设add()要执行两个整数相加，也要执行三个整数相加和两个小数相加，此时一个方法体无法实现所有功能，但又不能定义其他方法，就需要为add()定义不同的功能实现，该操作就称为方法重载（overloading）。 方法重载要求方法名一致，参数类型或个数不同。 package com.java.demo; public class Demo { public static void main(String[] args) { // 根据参数的个数或类型，调用不同方法 add(10,20); add(10.2,20.2); add(10,20,30); } // 方法名相同，参数的类型或个数不同 public static void add(int x, int y) { System.out.println(&quot;两个整数相加：&quot; + (x + y)); } public static void add(double x, double y) { System.out.println(&quot;两个小数相加：&quot; + (x + y)); } public static void add(int x, int y, int z) { System.out.println(&quot;三个整数相加：&quot; + (x + y + z)); } } System.out.println()可以输出不同类型数据，可知此方法是一个被重载后的方法。 方法重载的说明： （1）虽然重载后的方法的返回值类型可以不同，但建议方法重载时返回值类型应一致； （2）方法重载是根据参数类型或个数的不同来区分调用，而不是根据返回值类型。 package com.java.demo; public class Demo { public static void main(String[] args) { } // 报错,已在类中定义了方法 add(int,int) // 说明方法重载的依据是参数的个数或类型不同，而不是返回值类型不同 public static int add(int x, int y) { return x + y; } public static double add(int x, int y) { return x + y; } } 递归调用 递归调用是指方法调用自身。要实现递归调用，要有结束条件。递归调用应尽量少使用，因为处理不当会出现内存溢出。 范例：递归实现1~100的累加操作 package com.java.demo; public class Demo { public static void main(String[] args) { System.out.println(sum(100)); } public static int sum(int num){ if (num == 1) { // 结束递归调用 return 1; } // 递归调用 return num + sum(num - 1); } } 代码的执行步骤： No. 内容 返回值 1 主方法调用sum(100) 100+sum(99) 2 递归调用sum(99) 100 + 99 + sum（98) 3 递归调用sum(98) 100 + 99 + 98+ sum(97) … 依此类推 … 最后一次 递归调用sum(1) sum=100+99+98+…+2+1,结束递归 类与对象 面向对象简介 面向过程：指的是针对某一个问题单独提出解决方案和代码开发。 面向对象：以组件化的形式进行代码设计，优点是代码可重用。 面向对象语言的特征： （1）封装性：保护内部结构安全性。 （2）继承性：在已有的程序结构上扩充新的功能。 （3）多态性：相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果 面向对象开发步骤：OOA（面向对象分析）,OOD（面向对象设计）,OOP（面向对象编程）。 类与对象 1 类与对象是面向对象中的最基础的组成单元。类是共性的集合，对象是某一个性的产物。 2 类用于描述对象的结构， 例如每个人的名字、年龄等一系列特征。类除了包含特征(属性)外，还包括许多行为(方法)。根据这个类产生的对象都具有相同的行为。 3 对象所拥有的行为由类决定，无法执行超出类定义范畴的操作。 4 综上所述，类是对象的模版，但类无法直接使用，必须通过实例对象来使用。对象是由类产生的。 类与对象的定义及使用 1.定义类使用class class_name {}语句完成。类的组成： (1)field（属性，成员，变量）：一堆变量的集合； (2)method（方法，行为）：由对象调用。 范例：定义类 package com.java.entity; public class Book { // 定义属性 public String title; public double price; // 定义方法 public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 2.要使用类，必须要有对象，对象定义的语法有如下两种： (1)声明并实例化对象：class_name object_name = new class_name()； (2)分步完成： 第一步-声明对象：class_name object_name = null; 第二部-实例化对象：object_name =new class_name(); 引用数据类型与基本数据类型最大区别是需要内存的开辟及使用，所以关键字new的主要功能就是开辟内存空间。 3.当一个对象实例化后，利用如下方式操作类： (1)object_name.field：操作类中的属性； (2)object_name.method()：调用类中的方法。 范例：使用类 public class Demo { public static void main(String[] args) { Book book = new Book(); // 声明并实例化对象 book.title = &quot;Java开发&quot;; // 定义属性 book.price = 66.6; book.getInfo(); // 调用方法 } } 4.堆内存和栈内存的概念： 堆内存 栈内存 保存对象的属性内容，使用关键字new开辟 栈内存：保存堆内存的地址。可以理解为栈内存保存对象的名字 范例：分步使用实例化对象 public class Demo { public static void main(String[] args) { Book book = null; // 声明对象 book = new Book(); // 实例化对象 book.title = &quot;Java开发&quot;; book.price = 66.6; book.getInfo(); } } 内存分析：使用关键字new开辟了新的的堆内存，堆内存中保存类定义的属性，此时所有的属性值都为默认值。 使用未实例化的对象，程序运行时会出现“NullPointerException（空指向异常）” 对象引用分析 1.在引用分析中，每次使用new关键字便会开辟新的堆内存。假设声明了两个对象，且都用new分别进行了实例化，那么两个对象占据的是不同的堆内存，因此不会互相影响。 范例：声明两个对象 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); bkB.title = &quot;C++开发&quot;; bkB.price = 22.6; bkB.getInfo(); } } 2. 范例：对象引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = null; bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkA.getInfo(); // 66.6 bkB = bkA; // 引用传递 bkB.price = 90.5; bkA.getInfo(); // 90.5 bkB.getInfo(); // 90.5 } } 由于两个对象指向同一块堆内存，所以任意一个对象修改了堆内存的属性值后，都会影响到其他对象的值。在引用中，一块堆内存可以被多个栈内存指向，但一个栈内存只能保存一个堆内存的地址。 3. 范例：引用传递 public class Demo { public static void main(String[] args) { Book bkA = new Book(); Book bkB = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = 66.6; bkB.title = &quot;C++开发&quot;; bkB.price = 90.5; bkB = bkA; // 引用传递 bkB.price = 100; bkA.getInfo(); // 100 bkB.getInfo(); // 100 } } 通过内存分析可知，在引用时，一块没有栈内存指向的堆内存将成为垃圾，最后被垃圾收集器(GC)回收，回收后，释放其所占空间。 封装性 public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; bkA.price = -66.6; bkA.getInfo(); } } 上述代码没有语法错误，但存在业务逻辑错误，因为书的价格不能为负数。造成该问题是因为对象可以在类的外部直接访问属性。 1.因此应将Book类的属性设为对外不可见（只允许本类访问），可以使用private关键字定义属性。 public class Book { private String title; private double price; public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.title = &quot;Java开发&quot;; // 报错，无法访问私有属性 } } 此时外部对象无法直接调用类中的属性，但程序要正常执行，必须让对象可以操作类中的属性。因此在开发中，对于属性有该要求：类中的属性要使用private声明，如果属性需被外部使用，按照要求定义对应的setter()/getter(). 2. 以Book类中的title属性为例，定义setter()/getter()： setter() getter() 作用 设置属性值 取得属性值 语法 public void setTitle(String t) public void getTitle() 是否含参 有参 无参 package com.java.entity; public class Book { private String title; private double price; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public void getInfo(){ System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } 如果要添加如价格不能为负数的功能，应在setter()中添加： public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } 对于数据的验证，开发中应有其他辅助代码完成，setter()只是简单地设置数据，getter()只用于返回数据。 构造方法与匿名对象 定义对象的语法：类名称 对象名称 = new 类名称(); ①类名称：定义对象的类型； ②对象名称：标识符，要使用对象，需要有一个对象名； ③new：用于开辟堆内存空间，实例化对象； ④类名称()：一个方法名和类名称一样的方法，这就是构造方法。 通过上述分析，我们发现了构造方法的存在，但我们并没有定义构造方法。之所以能使用这个构造方法，是因为Java默认在没有自定义构造方法的情况下，程序编译时自动在类中添加一个无参无返回值的构造方法。 1.构造方法的定义原则：方法名称与类名称相同，没有返回值。 class Book { public Book() { // 系统自动生成的构造方法 } } 2.构造方法在对象使用new实例化时调用。 范例：证明构造方法被调用 public class Book { public Book() { System.out.println(&quot;构造方法被调用&quot;); } } public class Demo { public static void main(String[] args) { Book book = null ; // 声明对象 book = new Book(); // 实例化对象时调用构造方法 //结果：构造方法被调用 } } 构造方法与普通方法的最大区别：构造方法只在实例化对象时调用一次。普通方法在对象实例化后可以多次调用。 3.范例：自定义构造方法 class Book { private String title; private double price; // 自定义构造方法后，系统不再自动生成无参无返回值的构造方法 public Book(String t, double p) { title = t; price = p; } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book book = new Book(&quot;Java开发&quot;, 66.6); book.getInfo(); } } 由上述代码可知构造方法的作用：在类对象实例化时设置属性的初始值，即构造方法用于属性初始化。 4.构造方法也属于方法，因此可以进行重载。 范例：构造方法重载 class Book { public Book() { System.out.println(&quot;系统自动生成的构造方法&quot;); } // 进行方法重载的构造方法 public Book(String t, double p) { System.out.println(&quot;方法重载后的构造方法&quot;); } } public class Demo { public static void main(String[] args) { Book bookA = new Book(); // 系统自动生成的构造方法 Book bookB = new Book(&quot;Java开发&quot;, 66.6); // 方法重载后的构造方法 } } 重载方法时要求：按照参数个数，对方法进行升序或者降序排列。 5.在定义类时可为属性设置默认值。但该默认值只有在对象实例化后才进行设置。而对象实例化是对象构造的最后一步。对象实例化过程的步骤：类的加载，内存的分配，默认值的设置，构造方法。 class Book { private String title = &quot;Java开发&quot;; // 设置默认值 private double price; public Book() { } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public double getPrice() { return price; } public void setPrice(double price) { if (price &gt; 0.0){ this.price = price; } } public void getInfo() { System.out.println(&quot;书名：&quot; + title + &quot;,价格：&quot; + price); } } public class Demo { public static void main(String[] args) { Book bkA = new Book(); bkA.getInfo(); // 书名：Java开发,价格：0.0 } } 本程序中，只有在对象实例化后，才会将”Java开发”设置给title属性。在没有实例化前，title的值仍为其数据类型的默认值，即null。真实的对象信息都保存在堆内存中。 6.匿名对象：没有栈内存指向的对象，即没有标识符的对象。 public class Demo { public static void main(String[] args) { new Book(&quot;Java开发&quot;,6.6).getInfo(); } } 由于匿名对象没有标识符，也没有其他对象对其引用，因此只能使用一次，之后该对象空间变为垃圾，等待回收。 何时使用匿名对象：但一个对象仅需要被使用一次时就使用匿名对象。当一个对象要被反复调用时，就使用非匿名对象。 简单Java类实践 题目要求：定义一个雇员类，类中有雇员编号、姓名、职位、基本工资、佣金等属性。 提示：这种类被称为简单java类，因为这种类不包含过于复杂的程序逻辑。 对于简单Java类而言，它的要求如下： ·类名必须有意义； ·类中所有属性必须private封装，封装后的属性必须提供setter和getter方法； ·类中可以有多个构造方法，但必须保留无参构造方法； ·类中不允许出现输出语句，信息输出必须交给调用处。 ·类中需要提供有一个取得对象完整信息的方法，暂定为getInfo(),返回值类型为String型。 第一步：定义类 public class Emp { private int eId; // 编号 private String eName; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 佣金 // 定义构造方法 public Emp() { } public Emp(int eId, String eName, String job, double sal, double comm) { this.eId = eId; this.eName = eName; this.job = job; this.sal = sal; this.comm = comm; } // 定义setter和getter方法 public int geteId() { return eId; } public void seteId(int eId) { this.eId = eId; } public String geteName() { return eName; } public void seteName(String eName) { this.eName = eName; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } public double getComm() { return comm; } public void setComm(double comm) { this.comm = comm; } // 定义普通方法 public String getInfo() { return &quot;编 号&quot; + this.eId + &quot;\\n&quot; + &quot;姓 名&quot; + this.eName + &quot;\\n&quot; + &quot;职 位&quot; + this.job + &quot;\\n&quot; + &quot;工 资&quot; + this.sal + &quot;\\n&quot; + &quot;佣 金&quot; + this.comm; } } 第二步：测试 public class TEmp { public static void main(String[] args) { Emp e = new Emp(1, &quot;Tom&quot;, &quot;保安&quot;, 800.0, 10.0); System.out.println(e.getInfo()); // 获取全部信息 System.out.println(e.geteId()); // 通过getter()获取单一信息 } } 类中的setter()/getter()必须写。setter()除了有设置属性内容功能外，还有修改属性值的功能。","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Kubernetes安装及使用","slug":"Docker/Kubernetes安装及使用","date":"2017-09-30T08:11:30.179Z","updated":"2017-09-30T08:44:56.612Z","comments":true,"path":"article/容器/Docker/Kubernetes安装及使用/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Kubernetes安装及使用/","excerpt":"","text":"环境配置 系统要求: CentOS 7 软件版本: 1.5.2 配置目标: master端 node端 IP 10.0.0.100 10.0.0.101 etcd ✔ flannel ✔ ✔ kube-apiserver ✔ kube-controller-manager ✔ kube-scheduler ✔ kubelet ✔ ✔ kube-proxy ✔ ✔ docker ✔ ✔ 共同配置（即master和node都需要进行的操作） (1)修改/etc/hosts文件，添加master和node节点IP $ echo &quot;10.0.0.100 centos-master 10.0.0.101 centos-minion&quot; &gt;&gt; /etc/hosts $ cat /etc/hosts 10.0.0.100 centos-master 10.0.0.101 centos-minion (2)禁用fierwalld，安装iptables，设置iptables开机自动启动，启用iptables，禁用iptables-services # 关闭fierwalld $ systemctl stop firewalld $ systemctl disable firewalld # 安装iptables，启动该服务并设置开机自启动 $ yum install iptables $ systemctl start iptables $ systemctl enable iptables # 关闭iptables-services $ systemctl disable iptables-services $ systemctl stop iptables-services # 关闭iptables-services时，可能出现&quot;Failed to issue method call: Access denied&quot; # 解决方法：修改SElinux配置 $ vi /etc/selinux/config # SELINUX=enforcing #注释掉 # SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq! #保存退出 $ setenforce 0 #使配置立即生效 (3)安装","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://yov.oschina.io/tags/Kubernetes/"}]},{"title":"Docker Hub Mysql官方镜像实现首次启动后初始化库表","slug":"Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表","date":"2017-09-29T11:59:23.364Z","updated":"2017-09-30T04:25:40.870Z","comments":true,"path":"article/容器/Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker Hub mysql官方镜像实现首次启动后初始化库表/","excerpt":"","text":"概述 在Docker Hub中查看MySQL官方镜像的Dockerfile: COPY docker-entrypoint.sh /usr/local/bin/ RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] 镜像启动时，会运行entrypoint.sh脚本，该脚本的shell命令中: echo for f in /docker-entrypoint-initdb.d/*; do case &quot;$f&quot; in *.sh) echo &quot;$0: running $f&quot;; . &quot;$f&quot; ;; *.sql) echo &quot;$0: running $f&quot;; &quot;${mysql[@]}&quot; &lt; &quot;$f&quot;; echo ;; *.sql.gz) echo &quot;$0: running $f&quot;; gunzip -c &quot;$f&quot; | &quot;${mysql[@]}&quot;; echo ;; *) echo &quot;$0: ignoring $f&quot; ;; esac echo done 上述shell命令会遍历/docker-entrypoint-initdb.d/文件中的sh文件，sql文件，sql.gz压缩包，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。 实现首次启动后初始化库表 创建mysql_data文件夹，将data.sql放入： -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 启动容器 $ docker run --name test -v /home/master/mysql_data:/docker-entrypoint-initdb.d -d -e MYSQL_ROOT_PASSWORD=123456 mysql 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u root -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重启该容器后，数据依然存在。但启动一个新容器后，该容器数据依然为初始状态。 指定sql文件运行顺序 entrypoint.sh脚本执行sql文件的顺序是按照文件名排序的，这可能导致一些文件执行顺序不符合预期，从而出现错误。例如预期是数据库创建后，再执行表格创建，最后插入数据，而因为文件名，可能数据库先创建后，插入数据，最后创建表格，从而使得数据插入失败。要解决该问题有如下几种方法： 将文件按照预期顺序，进行命名，比如1_xx,2_xx; 将必须有前后顺序的sql文件合并在一个sql文件中; 将sql文件单独放在一个文件夹如data_mysql,将指定sql文件执行顺序的shell脚本放在shell_mysql文件中。容器启动时，将shell_mysql映射到docker-entrypoint-initdb.d文件夹，data_mysql映射到容器内其他文件夹。 假设：data_mysql文件夹存放三个sql文件: database.sql,table.sql,data.sql,shell_mysql存放data.sh #!/bin/bash mysql -uroot -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOF source /usr/local/work/database.sql; source /usr/local/work/table.sql; source /usr/local/work/data.sql; 启动容器： $ docker run --name test -e WORK_PATH=/usr/local/work -e MYSQL_ROOT_PASSWORD=123456 -v /home/master/shell_mysql:/docker-entrypoint-initdb.d -v /home/master/data_mysql:/usr/local/work mysql 数据结果应与上述一致。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker实现mysql容器启动后自动建库","slug":"Docker/Docker实现mysql容器启动后自动建库","date":"2017-09-28T09:22:57.955Z","updated":"2017-09-30T01:47:23.779Z","comments":true,"path":"article/容器/Docker/Docker实现mysql容器启动后自动建库/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker实现mysql容器启动后自动建库/","excerpt":"","text":"概述 通过Dockerfile创建一个mysql镜像,该镜像具有如下功能： mysql容器启动时，会自动执行指定的sql文件; 每次启动该容器，数据都进行初始化，删除所有的修改。 执行步骤 创建Dockerfile $ vim Dockerfile # 指定基础镜像，选用docker官方最新mysql镜像 FROM docker.io/mysql:latest # 环境变量设置，设置mysql登陆时不需密码 ENV MYSQL_ALLOW_EMPTY_PASSWORD yes # 复制文件到容器中，要复制的文件有：启动脚本和sql文件 COPY setup.sh /mysql/setup.sh COPY data.sql /mysql/data.sql COPY privileges.sql /mysql/privileges.sql # 容器启动命令启动脚本 CMD [&quot;sh&quot;, &quot;/mysql/setup.sh&quot;] 创建privileges.sql用于修改mysql权限 $vim privileges.sql use mysql; select host, user from user; -- 将docker_mysql数据库的权限授权给创建的docker用户，密码为123456： -- 如果用户docker不存在，则创建用户docker grant all on docker_database.* to docker@'%' identified by '123456' with grant option; -- mysql新设置用户或权限后需要刷新系统权限否则可能会出现拒绝访问： flush privileges; 创建data.sql导入数据 $ vim data.sql -- 创建数据库 DROP database IF EXISTS `docker_database`; create database `docker_database` default character set utf8 collate utf8_general_ci; -- 切换到test_data数据库 use docker_database; -- 建表 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` bigint(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- 插入数据 INSERT INTO `user` (`id`,`name`,`age` ) VALUES (0,'Tom',18); 创建容器启动脚本setup.sh $ vim setup.sh # !/bin/bash set -e # 查看mysql服务的状态，方便调试 echo `service mysql status` echo '1.启动mysql' # 启动mysql service mysql start # 使进程休眠 sleep 3 echo `service mysql status` echo '2.开始导入数据' #导入sql文件 mysql &lt; /mysql/data.sql echo '3.导入数据完毕....' sleep 3 echo `service mysql status` # 由于最开始设置mysql为免密登陆，为了安全，在此设置mysql密码 echo '4.开始修改密码....' # 导入修改mysql权限设置的文件 mysql &lt; /mysql/privileges.sql echo '5.修改密码完毕....' #sleep 3 echo `service mysql status` echo 'mysql容器启动完毕,且数据导入成功' 创建镜像 创建镜像并命名为mysql:9.29 $ docker build -t mysql:9.29 . 验证 启动mysql:9.29镜像，生成容器 $ docker run --name sql -d -p 23306:3306 mysql:9.29 6da21b87a0a53b247f0d249366433d04a632ede5521bd36650164180448a5e41 查看容器日志 $ docker log sql 1.启动mysql.... 2017-09-29T01:04:33.521418Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2017-09-29T01:04:36.647637Z 0 [Warning] InnoDB: New log files created, LSN=45790 2017-09-29T01:04:37.431760Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 2017-09-29T01:04:37.818755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a41ede9-a4b2-11e7-a72e-0242ac115903. 2017-09-29T01:04:37.823362Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened. 2017-09-29T01:04:37.824245Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2017-09-29T01:04:40.977642Z 1 [Warning] 'user' entry 'root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977679Z 1 [Warning] 'user' entry 'mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977689Z 1 [Warning] 'user' entry 'mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977710Z 1 [Warning] 'db' entry 'performance_schema mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977715Z 1 [Warning] 'db' entry 'sys mysql.sys@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977726Z 1 [Warning] 'proxies_priv' entry '@ root@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977764Z 1 [Warning] 'tables_priv' entry 'user mysql.session@localhost' ignored in --skip-name-resolve mode. 2017-09-29T01:04:40.977774Z 1 [Warning] 'tables_priv' entry 'sys_config mysql.sys@localhost' ignored in --skip-name-resolve mode. .. MySQL Community Server 5.7.19 is started. MySQL Community Server 5.7.19 is running. 2.开始导入数据.... 3.导入数据完毕.... MySQL Community Server 5.7.19 is running. 4.开始修改密码.... host user localhost mysql.session localhost mysql.sys localhost root 5.修改密码完毕.... MySQL Community Server 5.7.19 is running. mysql容器启动完毕,且数据导入成功 容器启动过程与setup.sh中编写的步骤完全一致。 进入容器进行验证 $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 验证重启mysql容器，数据库初始化 插入数据 mysql&gt; insert into person(id ,name ,age)values(1,'Jane',17); Query OK, 1 row affected (0.06 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | | 1 | Jane | 17 | +----+------+------+ 2 rows in set (0.00 sec) 重新启动容器 $ docker stop sql $ docker start sql $ docker exec -it sql /bin/bash root@6da21b87a0a5:/# mysql -u docker -p Enter password: mysql&gt; use docker_database; mysql&gt; show tables; +---------------------------+ | Tables_in_docker_database | +---------------------------+ | person | +---------------------------+ 1 row in set (0.00 sec) mysql&gt; select * from person; +----+------+------+ | id | name | age | +----+------+------+ | 0 | Tom | 18 | +----+------+------+ 1 row in set (0.00 sec) 重启容器后，数据初始化。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"利用TestNG进行单元测试","slug":"Test/利用TestNG进行单元测试","date":"2017-09-26T12:41:55.451Z","updated":"2017-12-21T08:22:37.807Z","comments":true,"path":"article/测试/Test/利用TestNG进行单元测试/","link":"","permalink":"http://yov.oschina.io/article/测试/Test/利用TestNG进行单元测试/","excerpt":"","text":"TestNG简介 TestNG是一个用来简化广泛的测试需求的测试框架，从单元测试到集成测试。 Annotation Annotation 作用 @BeforeSuite 被注释的方法将在所有测试运行前运行 @AfterSuite 被注释的方法将在所有测试运行后运行 @BeforeTest 被注释的方法将在测试运行前运行 @AfterTest 被注释的方法将在测试运行后运行 @BeforeGroups 被注释的方法将在gourp中方法运行前运行 @AfterGroups 被注释的方法将在gourp中方法运行后运行 @BeforeClass 被注释的方法将在当前类的第一个方法运行前运行 @AfterClass 被注释的方法将在当前类的所有方法运行后运行 @BeforeMethod 被注释的方法将在每一个方法运行前运行 @AfterMethod 被注释的方法将在每一个方法运行后运行 @DataProvider 被注释的方法用于为其他方法提供数据 @Factory 被标记的方法作为一个返回对象的工厂，这些对象将被TestNG作为测试类，该返回必须返回Object[] @Par##ameters 传递参数给测试方法 使用TestNG进行单元测试 @Test() // Test中所有方法变为测试方法 public class Test { @Test(enable = false) // 该注释后，test1()测试时被忽略，相当于普通方法 public void test1(){} @BeforeTest() // 该注释后，test3(),test4()执行前，test2()先执行 public void test2(){} @ public void test3(){} public void test4(){} } 测试中的一些小问题 1、匿名JSON节点验证： [ { &quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:12 }, { &quot;name&quot;:&quot;Jane&quot;, &quot;age&quot;:18 } ] 对于上述JSON的验证代码如下： public void method_name() { given(). header(&quot;Authorization&quot;, &quot;token &quot; + Config.getToken()). when(). get(url). then(). statusCode(200). body(&quot;[0].name&quot;, equalTo(&quot;正常&quot;)). body(&quot;[0].age&quot;, greaterThanOrEqualTo(0)); }","categories":[{"name":"测试","slug":"测试","permalink":"http://yov.oschina.io/categories/测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yov.oschina.io/tags/TestNG/"}]},{"title":"Git使用(Linux)","slug":"Tool/Git使用(Linux)","date":"2017-09-25T09:36:06.108Z","updated":"2017-09-26T12:52:36.797Z","comments":true,"path":"article/工具/Tool/Git使用(Linux)/","link":"","permalink":"http://yov.oschina.io/article/工具/Tool/Git使用(Linux)/","excerpt":"","text":"环境安装 安装git sudo apt-get install git 配置git用户名 git config –global user.name &quot;user_name&quot; 配置用户邮箱地址 git config –global user.email &quot;user_mail&quot; 创建本地仓库 创建空目录 mkdir folder_name 进入空目录 cd folder_name 显示当前目录 pwd 把当前目录变为Git仓库 git init 把文件添加到Git仓库 git add file 把文件提交到Git仓库 git commit -m &quot;commit_message&quot; 版本库操作 查看修改内容 git diff file_name 查看工作区状态 git status 查看历史记录 git log 查看精简历史记录 git log --pretty=oneline 回退到上一个版本 git reset --hard HEAD^ 回到某个指定版本 git reset –-hard commit-id(git log查看) 查看命令记录 git reflog 撤销全部工作区修改 git checkout --file 将暂存区修改撤销放回工作区 git reset HEAD 文件 linux删除文件 rm file git库删除文件 git rm file 下载他人项目 git clone https://github.com/xxx/xxx.git new_git_name 分支管理 创建并切换到分支 git checkout -b dev_name 查看当前分支 git branch (*表示当前分支) 切换分支 git checkout dev_name 合并指定分支到当前分支(fast forward 模式) git merge dev_name 删除分支 git branch -d dev_name 合并分支时冲突,修改文件后,再提交 查看分支合并图 git log --graph --pretty=oneline --addrev-commit 合并分支（普通模式） git merge -- no-ff -m &quot;commit_message&quot; dev 多人合作 查看远程库信息 git remote -v 推送主分支 git push origin master 推送其他分支 git push origin dev_name 创建本地分支 git checkout -b dev_name origin/dev_name 指定本地分支与远程分支的链接 git branch --set-upstream-to=origin/dev_name 获取远程库内容 git pull 解决冲突后commit，再上传 git push origin dev_name 标签管理 创建标签 git tag tag_name 给指定提交打标签 git tag tag_name commit-id 创建带说明的标签 git tag -a tag_name -m &quot;message&quot; commit-id 查看标签说明 git show tag_name 删除标签 git tag -d tag_name 推送标签 git push origin tag_name 一次性推送所有标签 git push origin --tags 删除标签（本地） git tag -d tag_name 删除远程标签 git push origin :refs/tags/tag_name 自定义Git 使git显示不同颜色 git config --global color.ui true 忽略某些文件时，需要编写.gitignore 强制添加被忽略文件 git add -f file 检查某个文件符合被忽略要求 git check-ignore -v file 配置命令别名 git config --global alias.别名 命令","categories":[{"name":"工具","slug":"工具","permalink":"http://yov.oschina.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yov.oschina.io/tags/Git/"}]},{"title":"Docker的安装说明","slug":"Docker/Docker的安装说明","date":"2017-09-24T10:43:23.795Z","updated":"2017-10-19T02:19:59.220Z","comments":true,"path":"article/容器/Docker/Docker的安装说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker的安装说明/","excerpt":"","text":"安装及部署Docker 系统和资源说明 Docker系统要求最低CentOS7，且系统必须为64位，且内核版本不低于3.10。 资源需求：Docker1.12.6 安装步骤 (1)安装 $ yum install docker (2)设置开机启动Docker Daemon进程 $ systemctl start docker.service // 启动docker $ systemctl enable docker.service // 设置Docker开机自启动 $ systemctl disable firewalld // 关闭防火墙 $ yum -y install iptables-services // 安装iptable服务 $ systemctl start iptables.service // 启动iptable $ systemctl enable iptables.service // 设置iptable开机自启动 (3)安装成功的Docker $ docker version (4)建立docker用户组，将使用docker的用户加入docker用户组。 $ groupadd docker $ usermod -aG docker $USER Docker的代理配置 $ vim /usr/lib/systemd/system/docker.service [Service] Environment=”HTTP_PROXY=http://192.168.13.19:7777” Environment=”HTTPS_PROXY=http://192.168.13.19:7777” Type=notify Docker配置加速器 国内访问Docker Hub可能有些慢，因此我们可以配置加速器。阿里云提供了阿里云加速器 注册用户并且申请加速器后，会获得 https://xxx.mirror.aliyuncs.com 这样的地址。 $ vim /usr/lib/systemd/system/docker.service ExecStart= --registry-mirror=https://xxx.mirror.aliyuncs.com $ systemctl daemon-reload // 重新加载配置 $ systemctl restart docker // 重启docker Docker配置文件说明 $ vim /etc/sysconfig/docker OPTIONS=' --selinux-enabled // 是否开启selinux，默认开启 --insecure registry ip:port // 添加私人仓库地址 --bip=ip // 表示网桥docker0的CIDR地址 ' Docker的常用命令 Docker信息查看 (1)查看docker进程状态 $ systemctl status docker (2)查看docker的具体信息 $ docker info (3)查看docker的版本信息 $ docker version Docker的镜像操作 (1)查找镜像 $ docker search image_name (2)拉取镜像 $ docker pull image_name:tag (3)列出本地镜像 $ docker images 列表参数说明 Repository：镜像的仓库源 Tag：镜像的标签 Image ID： 镜像ID Created： 镜像的创建时间 Size： 镜像大小 (4)设置镜像标签 $ docker tag image_id tag (5)利用镜像创建容器 $ docker run image_name:tag command (6)提交镜像 $ docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; image_name new_image_name Docker的容器操作 (1)启动容器 $ docker run option host_port:contaniner_port image_name:tag command 例如：docker run -it -d -p 5000:5000 java java -version -d：后台运行容器 -p:将容器端口映射到宿主机端口 -it:进行交互式操作 command: 执行java -version命令 (2)查看容器 $ docker ps // 查看正在运行的容器 (3)容器生命周期命令 $ docker create image:tag // 创建容器但不启动 $ docker start container_name // 启动容器 $ docker stop contaniner_name // 停止容器 $ docker restart container_name // 重启容器 $ docker pause contaniner_name // 暂停容器内所有进程 $ docker unpause contaniner_name // 恢复容器内所有进程 $ docker rm contaniner // 删除容器 $ docker rm ${docker ps -a -q} // 删除所有停止的容器","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Docker的简单说明","slug":"Docker/Docker的简单说明","date":"2017-09-24T09:36:05.890Z","updated":"2017-09-25T08:47:46.484Z","comments":true,"path":"article/容器/Docker/Docker的简单说明/","link":"","permalink":"http://yov.oschina.io/article/容器/Docker/Docker的简单说明/","excerpt":"","text":"Docker简介 Docker的概念 Docker最初是dotCloud公司的内部项目，是基于dotCloud公司多年云服务的一次革新，于2013年3月开源。Docker被称为第三代Paas平台，是一种容器（虚拟化的轻量级替代技术）技术，将应用软件及其依赖软件（运行时环境、系统工具、系统库）等打包在容器中，使应用具备完整性、移植性和隔离性。以容器的方式交付应用，可以让应用无差别地运行在开发、测试、生产环境，提供标准化的环境和标准化的交付、标准化的部署。 Dcoker的技术依赖 Docker使用Go语言进行开发实现，基于Linux内核的cgroup、namespace以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。最初实现是基于LXC、0.7后去除LXC，使用自行开发的libcontainer。从1.11开始，则使用runC和containerd。 （1）cgroup是将任意进程进行分组化管理的Linux内核功能。重要概念是子系统，即资源控制器。先挂载子系统，然后在子系统中创建一个control group节点，将需要控制的进程id和属性写入，从而完成内存的资源限制。 （2）LXC（Linux containers），一种基于容器的操作系统层级的虚拟技术，借助于namespace的隔离机制和cgroup限额功能，提供了一套统一的API和工具来建立和管理container，旨在提供一个共享kernel的OS级虚拟化方法。 （3）AUFS是一个能透明覆盖一或多个现有文件系统的层状文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。 （4）App打包：Docker额外提供的Feature,标准统一的打包部署运行方案。 Docker的优势 Docker在容器的基础上，进行了进一步封装，从文件系统、网络互联到进程隔离等，极大地简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。Docker和传统虚拟化方式的不同：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上运行所需的应用进程;而容器内的应用进程直接运行于宿主的内核，没有自己的内核，而且也没有进行硬件虚拟，所以容器更为轻便。 （1）更高效的利用系统资源 由于容器不需要硬件虚拟化以及运行完整的操作系统等额外开销，Docker对系统的资源利用率更高。因此一个相同配置的主机，可以运行更多应用。 （2）更快速的启动 Docker容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动，大大节约了开发、测试、部署的时间。 （3）一致的运行环境 Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致性。 （4）持续交付和部署 Docker可以通过定制应用镜像实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来创建镜像，并结合持续集成（Continuous integration）系统进行集成测试，而运维人员则可以直接在生成环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。而且使用Dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需环境，帮助更好地部署该镜像。 （5）更轻松的迁移 由于Docker确保了运行环境的一致性，使得应用迁移更加容易。 （6）更轻松的维护和扩展 Docker使用的分层存储以及镜像技术，使得应用重复部分的复用更容易，也使得维护更新更容易,扩展镜像更容易. Docker相关的基础概念 Docker Image 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。Docker镜像（Image）就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含一些为运行时准备的配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建后也不会被改变。 分层存储 因为传统镜像包含操作系统完整的root文件系统，其体积往往庞大。因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，Docker镜像并非像ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除某一层文件时，仅在当前层标记为该文件已经删除，但实际该文件会一直跟随镜像。因此构建镜像时，每一层尽量只包含该层需要添加东西，任何额外的东西应在该层构建结束前清理结束。 分层存储使得镜像的复用、定制、甚至以此为基础构建新的镜像变得更容易。 Docker Container 镜像（Image）是静态定义，容器（Container）是镜像运行时的实体。容器可以被创建、启动、停止等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境中，使用起来，就像是在一个独立于宿主的系统下操作。这特性使得容器封装的应用比直接在宿主机运行更安全。 容器也是分层存储的，每个容器运行时以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器周期一样，容器消亡时，容器存储层随之消失。 按照Docker最佳实践的要求:容器不应该向存储层写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷或者绑定宿主机目录，在这些位置的读取会跳过容器存储层，直接对宿主或网络存储发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，不随着容器消亡。 Docker Registry 镜像构建完成后，可以很容易地在本地运行。但如需在其他服务器使用该镜像，就需要一个集中的存储、分发镜像的服务，即Docker Registry。 一个Docker Registry包含多个仓库（Repository）；每个仓库包含多个标签Tag；每个Tag对应一个镜像。通常一个仓库中会包含同一个软件不同版本的镜像，而标签就对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;来获取指定版本的镜像，如果不给出标签，就将以latest为默认标签。 Docker Registry公开服务是开放给用户使用、允许用户管理镜像的服务，一般允许用户免费上传、下载公开的镜像。最常使用的Registry公开服务就是官方的Docker Hub。 除了公开服务外，用户还可以在本地搭建私有的Docker Registry。Docker官方提供Docker Registry镜像，可以直接使用作为私有Registry服务。","categories":[{"name":"容器","slug":"容器","permalink":"http://yov.oschina.io/categories/容器/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yov.oschina.io/tags/Docker/"}]},{"title":"Java基础知识(二)","slug":"Java Base/Java基础知识(二)","date":"2017-09-24T03:29:54.604Z","updated":"2017-10-21T05:58:30.981Z","comments":true,"path":"article/Java/Java Base/Java基础知识(二)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(二)/","excerpt":"","text":"运算符 常用运算符：四则运算符、逻辑运算符、三目运算符和位运算符。 基本运算符 =为赋值运算符。 四则运算符基本组成：+、-、*、/、%。不要使用运算符编写过于复杂的计算。 public class Demo { public static void main(String[] args) { int numA = 10; double numB = 20; int numC = 3; System.out.println(&quot;加法计算：&quot; + (numA + numB)); System.out.println(&quot;减法计算：&quot; + (numA - numB)); System.out.println(&quot;乘法计算：&quot; + (numA * numB)); System.out.println(&quot;除法计算：&quot; + (numA / numB)); System.out.println(&quot;求模计算：&quot; + (numA % numC)); } } 简化运算符：+=、-=、*=、/=、%=: public class Demo { public static void main(String[] args) { int numA = 10; numA += 2; // 等同于 numA = numA + 2 System.out.println(&quot;加法计算&quot; + (numA)); // 12 } } ++（自增），--（自减）：位置不同，功能也不同： ·++变量，--变量：先对变量加/减1，再使用自增或自减后的变量进行计算; ·变量++，变量--：先使用变量进行计算，再进行变量加/减1。 public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; // ++变量，先numA + 1 // 然后(numA + 1) + numB内容 // 最后对numB加1 int result = (++numA) + (numB++); System.out.println(&quot;numA=&quot; + numA); // 11 System.out.println(&quot;numB=&quot; + numB); // 21 System.out.println(&quot;result=&quot; + result); // 31 } } 三目运算符 三目运算符根据布尔表达式的结果进行赋值： value_type value_name = 布尔表达式 ? true_value : false_value; 利用三目运算符可以减少判断代码: public class Demo { public static void main(String[] args) { int numA = 10; int numB = 20; int max = 0; /** 使用三目运算符 * 当numA大于numB,返回true,max = numA * 当numA小于numB,返回false,max = numB */ max = numA&gt;numB ? numA : numB; // 不使用三目运算符 // if (numA &gt; numB) { // max = numA; //} else { // max = numB; //} System.out.println(max); } } 逻辑运算符 逻辑运算符：与&amp;，&amp;&amp;、或|，||、非! package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = true; System.out.println(!flag); // false } } 布尔表达式的连接，只能使用与和或操作 与：所有条件都为true时，结果为true;有一个为false，结果就是false. 范例：普通与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：程序报错，因为&amp;会对所有条件进行判断。但就与的特点而言，前一个条件为false，结果就是false，后续的判断没有意义。 范例：短路与&amp;&amp; package com.java.demo; public class Demo { public static void main(String[] args) { // 除数不能为0 if ((1 == 2) &amp;&amp; (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // false,不报错 } } } 结果:程序不报错，因为&amp;&amp;只要有一个条件为false后，后续判断就不再进行，从而提高了效率。 或操作：一个条件为true，结果为true。 范例：普通或| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) | (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // 报错 } } } 结果：使用|，会对所有条件进行判断，但是或运算的特点是：一个条件为true，结果就是true。 范例：短路或|| package com.java.demo; public class Demo { public static void main(String[] args) { if ((1 &lt; 2 ) || (10 / 0 == 0)){ System.out.println(&quot;Hello&quot;); // true,不报错 } } } 因此使用逻辑运算时就使用&amp;&amp;和||。 位运算符 数学计算为十进制。Java支持二进制、八进制和十六进制。如果要想将十进制变为二进制，采用的方式为：除2，取余，倒序。 位运算主要是进行二进制数据操作，位运算符：&amp;、|、&gt;&gt;(移位)、&lt;&lt;、^(反码)、~。 范例：位与&amp; package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA &amp; numB); // 9 } } 运算过程： 1001 → 9 &amp; 1011 → 11 1001 → 9 范例：位或| package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 9; int numB = 11; System.out.println(numA | numB); // 11 } } 运算过程： 1001 → 9 | 1011 → 11 1011 → 11 范例：移位（最快方式计算2的3次方） package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; num = num &lt;&lt; 2; // 向左移位 System.out.println(num); // 8,相当于2的3次方 } } 运算过程： 0010 → 2 2&lt;&lt; 1000 → 8 章节小问题：请解释&amp;与&amp;&amp;的区别，以及|与||的区别: 1. 在逻辑运算中： |- &amp;和|会对所有条件进行判断后，返回结果 |- &amp;&amp;只要一个条件返回false，就不进行后续判断，结果为false |- ||只要一个条件为true，就不进行后续判断，结果为true 2. 在位运算中： |- &amp;为位与元算，|为位或元算 |- &amp;&amp;和||不能用于位运算 Java程序逻辑控制 程序逻辑结构主要分为三种：顺序结构、分支结构、循环结构。顺序结构执行顺序是从前到后，但有时是以代码所在的{}为界限。 分支结构 分支结构即判断结构，有两种语法：if和switch. if语句: if语句的格式: if if…else if…else if…else 范例：if判断 package com.java.demo; public class Demo { public static void main(String[] args) { double score = 90.0; if (score &lt; 60.0) { System.out.println(&quot;不及格&quot;); } else if (score &lt; 90) { System.out.println(&quot;良&quot;); } else { System.out.println(&quot;优秀&quot;); } } } switch语句: switch判断不能使用布尔表达式，JDK1.5之前只能进行整数或字符判断，JDK1.5增加了枚举判断，JDK1.7增加了String判断，语法： switch (数字/字符/枚举/字符串){ case 内容 : 内容满足时执行的代码 ; break; case 内容 : 内容满足时执行的代码 ; break; ... default { 内容都不满足case时执行; break; } } 范例：使用switch package com.java.demo; public class Demo { public static void main(String[] args) { int num = 2; switch (num) { case 1: System.out.println(&quot;数字1&quot;); break; case 2: System.out.println(&quot;数字2&quot;); break; default: System.out.println(&quot;大于2的数字&quot;); break; } } } switch默认从第一个符合条件的case语句开始执行，直到整个switch执行完毕或遇到break关键字，才停止执行。程序区分大小写。 循环结构 当某段代码需要重复执行时，可使用循环语句实现，循环有两种：for循环和while循环。 while循环： while循环 do…while循环 while（布尔语句）｛｝ do｛｝while（布尔语句); 范例：实现1到100的累加（while循环先判断再执行）： package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; // 循环的初始化条件 while (current &lt;= 100) { // 循环结束条件 sum += current; // 累加 current++; // 修改循环的初始化条件 } System.out.println(sum); // 5050 } } 范例：实现1到100的累加（do…while循环是先执行再判断） package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; int current = 1; do { sum += current; current++; } while (current &lt;= 100); System.out.println(sum); } } do…while循环先执行再判断，即不论循环条件是否满足，都至少执行一次，因此开发中不建议使用do…while。 for循环： for (循环初始化条件; 循环结束条件; 循环条件变更) { 循环语句; } 即使三个条件都不写，但是两个&quot;;&quot;必须保留。 范例：实现1~100的累加 package com.java.demo; public class Demo { public static void main(String[] args) { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(sum); } } 开发原则: （1）循环次数未知，循环结束条件已知时使用while循环； （2）循环次数已知，使用for循环。 循环嵌套 public class 九九乘法表 { public static void main(String[] args) { for (int x = 1; x &lt;= 9; x++) { for (int y = 1; y &lt;= x; y++) { System.out.print(x + &quot;*&quot; + y + &quot;=&quot; + (x * y) + &quot;\\t&quot;); } System.out.println(); } } } 循环控制 循环控制有两个语句：continue（退出本次循环）和break（结束整个循环）。该语句要和判断语句一起使用。 范例：continue使用 package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { continue; // 跳出本次循环，不进行后续的输出操作 } System.out.print(x + &quot;,&quot;); // 0,1,2,4, } } } 范例：break package com.java.demo; public class Demo { public static void main(String[] args) { for (int x = 0; x &lt; 5; x++) { if (x == 3) { break; // 结束整体循环 } System.out.print(x + &quot;,&quot;); // 0,1,2, } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2017-09-23T09:19:24.607Z","updated":"2017-09-25T08:47:54.233Z","comments":true,"path":"article/语言/Markdown语法/","link":"","permalink":"http://yov.oschina.io/article/语言/Markdown语法/","excerpt":"","text":"Markdown是一种轻量级的标记语言，语法简单，由一些符号组成，这些符号作用一目了然，实现易读易写的目标。Markdown兼容HTML，即你可以直接在文本中添加HTML语言，但是你不能在HTML区块标签间使用Markdown语法。 Markdown语法 区块元素 段落与换行 一个Markdown段落是由一个或多个连续的文本行组成的。在Markdown中是无法使用空格或制表符来缩进的，因为其默认一个空格就是一个空行。 标题 Markdown支持两种标题的语法，类Setext形式和类Atx形式，接下来介绍的类Atx形式：该形式是在行首插入1到6个#，对应1到6级标题。 # 这是H1 ## 这是H2 ... ###### 这是H6 区块引用Blockquotes Markdown标记区块引用方式如下： &gt; 文本内容。 &gt;&gt; 文本中也可以使用嵌套引用，只要根据层次加上不同数量的&gt; 在引用的区域中，也可以使用其他的Markdown语法。 列表 Markdown支持有序列表和无序列表。无序列表使用星号、减号或加号作为列表标记: * red - green + blue 有序列表则使用数字接着一个英文句号： 1. red 2. green 3. blue 如果列表项目间用空行分开，在输出HTML时Markdowm就会将内容用段落标签包起来，即： * blue *red 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;blue&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;red&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 如果要在列表项目中放入引用，就需要缩进 * red &gt; this is color 如果要放入代码块，那就需要连续缩进两次。并且为避免行首出现数字-句号-空白，应在句号前加反斜杠。 代码区域 要在Markdown中建立代码区块很简单，只需要缩进4个空格或一个tab即可。 分隔线 你可以在一行使用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。你可以在星号或减号中间插入空格。 星号： * * * 减号： - - - 下划线：_ _ _ 区段元素 链接 Markdown支持两种形式的链接语法：行内式和参考式。建立一个行内式的链接，只要在方块括号后面紧接着圆括号插入链接即可，如果想要加上链接的title文字，只要网址后面用双引号把title文字包起来即可。 [example](https://www.baidu.com &quot;Title&quot;) 强调 Markdown使用星号和下划线标记强调，被*或_包围的字词会被转为用&lt;em&gt;标签包围，而用两个*或_包起来，则变为&lt;strong&gt; *强调* _强调_ **强调** __强调__ 如果只想在文字前后插入普通的星号或下划线，可以使用反斜杠： \\*文字\\* 代码 如果要标记一小段行内代码，可以使用反引号把它包起来，例如： `printf()` 如果要在代码中插入反引号，你可以用多个反引号开启或结束代码区段: `` (`) `` 将变为 &lt;p&gt;&lt;code&gt;(`)&lt;/code&gt;&lt;/p&gt; 图片 插入图片有两种方式：行内式和参考式 ![替代图片的文字](/path/to/img.jpg &quot;文字&quot;) 结束 感谢您的阅读，如果您有什么问题，请在下方留言，谢谢。","categories":[{"name":"语言","slug":"语言","permalink":"http://yov.oschina.io/categories/语言/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yov.oschina.io/tags/Markdown/"}]},{"title":"SpringBoot小例子","slug":"Spring Boot/SpringBoot小例子","date":"2017-09-23T08:58:23.811Z","updated":"2017-10-26T02:15:33.009Z","comments":true,"path":"article/框架/Spring Boot/SpringBoot小例子/","link":"","permalink":"http://yov.oschina.io/article/框架/Spring Boot/SpringBoot小例子/","excerpt":"","text":"第一个Spring Boot应用 创建项目 1.打开 IDEA, 选择 Create New Project 2.左侧菜单选择Spring Initializr, Next即可 3.Project Metadata默认即可，Next 4.Dependencies选择Web中的Web即可,Next 5.Project Name默认即可,finsh 项目结构 demo // 项目名 |- .idea |- .mvn |- src // 代码存放区 |- main |- java |- com.example.demo // java包 |- DemoApplication.java // 项目启动类 |- resources |- static // 用于存放css,js等样式文件 |- templates // 用于存放html文件 application.properties // 项目配置文件 |- test //测试代码存放区 |- target .gitignore mvnw mvnw.cmd demo.iml pom.xml // 项目对象模型,添加项目依赖等配置 DemoApplication.java package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(PersonApplication.class, args); } } @SpringBootApplication标注它是一个SpringBoot应用,main方法使说明它是主程序,在应用启动时首先被执行。 右键run,然后在浏览器中输入localhost:8080即可访问页面,因为当前未定义页面,因此显示Error Page 第一个页面 在com.example.demo文件下创建HelloController.java package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { // 设置请求路径为 /hello,请求方式为get @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return &quot;Hello World!&quot;; } } RestController注解该类是一个控制器。当用户访问指定路径时,将调用say()返回&quot;Hello World&quot;。 右键run,然后在浏览器中输入localhost:8080/hello即可访问页面,此时可在页面看到Hello World! 项目属性配置 建议将项目中application.properties改为application.yml,便于配置 server: port: 8080 # 端口号 context-path: /demo # 主路径配置 age: 18 # 自定义属性 content: &quot;age: ${age}&quot; # 配置文件中调用属性 获取配置文件中的属性值 package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Value(&quot;${content}&quot;) private String content; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return content; } } 右键run,然后在浏览器中输入localhost:8080/demo/hello即可访问页面,此时可在页面看到age: 18 当有一系列属性值时 可将其定义为某个属性的子属性 server: port: 8080 person: name: Tom age: 40 定义一个PersonProperties类 package com.temp.person; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component // 将类实例化到Spring容器中 @ConfigurationProperties(prefix = &quot;person&quot;) // 获取前缀为person的配置 public class PersonProperties { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 获取配置文件中的值: package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired private PersonProperties personProperties; // 定义对象,从而间接获取属性值 @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String say() { return personProperties.getName; } } 右键run,然后在浏览器中输入localhost:8080/demo/hello即可访问页面,此时可在页面看到Tom。对于配置文件中属性的读取建议采用该方式。 多种配置文件 假设现在有两种配置文件application-dev.yml和application-prod.yml [application-dev.yml] demo: name: you age: 20 [application-prod.yml] demo: name: you age: 20 只需在application.yml中 spring: profiles: # 选择要调用的配置文件 active: dev 当要使用某种时,active设为那个文件的值即可。 Controller的基本使用 注解 功能 @Controller 处理http请求 @RestController Spring4之后新加的注解，原先返回json需要@ResponseBody配合@Controller @RequestMapping 配置url映射 @PathVariable 获取url中的数据 @RequestParam 获取请求参数的值 @GetMapping 组合注解 访问路径和访问方式 1.@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)设置访问路径为&quot;hello&quot;,请求方式为get，可以简写为@GetMapping(value = &quot;/hello&quot;) 2.可将路径设为集合,使得访问的路径不同,但请求的资源相同:@RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;}) 3.可以为整个类设置访问路径,如下： package com.example.demo; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController @GetMapping(value = &quot;/demo&quot;) public class HelloController { @GetMapping(value = {&quot;/hello&quot;, &quot;hi&quot;}) public String say() { return &quot;Hello World!&quot;; } } 在浏览器输入地址http://localhost:8080/demo/hello和http://localhost:8080/demo/hi均能看到页面显示Hello World!. 获取路径参数 1.@PathVariable 获取路径参数 @GetMapping(value = &quot;/hello/{id}&quot;) public Integer say(@PathVariable(&quot;id&quot;) Integer id) { return id; } 在浏览器输入地址http://localhost:8080/hello/100此时页面显示100 2.@RequestParam 获取请求参数 @GetMapping(value = &quot;/hello&quot;) // 获取路径中参数id的值,id可不存在，默认为0 public Integer say(@RequestParam(value = &quot;id&quot;,required = false,defaultValue =&quot;0&quot;) Integer id) { return id; } 在浏览器输入地址http://localhost:8080/hello/100?id=100此时页面显示100 数据库操作 Java客户端使用Spring-Data-Jpa组件。 JPA（Java Persistence API）定义了一系列对象持久化的标准,目前实现这一规范的产品有Hibernate、TopLink等。 RESTful API设计 请求类型 请求路径 功能 Get /person 获取数据列表 POST /person 添加数据 Get /person/id 根据id获取数据 PUT /person/id 根据id修改数据 DELETE /person/id 根据id删除数据 添加依赖 在pom.xml添加jpa依赖和MySQL组件 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 修改配置文件 在application.yml中添加数据库配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver # 驱动 url: jdbc:mysql://127.0.0.1:3306/dbperson # 数据库url username: root password: jpa: hibernate: ddl-auto: udate show-sql: true 创建数据表 在Spring Boot中可通过创建实体类，自动生成数据表 package com.example.demo; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity // 注册实体,Spring Boot会自动将其变为数据表 public class Person { @Id // 设为数据表中id属性 @GeneratedValue // 设置为自增 private Integer id; private String name; private Integer age; public Person() { } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } } Spring Boot会将上述代码中类的属性变为数据表的字段。 创建PersonRepository接口 该接口继承JpaRepositoy,实现sql语句 package com.example.demo; import org.springframework.data.jpa.repository.JpaRepository; import java.util.List; public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; { // 自定义方法,实现通过年龄找数据 List&lt;Person&gt; findByAge(Integer age); } 创建PersonController,实现访问时根据访问方式和路径实现数据操作 package com.example.demo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import javax.transaction.Transactional; import java.util.List; @RestController public class PersonController { @Autowired private PersonRepository personRepository; /** * 通过get方式访问localhost:8080/person可获取全部数据 * @return 数据类集 */ @GetMapping(value = &quot;/person&quot;) public List&lt;Person&gt; personList(){ return personRepository.findAll(); } /** * 通过post方式访问localhost:8080/person?name=Jane&amp;age=10可添加数据 * @param name 数据表的name字段 * @param age 数据表的age字段 * @return 返回Person对象 */ @PostMapping(value = &quot;/person&quot;) public Person addPerson(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) Integer age) { Person person = new Person(); person.setName(name); person.setAge(age); return personRepository.save(person); } /** * 通过get方式访问localhost:8080/person/1可获取id为1的数据 * @param id 要查询的数据id * @return Person对象 */ @GetMapping(value = &quot;/person/{id}&quot;) public Person findPersonById(@PathVariable(&quot;id&quot;) Integer id) { return personRepository.findOne(id); } /** * 通过put方式访问localhost:8080/person/1?name=Jane&amp;age=10可将id为1的数据修改 * @param id 要修改的数据id * @return Person对象 */ @PutMapping(value = &quot;/person/{id}&quot;) public Person updatePersonByid(@PathVariable(&quot;id&quot;) Integer id, @RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) Integer age) { Person person = personRepository.findOne(id); person.setName(name); person.setAge(age); return personRepository.save(person); } /** * 通过delete方式访问localhost:8080/person/1可将id为1的数据删除 * @param id 要删除数据的id */ @DeleteMapping(value = &quot;/person/{id}&quot;) public void deletePersonById(@PathVariable(&quot;id&quot;) Integer id) { personRepository.delete(id); } /** * 通过get方式访问localhost:8080/person/age/10可查找age为10的数据 * @param age 要查找的年龄 */ @GetMapping(value = &quot;/person/age/{age}&quot;) public List&lt;Person&gt; personListByAge(@PathVariable(&quot;age&quot;) Integer age) { return personRepository.findByAge(age); } /** * 实现事务管理,批量增加数据,一个数据失败，全部数据不得入库 * @Transactional 用于标注事务管理 */ @PostMapping(value = &quot;/person/two&quot;) @Transactional public void addTwoPerson() { Person personA = new Person(); personA.setName(&quot;Tony&quot;); personA.setAge(13); personRepository.save(personA); Person personB = new Person(); personB.setName(&quot;Maria&quot;); personB.setAge(18); personRepository.save(personB); } }","categories":[{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/categories/框架/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://yov.oschina.io/tags/框架/"}]},{"title":"Go基础知识","slug":"Go Base/Go基础知识","date":"2017-09-23T08:57:17.833Z","updated":"2017-10-21T05:57:57.492Z","comments":true,"path":"article/Go/Go Base/Go基础知识/","link":"","permalink":"http://yov.oschina.io/article/Go/Go Base/Go基础知识/","excerpt":"","text":"入门 Go语言是一门编译型语言，是一个开源的编程语言，能让构造简单、而且高效的软件变得容易。Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go语言环境安装 Go语言安装包下载地址为Golang。Windows使用mis后缀的安装包即可。默认情况msi文件会安装在c:\\Go目录下。Go语言的开发工具可以使用LitelDE，是一款开源、跨平台的轻量级Go语言集成开发环境.。也可以在Eclipse或IDEA中安装Go语言插件。 第一个Go程序 package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello World!&quot;) } Go的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go提供的工具都通过go命令调用。其中go run就是编译go的源文件，链接库文件，并运行生成的可执行文件。 $ go run helloworld.go Go语言支持Unicode，可以处理任何语言的文本，包括中文。 如果要编译上述程序，保存编译结果以备将来使用，可以使用build子命令： $ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（注：Windows系统下生成的是helloworld.exe），之后可以随时运行它，不需要任何处理（注：因为是静态编译，所以不必担心系统库更新时的冲突）。 Go语言的代码通过包（package）组织，包类似与其他语言中的库（libraries）或者模块（modules）。一个包由单个目录下的一个或多个go源代码文件组成，目录定义包的作用。每个源文件都以package声明语句为开始。上述例子就是package main，紧跟着导入（import）的包，之后是程序代码。 fmt包含有格式化输出、接收输入的函数，Println是其中一个基础函数。 main包比较特殊，定义了一个独立可执行的程序，而不是一个库。main包中的main函数是整个程序执行时的入口。import声明告诉编译器需要哪些包，缺少必要的包或者导入不需要的包，程序都无法编译通过。 组成程序的函数、变量、常量、类型的声明语句分别由关键字func、var、const、type定义。一个函数的声明由func关键字、函数名、参数列表、返回值列表（mian函数不含返回值）以及包含在大括号里的函数体组成。Go语言不需在语句末尾添加分号，除非一行有多条语句。 程序结构 命名 Go语言的函数名、变量名、常量名、类型名、语句标号和包名等所有命名的规则是： （1）由字母、下划线、或数字组成，以字母或下划线开头，区分大小写。 （2）不能使用关键字。Go语言有25个关键字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var （3）Go语言还有30多个预定义的名字，如int和true等，对应内建的常量、类型和函数。 内建常量 true false iota nil 内建类型 int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数 make len cap new append copy close delete complex real imag panic revover 内部预定义的名字不是关键字，因为可以在定义中重新使用它们。在一些特殊场景重新定义它们时要避免过度而引起的语义混乱。 （4）命名长度没有限制，但应尽量短小。如果作用域较大，生命周期长，应见名知意。 （5）Go语言推荐使用驼峰式命名，而对于ASCII和HTML这样的缩略词则不变，即escapeHTML，而不是escapeHtml。 （6）如果一个标识符是在函数内部定义的，那么它只在函数内部有效。如果在函数外部定义，则当前包中所有的文件都可以访问该标识符。名字开头字母的大小写决定了标识符在包外的可见性：如果开头是大写字母，那么它是公开，可被外部包访问，如fmt包的Printf函数就可以在fmt包外访问。包的名字一般总是小写。 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。 （1）一个Go程序对应一个或多个go源文件。每个源文件以包的声明语句开始，说明该文件属于哪个包。之后是import语句，然后是包一级的类型、变量、常量、函数声明语句。 范例：声明常量、函数、变量 package main // 包声明 import &quot;fmt&quot; // 导入依赖包 const boilingF = 212.0 // 定义常量 /** 进行摄氏度和华氏度的转换 */ func main() { // 定义函数 var f = boilingF // 定义变量 var c = (f - 32) * 5 / 9 fmt.Printf(&quot;boiling point = %g°F or %g°C\\n&quot;, f, c) } 上述代码中，bilingF是包级别的声明,作用范围为包内的所有文件。f和c是在函数内部声明的，作用范围仅在函数内部。 （2）一个函数的声明由函数名、参数、可选的返回值和函数体组成。如果没有返回值，就可不定义返回值。函数的执行从第一个语句，依次执行直到遇到return语句或执行完毕。 如果要多次进行摄氏度与华氏度的转换，可以将其定义为函数。 package main import &quot;fmt&quot; func main() { const freezingF, boilingF = 32.0, 212.0 fmt.Printf(&quot;%g°F = %g°C\\n&quot;, freezingF, fToC(freezingF)) fmt.Printf(&quot;%g°F = %g°C\\n&quot;, boilingF, fToC(boilingF)) } /** 华氏度转为摄氏度 * f: 华氏度值 * return: 返回float64类型数据 */ func fToC(f float64) float64 { return (f - 32) * 5 / 9 } 变量 变量声明的一般语法：var 变量名 类型 = 表达式 类型或表达式可省略其一。如果省略类型，则根据表达式推断变量的类型;如果省略表达式，则变量的值为默认值： 数据类型 初始值 数值类型 0 布尔型 false 字符串型 空字符串 接口或引用类型(包括slice、指针、map、chan和函数) nil 数组或结构体等聚合类型 每个元素或字段对应该类型的初始值 Go的零值初始化机制可以保证每个变量都被初始化，因此Go中不存在未初始化的变量。这个特性可以简化很多代码，在不增加额外工作的情况下，确保边界条件下的合理行为。 可以在声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量，如果忽略每个变量的类型，就可以声明多个不同类型变量（类型由初始表达式推导） var i, j, k int // int, int, int var b, f, s = true, 2.3, &quot;four&quot; // bool, float64, string 变量也可以通过调用函数，由函数的返回值进行初始化： var f, err = os.Open(name) 简短变量声明 简短变量声明，变量的类型根据表达式自动推导，语法变量名 := 表达式 因为其简洁灵活的特点，简短变量声明常用于大部分的局部变量；var声明常用于需要显示变量类型的地方或者变量稍后会被重新赋值的而初始值无关紧要的地方。 i := 100 var boilong float64 = 100 var name []string 简短变量声明也同var一样可以声明一组变量，表达式可以是函数。 （1）简短变量声明左边的变量如果是已经被声明过的，那么此时该语句对该变量的作用只是赋值（简短变量声明一句中至少有一个变量是新地！） in, err := os.Open(infile) out, err := os.Open(outfile) // 此时&quot;:=&quot; 对于err只是进行赋值 out, err := os.Create(outfile) // 报错,没有新的变量 解决上述错误的方法是将第二个简短变量声明改为普通的多重赋值语句。 简短变量声明只对已经在同级作用范围声明的变量起到赋值作用，如果是作用域外的声明，则会在当前作用域重新声明一个新的变量。 指针","categories":[{"name":"Go","slug":"Go","permalink":"http://yov.oschina.io/categories/Go/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"http://yov.oschina.io/tags/Go基础/"}]},{"title":"Java基础知识(一)","slug":"Java Base/Java基础知识(一)","date":"2017-09-23T08:57:00.371Z","updated":"2017-10-21T05:58:00.288Z","comments":true,"path":"article/Java/Java Base/Java基础知识(一)/","link":"","permalink":"http://yov.oschina.io/article/Java/Java Base/Java基础知识(一)/","excerpt":"","text":"Java基础知识 Java是一门面向对象语言，支持多线程编程;通过使用更为简单的引用来进行内存关系的匹配，而不是复杂的指针;Java提供垃圾自动回收机制，能更好地处理垃圾空间;可以实现多平台的移植。 第一个Java程序 运行Java程序的步骤 javac xx.java:对Java程序进行编译，生成字节码文件xx.class。 java xx：对Java程序进行解释。 Java程序的核心单元—类 类的声明方式有两种: public class class_name {}：该声明方式声明的java文件，文件名必须与类名一致，一个类文件中只允许使用一次该声明。 class class_name {}：一个java文件可以多次使用该声明（不建议如此操作），但编译后会生成多个class文件。 第一个Java程序：Hello World package com.java.demo; // 包名 public class HelloWorld { // 类 public static void main(String[] args) { // 主方法 System.out.println(&quot;Hello World&quot;); // 方法体 } } Java程序都是从主方法开始执行的.System.out.println()将内容输出后换行。 CLASSPATH环境属性 PATH和CLASSPTH的区别：PATH是操作系统路径，定义了所有可执行程序的路径；CLASSPATH是Java解释类文件时的加载路径，当java命令运行时，JVM通过CLASSPATH属性设置的路径，加载所需要的类。 配置CLASSPATH时，一定要定义一个“.”，表示在当前所在目录进行类的加载。 注释 // 注释内容： 单行注释 /* 注释内容 */： 多行注释 /** 注释内容 */：文档注释 标识符与关键字 标识符 标识符是指Java程序中的类名、属性名、方法名等，其定义要求如下： （1）标识符由字母，数字，_，$组成，不能以数字开头，不能是Java中的关键字或保留字； （2）标识符应尽量有意义，可见名知意。 （3）Java标识符可以是中文，但不建议使用中文命名标识符。 关键字 Java中有两个未使用的关键字goto和const；JDK1.4之后增加了assert关键字；JDK1.5之后增加了enum关键字。 Java数据类型 Java数据类型分为两大类：基础数据类型和引用数据类型 两者的区别在于基础数据类型不需要进行内存分配，而引用数据类型需要进行内存分配。 基本数据类型： |-数值型： |-整型：byte、short、int、long； →默认值：0； |-浮点型：float、double； →默认值：0.0 |-字符型：char； →默认值：‘\\u0000’ |-布尔型：boolean； →默认值：false |-引用数据类型：数组、类、接口等。 →默认值：null 数据类型的选择原则 （1）整数用int，小数用double； （2）描述日期时间或内存大小，用long； （3）实现内容传递或编码转换用byte； （4）逻辑控制用boolean； （5）避免中文乱码用char。 整型 数字常量属于int型数据，如数字30。 常量与变量的区别在于：常量的内容是固定的，变量的内容是可变的。范例–定义int型变量： package com.java.demo; public class Demo { public static void main(String[] args) { // 一个变量名在同一块代码中只允许声明一次 // 变量赋值语法：value_type value_name = value ; int num = 10; num = num * 2; System.out.println(num); } } 每个数据类型都有其对应的存储范围 package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; // int型数据的最大值 int min = Integer.MIN_VALUE; // int型数据的最小值 System.out.println(max); // 2147483647 System.out.println(max + 1); // -2147483648 System.out.println(min); // -2147483648 System.out.println(min - 1); // 2147483647 System.out.println(min - 2); // 2147483646 } } 当数据超过int型数据的保存范围时，数值会按照循环的形式出现，即（最大值+1）变为最小值，再+1变为第二小的最小值，以此类推。这是因为数据是按照二进制进行的，第一位是符号位，而其他31位是数据位。这种现象称为数据溢出，解决方法是扩大数据范围： package com.java.demo; public class Demo { public static void main(String[] args) { int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; // int变量 + long变量 = long变量,扩大了数据的范围 System.out.println(max + 1L); // 2147483648 System.out.println(min - (long)1); // -2147483649 System.out.println((long)min - 2); // -2147483650 } } 数据类型的转换规律 范围小的数据类型与范围大的数据类型计算时，自动转换为范围大的所数据类型； 范围大的数据类型只能通过强制转换变为范围小的数据类型。 常量进行强制转换，可通过使用常量标记（如L，l可将int型常量变为long型）或使用(数据类型)常量。范例–强制转换： package com.java.demo; public class Demo { public static void main(String[] args) { // 1000是int型，使用long型变量接收，发生自动转换 long num = 1000; // long型变为int型，强制转换 int x = (int) num; System.out.println(x); // 1000 } } 当进行强制转换的数值超出范围小的数据类型的范围时，依然会发生数据溢出。 package com.java.demo; public class Demo { public static void main(String[] args) { // 2147483650L是long型数据，超出int型的范围 long num = 2147483650L ; int x = (int) num; System.out.println(x); // -2147483646，数据溢出 } } byte型数据的取值范围为-128~127，当整数数值在这个范围内时，会自动转型；超出byte范围时会发生数据溢出。 4. 注意点 变量声明时应设置具体数值，不使用默认值。在方法中定义的变量，其默认值是无效的。 package com.java.demo; public class Demo { public static void main(String[] args) { // 未给变量赋值 int num; // 报错,未初始化变量,无法使用该变量 System.out.println(num); } } 浮点型 Java中浮点数属于double型（double型是保存范围最广的类型）。 package com.java.demo; public class Demo { public static void main(String[] args) { double num = 10.2; // 10.2是小数，属于double型 // double型 * int型 = double型 System.out.println(num * 2); // 20.4 } } 所以使用float数据须将double强制转换为float型： package com.java.demo; public class Demo { public static void main(String[] args) { float fA = 10.2F; // 强制转型方式一 float fB = (float) 10.2; // 强制转型方式二 System.out.println(fA); // 10.2 System.out.println(fB); // 10.2 System.out.println(fA * fB); // 104.03999,该bug无法解决 } } 开发过程中要考虑到整型数据不保留小数位： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / x); // 1 } } 因为int型/int型=int型，不保留小数位，所以要取得正确的计算结果，需要将其中一个整型变为浮点型： package com.java.demo; public class Demo { public static void main(String[] args) { int x = 5; int y = 9; System.out.println(y / (double) x); // 1.8 } } 字符型 byte byte是字节，1字符=2字节。Java使用十六进制UNICODE编码，可以保存任意符号，并且考虑到与其他语言的结合，包含了ASCII码的部分编码，以实现无缝衔接。 字符使用单引号'声明，一对单引号只能保存一位字符。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型可以自动转换为int型 System.out.println(c); System.out.println(num); // 65,是A的ASCII码值 } } 编码：'A'(65)~'Z'(90); 'a'（97）~'z'（122）; '0'（48）~'9'(57),可利用A和a的编码差为32，实现字母大小写转换： package com.java.demo; public class Demo { public static void main(String[] args) { char c = 'A'; int num = c; // char型变为int型才能进行四则运算 num = num + 32; // 大写与小写编码值差为32 c = (char) num; // int型只能强制转换为char型 System.out.println(c); // a } } 传统编程语言字符只能保存英文标记，但UNICODE可以保存任何文字包括中文。 package com.java.demo; public class Demo { public static void main(String[] args) { char c = '游'; int num = c; System.out.println(num); // 28216 } } 由于Java保存中文很方便,因此处理断句时，字符数据很有用，其他时候基本用不到。 布尔型 布尔型返回逻辑结果，只保存两种数据：true和false，主要用于逻辑控制： package com.java.demo; public class Demo { public static void main(String[] args) { boolean flag = false; // if (布尔值){满足条件时的操作} if (!flag) { System.out.println(&quot;Hello World !&quot;); } } } String型 String型 String属于引用数据类型（是类,Java中类名称首字母大写），表示字符串，即多个字符的集合，使用双引号&quot;&quot;声明。 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello World !&quot;; // str为字符串变量 System.out.println(str); // &quot;Hello World !&quot;为字符串常量 System.out.println(&quot;Hello World !&quot;); } } +可实现字符串连接 package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello&quot;; str = str + &quot; World !&quot;; System.out.println(str); } } 当四则运算与字符串连接同时存在时： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + numA + numB; System.out.println(str); // 加法计算：10099.9 } } 出现上述结果是因为小范围数据会自动转型为大范围数据，即String型+任意数据类型=String型，然后进行字符串连接，可使用()来实现正确的运算： package com.java.demo; public class Demo { public static void main(String[] args) { int numA = 100; double numB = 99.9; String str = &quot;加法计算：&quot; + (numA + numB); System.out.println(str); // 加法计算：199.9 } } Java支持转义字符， 例如：换行\\n、制表符\\t、反斜杠\\\\、双引号\\&quot;、单引号\\'： package com.java.demo; public class Demo { public static void main(String[] args) { String str = &quot;Hello \\&quot;World\\&quot; \\nHello MLDN&quot;; System.out.println(str); /** * Hello &quot;World&quot; * Hello MLDN */ } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yov.oschina.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yov.oschina.io/tags/Java基础/"}]},{"title":"Gitee+Hexo搭建个人博客","slug":"Tool/Gitee+Hexo搭建个人博客","date":"2017-09-22T13:48:40.243Z","updated":"2017-10-02T06:55:01.573Z","comments":true,"path":"article/博客搭建/Tool/Gitee+Hexo搭建个人博客/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/Tool/Gitee+Hexo搭建个人博客/","excerpt":"","text":"Gitee: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。 Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。 环境搭建 安装Node.js Windows用户访问Node.js下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。 $ npm config set registry http://registry.npm.taobao.org/ Hexo安装 $ npm install -g hexo-cli Hexo的基本使用请查看hello-world文中所写。 本地运行Hexo 在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件： $ hexo init 初始化后，文件夹的目录如下： . ├── .deploy #需要部署的文件 ├── node_modules #Hexo插件 ├── public #生成的静态网页文件 ├── scaffolds #模板 ├── source #博客正文和其他源文件等都应该放在这里 | ├── _drafts #草稿 | └── _posts #文章 ├── themes #主题 ├── _config.yml #全局配置文件 └── package.json 之后在本地执行如下命令后，即可访问 http://localhost:4000 访问Hexo页面 $ hexo s Git安装 Git安装包地址,根据操作系统选择安装包下载后安装即可。 注册码云账号，并创建一个项目 获取项目地址 发布博客 修改Hexo配置文件_config.yml deploy: type: git repo: 码云的项目地址 branch: master 部署博客 $ npm install hexo-deployer-git --save $ hexo g --d #一键部署 此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。 开启Page功能 访问博客 在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下： 博客使用 在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为file_name.md file_name.md的文件开头如下: --- title: file_name tag: 标签名 categories: 分类 comment: 是否允许评论(true or false) description: 描述 --- 文档正文编写，请参照markdown语法。 结尾 如果搭建过程中，还有什么问题，请在下方留言。谢谢您的阅读！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-22T08:28:42.119Z","updated":"2017-09-25T08:47:28.553Z","comments":true,"path":"article/博客搭建/hello-world/","link":"","permalink":"http://yov.oschina.io/article/博客搭建/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yov.oschina.io/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yov.oschina.io/tags/Hexo/"}]}]}